issue_id,issue_number,issue_title,issue_body,comment_id,comment_body
2671814233,3860,RFC/Feature Request: Add a type-safe convert/input output mapper method for compile time input validation,"**RFC/Feature Request**: Add a type-safe `convert`/`input output mapper` method for compile time input validation

**Summary**

Introduce a new method, ie. `convert`, for Zod schemas that provides type-safe input validation and transformation. This method would enforce that the provided input matches the schemaâ€™s defined input type (`T[""_input""]`) at compile time, ensuring a stricter contract compared to `parse`.

**Motivation**

Zodâ€™s `parse` and `safeParse` methods currently accept `unknown` as input. While this is intentional for unstructured or untrusted data validation, there are common use cases where input data is already structured (e.g., from a typed API response, database query, or other controlled sources). For such cases, allowing type-safe input validation without relying on runtime type checking enhances both safety and developer experience.

The proposed method aligns with Zodâ€™s TypeScript-first philosophy by:

1. Enforcing input types at compile time, reducing reliance on runtime checks.
2. Providing a clear distinction between structured and unstructured input handling.
3. Supporting scenarios where transformations (via `.transform()`) are applied, while maintaining type safety.

**Proposed API**

Add a method `convert` to Zod schemas with the following behavior:

```typescript
schema.convert(input: T[""_input""]): T[""_output""];
```

- **Input Type (`T[""_input""]`)**: Enforces that the input matches the schema's input type at compile time.
- **Output Type (`T[""_output""]`)**: Returns the validated and transformed data, adhering to the schema's transformation logic.

  **Example Usage**

https://github.com/colinhacks/zod/blob/dad88200ec45b673d33eae442dff40d805d8add9/src/__tests__/convert.test-d.ts#L21-L59

**Comparison with Existing Methods**

1. **`parse`**:

   - Accepts `unknown` input and validates it.
   - Use case: General-purpose validation of unstructured data.

2. **`convert`** (Proposed):
   - Enforces that the input matches the schemaâ€™s input type at compile time.
   - Use case:
     - Validating already-structured data with guaranteed input types, while benefiting from transformations and Zodâ€™s validation.
     - Using zod as typesafe converter ie. between well defined input and output types.

**Potential Concerns**

- **Confusion with Existing Methods**:
  - I am uncertain about how to name the method in order to clearly differentiate itself from `parse`, `safeParse`, `transform`,... to avoid ambiguity. Suggested name: `convert`, `inputToOutput`, `parseConvert`?

**Example implementation**

https://github.com/colinhacks/zod/pull/3861

https://github.com/colinhacks/zod/blob/dad88200ec45b673d33eae442dff40d805d8add9/src/types.ts#L521-L541",,
2669276740,3858,Export enumUtil types,"Similar to `z.objectUtil` and `z.util`, It'd be great if we had access to the types defined by the `enumUtil` namespace.

Is it possible to export these types? Thanks a ton.",,
2668454170,3856,Error Handling: differentiating .errors and .issues on ZodError,"Whenever working with zod errors/issues I find out that `issues` and `errors` have exactly the same content, like below:

<img width=""581"" alt=""image"" src=""https://github.com/user-attachments/assets/45baf9ea-1fcb-4316-b1bc-35f755f04cc4"">

sample code below:

```ts
try {
Schema.parse(something);
} catch (e) {
  if (e instanceof z.ZodError) {
    for (const zodIssue of e.issues) { // A
    for (const zodIssue of e.errors) { // B
      console.error(zodIssue.code);
      console.error(zodIssue.message);
      console.error(zodIssue.path);
    }
  }
}
```

and inside internal TS zod types, both properties relate to the same `ZodIssue` type:

```ts
export declare class ZodError<T = any> extends Error {
    issues: ZodIssue[];
    get errors(): ZodIssue[];
```

My question is: what's the difference between them? Why are they separate? I see docs relate to issues (and methods such as `addIssue`/`addIssues` exist). **What's the point of `errors` anyway?**

I've read [error handling](https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md) but it doesn't answer this question.

",,
2667797030,3855,Unexpected 'optional' in input type when using generic function,"I've been trying to write a generic function to generate schemas for a corresponding generic interface but keep getting errors related to some fields supposedly being optional when validating the types. I have no optionals anywhere.

## Steps to reproduce
Execute the following code:
```ts
import z from 'zod';

export interface PathParameter<T> {
  pathParameter: T;
}

export const PathParameterSchema = <T extends z.ZodTypeAny>(pathParamSchema: T) => {
  return z.object({
    pathParameter: pathParamSchema,
  }) satisfies z.ZodSchema<PathParameter<z.input<T>>, z.ZodTypeDef, PathParameter<z.output<T>>>;
};
```
### Output (Error)
```error
test.ts:10:6 - error TS1360: Type 'ZodObject<{ pathParameter: T; }, ""strip"", ZodTypeAny, { [k in keyof addQuestionMarks<baseObjectOutputType<{ pathParameter: T; }>, any>]: addQuestionMarks<...>[k]; }, { [k_1 in keyof baseObjectInputType<...>]: baseObjectInputType<...>[k_1]; }>' does not satisfy the expected type 'ZodType<PathParameter<input<T>>, ZodTypeDef, PathParameter<output<T>>>'.
  Types of property '_type' are incompatible.
    Type '{ [k in keyof addQuestionMarks<baseObjectOutputType<{ pathParameter: T; }>, any>]: addQuestionMarks<baseObjectOutputType<{ pathParameter: T; }>, any>[k]; }' is not assignable to type 'PathParameter<input<T>>'.
      Property 'pathParameter' is optional in type '{ [k in keyof addQuestionMarks<baseObjectOutputType<{ pathParameter: T; }>, any>]: addQuestionMarks<baseObjectOutputType<{ pathParameter: T; }>, any>[k]; }' but required in type 'PathParameter<input<T>>'.

10   }) satisfies z.ZodSchema<PathParameter<z.input<T>>, z.ZodTypeDef, PathParameter<z.output<T>>>;
        ~~~~~~~~~
```
### Expected output
I expect there not to be an error, just like with the code below doesn't throw an error
```ts
const testInterfaceSchema = z.object({ str: z.string() });

const testSchema = z.object({ pathParameter: testInterfaceSchema }) satisfies z.ZodSchema<
  PathParameter<z.input<typeof testInterfaceSchema>>,
  z.ZodTypeDef,
  PathParameter<z.output<typeof testInterfaceSchema>>
>;
```",2482449908,"I found my own answer in #153, basically, this is impossible due to the typescript type interference. A solution like
```ts
export const PathParameterSchema = <T extends z.ZodTypeAny>(pathParamSchema: T): z.ZodObject<{ pathParameters: T }> => {
  return z
    .object({
      pathParameters: pathParamSchema,
    });
};
```
is recommended, but this doesn't guarantee that the types are in sync anymore."
2667247063,3854,Zod Custom Type Assertion with .pipe() Does Not Propagate Type Inference Correctly,"I'm experiencing an issue where Zod doesn't automatically propagate the custom type (CustomDate) when using .pipe() with a custom schema. Specifically, when trying to apply a .pipe(zod.custom<CustomDate>()) after defining a schema with .refine(), Zod continues to treat the output as a general string type instead of the expected CustomDate type. This causes type errors when passing the schema to the constructor.

**Steps to Reproduce:**
1. Define a custom schema using .refine() to validate a time string.
2. Use .pipe(zod.custom<CustomDate>()) to assert the type as CustomDate.
3. Try passing the schema to a constructor or other Zod-related validation flow.
4. Observe that Zod infers the type as a string instead of CustomDate, resulting in a type error.

**Code Example:**
```javascript
const zodCustomDateSchema = zod.string().refine((value) => moment(value, customFormat, true).isValid(), {
  message: ""Invalid time format. Must be in format: "" + customFormat + ""."",
  path: [""invalidCustomFormat""],
}).pipe(zod.custom<CustomDate>());
```

**Error:**
```
Type 'ZodObject<{ category: ZodEnum<[""PRODUCT_A"", ""PRODUCT_B"", ""PRODUCT_C""]>; productId: ZodString; userId: ZodString; purchaseDate: ZodPipeline<...>; shippingDate: ZodPipeline<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<{ category: ""PRODUCT_A"" | ""PRODUCT_B"" | ""PRODUCT_C""; productId: string; userId: string; purchaseDate: CustomDate; shippingDate: CustomDate; }, ZodTypeDef, { ...; }>'.
  The types of '_input.purchaseDate' are incompatible between these types.
    Type 'string' is not assignable to type 'CustomDate'.
```

Expected Behavior:
The type should be correctly inferred as CustomDateafter applying .pipe(zod.custom<CustomDate>()), and no type errors should occur when using the schema in other validation or constructor contexts.

Actual Behavior:
Zod does not propagate the custom type assertion correctly, and the type remains string, leading to type errors in downstream code (e.g., passing the schema to the constructor).

It would be great if Zod could propagate custom types properly, ensuring that inferred types are consistent throughout validation and type assertions.
",,
2667059828,3853,"[suggestion] invalid discriminator value errors should include the given value, or signify if the value was omitted","Currently, a discriminated union schema, when given a value with a bad discriminator, does not spit out the given value in the ZodError:
```ts
const SomeSchema = z.discriminatedUnion('type', [
  z.object({ type: z.literal('foo'), foo: z.string() }),
  z.object({ type: z.literal('bar'), bar: z.string() }),
  z.object({ type: z.literal('baz'), baz: z.string() }),
]);

SomeSchema.parse({ type: 'qux' });
```

```
[
  {
    ""code"": ""invalid_union_discriminator"",
    ""options"": [
      ""foo"",
      ""bar"",
      ""baz""
    ],
    ""path"": [
      ""type""
    ],
    ""message"": ""Invalid discriminator value. Expected 'foo' | 'bar' | 'baz'""
  }
]
```

It would be nice if this error included the invalid value.
",,
2663739970,3852,Can't verify that a number is in a list,"Using enum (or any other validator provided by zod), it is not possible to verify that a number belongs in a list.

With an enum, I can verify whether the string ""1"" belongs to, say:

[""2"", ""7"", ""1""]

However, if the data to be parsed is 1, instead of ""1"", zod does not provide the necessary resources to verify whether the number 1, when converted to string, belongs or not to that list of strings.

This is a very basic requirement, but the documentation does not mention how to accomplish this. Ideally, it should be possible to coerce the fields to a string and then compare to the enum.

The only way I could do this was using a ""refine"" after coerce.string(). Then the ""enum"" logic is completely custom (comparison to an array in a regular javascript function). Is this how it was designed?",,
2655668017,3849,z.discriminatedUnion requires literal array,"not sure why by discriminateUnion cannot use an array defined elsewhere.  Is this by design or fixable?
thanks

```typescript
const state1 = z.object({
    state: z.literal(""on""),
    text: z.string()
})
const state2 = z.object({
    state: z.literal(""off""),
    number: z.number()
})
const states = [state1,state2]

const dUnion1 = z.discriminatedUnion('state', states) // errors ; see image
const dUnion2 = z.discriminatedUnion('state', [state1,state2]) //works
```

![image](https://github.com/user-attachments/assets/6c031cc0-27c3-4ced-bfd8-cfe4379bdbdd)
",2478604552,"Hi @JaeTLDR, thatâ€™s a good question! This behavior actually makes sense because `z.discriminatedUnion` expects a tuple rather than a general array. When you define `const states = [state1, state2]`, TypeScript infers it as an array, which is incompatible with the tuple type requirement.

To fix this, you can adjust states to be explicitly typed as a tuple:

```typescript
const states: [typeof state1, typeof state2] = [state1, state2];
```
This way, TypeScript treats states as a tuple, making it compatible with `z.discriminatedUnion`. Hope this helps!"
2655668017,3849,z.discriminatedUnion requires literal array,"not sure why by discriminateUnion cannot use an array defined elsewhere.  Is this by design or fixable?
thanks

```typescript
const state1 = z.object({
    state: z.literal(""on""),
    text: z.string()
})
const state2 = z.object({
    state: z.literal(""off""),
    number: z.number()
})
const states = [state1,state2]

const dUnion1 = z.discriminatedUnion('state', states) // errors ; see image
const dUnion2 = z.discriminatedUnion('state', [state1,state2]) //works
```

![image](https://github.com/user-attachments/assets/6c031cc0-27c3-4ced-bfd8-cfe4379bdbdd)
",2481917752,"It's easier to type it as `const states = [state1,state2] as const` - `as const` will automatically infer the tightest type."
2655668017,3849,z.discriminatedUnion requires literal array,"not sure why by discriminateUnion cannot use an array defined elsewhere.  Is this by design or fixable?
thanks

```typescript
const state1 = z.object({
    state: z.literal(""on""),
    text: z.string()
})
const state2 = z.object({
    state: z.literal(""off""),
    number: z.number()
})
const states = [state1,state2]

const dUnion1 = z.discriminatedUnion('state', states) // errors ; see image
const dUnion2 = z.discriminatedUnion('state', [state1,state2]) //works
```

![image](https://github.com/user-attachments/assets/6c031cc0-27c3-4ced-bfd8-cfe4379bdbdd)
",2488618917,"Thanks @AlexChadwickP  that makes a lot more sense, would there be an advantage to Zod using a tuple rather than an array ? I wanted a way to 'register' various schemas (this would include other functionality as well) and use a discriminated union array as part of that, however adding a dynamic tuple has been its own rabbit hole that doesnt feel pheasable.

thanks @mitchell-merry  i did see that in my experiments and research after Alex's answer, it does seem cleaner and for now i am using it to keep my schemas together in a more relevant file than where the union lives"
2652974048,3847,Error trying to reuse inferred type,"I'm trying to use a type inferred from a zod schema, but when I need to reuse the inferred type in other generic function I just couldn't find a way of doing it.

Considering the following code:

```typescript
import { z } from 'zod';

const Schema = z.object({
  id: z.number(),
  name: z.string(),
  nickname: z.string().optional().default('')
});

export type SchemaDto = z.infer<typeof Schema>;

const parsedSchema: z.Schema<SchemaDto> = Schema;
```

I got the following error:

```
Type 'ZodObject<{ id: ZodNumber; name: ZodString; nickname: ZodDefault<ZodOptional<ZodString>>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<{ name: string; id: number; nickname: string; }, ZodTypeDef, { name: string; id: number; nickname: string; }>'.
  The types of '_input.nickname' are incompatible between these types.
    Type 'string | undefined' is not assignable to type 'string'.
      Type 'undefined' is not assignable to type 'string'.ts(2322)
```

I can understand that the inferred type assumed that, once I have the default `''` the field wouldn't be undefined in the generated type:

```typescript
type SchemaDto = {
    name: string;
    id: number;
    nickname: string;
}
```

But, if I need to use the generated type to force the usage of a Schema that is compatible with a type, I cannot use the inferred type to accomplish my goal.

In the documentation there's no information on how to infer a type without considering the `default`  to be able to reuse the inferred type in other generic functions. Is this a relevant functionality to the package?


",2478630568,"Hi @mauroviniciussilva that's correct, I looked into the documentation and found `.input`.

To work around this and get the input type (before defaults are applied), you can use `z.input<typeof Schema>` instead of `z.infer`. This will preserve the optionality of nickname, so itâ€™s typed as `string | undefined`, matching what you need for your generic function.

This is what your code would look like:

```typescript
import { z } from 'zod';

const Schema = z.object({
  id: z.number(),
  name: z.string(),
  nickname: z.string().optional().default('')
});

type SchemaInput = z.input<typeof Schema>;  //  nickname will be string | undefined

const parsedSchema: z.ZodType<SchemaInput> = Schema;
```"
2649724025,3845,Add `shape` on `ZodNullable` and `ZodOptional`,"Hi,

I need to traverse and get type of internal properties of a specific schema, but the problem is that, it is not predictable and when  for example some one adds `z.object().nullish()`, my main `ZodObject` will be wrapped in a ZodNullable and ZodOptional and I have to write some dirty code to read `_def` and inner type. Can we have `shape` method on ZodNullable and ZodOptional? so it can be called much easier.",,
2641746375,3840,Using function arg values in return validator," I think what I'd like to do is not currently possible in zod, but I'd love to be proven wrong.

The basic idea is the ability to use the function arguments in the returns validator.

So let's say I have an [`identity`](https://en.wikipedia.org/wiki/Identity_function) function, I'd like to do the following pseudo code:

`z.function().args(z.any()).returns((arg1, result) => { arg1 === result }).implements((arg1) => { arg1 })`

",2465570071,"Hi, what usecase would this have? Do you have an example of a schema with usage so we can understand this feature.
"
2641746375,3840,Using function arg values in return validator," I think what I'd like to do is not currently possible in zod, but I'd love to be proven wrong.

The basic idea is the ability to use the function arguments in the returns validator.

So let's say I have an [`identity`](https://en.wikipedia.org/wiki/Identity_function) function, I'd like to do the following pseudo code:

`z.function().args(z.any()).returns((arg1, result) => { arg1 === result }).implements((arg1) => { arg1 })`

",2465756304,"Hi, not sure I understand the question. The `identity` function is a use case in itself no ? But there are other cases, like forcing the output to contain the input. "
2635748162,3837,"We should not allow `optional`, `nullish`, or `nullable` on `z.coerce` schemas","Since `z.coerce.*` schemas will _always_ return the primitive, even if you pass `undefined` or `null`, we should disallow this. Also, things like `z.union([z.coerce.string(), z.coerce.number()])` will always return a `string` since the first schema will just always succeed.",,
2634288956,3836,feat: copy (clone) any schema,"I'm using zod with zod-to-openapi.

If I define the constant:

```typescript
export const userDataZodSchemas = {
  account: z.string().describe('account').optional(),
  avatar: z.string().describe('avatar url or path'),
  birthday: commonZodValidatorSchemas.iso8601DateString.describe('birthday (ISO 8601 format)').optional(),
  nickname: z.string().describe('nickname')
  // More...
};
```

Now I'm going to use this entire constant in a number of places, such as in the user information API document.

But I also use it when updating user data, if I only want to use the nickname field and it's optional when updating user data.

But when I use `userDataZodSchemas.nickname.optional()`, it makes that field in the API on the user info side non-required as well, I should say it makes userDataZodSchemas.nickname directly optional!

Is there a way to copy the entire schema?",2456149192,"It looks like I'm misreading the code, but there's no such problem."
2634213262,3835,Proposal to Add Japanese Documentation for Zod,"Hi, I am a native Japanese speaker, and Iâ€™m interested in contributing Japanese documentation for Zod. I believe this could make Zod more accessible to Japanese developers and support the community. I havenâ€™t started the work yet, but if youâ€™re open to it, Iâ€™d be glad to begin and eventually submit a pull request. Thank you for considering this idea!",,
2634085714,3834,[suggestion] regex validation errors should include the pattern,"If I have a schema with a .regex(), and attempt to parse an invalid value:

```ts
const SomeSchema = z.string().regex(/^[a-z]+$/);
SomeSchema.parse('abc3');
```

The error I get looks like this:
```
ZodError: [
  {
    ""validation"": ""regex"",
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": []
  }
]
```

It would be very nice if this error included a way to get the pattern which failed, like so:
```ts
ZodError: [
  {
    ""validation"": ""regex"",
    ""pattern"": /^[a-z]+$/,
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": []
  }
]
```

or something like that - maybe errors can start including the zod schema it relates to, so that I can infer these things myself.
```ts
ZodError: [
  {
    ""validation"": ""regex"",
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": [],
    ""schema"": ...
  }
]
```

I can currently get around this like so:
```ts
const regexRefine = (regex: RegExp) =>
  [
    (data: string) => regex.test(data),
    `String does not match regex ${regex}`,
  ] as const;
const SomeSchema = z.string().refine(...regexRefine(/^[a-z]+$/));
```",2460952489,"Actually, this is way better:
```ts
const regexWithPatternInError = (regex: RegExp): [RegExp, string] =>
  [regex, `String does not match pattern ""${regex}""`] as const;
```

```ts
const SomeSchema = z.string().regex(...regexWithPatternInError(/^[a-z]+$/));
```

but the issue still stands"
2634085714,3834,[suggestion] regex validation errors should include the pattern,"If I have a schema with a .regex(), and attempt to parse an invalid value:

```ts
const SomeSchema = z.string().regex(/^[a-z]+$/);
SomeSchema.parse('abc3');
```

The error I get looks like this:
```
ZodError: [
  {
    ""validation"": ""regex"",
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": []
  }
]
```

It would be very nice if this error included a way to get the pattern which failed, like so:
```ts
ZodError: [
  {
    ""validation"": ""regex"",
    ""pattern"": /^[a-z]+$/,
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": []
  }
]
```

or something like that - maybe errors can start including the zod schema it relates to, so that I can infer these things myself.
```ts
ZodError: [
  {
    ""validation"": ""regex"",
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": [],
    ""schema"": ...
  }
]
```

I can currently get around this like so:
```ts
const regexRefine = (regex: RegExp) =>
  [
    (data: string) => regex.test(data),
    `String does not match regex ${regex}`,
  ] as const;
const SomeSchema = z.string().refine(...regexRefine(/^[a-z]+$/));
```",2484259002,"There's another way to get the regex which might be useful for some cases:

```typescript
declare const stringSchema: z.ZodString;

const regex = stringSchema._def.checks.find(c => c.kind === ""regex"")?.regex;
```"
2634085714,3834,[suggestion] regex validation errors should include the pattern,"If I have a schema with a .regex(), and attempt to parse an invalid value:

```ts
const SomeSchema = z.string().regex(/^[a-z]+$/);
SomeSchema.parse('abc3');
```

The error I get looks like this:
```
ZodError: [
  {
    ""validation"": ""regex"",
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": []
  }
]
```

It would be very nice if this error included a way to get the pattern which failed, like so:
```ts
ZodError: [
  {
    ""validation"": ""regex"",
    ""pattern"": /^[a-z]+$/,
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": []
  }
]
```

or something like that - maybe errors can start including the zod schema it relates to, so that I can infer these things myself.
```ts
ZodError: [
  {
    ""validation"": ""regex"",
    ""code"": ""invalid_string"",
    ""message"": ""Invalid"",
    ""path"": [],
    ""schema"": ...
  }
]
```

I can currently get around this like so:
```ts
const regexRefine = (regex: RegExp) =>
  [
    (data: string) => regex.test(data),
    `String does not match regex ${regex}`,
  ] as const;
const SomeSchema = z.string().refine(...regexRefine(/^[a-z]+$/));
```",2484475878,"Right, but unfortunately the ZodError doesn't include the schema that failed, so I'm unable to even inspect the schema"
2632744965,3833,".describe() is not wrapping, but creates a ""new"" _def","Hey there ðŸ‘‹ 

I've regularly hoped for some kind of ""metadata"" in zod, but read a lot of discussion about  why it's not needed.

In my case, I just need to be able to identify some of my own schemas.
I do this by comparing `someSchema._def` with `mySchema._def`, unwrapping optional et al.

Now I noticed that it does not work with descriptions. Digging into the zod code, I found this:
https://github.com/colinhacks/zod/blob/086273160e5952ee661a7b9db82fc757f0e68eab/src/types.ts#L499-L505

My feeling is that this means that the ._def will not point to my schema anymore.
What do you think about adding something like `unwrap` or `innerType` to describe, too?
Or am I doing something wrong?",2465574094,"Hi, this pattern is very common in zod, the general def type name will be available, might not be what you need but that could be a pointer in the right direction."
2632744905,3832,".describe() is not wrapping, but creates a ""new"" _def","Hey there ðŸ‘‹ 

I've regularly hoped for some kind of ""metadata"" in zod, but read a lot of discussion about  why it's not needed.

In my case, I just need to be able to identify some of my own schemas.
I do this by comparing `someSchema._def` with `mySchema._def`, unwrapping optional et al.

Now I noticed that it does not work with descriptions. Digging into the zod code, I found this:
https://github.com/colinhacks/zod/blob/086273160e5952ee661a7b9db82fc757f0e68eab/src/types.ts#L499-L505

My feeling is that this means that the ._def will not point to my schema anymore.
What do you think about adding something like `unwrap` or `innerType` to describe, too?
Or am I doing something wrong?",,
2627162097,3827,Issue with high character limits,"When the character limit is set to 1,500, Zod seems to incorrectly count the characters, saying that the limit is reached at 1,497 characters. So to get exactly 1,500 characters to be accepted, the limit needs to be set higher to 1,503.

I tested using:
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exe
",2451815281,"```
`Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exe`.length
// ^ 1503
```
So seems you are using a larger string and that won't work for max(1500)."
2627162097,3827,Issue with high character limits,"When the character limit is set to 1,500, Zod seems to incorrectly count the characters, saying that the limit is reached at 1,497 characters. So to get exactly 1,500 characters to be accepted, the limit needs to be set higher to 1,503.

I tested using:
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exe
",2451912664,"I am not sure if my first post was confusing, so I will try to clarify:

1. I tried setting a max(1500)
2. With this max(1500), I tested the following (1,500 characters):
```
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exe
```
3.  However, validation was saying that this was over the limit, when I don't think it should (1,500 characters and a max(1500). I set the max(1503) and then it worked.


Is there a reason I am missing as to why Zod counts this as 1503 characters? Other tools seem to count it as 1,500.
"
2627162097,3827,Issue with high character limits,"When the character limit is set to 1,500, Zod seems to incorrectly count the characters, saying that the limit is reached at 1,497 characters. So to get exactly 1,500 characters to be accepted, the limit needs to be set higher to 1,503.

I tested using:
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exe
",2452342766,"My previous comment was your exact string `.length`, try so yourself in the developer console.

So question should be with the other tools, not zod."
2627162097,3827,Issue with high character limits,"When the character limit is set to 1,500, Zod seems to incorrectly count the characters, saying that the limit is reached at 1,497 characters. So to get exactly 1,500 characters to be accepted, the limit needs to be set higher to 1,503.

I tested using:
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exe
",2456170962,"If i had to guess, your generator isn't including the 3 newline characters?"
2627162097,3827,Issue with high character limits,"When the character limit is set to 1,500, Zod seems to incorrectly count the characters, saying that the limit is reached at 1,497 characters. So to get exactly 1,500 characters to be accepted, the limit needs to be set higher to 1,503.

I tested using:
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exe
",2465576242,I think this issue can be closed.
2626417424,3826,generic Omit function breaks type inferance ,"When using a function to omit shared keys among many schemas z.infer nolonger exports the underlying types correctly 

```typescript 
import { z } from ""zod"";

const metaKeys = {
    _rid: z.string(),
    _self: z.string(),
    _etag: z.string(),
    _attachments: z.string(),
    _ts: z.string(),
};

function omitMetaKeys(schema: z.AnyZodObject): z.AnyZodObject {
    return schema.merge(z.object({...metaKeys})).omit(Object.keys(metaKeys).reduce((prev, curr) => { return { [curr]: true, ...prev } }, {}));
}

export const mySchema = z.object({
    id: z.string(),
});
export interface myType extends z.infer<typeof mySchema> {}
// works correctly complaining about the missing id property
const eg:myType ={}

export const myOmitSchema = omitMetaKeys(z.object({
    id: z.string(),
}));
export interface myOmitType extends z.infer<typeof myOmitSchema> {}
//does not complain, whihc is incorrect behaviour
const egOmit:myOmitType ={} 
```
<img width=""701"" alt=""image"" src=""https://github.com/user-attachments/assets/ce816280-0263-42e5-8893-e48a9caa590c"">



if  we use the same schema and remove the call to omitMetaKeys, we gain typing within vscode

<img width=""720"" alt=""image"" src=""https://github.com/user-attachments/assets/8b8e3e3d-f13b-4598-88b6-6f23c00f31d7"">
",2453454729,"Hi,
My first thought is that it 'breaks' because you are returning z.AnyZodObject, and not a generic T extends AnyZodObject.

if you would change it into:

```ts

function omitMetaKeys<T extends z.AnyZodObject>(schema: T): Omit<z.infer<T>, 'key_a' | 'key_b'> {
    return schema.merge(z.object({...metaKeys})).omit(Object.keys(metaKeys).reduce((prev, curr) => { return { [curr]: true, ...prev } }, {}));
}

```

Then I believe it should work.

Try to extract the keys from your metadata, then you can use that in the Omit TS generic type.
"
2626417424,3826,generic Omit function breaks type inferance ,"When using a function to omit shared keys among many schemas z.infer nolonger exports the underlying types correctly 

```typescript 
import { z } from ""zod"";

const metaKeys = {
    _rid: z.string(),
    _self: z.string(),
    _etag: z.string(),
    _attachments: z.string(),
    _ts: z.string(),
};

function omitMetaKeys(schema: z.AnyZodObject): z.AnyZodObject {
    return schema.merge(z.object({...metaKeys})).omit(Object.keys(metaKeys).reduce((prev, curr) => { return { [curr]: true, ...prev } }, {}));
}

export const mySchema = z.object({
    id: z.string(),
});
export interface myType extends z.infer<typeof mySchema> {}
// works correctly complaining about the missing id property
const eg:myType ={}

export const myOmitSchema = omitMetaKeys(z.object({
    id: z.string(),
}));
export interface myOmitType extends z.infer<typeof myOmitSchema> {}
//does not complain, whihc is incorrect behaviour
const egOmit:myOmitType ={} 
```
<img width=""701"" alt=""image"" src=""https://github.com/user-attachments/assets/ce816280-0263-42e5-8893-e48a9caa590c"">



if  we use the same schema and remove the call to omitMetaKeys, we gain typing within vscode

<img width=""720"" alt=""image"" src=""https://github.com/user-attachments/assets/8b8e3e3d-f13b-4598-88b6-6f23c00f31d7"">
",2458782713,"Thanks this seems to be much closer, your code didn't seem to work for me, but the below did, however i am not sure how 'good' it is in comparison in terms of typescript correctness.
```typescript
function omitMetaKeys<T extends z.AnyZodObject>(schema: T): T {
    return schema.merge(z.object({...metaKeys})).omit(Object.keys(metaKeys).reduce((prev, curr) => { return { [curr]: true, ...prev } }, {})) as T;
}
```

further suggestions are very welcome,

Thanks again 
"
2626197019,3825,Type inference issue with extending/narrowing enum types in generic schemas,"I'm encountering a TypeScript error when trying to extend/narrow an enum type in a generic schema context. While TypeScript normally allows narrowing of enum types, this doesn't seem to work properly with Zod's type system.

```ts
import { z } from 'zod';

// Base schema with broader enum
const baseSchema = z.object({
gender: z.enum([""RÃ¼de"", ""HÃ¼ndin"", ""mÃ¤nnlich"", ""weiblich""]).nullable(),
// ... other fields
});
// Trying to create a more specific schema with narrower enum
const dogSchema = z.object({
gender: z.enum([""RÃ¼de"", ""HÃ¼ndin""]).nullable(),
// ... other fields
});
// Generic interface that should accept both schemas
interface MyInterface<T extends typeof baseSchema> {
schema: T;
// ... other properties
}
// This fails with type error even though dogSchema's enum is a subset of baseSchema's enum
const implementation: MyInterface<typeof dogSchema> = {
schema: dogSchema
};
```


the type error probobly happens since zod is saying that 

` Type 'ZodEnum<[""RÃ¼de"", ""HÃ¼ndin""]>' is not assignable to type 'ZodEnum<[""RÃ¼de"", ""HÃ¼ndin"", ""mÃ¤nnlich"", ""weiblich""]>`


### Expected Behavior
Since the enum in `dogSchema` is a subset of the enum in `baseSchema`, and TypeScript normally allows this kind of type narrowing, the implementation should type-check successfully.

### Actual Behavior
TypeScript produces an error indicating that the narrower enum type is not assignable to the broader enum type when used in this generic context with Zod schemas.

### Possible Solutions
One potential solution might be to add a utility type or method to Zod that explicitly handles enum narrowing in generic contexts, similar to how TypeScript handles normal enum type narrowing.

",2453455720,"Hi, zod does not actually know that the values are the same, does it?

Have you tried with .extend or .merge?"
2623035812,3824,`ZodCatch` Rethrow,"I was working on my library: https://github.com/samchungy/zod-openapi and was trying to simplify how I determine if a schema should be ""required"".

`ZodCatch` I initially thought I could handle as if nothing happened, however, it seems to accept `undefined` which makes it technically optional. I believe consumers should be able to mark this as a required schema since we have `.default()` to be able to handle `undefined` values.

I think it would be helpful for consumers to be able to catch the error, and to rethrow/or return a ZodError if they think it should be still flagged as invalid.

eg.

```ts
const schema = z.string().min(1).catch((ctx) => {
  if (ctx.input === undefined) {
    throw ctx.error;
  }
  return 'foo'
})

schema.safeParse(undefined); // Does not throw
schema.isOptional() // false

```
It would be akin to `z.string().optional()` with `.refine()` but your input boundary would be introspectable as non optional

",,
2619668368,3821,Bigint with coerce throws exception in safeParse and safeParseAsync,"Hi,

I noticed a bug while using safeParse and safeParseAsync. Those methods IMO shouldn't throw any errors. Instead, they should hold error in returned object. However, currently this does not work in case of coerced big integers.

Here's an example snippet:
```
const { z } = require(""zod"");
const schema = z.object({
  data: z.coerce.bigint(),
});
const example = { data: undefined };
try {
  const result = schema.safeParse(example);
  console.log(""RESULT ok?: "", result.success);
} catch (err) {
  console.error(""Catched: "", err);
}
```

Excepted output
`RESULT ok?: false`

**Actual output**

```
Catched:  TypeError: Cannot convert undefined to a BigInt
    at BigInt (<anonymous>)
    at ZodBigInt._parse (/home/aleksander/projects/zod-bigint-error/node_modules/zod/lib/types.js:1205:26)
    at ZodObject._parse (/home/aleksander/projects/zod-bigint-error/node_modules/zod/lib/types.js:1864:37)
    at ZodObject._parseSync (/home/aleksander/projects/zod-bigint-error/node_modules/zod/lib/types.js:146:29)
    at ZodObject.safeParse (/home/aleksander/projects/zod-bigint-error/node_modules/zod/lib/types.js:176:29)
    at Object.<anonymous> (/home/aleksander/projects/zod-bigint-error/index.js:10:25)
    at Module._compile (node:internal/modules/cjs/loader:1469:14)
    at Module._extensions..js (node:internal/modules/cjs/loader:1548:10)
    at Module.load (node:internal/modules/cjs/loader:1288:32)
    at Module._load (node:internal/modules/cjs/loader:1104:12)
```
 ",,
2612647831,3816,Strip conditions from a schema,"I would like to be able to achieve this

```
const myZodSchema = z.object({
  property: z.integer().min(5).max(10)
  property2: z.integer().min(5).max(10)
})

const myZodSchemaOnlyCheckType = z.stripKeywords(myZodSchema, ['min', 'max'])

// Should return 
z.object({
  property: z.integer()
   property2: z.integer()
})
```

Is there any way to do that?

### Some context
I am building an app which uses Drizzle, Zod and Open AI.

On my app, I defined a Drizzle schema and generate a zod schema from it.
```
import { createInsertSchema } from 'drizzle-zod';

export const profiles = pgTable(
  'profiles',
  {
    headline: varchar('headline', { length: 255 }).notNull(),
  },
);

export const insertProfileSchema = createInsertSchema(profiles);
```


then send the schema over to Open AI to get [Structured output](https://platform.openai.com/docs/guides/structured-outputs/supported-schemas?context=ex1). 

The generated Zod schema would include the `length` check. However, [OpenAI doesn't support some keyword at the moment](https://platform.openai.com/docs/guides/structured-outputs/some-type-specific-keywords-are-not-yet-supported), including maxLength. So that's why I am trying to work around this.

I've tried with `createSelectSchema` from `drizzle-zod` without luck.

Any other more elegant solutions are welcomed. :)",,
2602135013,3813,The inferred type of <SchemaName> references an inaccessible this type. A type annotation is necessary.,"I'm using Zod with NestJS and facing an issue when trying to declare properties as .nullish() or .nullable().

An example
```ts
import { z } from 'zod';

export const partnerSchema = z.object({
  projectName: z.string(),
  startDate: z.coerce.date(),
  projectDuration: z.number().nullish(),
});
```
This yields a TS2527 error.

![image](https://github.com/user-attachments/assets/5ee647e8-501b-46eb-853b-ce29622ffb4c)
",2428394387,"I used this code snippet, but it didnâ€™t raise any exceptions. This might be related to the TypeScript configuration or other factors. Could you provide a minimal reproduction?"
2600957698,3812,ZodUnion options type bound causes unwanted errors,"This shouldn't happen:

```ts
z.union(
  ([1, 2, 3, 5, 8, 11] as const).map((value) => z.literal(value)),
  // ERROR: Argument of type 'ZodLiteral<number>[]' is not assignable to parameter of type 'readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
  //   Source provides no match for required element at position 0 in target.ts(2345)
)
```

I get that `[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]` is supposed to catch cases where someone accidentally makes a zero or one-option union, since that might be a mistake, though it's not technically invalid and zero/one-element unions have well-defined behavior.  But it's annoying to break a valid use case for the sake of this.

What's especially bad about this is *I can't just suppress the error*, because Zod doesn't even infer the correct input/output types here.  I'm forced to write out an explicit array literal to get Zod to infer the correct type:

```ts
z.union([
  z.literal(1),
  z.literal(2),
  // Could spread a .map after this point, but it's still an unnecessary waste of bytes
  z.literal(3),
  z.literal(5),
  z.literal(8),
  z.literal(11),
])
```

Which situation should take precedence?
1. Errors on potential mistakes that doesn't cause undefined behavior
2. No errors on clearly valid use cases

I would argue No. 2 should win here.  The type is overwrought.

Accepting just `ZodTypeAny[]` would work fine; the type of `[][number]` is `never`, the same as `z.union([])` accepts at runtime, hence any code that parses a value or operates on parse output will get a compile error if it expects a type other than `never`.  This will allow users who accidentally made a zero-option union to catch their mistake.  Some users may be generating the union options dynamically and have cases where it's intentional to end up with no options.  In those cases the type parameter inferred from their code will probably be an array type instead of a tuple type, which seems fine to me for a case where you're generating options dynamically.",,
2598369603,3808,Error Message docs inconsistent with actual behaviour for string().date() validation method,"The string().date() validation message takes a string as a parameter, 
`date(message?: string): ZodString;`
whereas all the rest of the methods take in an errorUtil.ErrMessage, ex:
`email(message?: errorUtil.ErrMessage): ZodString;`

This is not a huge issue, though it is inconsistent with the docs which show error messages for the string().date() validator can be set in this way
`z.string().date({ message: ""Invalid date string!"" });`
when they actually are set like this 
`z.string().date(""Invalid date string!"");`
",,
2594916725,3806,Allow nativeEnum() after coerce,"Currently a string like ""1"" cant be casted to a number enum:

```ts
enum Animals {
   Dog, // 0
   Cat, // 1
}

const param = '1'; // From query params, always comes as a string

// This throws error, which is correct because param is a string:
const animal = z.nativeEnum(Animals).parse(param);

// This should work, but is not supported by zod, error: ""Property nativeEnum does not exist on type ZodNumber""
const animal = z.coerce.number().nativeEnum(Animals).parse(param);

// This would be cool, too, error: ""Property nativeEnum does not exist on type""
const animal = z.coerce.nativeEnum(Animals).parse(param);
```

### Motivation
Query params always come as a string, e.g.

```ts
GET /animals/2
```

Will be `""2""` instead of `2` and therefor cant be casted to an enum with zod


### Workaround
```ts
const animal = z.coerce.number().pipe(z.nativeEnum(Animal)).parse(param);
```",,
2593952575,3804,Error on nested discriminated unions,"Hi,

I have a schema like so:
```typescript
const bananaSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('banana'),
  value: z.string(),
});

const orangeSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('orange'),
  value: z.string(),
});

const discriminatedFruitSchema = z.discriminatedUnion('subType', [bananaSchema, orangeSchema]);

const vegetableSchema = z.object({
  type: z.literal('vegetable'),
  value: z.string(),
});

export const discriminatedFoodSchema = z.discriminatedUnion('type', [
  vegetableSchema,
  ...discriminatedFruitSchema.options,
]);
```

All is good at first, but when I parse using the schema I get the following error:
```
/.../zod/lib/types.js:2386
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                          ^
Error: Discriminator property type has duplicate value fruit
```

",2419209053,`bananaSchema` and `orangeSchema` has the same `type`.
2593952575,3804,Error on nested discriminated unions,"Hi,

I have a schema like so:
```typescript
const bananaSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('banana'),
  value: z.string(),
});

const orangeSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('orange'),
  value: z.string(),
});

const discriminatedFruitSchema = z.discriminatedUnion('subType', [bananaSchema, orangeSchema]);

const vegetableSchema = z.object({
  type: z.literal('vegetable'),
  value: z.string(),
});

export const discriminatedFoodSchema = z.discriminatedUnion('type', [
  vegetableSchema,
  ...discriminatedFruitSchema.options,
]);
```

All is good at first, but when I parse using the schema I get the following error:
```
/.../zod/lib/types.js:2386
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                          ^
Error: Discriminator property type has duplicate value fruit
```

",2419226109,"> `bananaSchema` and `orangeSchema` has the same `type`.

Yes, that's intended, as both are of type `fruit`. It's their subtypes ('banana' and 'orange') that differ. So I basically want something like:
```
               type: fruit/vegetable DU
                         |
     orange/banana DU        vegetable schema
          |
  subType: banana/orange
                 |
  orange schema     banana schema
   ```
    "
2593952575,3804,Error on nested discriminated unions,"Hi,

I have a schema like so:
```typescript
const bananaSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('banana'),
  value: z.string(),
});

const orangeSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('orange'),
  value: z.string(),
});

const discriminatedFruitSchema = z.discriminatedUnion('subType', [bananaSchema, orangeSchema]);

const vegetableSchema = z.object({
  type: z.literal('vegetable'),
  value: z.string(),
});

export const discriminatedFoodSchema = z.discriminatedUnion('type', [
  vegetableSchema,
  ...discriminatedFruitSchema.options,
]);
```

All is good at first, but when I parse using the schema I get the following error:
```
/.../zod/lib/types.js:2386
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                          ^
Error: Discriminator property type has duplicate value fruit
```

",2419274928,"If you combine all of them, you can't use type alone to distinguish between them. What you need is something like this:

```ts
z.discriminatedUnion(z.union(['type', 'subType']), [
  vegetableSchema,
  ...discriminatedFruitSchema.options,
]);
```
However, currently, it only supports a single string as the discriminator."
2593952575,3804,Error on nested discriminated unions,"Hi,

I have a schema like so:
```typescript
const bananaSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('banana'),
  value: z.string(),
});

const orangeSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('orange'),
  value: z.string(),
});

const discriminatedFruitSchema = z.discriminatedUnion('subType', [bananaSchema, orangeSchema]);

const vegetableSchema = z.object({
  type: z.literal('vegetable'),
  value: z.string(),
});

export const discriminatedFoodSchema = z.discriminatedUnion('type', [
  vegetableSchema,
  ...discriminatedFruitSchema.options,
]);
```

All is good at first, but when I parse using the schema I get the following error:
```
/.../zod/lib/types.js:2386
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                          ^
Error: Discriminator property type has duplicate value fruit
```

",2419388990,"Yeah, I'm guessing nested discriminated unions with different discriminators aren't currently supported? "
2593952575,3804,Error on nested discriminated unions,"Hi,

I have a schema like so:
```typescript
const bananaSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('banana'),
  value: z.string(),
});

const orangeSchema = z.object({
  type: z.literal('fruit'),
  subType: z.literal('orange'),
  value: z.string(),
});

const discriminatedFruitSchema = z.discriminatedUnion('subType', [bananaSchema, orangeSchema]);

const vegetableSchema = z.object({
  type: z.literal('vegetable'),
  value: z.string(),
});

export const discriminatedFoodSchema = z.discriminatedUnion('type', [
  vegetableSchema,
  ...discriminatedFruitSchema.options,
]);
```

All is good at first, but when I parse using the schema I get the following error:
```
/.../zod/lib/types.js:2386
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                          ^
Error: Discriminator property type has duplicate value fruit
```

",2419400840,Yes.
2593262377,3802,suggestion: z.record() should support .max() and .min() to specify a number of properties,"_Apologies if this is a duplicate - I wasn't able to find any existing discussion on this topic._

I have a use case where I'm trying to replicate the behaviour of the minProperties / maxProperties (see https://json-schema.org/draft/2020-12/json-schema-validation#name-validation-keywords-for-obj).

I can currently achieve this like so:

```ts
const TestSchema = z.record(z.string()).refine(
  value => {
    const propertyCount = Object.keys(value).length;
    return propertyCount >= 1 && propertyCount <= 3;
  },
  {
    message: 'Invalid input: must have between 1 and 3 properties',
  },
);
```

Which results in:
```ts
TestSchema.safeParse({}).success; // false
TestSchema.safeParse({ a: 'foo' }).success; // true
TestSchema.safeParse({ a: 'foo', b: 'bar', c: 'baz' }).success; // true
TestSchema.safeParse({ a: 'foo', b: 'bar', c: 'baz', d: 'buz' }).success; // false
```

I'm proposing that there's an API like so:
```ts
const TestSchema = z.record(z.string()).min(1).max(3);
```

that behaves the same way, primarily so that JSON schema generation tools can read `min` and `max` here to fill in the `maxProperties` and `minProperties` fields in their generated schemas.

It may be more useful for this to be extended more generally into a `minProperties()` and `maxProperties()` that is usable for anything that resembles a `z.object`, so that it can deal with more complex intersections and constructions of objects than just records. It also may be useful to include a `.length()` equivalent (though at this moment I don't have use for it).",,
2589320941,3799,Branded record keys break generics when used in an object with other branded types,"## Versions ##
Zod: 3.23.8
Typescript: 5.6.3

## Observations ##
```ts
import { z } from 'zod';

function testFn<T>(zodType: z.ZodType<T>) {
  return zodType;
}

const branded_1 = z.string().brand('type1');
const branded_2 = z.string().brand('type2');
const bad_record = z.record(branded_1, z.string());

const good_1 = z.object({
  branded_1,
});
testFn(good_1); // No type errors, a branded_1 in an object is fine

const good_2 = z.object({
  branded_2,
});
testFn(good_2); // No type errors, branded_2 in an object is fine

const good_3 = z.object({
  branded_1,
  branded_2,
  record_1: z.record(branded_1, z.any()),
  record_2: z.record(branded_1, z.unknown()),
  record_3: z.record(branded_1, z.undefined()),
});
testFn(good_3); // No type errors, we can have branded records where the value is potentially undefined

const good_4 = z.object({
  bad_record,
});
testFn(good_4); // No type errors, bad_record is not bad by itself

const good_5 = z.object({
  x: z.number(),
  bad_record,
});
testFn(good_5); // No type errors, bad_record is not bad with some other non-branded types

const bad_1 = z.object({
  branded_1,
  bad_record,
});
testFn(bad_1); // Type error!, bad_record cannot be put with another branded type here

const bad_2 = z.object({
  branded_2,
  bad_record,
});
testFn(bad_2); // Type error! it doesn't matter if it's mixed with the branded type it uses, any other branded type will cause the issue

const bad_3 = z.object({
  a: z.object({
    branded_2,
  }),
  b: z.object({
    bad_record,
  }),
});
testFn(bad_3); // Type error! Issue still occurs when separately nested
```

Errors are:
```log
mre.ts(45,8): error TS2345: Argument of type 'ZodObject<{ branded_1: ZodBranded<ZodString, ""type1"">; bad_record: ZodRecord<ZodBranded<ZodString, ""type1"">, ZodString>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to parameter of type 'ZodType<{ branded_1: string & BRAND<""type1"">; bad_record: Partial<Record<string & BRAND<""type1"">, string>>; }, ZodTypeDef, { branded_1: string & BRAND<...>; bad_record: Partial<...>; }>'.
  The types of '_input.branded_1' are incompatible between these types.
    Type 'string' is not assignable to type 'string & BRAND<""type1"">'.
      Type 'string' is not assignable to type 'BRAND<""type1"">'.
mre.ts(51,8): error TS2345: Argument of type 'ZodObject<{ branded_2: ZodBranded<ZodString, ""type2"">; bad_record: ZodRecord<ZodBranded<ZodString, ""type1"">, ZodString>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to parameter of type 'ZodType<{ branded_2: string & BRAND<""type2"">; bad_record: Partial<Record<string & BRAND<""type1"">, string>>; }, ZodTypeDef, { branded_2: string & BRAND<...>; bad_record: Partial<...>; }>'.
  The types of '_input.branded_2' are incompatible between these types.
    Type 'string' is not assignable to type 'string & BRAND<""type2"">'.
      Type 'string' is not assignable to type 'BRAND<""type2"">'.
mre.ts(61,8): error TS2345: Argument of type 'ZodObject<{ a: ZodObject<{ branded_2: ZodBranded<ZodString, ""type2"">; }, ""strip"", ZodTypeAny, { branded_2: string & BRAND<""type2"">; }, { branded_2: string; }>; b: ZodObject<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to parameter of type 'ZodType<{ a: { branded_2: string & BRAND<""type2"">; }; b: { bad_record: Partial<Record<string & BRAND<""type1"">, string>>; }; }, ZodTypeDef, { ...; }>'.
  The types of '_input.a.branded_2' are incompatible between these types.
    Type 'string' is not assignable to type 'string & BRAND<""type2"">'.
```

## Expected ##

`testFn` should take any instance of `ZodType`, which `ZodObject` extends, without error.",,
2589138304,3798,Email Regex not respecting RFC,"In our project we validate email addresses using `z.string().email()`, a user reported that he couldn't signup since his email was containing an `&` (`user&user@company.com`).

According to the email RFC (section [3.4.1][local-part-rfc] and [3.2.4][atom-rfc]) it should allow the following special characters:

```
atext           =       ALPHA / DIGIT / ; Any character except controls,
                        ""!"" / ""#"" /     ;  SP, and specials.
                        ""$"" / ""%"" /     ;  Used for atoms
                        ""&"" / ""'"" /
                        ""*"" / ""+"" /
                        ""-"" / ""/"" /
                        ""="" / ""?"" /
                        ""^"" / ""_"" /
                        ""`"" / ""{"" /
                        ""|"" / ""}"" /
                        ""~""
```

but in the current regex the `&` is not included: 
https://github.com/colinhacks/zod/blob/3032e240a0c227692bb96eedf240ed493c53f54c/src/types.ts#L600

[atom-rfc]: https://datatracker.ietf.org/doc/html/rfc2822#section-3.2.4
[local-part-rfc]: https://datatracker.ietf.org/doc/html/rfc2822#section-3.4.1",,
2583490246,3795,ZodType is not contravariant to the input,"## Background

[Contravariance](https://www.typescriptlang.org/docs/handbook/2/generics.html#variance-annotations) is a property associated of generic types on their type parameters where the generic type `G<A>` extends `G<B>` if `B` extends `A`. It is usually associated with type parameters used as inputs.

Each `ZodType` is composed of an input and an output type. Consider, for instance, the following Zod schema:

```ts
const s = z.object({
    a: z.string().default(""foo"")
});
```

Its input type has `a` as an optional field, but it is required on the output type:

```ts
type A = z.input<typeof s>; // { a?: string | undefined; }
type B = z.output<typeof s>; // {a: string}
```

## Description

Given that the input and output types are type parameters to `ZodType`, one might expect `ZodType` to be covariant on the output type and contravariant on the input type. While the former is true, the latter, unfortunately, is not.

## Example
```ts
function f<S extends z.ZodType<string, any, any>>(_: S) {}
f(z.literal(""a"")); // Works fine

function g<S extends z.ZodType<any, any, ""a"">>(_: S) {}
g(z.string()); // Errors out :(
```

## Expected behaviour

`ZodType` should be contravariant with respect to the input type

## Actual behaviour

`ZodType` is not contravariant with respect to the input type",,
2581581665,3794,Unable to chain min & max method on string,"I have created a custom zod Instance to check any string if it contains ""undefined"" or ""null"" as string.

```ts
import { z } from 'zod'

export const cZ = {
    ...z,
    string: () =>
        z
            .string()
            .refine((val) => val !== 'undefined' && val !== 'null', {
                message: 'string cannot be ""undefined"" or ""null""',
            })
}
```

Now when i tried to use this custom zod instance i am unable to chain min and max methods on strings.

```ts
import { cZ } from '..utils/custom-zod.js'

const user = cZ.object({
    name : cZ.string().min(2).max(20)
})

```
",,
2580779281,3793,"Does not infer the types correctly, forcing me to cast the typing","When using safeParse with SelectOption and SelectOptionDto, TypeScript does not infer the types correctly, forcing me to cast parseResult.data manually as { id: T; label: string }.

```TypeScript
const { id, label } = parseResult.data as { id: T; label: string };

const maybeSelectOption = SelectOption(valueSchema).safeParse({
    value: id,
    label,
});
```
However, parseResult comes from:
```TypeScript
const parseResult = SelectOptionDto(valueSchema).safeParse(selectOptionDto);
```
```TypeScript
export const SelectOption = <T extends z.ZodTypeAny = z.ZodNumber>(
    valueSchema: T = z.number() as z.infer<T>,
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
) =>
    z
        .object({
            value: valueSchema,
            label: z.string(),
        })
        .strict()
        .brand(""SelectOption"");

export type SelectOptionInputProps<T extends z.ZodTypeAny = z.ZodNumber> =
    z.input<ReturnType<typeof SelectOption<T>>>;

export type SelectOption<T extends z.ZodTypeAny = z.ZodNumber> = z.infer<
    ReturnType<typeof SelectOption<T>>
```

```TypeScript
export const SelectOptionDto = <T extends z.ZodTypeAny = z.ZodNumber>(
    valueSchema: T = z.number() as z.infer<T>,
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
) =>
    z
        .object({
            id: valueSchema,
            label: z.string(),
        })
        .strict()
        .readonly();

export type SelectOptionDto<T extends z.ZodTypeAny = z.ZodNumber> = z.infer<
    ReturnType<typeof SelectOptionDto<T>>
>;
```

Question:
Is this a known typing issue with zod or could it be a problem with how Iâ€™m using generics?
Should this work without manual casting?
Additional info:
zod version: 3.23.8
TypeScript version: 5.5.3",,
2577068952,3791,"SourceType fully unrolls nested refinements, but TypeScript types don't reflect this.","In attempting to utilize `sourceType` on a ZodEffect to get to the underlying ZodObject, I discovered that in a situation where I have two refinements chained the types are inconsistent with the behaviour.

In a situation where you have two refinements chained, such as:
``` typescript
const nestedRefinementSchema = z.object({
  number: z.number(),
}).refine(data => {
  return data.number > 5;
}).refine(data => {
  return data.number < 10;
});
```

Calling .sourceType() on the returned schema will return a ZodObject, but the types expect it to be ZodEffect.

``` typescript
nestedRefinementSchema.sourceType(); // Returns a ZodObject, but the Types still believe it is a ZodEffect wrapping a ZodObject.
```

Here's a larger example demonstrating this:
``` typescript
import * as z from ""zod"";

const baseSchema = z.object({
  number: z.number(),
});

const firstRefinement = baseSchema.refine((data) => {
  return data.number > 5;
});
/**
 * const firstRefinementSourceType: z.ZodObject<{
    number: z.ZodNumber;
}, ""strip"", z.ZodTypeAny, {
    number: number;
}, {
    number: number;
}>
 */
const firstRefinementSourceType = firstRefinement.sourceType();

const secondRefinement = firstRefinement.refine((data) => {
  return data.number < 10;
});
/**
 * const secondRefinementSourceType: z.ZodEffects<z.ZodObject<{
    number: z.ZodNumber;
}, ""strip"", z.ZodTypeAny, {
    number: number;
}, {
    number: number;
}>, {
    number: number;
}, {
    number: number;
}>
 */
const secondRefinementSourceType = secondRefinement.sourceType();


console.log(""Base"", baseSchema._def.typeName); // Base ZodObject
console.log(
  ""First"",
  firstRefinement._def.typeName,
  firstRefinementSourceType._def.typeName
); // First ZodEffects ZodObject
console.log(
  ""Second"",
  secondRefinement._def.typeName,
  secondRefinementSourceType._def.typeName
); // Second ZodEffects ZodObject
```

Zod version: 3.23.8
TypeScript version: 4.9.5",,
2576689838,3790,Unexpected output type in ZodDefault,"`ZodDefault` use `util.noUndefined<T[""_output""]` as output, which actually means `Exclude<T[""_output""], undefined>`. If output is converted to `undefined`, e.g. 
```ts
const checker = z.number().optional().transform((n) => {
  console.log(n); // n is 0 which means `default` is reachable
  return undefined; // return `undefined`
}).default(0);

// data got `undefined` without panic but actually return type of `parse` is `number` instead of `number | undefined` due to usage of `default`
const data = checker.parse(undefined); 
```
I think this is a type issue caused by `util.noUndefined`, maybe it should be `undefined extends T ? never : T` instead of `T extends undefined ? never : T`",,
2575258623,3787,Request: make BRAND<T> readonly to support @typescript-eslint/prefer-readonly-parameter-types,"Currently, BRAND is defined as follows:

```ts
export type BRAND<T extends string | number | symbol> = {
  [BRAND]: { [k in T]: true };
};
```

https://github.com/LumaKernel/zod/blob/3032e240a0c227692bb96eedf240ed493c53f54c/src/types.ts#L4904-L4906

Here is the suggestion to update this to following readonly added type.

```ts
export type BRAND<T extends string | number | symbol> = {
  readonly [BRAND]: { readonly [k in T]: true };
};
```

This can support the [`@typescript-eslint/prefer-readonly-parameter-types`](https://typescript-eslint.io/rules/prefer-readonly-parameter-types/https://typescript-eslint.io/rules/prefer-readonly-parameter-types/) rule.

This can be now confirmed as following with the repository: https://github.com/LumaKernel/zod-issue-3787

```sh
npx eslint .

/<proj>/int.ts
  8:22  error  Parameter should be a read only type  @typescript-eslint/prefer-readonly-parameter-types

/<proj>/span.ts
  15:23  error  Parameter should be a read only type  @typescript-eslint/prefer-readonly-parameter-types

âœ– 2 problems (2 errors, 0 warnings)

```

And I already confirmed that, if I replace the `BRAND` definition in `node_modules/` as above, this lint error is resolved for `span.ts` (using `z.object()` base).

Unfortunately, for the limitation of the eslint rule, the branded types for literal types like `number & { readonly some: null }` is not treated as readonly by the rule. That's why, `int.ts` (using `z.number()` base) in the repo cannot be resolved by this change, but it's still happy for the pattern of `span.ts`, it's mainly used in my project.
",,
2567618700,3785,Typescript doesn't realize record can return undefined,"Hey there. Just ran into an issue where typescript didn't realize that a key can not exist in a record. It assumes no matter what key you use, it will return the defined type.

```ts
import { z } from ""zod""

const testContract = z.record(z.string(), z.number())

type TestType = z.infer<typeof testContract>

const testObject: TestType = {
  hello: 1,
  world: 2,
}

// Typescript has no problem with this, but I'd expect it to 
// complain about the potential for it to be undefined
const x: number = testObject[""not in object""]

```

Is this expected behavior?",,
2566124059,3783,Proposal: Include received value in union discriminator error messages,"Currently, when a union discriminator validation fails, the error message only includes the expected values but not the actual received value.

My proposition is to change:
`src/types.ts`:
```typescript
const discriminator = this.discriminator;

const discriminatorValue: string = ctx.data[discriminator];

const option = this.optionsMap.get(discriminatorValue);

if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator],
+        received: discriminatorValue,
   });
      return INVALID;
    }
```
and `src/locales/en.ts`:
```typescript
case ZodIssueCode.invalid_union_discriminator:
-      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
+      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
```

If there are reasons for the current implementation, I'd appreciate any insights.",,
2565744202,3782,z.coerce.number() return unexpected behavior when pass 17 character  ,"When I pass numeric or number that pass 17 character, it adds some number by himself : 


https://zod-playground.vercel.app?appdata=N4IgzgxgFgpgtgQxALhALwHQHsBGArGCAFwApgAdAOwAJqIsYAnCGAOQFc4cnlrN6mLDJU7dGJAJRUAvhJAAaEADcEAG3YwwKANogKNWnQbM2optV7kQARlt37D21ZkgAuoqVMwASyyUUIADMGABMwQAcINJAA",,
2562024130,3779,Proposal: JSR package,would be cool to add zod to jsr for convenience,,
2553396282,3777,ðŸ Race of Sloths: The Open Source Developer Challenge is about to start,"As a team of Rust developers from [Race of Sloths](https://race-of-sloths.com/),  we recognized this repo to be highly valuable in the open-source movement.

Race of Sloth makes the open-source contributions more fun and rewarding.

* This issue is an invitation to check how Race of Sloths works
* To accept the invitation, comment @race-of-sloths accept
* Once the invitation is accepted, your contributors are eligible participate in the Race
* Contributors just need to mention @race-of-sloths in their PR within your normal contribution flow
* We invite you for collaboration and making open source development more engaging together!",,
2552286203,3776,Wrong export types (CJS vs ESM modules),"The `package.json` export field seems to be misconfigured for the ESM export. I've run into the issues importing zod in one of my projects. 

The publint is giving following warning (https://publint.dev/zod@3.23.8). 

> **The types is interpreted as CJS when resolving with the ""import"" condition.** This causes the types to be ambiguous when default importing the package due to its implied interop. Consider splitting out two ""types"" conditions for ""import"" and ""require"", and use the .mts extension, e.g. pkg.exports["".""].import.types: ""./index.d.mts"" ([More info](https://publint.dev/rules.html#export_types_invalid_format))

Fixing that should solve the problem. Would you accept a PR?

---

Possibly related https://github.com/colinhacks/zod/issues/2557
",,
2550810720,3774,Zod superRefinement doesn't get triggered if prior prop validation fails,"I have a zod object that has some props and then a .superRefine at the end which dynamicly checks some props based on other prop values. 

The issue is if a prop fails validation the superRefine doesn't get triggered.

This is a major issue as the goal of the validation is to get all of the errors and this then just returns the prop errors without the errors the superRefine would return.

",,
2549417550,3773,Bug: Zod function types not inferred correctly,"# Detail
Zod types generate function always carry a unknown[] args.
But it's a difference from `(...args: unknown[]) => string;` between `() => string;`

# Code 
```ts
import { z } from ""zod"";

const myFunction = z.function().returns(z.string());

// MyFunction1 type is (...args: unknown[]) => string;
type MyFunction1 = z.infer<typeof myFunction>;

const f1: MyFunction1 = (x1: string) => """";

// Expect type is () => string;
type MyFunction2 = () => string;

const f2: MyFunction2 = () => """";

```",,
2547541784,3772,No index signature with a parameter of type 'string' was found on type with union of array and key-ed object,"Hi,

I have the following schema:
```typescript
const TeamRadio = z.object({
    Utc: z.string(),
    RacingNumber: z.string(),
    Path: z.string(),
}).strict();

type TeamRadio = z.infer<typeof TeamRadio>;

const TeamRadios = z.object({
    Captures: z.union([
        z.array(TeamRadio),
        z.record(z.string(), TeamRadio),
    ]),
}).strict();

type TeamRadios = z.infer<typeof TeamRadios>;
```

So basically the `Captures` property of TeamRadios is either an array of TeamRadio OR an object with a string key (sequence number and a single  TeamRadio object.

I then want to process all TeamRadio objects into a large array using the following code:
```typescript
const test = async (filepath: string) => {
    const file = await Deno.open(filepath, { read: true, write: false });
    const lines = readLines(file);
    const radios: TeamRadio[] = [];
    for await (const line of lines) {
        console.log(line);
        const [_timestamp, obj] = [line.slice(0, 12), line.slice(12)];
        const json = JSON.parse(obj) as TeamRadios;
        if (Array.isArray(json.Captures)) {
            json.Captures.forEach((c) => radios.push(c));
        } else {
            const keys = Object.keys(json.Captures);
            keys.forEach((c) => radios.push(json.Captures[c])); <--------------------------------------
        }
        // const parsed = TeamRadios.safeParse(json);
        // if (parsed.error) console.log(""error"", parsed.error.stack);
    }
    console.log(radios.length);
};

const filepath = ""../2024-09-22_Singapore_Grand_Prix/2024-09-22_Race/TeamRadio.jsonStream"";
await test(filepath);
```
At the arrow I get the following error:
```
Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ Utc: string; RacingNumber: string; Path: string; }[] | Record<string, { Utc: string; RacingNumber: string; Path: string; }>'.
  No index signature with a parameter of type 'string' was found on type '{ Utc: string; RacingNumber: string; Path: string; }[] | Record<string, { Utc: string; RacingNumber: string; Path: string; }>'.
```

Data:
```
00:13:11.872{""Captures"":[{""Utc"":""2024-09-22T11:20:10.75Z"",""RacingNumber"":""44"",""Path"":""TeamRadio/LEWHAM01_44_20240922_192005.mp3""}]}
00:15:24.940{""Captures"":{""1"":{""Utc"":""2024-09-22T11:22:22.852Z"",""RacingNumber"":""43"",""Path"":""TeamRadio/FRACOL01_43_20240922_192211.mp3""}}}
00:15:57.207{""Captures"":{""2"":{""Utc"":""2024-09-22T11:30:07.5758076Z"",""RacingNumber"":""18"",""Path"":""TeamRadio/LANSTR01_18_20240922_192927.mp3""}}}
00:49:01.425{""Captures"":{""11"":{""Utc"":""2024-09-22T11:56:01.865Z"",""RacingNumber"":""24"",""Path"":""TeamRadio/GUAZHO01_24_20240922_195530.mp3""},""12"":{""Utc"":""2024-09-22T11:56:01.865Z"",""RacingNumber"":""10"",""Path"":""TeamRadio/PIEGAS01_10_20240922_195544.mp3""}}}
```
How to get rid of it?  tried a lot of `keyof` / `typeof` combinations, but doing that didn't get rid of the errors;
Scratching my head as `c` is a string, and so is `z.record(z.string(), TeamRadio)`

",,
2546228103,3771,feat: `strict` option for transforming overflow properties to value,"It would be handy if ZodObject's `strict` function accepted a parameter that let you transform any overflowing properties to a specific value rather than simplify removing them.

For example:
```

const user = {
  firstName: ""foo"",
  lastName: ""bar"",
} ;

const filteredUserSchema = z.object({
  firstName: z.string(),
}).strict({
  castOverflowTo: ""[filtered]""
});

// castOverflowTo would result in the parsed return looking like:
// { 
//    firstName: ""foo"",
//    lastName: ""[filtered]""
// }
filteredlUserSchema.safeParse(user).data

```

This would be very useful for scrubbing data.

Thanks in advance!
",,
2543081219,3769,Proposal : make `coerce` more generic,"Hi!

I've been thinking about how to make `coerce` something more powerful and generic than what it is right now and I think I found an elegant solution. Not knowing `zod` codebase perfectly (I read a big part of it though) I might be missing things that would make this impossible. But I think it should work.

1st, add to every zod schema a `schema.constructWith(inputSchema)` method (that name can obviously be changed, I'm not sure it is good) that would satisfy the followings:

- `inputSchema` **REQUIRES** a compatible `OutputType` type with the schema's `InputType`
- That method would return a similarly typed `ZodSchema` except for its `InputType` that would be changed to the same one as the one of `inputSchema`
- The returned schema would basically be the same `schema` but constructed with the `inputSchema` in its def object
- Change the parse method to run it on `inputSchema.parse(val)` instead of `val` directly when there is one

2nd add a `schema.coerce(transformFn, outputSchema)` method to every zod schema that would basically just return `outputSchema.constructWith(schema.transform(transformFn))`.

Those changes would allow to implement existing coerce tooling more easily:

```ts
zod.coerce.number = z.string()
  .or(z.number())
  // that might not be enough to put Number only there, but it keeps things simple
  .coerce(Number, z.number());

// or:
zod.coerce.number = z.number()
  .constructWith(
    z.number()
      .or(z.string().transform(Number))
  );

// ZodNumber would need to be parameterized with its input type now
// eg: ZodNumber<Input = number> extends ZodType<number, ZodNumberDef, Input> {}

// zod.coerce.number would be defined as a ZodNumber<string | number>
```

If we want to keep very broad coercing tooling, it could be defined as:
```ts
zod.coerce.number = z.unknown()
  .coerce(Number, z.number()); // ZodNumber<unknown>
```

I think that would also allow to completely deprecate `z.preprocess()` that would be better served by using `.coerce()` or `.constructWith()` (it could always be simulated using `z.unknown().coerce()`, the only difference being that the resulting schema would be ""better"" typed).

Some very cool uses for this would be to create some generic schemas representing more complex things that can still be used in a very intuitive way after that:

```ts
// duration.ts
import parseDuration from ""parse-duration"";

export const duration = z.string()
  .min(1)
  .or(z.number())
  .coerce(
    (val: string | number) => typeof val === ""string"" ? parseDuration(val) : val,
    z.number()
  ) // another ZodNumber<string | number>

// example.ts
import { duration } from ""./duration.js"";

const requestTimeout = duration
  .int(""do not support Âµs"")
  .min(1_000, ""1s minimum timeout"")
 ;
 
 // ...
requestTimeout.parse(""20s""); // OK => 20_000
requestTimeout.parse(""200ms""); // fails with ""1s minimum timeout""
requestTimeout.parse(10_000); // OK => 10_000
requestTimout.parse(10_000.25); // fails with ""do not support Âµs""",,
2539159566,3767,Bug: z.output makes all properties optional,"Using `z.output`, ALL properties optional. E.g. the following should throw a TypeScript error that `count` is required but it does not:

```
export const myMsgSchema = z.object({
  message: z.string(),
  count: z.number().positive(),
});

export type MyMsg = z.output<typeof myMsgschema>;

const msg: MyMsg = {
  message: 'hello';
}
```",,
2538481094,3766,"Access, manipulate, and throw error from `z.catch`","If I understand correctly, `z.catch` always catches all errors, and it is not possible to only catch on certain cases and rethrow the error in other cases.

For example, if I want an `API_KEY` to have a hardcoded default value only when the global variable `env` is ""dev"", I might do something like this:

```
...
""API_KEY"": z.string()
  .catch(function () {
    if (env === ""dev"") return defaultValue;
  }).pipe(z.string()),
...
```

Note that I have to try to parse the entire result as a string again in the pipe, so that if I'm not in dev mode, the catch turns the key into `undefined` which fails the second `z.string()`.

Ideally I would imagine being able to ""rethrow"" the error in the catch.",,
2534622514,3761,The mapped-type is not recursive in `ZodFormattedError` (`error.format()`),"Hello, I've noticed that the mapped-type when formatting an error is not reused in the recursive type.
This causes the â€œsub-levelsâ€ `_errors` of an object to be incorrectly typed.

Here's an example:
```ts
declare const error: z.ZodError<{ flat: number; object: { nested: number } }>;

const formatted = error.format(issue => !!issue.fatal);

const ok: boolean[] = formatted._errors ?? [];
// Type 'string[]' is not assignable to type 'boolean[]'
const ko1: boolean[] = formatted.flat?._errors ?? [];
// Type 'string[]' is not assignable to type 'boolean[]'
const ko2: boolean[] = formatted.object?.nested?._errors ?? [];
```

I solved the problem locally on my end and will probably submit a â€œPRâ€ soon.",,
2533811458,3759,values of type number are not accepted when key of NativeEnum is specified as a number type,"version: v3.23.8

```ts
const STRING_KEY_ENUM = {
  ten: 10,
  twenty: 20,
} as const
z.nativeEnum(STRING_KEY_ENUM) // OK

const NUMBER_KEY_ENUM = {
  10: 10,
  20: 20,
} as const
z.nativeEnum(NUMBER_KEY_ENUM) // Error: Argument of type '{ readonly 10: 10; readonly 20: 20; }' is not assignable to parameter of type 'EnumLike'.

const NUMBER_WITH_QUOTE_KEY_ENUM = {
  '10': 10,
  '20': 20,
} as const
z.nativeEnum(NUMBER_WITH_QUOTE_KEY_ENUM) // Error: Argument of type '{ readonly '10': 10; readonly '20': 20; }' is not assignable to parameter of type 'EnumLike'.
```

While using numbers as keys might not be a common pattern, I would expect consistent behavior regardless of the key type. However, it appears that enums with number keys and stringified number keys lead to different results, which seems unintuitive. ",,
2528990382,3756,Bug: .safeParse() should not throw,"From the docs, 

> If you don't want Zod to throw errors when validation fails, use .safeParse. This method returns an object containing either the successfully parsed data or a ZodError instance containing detailed information about the validation problems.

This works fine and well so long as you stick to built-in refinements and schemas. But, if you make your own transformations/refinements, and they throw, then safeparse will throw.
```ts
const throwingSchema = z.any().transform((args, context) => {
   throw new Error('lol');
});

const resultShouldntThrow = throwingSchema.safeParse(""please don't throw!"");
```

I understand that user-defined `.transform()` and `.refine()` functions are not intended to throw, so they constitute an invalid schema. However, I would expect that to be reported from `.safeParse()` in a non-throwing way, for example

```ts
throwingSchema.safeParse(""please don't throw!""); // { valid: false, code: 'INVALID_SCHEMA', message: 'Exception was thrown during user-defined `.transform()` callback' }
```

If we really want a method called ""safeX"" to throw, I would expect it to come in the form of an _opt-in_ option, such as
```ts
throwingSchema.safeParse(""please don't throw!"", { throwOnInvalidSchema: true }); // Uncaught: ZodErrorInvalidSchema
```

Otherwise, we're stuck with
```ts
let parseResult;
try {
   parseResult = throwingSchema.safeParse(""please don't throw!"");
} catch (error) {
   // handle secondary error path
}
if (!parseResult.valid) {
   // handle primary error path
}
```
which defeats the purpose of `safeParse` in the first place.",,
2524395296,3753,"Although `z.string().date()` check fails, yet the callback to `.superRefine()` is executed.","Consider the following schema.

```typescript
import { z } from ""zod"";

export const dateRangeSchema = z.object({
    minimum: z.string().date(),
    maximum: z.string().date(),
}).superRefine(({ minimum, maximum }, context) => {
    console.log({ minimum, maximum }); // for debugging

    if (new Date(minimum) > new Date(maximum)) {
        context.addIssue({
            code: z.ZodIssueCode.too_big,
            type: ""date"",
            maximum,
            inclusive: true,
            path: [""minimum""],
            message: ""minimum must not be greater than maximum"",
        });

        context.addIssue({
            code: z.ZodIssueCode.too_small,
            type: ""date"",
            minimum,
            inclusive: true,
            path: [""maximum""],
            message: ""maximum must not be lesser than minimum"",
        });
    }
});
```

I expect when `minimum` or `maximum` are invalid date strings, then the callback to `.superRefine()` won't be executed. However, this is not the case. Consider the following example.

```typescript
console.log(dateRangeSchema.safeParse({ minimum: ""1"", maximum: ""0"" }).error.issues);
```

The above example prints out the following output to the console.

```typescript
{ minimum: '1', maximum: '0' }
[
  {
    code: 'invalid_string',
    validation: 'date',
    message: 'Invalid date',
    path: [ 'minimum' ]
  },
  {
    code: 'invalid_string',
    validation: 'date',
    message: 'Invalid date',
    path: [ 'maximum' ]
  },
  {
    code: 'too_big',
    type: 'date',
    maximum: '0',
    inclusive: true,
    path: [ 'minimum' ],
    message: 'minimum must not be greater than maximum'
  },
  {
    code: 'too_small',
    type: 'date',
    minimum: '1',
    inclusive: true,
    path: [ 'maximum' ],
    message: 'maximum must not be lesser than minimum'
  }
]
```

As you can see, although `""1""` and `""0""` fail the `z.string().date()` check, yet the callback to `.superRefine()` is executed. This is unintuitive behavior. At the very least, it violates the [principle of least astonishment](https://en.wikipedia.org/wiki/Principle_of_least_astonishment). The callback to `.superRefine()` should only be executed when the input is parsed without any issue.",,
2521773407,3752,Problem with validation of identical fields in the schema,"Currently, there is an issue in the schema where, if identical fields are present in the user's schemas, Zod incorrectly validates the second testProperty field. Is there a way to fix this? At the moment, the only solution I've found is to change the field name (testProperty) to a unique one.

[https://codesandbox.io/p/sandbox/zodschemas-forked-76tlcr?file=%2Fsrc%2FApp.tsx
![Ð¡Ð½Ð¸Ð¼Ð¾Ðº ÑÐºÑ€Ð°Ð½Ð° 2024-09-12 115322](https://github.com/user-attachments/assets/cf91d4f4-25a7-4871-a04f-c3e078e56620)
](url)

`import { useCallback, VFC } from ""react"";
import { SubmitHandler, useForm } from ""react-hook-form"";
import { zodResolver } from ""@hookform/resolvers/zod"";
import { z } from ""zod"";

const stringSchema = z.string().min(1, { message: ""fieldIsRequired"" });

const firstUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema,
});

const secondUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema.or(z.string().length(0)),
  testPropertySecond: stringSchema.or(z.string().length(0)),
});

const UserSchema = z.union([firstUser, secondUser]);

const usersSchema = z.object({
  users: UserSchema.array(),
});

type UsersForm = z.infer<typeof usersSchema>;

export const App: VFC = () => {
  const { register, handleSubmit, formState, control } = useForm<UsersForm>({
    resolver: zodResolver(usersSchema),
    defaultValues: {
      users: [
        {
          firstName: """",
          lastName: """",
          testProperty: """",
        },
        {
          firstName: """",
          lastName: """",
          testProperty: """",
          testPropertySecond: """",
        },
      ],
    },
  });

  const errors = formState.errors;

  console.log(errors, formState, control);

  const onSubmit: SubmitHandler<UsersForm> = useCallback(async (value) => {},
  []);

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      style={{
        display: ""flex"",
        flexDirection: ""column"",
        width: 512,
        margin: ""0 auto"",
      }}
    >
      <label>
        <span>First name first user</span>
        <input {...register(""users.0.firstName"")} />
        <span>{errors?.users?.[0]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name first user</span>
        <input {...register(""users.0.lastName"")} />
        <span>{errors?.users?.[0]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property first user</span>
        <input {...register(""users.0.testProperty"")} />
        <span>{errors?.users?.[0]?.testProperty?.message}</span>
      </label>

      <label style={{ marginTop: ""40px"" }}>
        <span>First name second user</span>
        <input {...register(""users.1.firstName"")} />
        <span>{errors?.users?.[1]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name second user</span>
        <input {...register(""users.1.lastName"")} />
        <span>{errors?.users?.[1]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property second user</span>
        <input {...register(""users.1.testProperty"")} />
        <span>{errors?.users?.[1]?.testProperty?.message}</span>
      </label>
      <label>
        <span>Second test property second user</span>
        <input {...register(""users.1.testPropertySecond"")} />
        <span>{errors?.users?.[1]?.testPropertySecond?.message}</span>
      </label>
      <button type=""submit"">Submit</button>
    </form>
  );
};
`",2346221877,"You can switch `firstUser` and `secondUser` position in union.

```ts
const UserSchema = z.union([secondUser, firstUser]);
```

Zod will iterate through all the options in a union array. If any of the options pass validation, the entire result is considered valid. However, if any of the options fail validation, it will return the result of the first invalid option and ignore the rest.

For example, if you use `z.union([firstUser, secondUser])` to parse `{ firstName: """", lastName: """", testProperty: """" }`, the `firstUser` schema will raise 3 errors, so that becomes the result. Even if you try parsing `{ firstName: """", lastName: """", testProperty: """", testPropertySecond: """" }`, the outcome remains the same. This happens because `firstUser` is the first option evaluated, and Zod will return its result, ignoring the `secondUser` schema."
2521773407,3752,Problem with validation of identical fields in the schema,"Currently, there is an issue in the schema where, if identical fields are present in the user's schemas, Zod incorrectly validates the second testProperty field. Is there a way to fix this? At the moment, the only solution I've found is to change the field name (testProperty) to a unique one.

[https://codesandbox.io/p/sandbox/zodschemas-forked-76tlcr?file=%2Fsrc%2FApp.tsx
![Ð¡Ð½Ð¸Ð¼Ð¾Ðº ÑÐºÑ€Ð°Ð½Ð° 2024-09-12 115322](https://github.com/user-attachments/assets/cf91d4f4-25a7-4871-a04f-c3e078e56620)
](url)

`import { useCallback, VFC } from ""react"";
import { SubmitHandler, useForm } from ""react-hook-form"";
import { zodResolver } from ""@hookform/resolvers/zod"";
import { z } from ""zod"";

const stringSchema = z.string().min(1, { message: ""fieldIsRequired"" });

const firstUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema,
});

const secondUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema.or(z.string().length(0)),
  testPropertySecond: stringSchema.or(z.string().length(0)),
});

const UserSchema = z.union([firstUser, secondUser]);

const usersSchema = z.object({
  users: UserSchema.array(),
});

type UsersForm = z.infer<typeof usersSchema>;

export const App: VFC = () => {
  const { register, handleSubmit, formState, control } = useForm<UsersForm>({
    resolver: zodResolver(usersSchema),
    defaultValues: {
      users: [
        {
          firstName: """",
          lastName: """",
          testProperty: """",
        },
        {
          firstName: """",
          lastName: """",
          testProperty: """",
          testPropertySecond: """",
        },
      ],
    },
  });

  const errors = formState.errors;

  console.log(errors, formState, control);

  const onSubmit: SubmitHandler<UsersForm> = useCallback(async (value) => {},
  []);

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      style={{
        display: ""flex"",
        flexDirection: ""column"",
        width: 512,
        margin: ""0 auto"",
      }}
    >
      <label>
        <span>First name first user</span>
        <input {...register(""users.0.firstName"")} />
        <span>{errors?.users?.[0]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name first user</span>
        <input {...register(""users.0.lastName"")} />
        <span>{errors?.users?.[0]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property first user</span>
        <input {...register(""users.0.testProperty"")} />
        <span>{errors?.users?.[0]?.testProperty?.message}</span>
      </label>

      <label style={{ marginTop: ""40px"" }}>
        <span>First name second user</span>
        <input {...register(""users.1.firstName"")} />
        <span>{errors?.users?.[1]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name second user</span>
        <input {...register(""users.1.lastName"")} />
        <span>{errors?.users?.[1]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property second user</span>
        <input {...register(""users.1.testProperty"")} />
        <span>{errors?.users?.[1]?.testProperty?.message}</span>
      </label>
      <label>
        <span>Second test property second user</span>
        <input {...register(""users.1.testPropertySecond"")} />
        <span>{errors?.users?.[1]?.testPropertySecond?.message}</span>
      </label>
      <button type=""submit"">Submit</button>
    </form>
  );
};
`",2348141746,"@sunnylost it could be a working solution, but if we change the order of zod schemas in the array and then decide to add a property with the same key but with different validation schema, validation will raise error in the `testPropertySecond` property. Take a look at this example below: 
![image](https://github.com/user-attachments/assets/a92f42c2-0689-4a24-9921-cebefeb3617f)
"
2521773407,3752,Problem with validation of identical fields in the schema,"Currently, there is an issue in the schema where, if identical fields are present in the user's schemas, Zod incorrectly validates the second testProperty field. Is there a way to fix this? At the moment, the only solution I've found is to change the field name (testProperty) to a unique one.

[https://codesandbox.io/p/sandbox/zodschemas-forked-76tlcr?file=%2Fsrc%2FApp.tsx
![Ð¡Ð½Ð¸Ð¼Ð¾Ðº ÑÐºÑ€Ð°Ð½Ð° 2024-09-12 115322](https://github.com/user-attachments/assets/cf91d4f4-25a7-4871-a04f-c3e078e56620)
](url)

`import { useCallback, VFC } from ""react"";
import { SubmitHandler, useForm } from ""react-hook-form"";
import { zodResolver } from ""@hookform/resolvers/zod"";
import { z } from ""zod"";

const stringSchema = z.string().min(1, { message: ""fieldIsRequired"" });

const firstUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema,
});

const secondUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema.or(z.string().length(0)),
  testPropertySecond: stringSchema.or(z.string().length(0)),
});

const UserSchema = z.union([firstUser, secondUser]);

const usersSchema = z.object({
  users: UserSchema.array(),
});

type UsersForm = z.infer<typeof usersSchema>;

export const App: VFC = () => {
  const { register, handleSubmit, formState, control } = useForm<UsersForm>({
    resolver: zodResolver(usersSchema),
    defaultValues: {
      users: [
        {
          firstName: """",
          lastName: """",
          testProperty: """",
        },
        {
          firstName: """",
          lastName: """",
          testProperty: """",
          testPropertySecond: """",
        },
      ],
    },
  });

  const errors = formState.errors;

  console.log(errors, formState, control);

  const onSubmit: SubmitHandler<UsersForm> = useCallback(async (value) => {},
  []);

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      style={{
        display: ""flex"",
        flexDirection: ""column"",
        width: 512,
        margin: ""0 auto"",
      }}
    >
      <label>
        <span>First name first user</span>
        <input {...register(""users.0.firstName"")} />
        <span>{errors?.users?.[0]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name first user</span>
        <input {...register(""users.0.lastName"")} />
        <span>{errors?.users?.[0]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property first user</span>
        <input {...register(""users.0.testProperty"")} />
        <span>{errors?.users?.[0]?.testProperty?.message}</span>
      </label>

      <label style={{ marginTop: ""40px"" }}>
        <span>First name second user</span>
        <input {...register(""users.1.firstName"")} />
        <span>{errors?.users?.[1]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name second user</span>
        <input {...register(""users.1.lastName"")} />
        <span>{errors?.users?.[1]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property second user</span>
        <input {...register(""users.1.testProperty"")} />
        <span>{errors?.users?.[1]?.testProperty?.message}</span>
      </label>
      <label>
        <span>Second test property second user</span>
        <input {...register(""users.1.testPropertySecond"")} />
        <span>{errors?.users?.[1]?.testPropertySecond?.message}</span>
      </label>
      <button type=""submit"">Submit</button>
    </form>
  );
};
`",2348166718,"So the issue is that you want to use the `firstUser` schema to parse the first user and the `secondUser` schema for the second, but since both users have the same structure, there's no way to determine which schema to apply. In my opinion, each user should have a property to distinguish them, allowing you to use a discriminated union for validation."
2521773407,3752,Problem with validation of identical fields in the schema,"Currently, there is an issue in the schema where, if identical fields are present in the user's schemas, Zod incorrectly validates the second testProperty field. Is there a way to fix this? At the moment, the only solution I've found is to change the field name (testProperty) to a unique one.

[https://codesandbox.io/p/sandbox/zodschemas-forked-76tlcr?file=%2Fsrc%2FApp.tsx
![Ð¡Ð½Ð¸Ð¼Ð¾Ðº ÑÐºÑ€Ð°Ð½Ð° 2024-09-12 115322](https://github.com/user-attachments/assets/cf91d4f4-25a7-4871-a04f-c3e078e56620)
](url)

`import { useCallback, VFC } from ""react"";
import { SubmitHandler, useForm } from ""react-hook-form"";
import { zodResolver } from ""@hookform/resolvers/zod"";
import { z } from ""zod"";

const stringSchema = z.string().min(1, { message: ""fieldIsRequired"" });

const firstUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema,
});

const secondUser = z.object({
  firstName: stringSchema,
  lastName: stringSchema,
  testProperty: stringSchema.or(z.string().length(0)),
  testPropertySecond: stringSchema.or(z.string().length(0)),
});

const UserSchema = z.union([firstUser, secondUser]);

const usersSchema = z.object({
  users: UserSchema.array(),
});

type UsersForm = z.infer<typeof usersSchema>;

export const App: VFC = () => {
  const { register, handleSubmit, formState, control } = useForm<UsersForm>({
    resolver: zodResolver(usersSchema),
    defaultValues: {
      users: [
        {
          firstName: """",
          lastName: """",
          testProperty: """",
        },
        {
          firstName: """",
          lastName: """",
          testProperty: """",
          testPropertySecond: """",
        },
      ],
    },
  });

  const errors = formState.errors;

  console.log(errors, formState, control);

  const onSubmit: SubmitHandler<UsersForm> = useCallback(async (value) => {},
  []);

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      style={{
        display: ""flex"",
        flexDirection: ""column"",
        width: 512,
        margin: ""0 auto"",
      }}
    >
      <label>
        <span>First name first user</span>
        <input {...register(""users.0.firstName"")} />
        <span>{errors?.users?.[0]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name first user</span>
        <input {...register(""users.0.lastName"")} />
        <span>{errors?.users?.[0]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property first user</span>
        <input {...register(""users.0.testProperty"")} />
        <span>{errors?.users?.[0]?.testProperty?.message}</span>
      </label>

      <label style={{ marginTop: ""40px"" }}>
        <span>First name second user</span>
        <input {...register(""users.1.firstName"")} />
        <span>{errors?.users?.[1]?.firstName?.message}</span>
      </label>
      <label>
        <span>Last name second user</span>
        <input {...register(""users.1.lastName"")} />
        <span>{errors?.users?.[1]?.lastName?.message}</span>
      </label>
      <label>
        <span>Test property second user</span>
        <input {...register(""users.1.testProperty"")} />
        <span>{errors?.users?.[1]?.testProperty?.message}</span>
      </label>
      <label>
        <span>Second test property second user</span>
        <input {...register(""users.1.testPropertySecond"")} />
        <span>{errors?.users?.[1]?.testPropertySecond?.message}</span>
      </label>
      <button type=""submit"">Submit</button>
    </form>
  );
};
`",2348183280,"> So the issue is that you want to use the `firstUser` schema to parse the first user and the `secondUser` schema for the second, but since both users have the same structure, there's no way to determine which schema to apply. In my opinion, each user should have a property to distinguish them, allowing you to use a discriminated union for validation.

Yes, you are right! We want to apply the schema to object depends on some key (for example, id from enum). Unfortunately, zod union do not support the determination of validation schema according to key property and its value. We have `z.discriminatedUnion` which could help if it could work with transformed zod schemas."
2520708502,3751,Question: TypeScript Isolated Declarations,"Hi folks,

Firstly, thanks for all the work you've done building such a great project.
We're wondering what you have plan for making a lighter type annotations for projects using isolated declarations. We tried Zod with the current version, and explicitly type annotating the module exports are not easy to maintain.

What are you thoughts?",2386569864,"I'm also interested in this, although I don't see a good way of reconciling Zod with isolated declarations since the whole point of Zod is that it will automatically keep the type in sync with the schema."
2517798227,3750,feat: Adding json Schema to the package,"How about adding json Schema generation to the package of the new version immediately for full compatibility of the Open API 3.1.0?

See that the Json schema of the latest project (2020-12) is added from behind the crust. This helps not to use separate packages to generate jsonSchema, which can then be used to generate OpenAPI (swagger)

I just want to use zod for request/response contracts, and the framework would already use ready-made JsonSchema to generate OpenAPI schemes. I'll give you an example, Json Schema is supplied to type box immediately out of the box, As well as for python, the most popular library for validation and serialization pydantic supplies JsonSchema immediately, and OpenAPI API endpoint schemes are already being built on its basis.

",,
2513970915,3749,Update repo link `zod-accelerator` in readme.,"Hello !

The package `zod-accelerator` change there name and the github link is changed too.

`https://github.com/duplojs/duplojs-zod-accelerator` -> `https://github.com/duplojs/zod-accelerator`

Thanks for your work.",2488009563,up :)
2512395540,3747,Allow `.extract`/`.exclude` for `nativeEnum`s,"Hey there! We're swapping to zod in our library for validation and we have the following use case:

```ts
// some-dependency
enum Something {
  X,
  Y,
  Z
}
```

We're using this numeric enum from our dependency (which has more like 14 available members), and we happen to want, say, 6 of them as allowed values to a record field.

My instinct was to use `z.nativeEnum(Something).extract(...)`, but I was surprised to learn it doesn't exist. My next idea was to do what I thought was the next most-correct thing, which is `z.enum([Something.X, Something.Y, ...])`, but I was quickly reminded it only supports strings (fair).

Which leaves me with using literals. https://github.com/colinhacks/zod/issues/2686#issuecomment-2073511939 would be of big help already, since I ended up having to do something like this: https://github.com/discordjs/discord.js/blob/6d44a77180fc52e6b87278b8054c54cb3a501600/packages/builders/src/interactions/slashCommands/Assertions.ts#L61-L75

I think ultimately though, it'd be ideal if ""native enums"" supported extract & exclude. I'd be willing to try to implement this, just figured I'd make an issue first in case there's a clear-cut sort of blocker for something like this.
",,
2512061178,3746,Type narrowing not working with generic zod type,"If we use `zod` to parse an API response:

```typescript
function foo(subSchema: z.ZodTypeAny) {
  fetch('example/api')
    .then(res => res.json())
    .then(json => {

      const resSchema = z.union([
        z.object({
          passed: z.literal(true),
          value: subSchema
        }),
        z.object({
          passed: z.literal(false),
          msg: z.string()
        })
      ])

      const parsed = resSchema.safeParse(json);

      if (parsed.success) {
        if (parsed.data.passed) {
          console.log(parsed.data.value);
        }
      }
    })
}
```

We see that when we specify a conditional for when the parse is successful, the type of `parsed` is narrowed. We specify another conditional inside of that for when the API result `passed === true`, and the type is narrowed further to one where the `value` key is present.

Let's say we want to make `foo` generic so that we can potentially return the parsed API response value.

```typescript
function foo<TSubSchema extends z.ZodTypeAny>(subSchema: TSubSchema) {
  fetch('example/api')
    .then(res => res.json())
    .then(json => {

      const resSchema = z.union([
        z.object({
          passed: z.literal(true),
          value: subSchema
        }),
        z.object({
          passed: z.literal(false),
          msg: z.string()
        })
      ])

      const parsed = resSchema.safeParse(json);

      if (parsed.success) {
        if (parsed.data.passed) {
          console.log(parsed.data.value);
        }
      }
    })
}
```

Now we have specified that subSchema is of a type `TSubSchema`, which is an extension of `ZodTypeAny`.

But we get an error on the line
```typescript
console.log(parsed.data.value);
```
indicating that 
```
Property 'value' does not exist on type '{ [k in keyof addQuestionMarks<baseObjectOutputType<{ passed: ZodLiteral<true>; value: TSubSchema; }>, any>]: addQuestionMarks<baseObjectOutputType<{ passed: ZodLiteral<...>; value: TSubSchema; }>, any>[k]; } | { ...; }'.
  Property 'value' does not exist on type '{ passed: false; msg: string; }'.ts(2339)
```

This tells that us that the type narrowing is not working, as it the type checker is complaining about `value` potentially not being a key of `parsed.data`.
",2345999371,Stuck in the same issue. No solution so far
2511202410,3745,How to union or merge two or more z.record schemas,"Thanks for the great library, really finding it useful.

Is there a recommended way to define a union of two or more record schemas, that would successfully parse an object with a mix of key/values from each record? Here's a minimal example outlining my unsuccessful attempt:

```ts
import { z } from 'zod';

// Define the schemas for the individual records
const record1Schema = z.record(z.enum(['a', 'b']), z.union([z.number(), z.string()]));

const record2Schema = z.record(z.enum(['c', 'd']), z.union([z.boolean(), z.string()]));

// Define the merged schema
const mergedSchema = z.union([record1Schema, record2Schema]);

// Example usage
const example1 = { a: 42, b: 'hello' }; // Valid according to record1Schema
const example2 = { c: true, d: 'world' }; // Valid according to record2Schema
const example3 = { a: 42, c: true }; // Valid according to mergedSchema

console.log(record1Schema.safeParse(example1)); // Success
console.log(record2Schema.safeParse(example2)); // Success
console.log(mergedSchema.safeParse(example3)); // Error
```

The last parse fails with invalid_union errors that includes invalid_enun_values errors like this:

```
{                                                                                                                
              ""received"": ""c"",               
              ""code"": ""invalid_enum_value"",      
              ""options"": [                                                                                                   
                ""a"",            
                ""b""                                                                                                          
              ],                                                                                                             
              ""path"": [                                                                                                      
                ""c""                                                                                                          
              ],                                                                                                             
              ""message"": ""Invalid enum value. Expected 'a' | 'b', received 'c'""                   
            }
```

I would expect it to work (and it does type check), but it seems like it expects it to conform to one of the record schemas only, and won't accept the other. Is there a better way to do this?
",2363174342,I suggest using `superRefine()` to gain more custom control.
2510856015,3744,Idea: `.meta(...)` method on ZodType,"I've considered asking this for a bit, for the sake of [trpc-cli](https://github.com/mmkal/trpc-cli). So far, it takes advantage of `.describe('...')` to allow adding CLI docs for zod input parameters, but it would be nice to add richer metadata.

How I think it could work:

1. Define a new `ZodMeta` interface (maybe make it generic with the same typeargs as `ZodType`)
2. Only add a `description` property to it
3. Add a `metadata: ZodMeta` prop to `ZodType`
4. Have `.describe('foo')` update the metadata to `{ description: 'foo' }` (maybe shallow-merging the old value?)
5. Update the description property of ZodType to `get description() { return this.metadata.description }` for backwards-compatibility

The fun part would be: end users could then use module augmentation to add to `ZodMeta` however they like, e.g. I in trpc-cli could do:

```ts
import {z} from 'zod'

declare module 'zod' {
  export interface ZodMeta {
    alias: string
  }
}

const router = t.router({
  test: t.input(
    z.object({
      glob: z.string().meta({
        description: 'Glob pattern for test files',
        alias: 'g',
      })
    })
  ).mutation(...)
)
```

Looking at the issues, I think this would cover a few requests zod has got:

https://github.com/colinhacks/zod/issues/3734
https://github.com/colinhacks/zod/issues/3732
https://github.com/colinhacks/zod/issues/3736 (maybe)
https://github.com/colinhacks/zod/issues/3673
https://github.com/colinhacks/zod/issues/1439

Possible more but I didn't go that far back in the issues. In general, with trpc and OpenAI adopting zod, there will be more cases where people use zod as a user-facing part of their libraries and applications, so there might be more and more requests for the ability to attach metadat to types

Alternatively, these fields could somehow be dumped onto `ZodDef`, which is where `description` lives now but that doesn't feel quite right to me.",2348288500,"i like the idea of removing all the non entity related stuff to a meta field, it would make it more consistent across types"
2510856015,3744,Idea: `.meta(...)` method on ZodType,"I've considered asking this for a bit, for the sake of [trpc-cli](https://github.com/mmkal/trpc-cli). So far, it takes advantage of `.describe('...')` to allow adding CLI docs for zod input parameters, but it would be nice to add richer metadata.

How I think it could work:

1. Define a new `ZodMeta` interface (maybe make it generic with the same typeargs as `ZodType`)
2. Only add a `description` property to it
3. Add a `metadata: ZodMeta` prop to `ZodType`
4. Have `.describe('foo')` update the metadata to `{ description: 'foo' }` (maybe shallow-merging the old value?)
5. Update the description property of ZodType to `get description() { return this.metadata.description }` for backwards-compatibility

The fun part would be: end users could then use module augmentation to add to `ZodMeta` however they like, e.g. I in trpc-cli could do:

```ts
import {z} from 'zod'

declare module 'zod' {
  export interface ZodMeta {
    alias: string
  }
}

const router = t.router({
  test: t.input(
    z.object({
      glob: z.string().meta({
        description: 'Glob pattern for test files',
        alias: 'g',
      })
    })
  ).mutation(...)
)
```

Looking at the issues, I think this would cover a few requests zod has got:

https://github.com/colinhacks/zod/issues/3734
https://github.com/colinhacks/zod/issues/3732
https://github.com/colinhacks/zod/issues/3736 (maybe)
https://github.com/colinhacks/zod/issues/3673
https://github.com/colinhacks/zod/issues/1439

Possible more but I didn't go that far back in the issues. In general, with trpc and OpenAI adopting zod, there will be more cases where people use zod as a user-facing part of their libraries and applications, so there might be more and more requests for the ability to attach metadat to types

Alternatively, these fields could somehow be dumped onto `ZodDef`, which is where `description` lives now but that doesn't feel quite right to me.",2403836753,"I am a long time zod user and had wanted something similar. There is this library [zod-to-openapi](https://github.com/asteasolutions/zod-to-openapi) that introspects metadata, but that has intimate knowledge of zod internals.

I'd like to share a zod compatible library I recently published. It is built with extensibility (like in this issue) in mind. I started it initially wanting to customize some zod error messages, and it kind of grew into something bigger.

https://github.com/ajaishankar/pukka?tab=readme-ov-file#extension-introspection

I apologize for the plug, but thought you'd find it interesting.

"
2510856015,3744,Idea: `.meta(...)` method on ZodType,"I've considered asking this for a bit, for the sake of [trpc-cli](https://github.com/mmkal/trpc-cli). So far, it takes advantage of `.describe('...')` to allow adding CLI docs for zod input parameters, but it would be nice to add richer metadata.

How I think it could work:

1. Define a new `ZodMeta` interface (maybe make it generic with the same typeargs as `ZodType`)
2. Only add a `description` property to it
3. Add a `metadata: ZodMeta` prop to `ZodType`
4. Have `.describe('foo')` update the metadata to `{ description: 'foo' }` (maybe shallow-merging the old value?)
5. Update the description property of ZodType to `get description() { return this.metadata.description }` for backwards-compatibility

The fun part would be: end users could then use module augmentation to add to `ZodMeta` however they like, e.g. I in trpc-cli could do:

```ts
import {z} from 'zod'

declare module 'zod' {
  export interface ZodMeta {
    alias: string
  }
}

const router = t.router({
  test: t.input(
    z.object({
      glob: z.string().meta({
        description: 'Glob pattern for test files',
        alias: 'g',
      })
    })
  ).mutation(...)
)
```

Looking at the issues, I think this would cover a few requests zod has got:

https://github.com/colinhacks/zod/issues/3734
https://github.com/colinhacks/zod/issues/3732
https://github.com/colinhacks/zod/issues/3736 (maybe)
https://github.com/colinhacks/zod/issues/3673
https://github.com/colinhacks/zod/issues/1439

Possible more but I didn't go that far back in the issues. In general, with trpc and OpenAI adopting zod, there will be more cases where people use zod as a user-facing part of their libraries and applications, so there might be more and more requests for the ability to attach metadat to types

Alternatively, these fields could somehow be dumped onto `ZodDef`, which is where `description` lives now but that doesn't feel quite right to me.",2405794802,"I like it
"
2510856015,3744,Idea: `.meta(...)` method on ZodType,"I've considered asking this for a bit, for the sake of [trpc-cli](https://github.com/mmkal/trpc-cli). So far, it takes advantage of `.describe('...')` to allow adding CLI docs for zod input parameters, but it would be nice to add richer metadata.

How I think it could work:

1. Define a new `ZodMeta` interface (maybe make it generic with the same typeargs as `ZodType`)
2. Only add a `description` property to it
3. Add a `metadata: ZodMeta` prop to `ZodType`
4. Have `.describe('foo')` update the metadata to `{ description: 'foo' }` (maybe shallow-merging the old value?)
5. Update the description property of ZodType to `get description() { return this.metadata.description }` for backwards-compatibility

The fun part would be: end users could then use module augmentation to add to `ZodMeta` however they like, e.g. I in trpc-cli could do:

```ts
import {z} from 'zod'

declare module 'zod' {
  export interface ZodMeta {
    alias: string
  }
}

const router = t.router({
  test: t.input(
    z.object({
      glob: z.string().meta({
        description: 'Glob pattern for test files',
        alias: 'g',
      })
    })
  ).mutation(...)
)
```

Looking at the issues, I think this would cover a few requests zod has got:

https://github.com/colinhacks/zod/issues/3734
https://github.com/colinhacks/zod/issues/3732
https://github.com/colinhacks/zod/issues/3736 (maybe)
https://github.com/colinhacks/zod/issues/3673
https://github.com/colinhacks/zod/issues/1439

Possible more but I didn't go that far back in the issues. In general, with trpc and OpenAI adopting zod, there will be more cases where people use zod as a user-facing part of their libraries and applications, so there might be more and more requests for the ability to attach metadat to types

Alternatively, these fields could somehow be dumped onto `ZodDef`, which is where `description` lives now but that doesn't feel quite right to me.",2457991537,"that'd be really awesome, I use zod schemas to generate forms in react and need to attach a lot of extra data to a ZodType. Currently I have to hack it a bit like so:

```typescript
type ZodTypeEnhanced<
	O = any,
	D extends ZodTypeDef = ZodTypeDef,
	I = O
> = ZodType<O, D, I> & {
	meta: FieldMeta
	original: ZodType<O, D, I>
}

export const isEnhanced = <O, D extends ZodTypeDef, I>(
	type: any
): type is ZodTypeEnhanced<O, D, I> =>
	type._def !== undefined && type.meta !== undefined

// Create a proxy to delegate method calls
export const asField = <
	M extends FieldMeta,
	O = any,
	D extends ZodTypeDef = ZodTypeDef,
	I = O
>(
	schema: ZodType<O, D, I>,
	meta: M
): ZodTypeEnhanced<O, D, I> => {
	return new Proxy(schema, {
		get(target: any, prop: string) {
			if (prop === 'meta') {
				return meta
			}
			if (prop === 'original') {
				return schema
			}
			if (typeof target[prop] === 'function') {
				return (...args: any[]) => target[prop](...args)
			}
			return target[prop]
		}
	})
}
```

then all I need to do is wrap the codecs with asField like so:

```typescript
object({
	...
	parent_id: asField(number().optional(), {
		label: 'Parent',
		placeholder: 'No parent',
		description: 'From which tag should values be inherited from?',
		editor: EditorType.Select,
		options: ....
	})
})
```
I'm pretty sure this would spark a ton of plugins for zod if it were natively supported."
2510353994,3743,parsed data is becoming never,"![image(1)](https://github.com/user-attachments/assets/ddddf4bc-d226-45a8-996a-9e286d1b5e16)
`const parsedData = getSuggestionsSchema.safeParse(
    action.payload?.data,
);
if (!parsedData.data) {
    console.error(""getSuggestions"", parsedData.error);
    state.suggestions = initialState.suggestions;
    state.userMessage = initialState.userMessage;
    return;
}
const parsedError = parsedData.error;
parsedError && console.warn(parsedError);
parsedData.error && console.error(parsedData.error);`

only in the last line inside the console error. Im getting error ""Property 'error' does not exist on type 'never'""",2334002260,"Before the `if(!parsedData.data)` statement, the type of `parsedData` can either be `SafeParseSuccess` or `SafeParseError`. However, after the if statement, it is resolved to `SafeParseSuccess`, which means its `error` property is `undefined`. Therefore, in `parsedData.error && console.error(parsedData.error)`, it's `console` will not execute because the precondition is false."
2510353994,3743,parsed data is becoming never,"![image(1)](https://github.com/user-attachments/assets/ddddf4bc-d226-45a8-996a-9e286d1b5e16)
`const parsedData = getSuggestionsSchema.safeParse(
    action.payload?.data,
);
if (!parsedData.data) {
    console.error(""getSuggestions"", parsedData.error);
    state.suggestions = initialState.suggestions;
    state.userMessage = initialState.userMessage;
    return;
}
const parsedError = parsedData.error;
parsedError && console.warn(parsedError);
parsedData.error && console.error(parsedData.error);`

only in the last line inside the console error. Im getting error ""Property 'error' does not exist on type 'never'""",2334040276,"Thanks for responding.
![image](https://github.com/user-attachments/assets/dd511a76-f694-4c0f-ba9c-546a09685d3e)
But the type of parsed data is becoming never not SafeParseSuccess and why ""const parsedError = parsedData.error;
"" line is not showing error."
2510353994,3743,parsed data is becoming never,"![image(1)](https://github.com/user-attachments/assets/ddddf4bc-d226-45a8-996a-9e286d1b5e16)
`const parsedData = getSuggestionsSchema.safeParse(
    action.payload?.data,
);
if (!parsedData.data) {
    console.error(""getSuggestions"", parsedData.error);
    state.suggestions = initialState.suggestions;
    state.userMessage = initialState.userMessage;
    return;
}
const parsedError = parsedData.error;
parsedError && console.warn(parsedError);
parsedData.error && console.error(parsedData.error);`

only in the last line inside the console error. Im getting error ""Property 'error' does not exist on type 'never'""",2334111544,"You should hover over `parsedData.error && ...`.

https://www.typescriptlang.org/docs/handbook/2/narrowing.html#truthiness-narrowing"
2510353994,3743,parsed data is becoming never,"![image(1)](https://github.com/user-attachments/assets/ddddf4bc-d226-45a8-996a-9e286d1b5e16)
`const parsedData = getSuggestionsSchema.safeParse(
    action.payload?.data,
);
if (!parsedData.data) {
    console.error(""getSuggestions"", parsedData.error);
    state.suggestions = initialState.suggestions;
    state.userMessage = initialState.userMessage;
    return;
}
const parsedError = parsedData.error;
parsedError && console.warn(parsedError);
parsedData.error && console.error(parsedData.error);`

only in the last line inside the console error. Im getting error ""Property 'error' does not exist on type 'never'""",2334188587,My doubt is if optional key part of schema failed at that case there would be error value right. even though parsedData.data exist.
2510353994,3743,parsed data is becoming never,"![image(1)](https://github.com/user-attachments/assets/ddddf4bc-d226-45a8-996a-9e286d1b5e16)
`const parsedData = getSuggestionsSchema.safeParse(
    action.payload?.data,
);
if (!parsedData.data) {
    console.error(""getSuggestions"", parsedData.error);
    state.suggestions = initialState.suggestions;
    state.userMessage = initialState.userMessage;
    return;
}
const parsedError = parsedData.error;
parsedError && console.warn(parsedError);
parsedData.error && console.error(parsedData.error);`

only in the last line inside the console error. Im getting error ""Property 'error' does not exist on type 'never'""",2334239894,Which part do you mean?
2510353994,3743,parsed data is becoming never,"![image(1)](https://github.com/user-attachments/assets/ddddf4bc-d226-45a8-996a-9e286d1b5e16)
`const parsedData = getSuggestionsSchema.safeParse(
    action.payload?.data,
);
if (!parsedData.data) {
    console.error(""getSuggestions"", parsedData.error);
    state.suggestions = initialState.suggestions;
    state.userMessage = initialState.userMessage;
    return;
}
const parsedError = parsedData.error;
parsedError && console.warn(parsedError);
parsedData.error && console.error(parsedData.error);`

only in the last line inside the console error. Im getting error ""Property 'error' does not exist on type 'never'""",2334252832,"Imagine if the schema had 3 keys. 2 required and 1 optional key. If optional key part of schema failed, I'll still get parsedData.data containing two required keys right? And I'll also get parsedData.error right? since optional key part failed."
2510353994,3743,parsed data is becoming never,"![image(1)](https://github.com/user-attachments/assets/ddddf4bc-d226-45a8-996a-9e286d1b5e16)
`const parsedData = getSuggestionsSchema.safeParse(
    action.payload?.data,
);
if (!parsedData.data) {
    console.error(""getSuggestions"", parsedData.error);
    state.suggestions = initialState.suggestions;
    state.userMessage = initialState.userMessage;
    return;
}
const parsedError = parsedData.error;
parsedError && console.warn(parsedError);
parsedData.error && console.error(parsedData.error);`

only in the last line inside the console error. Im getting error ""Property 'error' does not exist on type 'never'""",2334391113,"After digging a bit deeper, I found it's more complicated than I initially thought.

I've simplified some code to explain, and I hope this will be helpful.

https://www.typescriptlang.org/play/?#code/C4TwDgpgBA8g0gHgCoD4oF4oG8BQV8AmAhsEQFxRJ74QBOtA9rQPwUB2EAbnTgL445QkKADEiASwA2yNJlz4oxUqygdutalDqNaFKv0HhoAJQgBnAK6TgyADSjZsRKigAfUROkiUAgGYW2AGNgcQY2KAAPAAoASmxNAHoEqAABYDMAWnEAczYmCE1AsLNgKF1TS2sEACMGBkkIIjZ7AFF6JkcsAwVxXyjaADolIjj5BXxaCGALWjZNbomoJNUGUrYidoB3cTZsgR6+gEJB4dGl5OGoIqsCKGroXyJJMwh7MwYyq4Ybu+h4GrqDSaPnGi2WJSkkhWaw2jG2u00Ckm01m832YOS6y2O2yUGAH3+tXqjTYKHs1QspQAkoowgByUrAAAWOwA1niWWYoOIuUV6BBggNEeduaUmUQufjfmUIJISBBbttmVAAOIQDi0cSBLlNW7pOm8sLARhQ3ySBibKBNJ4gMw8zSDbRMKAAMhdXzY7waA3N2X6AydtBi6O5fUd7SD8VBn2WWLhOLxHzUPGj4Z0aN4QA

I suggest checking `parsedData.success` instead of `parsedData.data`. Since `parsedData` is a discriminated union, using `success` will provide a more accurate type check."
2510353994,3743,parsed data is becoming never,"![image(1)](https://github.com/user-attachments/assets/ddddf4bc-d226-45a8-996a-9e286d1b5e16)
`const parsedData = getSuggestionsSchema.safeParse(
    action.payload?.data,
);
if (!parsedData.data) {
    console.error(""getSuggestions"", parsedData.error);
    state.suggestions = initialState.suggestions;
    state.userMessage = initialState.userMessage;
    return;
}
const parsedError = parsedData.error;
parsedError && console.warn(parsedError);
parsedData.error && console.error(parsedData.error);`

only in the last line inside the console error. Im getting error ""Property 'error' does not exist on type 'never'""",2334669873,Thank you. My goal is to do console.warn if only optional part of schema fails and do console.error if required part fail. What is the recommended way to do this?
2510353994,3743,parsed data is becoming never,"![image(1)](https://github.com/user-attachments/assets/ddddf4bc-d226-45a8-996a-9e286d1b5e16)
`const parsedData = getSuggestionsSchema.safeParse(
    action.payload?.data,
);
if (!parsedData.data) {
    console.error(""getSuggestions"", parsedData.error);
    state.suggestions = initialState.suggestions;
    state.userMessage = initialState.userMessage;
    return;
}
const parsedError = parsedData.error;
parsedError && console.warn(parsedError);
parsedData.error && console.error(parsedData.error);`

only in the last line inside the console error. Im getting error ""Property 'error' does not exist on type 'never'""",2334680387,"You can break the whole schema into `requiredSchema` and `optionalSchema`, no need to combine them togather."
2510353994,3743,parsed data is becoming never,"![image(1)](https://github.com/user-attachments/assets/ddddf4bc-d226-45a8-996a-9e286d1b5e16)
`const parsedData = getSuggestionsSchema.safeParse(
    action.payload?.data,
);
if (!parsedData.data) {
    console.error(""getSuggestions"", parsedData.error);
    state.suggestions = initialState.suggestions;
    state.userMessage = initialState.userMessage;
    return;
}
const parsedError = parsedData.error;
parsedError && console.warn(parsedError);
parsedData.error && console.error(parsedData.error);`

only in the last line inside the console error. Im getting error ""Property 'error' does not exist on type 'never'""",2335044697,Thank you. I'll do that.
2508697384,3741,Add nonempty() method to zod.record() for empty object validation,"**Problem**
Currently, `zod.record()` allows empty objects to pass validation without error. 

```
const User = z.object({ name: z.string() });
const UserStore = z.record(z.string(), User);
UserStore.parse({}); // passes
```

In certain use cases, this behavior is not desired, as an empty object can represent invalid data. For example, when an object is expected to have at least one key-value pair, an empty object should trigger a validation error.

**Proposed Solution**
Introduce a nonempty() method to zod.record() that ensures the record is not empty. This would allow developers to enforce that objects must contain at least one key-value pair. Example usage:

```
zod.record(z.string(), User).nonempty();
UserStore.parse({}); // throws: ""Record cannot be empty""
```
In this case, an empty object would throw a validation error, while non-empty objects would pass validation as usual.

It would be great to add a custom error message:

```
// optional custom error message
zod.record(z.string(), User).nonempty({
  message: ""Can't be empty!"",
});
```

Next Steps
I would like feedback from the maintainers and community to see if this feature would be a valuable addition to Zod. If thereâ€™s support for the idea, Iâ€™m happy to start working on this feature and submit a pull request.
",2425301640,"Here is what i have hacked around with .refine

```js
schema: z
    .record(z.unknown())
    .refine(
      (schema) => Object.keys(schema).length > 0,
      ""JSON schema is required and cannot be empty"",
    ),
```"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2344638164,Can you provide `tsconfig.json`
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2344777936,"```json
{
  ""compilerOptions"": {
    /* Base Options: */
    ""esModuleInterop"": true,
    ""skipLibCheck"": true,
    ""target"": ""ESNext"",
    ""allowJs"": true,
    ""resolveJsonModule"": true,
    ""moduleDetection"": ""force"",
    ""isolatedModules"": true,

    /* Strictness */
    ""strict"": true,
    ""noUncheckedIndexedAccess"": true,
    ""checkJs"": true,

    /* Bundled projects */
    ""lib"": [""dom"", ""dom.iterable"", ""ESNext""],
    ""noEmit"": true,
    ""module"": ""ESNext"",
    ""moduleResolution"": ""Bundler"",
    ""jsx"": ""preserve"",
    ""plugins"": [{ ""name"": ""next"" }],
    ""incremental"": true,

    /* Path Aliases */
    ""baseUrl"": ""."",
    ""paths"": {
      ""~/*"": [""./src/*""]
    },
    ""types"": [""cypress""]
  },
  ""include"": [
    "".eslintrc.cjs"",
    ""next-env.d.ts"",
    ""**/*.ts"",
    ""**/*.tsx"",
    ""**/*.cjs"",
    ""**/*.js"",
    "".next/types/**/*.ts""
  ],
  ""exclude"": [""node_modules""]
}
```"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2345716279,I got the same error
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2346050907,"> ```json
> {
>   ""compilerOptions"": {
>     /* Base Options: */
>     ""esModuleInterop"": true,
>     ""skipLibCheck"": true,
>     ""target"": ""ESNext"",
>     ""allowJs"": true,
>     ""resolveJsonModule"": true,
>     ""moduleDetection"": ""force"",
>     ""isolatedModules"": true,
> 
>     /* Strictness */
>     ""strict"": true,
>     ""noUncheckedIndexedAccess"": true,
>     ""checkJs"": true,
> 
>     /* Bundled projects */
>     ""lib"": [""dom"", ""dom.iterable"", ""ESNext""],
>     ""noEmit"": true,
>     ""module"": ""ESNext"",
>     ""moduleResolution"": ""Bundler"",
>     ""jsx"": ""preserve"",
>     ""plugins"": [{ ""name"": ""next"" }],
>     ""incremental"": true,
> 
>     /* Path Aliases */
>     ""baseUrl"": ""."",
>     ""paths"": {
>       ""~/*"": [""./src/*""]
>     },
>     ""types"": [""cypress""]
>   },
>   ""include"": [
>     "".eslintrc.cjs"",
>     ""next-env.d.ts"",
>     ""**/*.ts"",
>     ""**/*.tsx"",
>     ""**/*.cjs"",
>     ""**/*.js"",
>     "".next/types/**/*.ts""
>   ],
>   ""exclude"": [""node_modules""]
> }
> ```

Can you try these settings?

{ ""compilerOptions"": { ""target"": ""ESNext"", ""module"": ""ESNext"", ""allowImportingTsExtensions"": true, ""moduleResolution"": ""Bundler"", ""noEmit"": true, ""esModuleInterop"": true, ""strict"": true } }"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2346394127,"I am getting the same error from many days in the vs code.
"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2346398711,"when did you start getting it?- JacobOn Sep 12, 2024, at 09:03, Taksh Chanana ***@***.***> wrote:ï»¿
I am getting the same error from many days in the vs code.

â€”Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you authored the thread.Message ID: ***@***.***>"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2346400076,"![Screenshot from 2024-09-12 19-35-11](https://github.com/user-attachments/assets/bdebb3fe-873e-429f-9c7c-d75bef4cbd42)
"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2356777215,"> allowImportingTsExtensions

same"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2356867870,"This fixes it for me:

in `eslint.config.mjs`, add the zod plugin:

```js
import typescriptEslint from ""@typescript-eslint/eslint-plugin"";
import drizzle from ""eslint-plugin-drizzle"";
import zod from ""eslint-plugin-zod"";
import tsParser from ""@typescript-eslint/parser"";
import path from ""node:path"";
import { fileURLToPath } from ""node:url"";
import js from ""@eslint/js"";
import { FlatCompat } from ""@eslint/eslintrc"";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const compat = new FlatCompat({
  baseDirectory: __dirname,
  recommendedConfig: js.configs.recommended,
  allConfig: js.configs.all
});

export default [...compat.extends(
  ""next/core-web-vitals"",
  ""plugin:@typescript-eslint/recommended-type-checked"",
  ""plugin:@typescript-eslint/stylistic-type-checked"",
), {
  plugins: {
    ""@typescript-eslint"": typescriptEslint,
    drizzle,
    zod,
  },

  languageOptions: {
    parser: tsParser,
    ecmaVersion: 5,
    sourceType: ""script"",

    parserOptions: {
      project: true,
    },
  },

  rules: {
    ""zod/prefer-enum"": 2,
    ""zod/require-strict"": 2,

    ""@typescript-eslint/array-type"": ""off"",
    ""@typescript-eslint/consistent-type-definitions"": ""off"",

    ""@next/next/no-duplicate-head"": ""off"",
    ""import/no-anonymous-default-export"": ""off"",

    ""@typescript-eslint/consistent-type-imports"": [""warn"", {
      prefer: ""type-imports"",
      fixStyle: ""inline-type-imports"",
    }],

    ""@typescript-eslint/no-unused-vars"": [""warn"", {
      argsIgnorePattern: ""^_"",
    }],

    ""@typescript-eslint/require-await"": ""off"",

    ""@typescript-eslint/no-misused-promises"": [""error"", {
      checksVoidReturn: {
        attributes: false,
      },
    }],

    ""@typescript-eslint/no-empty-object-type"": ""off"",

    ""drizzle/enforce-delete-with-where"": [""error"", {
      drizzleObjectName: [""db"", ""ctx.db""],
    }],

    ""drizzle/enforce-update-with-where"": [""error"", {
      drizzleObjectName: [""db"", ""ctx.db""],
    }],

    ""@typescript-eslint/no-unsafe-member-access"": ""off"",
    ""@typescript-eslint/no-unsafe-call"": ""off"",
    ""@typescript-eslint/no-unsafe-assignment"": ""off"",
    ""@typescript-eslint/no-unsafe-argument"": ""off"",
  },
}];
```

Then install the dependencies:

```bash
bun add @eslint/js @eslint/eslintrc @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint eslint-plugin-react eslint-plugin-jsx-a11y eslint-plugin-import eslint-plugin-drizzle eslint-plugin-zod 
```

For reference, here's my `package.json`:

```json
{
  ""name"": ""aii"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""build"": ""next build"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""dev"": ""next dev"",
    ""lint"": ""next lint"",
    ""start"": ""next start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@fullcalendar/daygrid"": ""^6.1.15"",
    ""@fullcalendar/interaction"": ""^6.1.15"",
    ""@fullcalendar/react"": ""^6.1.15"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-alert-dialog"": ""^1.1.1"",
    ""@radix-ui/react-collapsible"": ""^1.1.0"",
    ""@radix-ui/react-context-menu"": ""^2.2.1"",
    ""@radix-ui/react-dialog"": ""^1.1.1"",
    ""@radix-ui/react-hover-card"": ""^1.1.1"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@radix-ui/react-label"": ""^2.1.0"",
    ""@radix-ui/react-menubar"": ""^1.1.1"",
    ""@radix-ui/react-progress"": ""^1.1.0"",
    ""@radix-ui/react-select"": ""^2.1.1"",
    ""@radix-ui/react-separator"": ""^1.1.0"",
    ""@radix-ui/react-slider"": ""^1.2.0"",
    ""@radix-ui/react-slot"": ""^1.1.0"",
    ""@radix-ui/react-switch"": ""^1.1.0"",
    ""@radix-ui/react-tabs"": ""^1.1.0"",
    ""@radix-ui/react-toggle"": ""^1.1.0"",
    ""@radix-ui/react-toggle-group"": ""^1.1.0"",
    ""@radix-ui/react-tooltip"": ""^1.1.2"",
    ""@sendgrid/mail"": ""^8.1.3"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""eslint-plugin-import"": ""^2.30.0"",
    ""eslint-plugin-jsx-a11y"": ""^6.10.0"",
    ""eslint-plugin-react"": ""^7.36.1"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.441.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""node-cron"": ""^3.0.3"",
    ""nodemailer"": ""^6.9.15"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""react-hook-form"": ""^7.53.0"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""zod"": ""^3.23.8""
  },
  ""devDependencies"": {
    ""@eslint/eslintrc"": ""^3.1.0"",
    ""@eslint/js"": ""^9.10.0"",
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.6.0"",
    ""@typescript-eslint/parser"": ""^8.6.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^9.10.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""eslint-plugin-zod"": ""^1.4.0"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2372878644,"Okay so for those of us who don't have any linting rules and have this stupid error, what the heck is it"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2373071115,"yeah linting configuration didnâ€™t actually fix it for me either- JacobOn Sep 24, 2024, at 23:13, ZachHandley ***@***.***> wrote:ï»¿
Okay so for those of us who don't have any linting rules and have this stupid error, what the heck is it

â€”Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you authored the thread.Message ID: ***@***.***>"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2374314654,"@colinhacks can you please fix this or look at this, something got effed

```bash
â¯ bun install
bun install v1.1.30-canary.34 (17d719fa)

+ vite-tsconfig-paths@5.0.1
+ @astrojs/check@0.9.3
+ @astrojs/cloudflare@11.1.0
+ @astrojs/partytown@2.1.2
+ @astrojs/sitemap@3.1.6
+ @astrojs/tailwind@5.1.1
+ @astrojs/vue@4.5.1
+ @directus/sdk@17.0.1
+ @iconify/vue@4.1.2
+ @inox-tools/astro-when@0.2.3
+ @nanostores/persistent@0.10.2
+ @nanostores/vue@0.10.0
+ @vueuse/core@11.1.0
+ astro@4.15.9
+ nanostores@0.11.3
+ sweetalert2@11.14.1
+ tailwindcss@3.4.13
+ typescript@5.6.2
+ vue@3.5.8
+ zastro-service-worker@0.0.3
+ zod@3.23.8

865 packages installed [164.71s]
```

okay great, so it's installed right? and I can use it right?
![image](https://github.com/user-attachments/assets/b34feb42-fbb3-4729-8c02-a4351ccb0a9c)

okay............................................. idk what the hell to do here. No package manager properly resolves it and it's broken now on multiple projects."
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2374347897,i should clarify that this is not a eslint error. because even if i get eslint to shut up next build still fails
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2374365014,^ correct. Something got effed.
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2395468058,"I have the same issue with Typescript 5.6, but it works fine with Typescript 5.5.

I suspect the problem is related to [this change](https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/#respecting-file-extensions-and-package.json-from-within-node_modules) ([related Typescript pull request](https://github.com/microsoft/TypeScript/pull/58825)). This change was already in the typescript@5.5.1-rc prerelease, and I'm also encountering the issue when using this version."
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2395495126,"I fixed above issue by putting the following inside the tsconfig.json for your front end project **NOT** Amplify file:

```
{
  ""compilerOptions"": {
    ...
    ""esModuleInterop"": true
    ...
  }
}
```
"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2403559062,"1. Add this to your package.json dependency (^ is the problem)
```
""zod"": ""3.22.4""
```

2. Remove node_modules(`sudo rm -rf node_modules`)
3. Re-install npm modules (`npm i`)"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2407877765,"careful with the sudo rm- JacobOn Oct 9, 2024, at 15:52, Taksh Chanana ***@***.***> wrote:ï»¿

Add this to your package.json dependency (^ is the problem)

""zod"": ""3.22.4""


Remove node_modules(sudo rm -rf node_modules)
Re-install npm modules (npm i)


â€”Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you authored the thread.Message ID: ***@***.***>"
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2439704006,"> 1. Add this to your package.json dependency (^ is the problem)

^ is not the problem. ^ merely allows to get the newest 3.x.x version out there. The real problem is the specific version ^3 gets you and since I just installed zod in my new project my version looks like this `""zod"":""^3.23.8`. Removing the ^ does literally nothing in my case.

But sure, I installed v3.22.4 and it worked, so then I kept upgrading zod until it broke. v3.23.7 works and v3.23.8 doesnt.

Also, v3.23.8 works with commonjs. It's just the ESM part that's broken."
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2470270575,any update on the issue ? using pnpm instead of bun seems to resolve the issue.
2506729680,3739,"Module '""zod""' has no exported member 'z'.ts","I get this error when my linter runs over the bunx create-t3-app starting repo. I also get this linting error when i install zod separately into a empty repo. **The code runs fine tho**. I don't know if I'm missing type deps or maybe the package has changed and all the tutorials telling me to `import {z} from 'zod'` are outdated now. How can i fix this error?

zod version: ^3.23.3
bun version: 1.1.17
node version: v20.12.2

`package.json`:
```json
{
  ""name"": ""subhub"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""type"": ""module"",
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""lint"": ""next lint"",
    ""start"": ""next start"",
    ""dev:soft-reset"": ""bun db:wipe && bun db:seed && bun dev"",
    ""dev:hard-reset"": ""bun i && bun db:rm && bun db:start && bun db:seed && bun dev"",
    ""db:generate"": ""drizzle-kit generate"",
    ""db:migrate"": ""drizzle-kit migrate"",
    ""db:push"": ""drizzle-kit push"",
    ""db:studio"": ""drizzle-kit studio"",
    ""db:seed"": ""bun run src/server/db/seed.ts"",
    ""db:wipe"": ""bun run src/server/db/wipe.ts"",
    ""db:start"": ""./start-database.sh && sleep 10 && bun db:generate && bun db:migrate && bun db:push"",
    ""db:stop"": ""docker stop $(docker ps -aq) || true"",
    ""db:rm"": ""rm -rf drizzle || true && bun db:stop || true && docker rm $(docker ps -aq) || true"",
    ""db:restart"": ""bun db:stop || true && bun db:rm || true && bun db:start""
  },
  ""dependencies"": {
    ""@auth/drizzle-adapter"": ""^1.1.0"",
    ""@hookform/resolvers"": ""^3.9.0"",
    ""@radix-ui/react-icons"": ""^1.3.0"",
    ""@t3-oss/env-nextjs"": ""^0.10.1"",
    ""@tanstack/react-query"": ""^5.50.0"",
    ""@trpc/client"": ""^11.0.0-rc.446"",
    ""@trpc/next"": ""^11.0.0-rc.446"",
    ""@trpc/react-query"": ""^11.0.0-rc.446"",
    ""@trpc/server"": ""^11.0.0-rc.446"",
    ""@types/uuid"": ""^10.0.0"",
    ""bcrypt"": ""^5.1.1"",
    ""class-variance-authority"": ""^0.7.0"",
    ""clsx"": ""^2.1.1"",
    ""drizzle-orm"": ""^0.33.0"",
    ""geist"": ""^1.3.0"",
    ""lucide-react"": ""^0.438.0"",
    ""next"": ""^14.2.4"",
    ""next-auth"": ""^4.24.7"",
    ""next-themes"": ""^0.3.0"",
    ""postgres"": ""^3.4.4"",
    ""react"": ""^18.3.1"",
    ""react-dom"": ""^18.3.1"",
    ""recharts"": ""^2.12.7"",
    ""superjson"": ""^2.2.1"",
    ""tailwind-merge"": ""^2.5.2"",
    ""tailwindcss-animate"": ""^1.0.7"",
    ""uuid"": ""^10.0.0"",
    ""zod"": ""^3.23.3""
  },
  ""devDependencies"": {
    ""@types/bcrypt"": ""^5.0.2"",
    ""@types/eslint"": ""^8.56.10"",
    ""@types/node"": ""^20.14.10"",
    ""@types/react"": ""^18.3.3"",
    ""@types/react-dom"": ""^18.3.0"",
    ""@typescript-eslint/eslint-plugin"": ""^8.1.0"",
    ""@typescript-eslint/parser"": ""^8.1.0"",
    ""drizzle-kit"": ""^0.24.0"",
    ""eslint"": ""^8.57.0"",
    ""eslint-config-next"": ""^14.2.4"",
    ""eslint-plugin-drizzle"": ""^0.2.3"",
    ""postcss"": ""^8.4.39"",
    ""prettier"": ""^3.3.2"",
    ""prettier-plugin-tailwindcss"": ""^0.6.5"",
    ""tailwindcss"": ""^3.4.3"",
    ""typescript"": ""^5.5.3""
  },
  ""ct3aMetadata"": {
    ""initVersion"": ""7.37.0""
  }
}
```",2471796532,"hmm thank u ill stick with pnpm then- JacobOn Nov 12, 2024, at 03:22, catinrage ***@***.***> wrote:ï»¿
any update on the issue ? using pnpm instead of bun seems to resolve the issue.

â€”Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you authored the thread.Message ID: ***@***.***>"
2502927180,3737,zod import triggers an error in typescript,"tsx v4.19.0
node v22.7.0
zod version: ""^3.23.8""

tsconfig:

```json
{
  ""compilerOptions"": {
    ""target"": ""ESNext"",
    ""module"": ""NodeNext"",
    ""allowImportingTsExtensions"": true,
    ""moduleResolution"": ""NodeNext"",
    ""noEmit"": true,
    ""esModuleInterop"": true,
    ""strict"": true
  }
}
```


code:

```ts
import { z } from ""zod"";
```

yields in vscode

```txt
Cannot find module 'zod' or its corresponding type declarations.ts(2307)
```

but running it works",2344624486,"Can you try it like this?

`{
  ""compilerOptions"": {
    ""target"": ""ESNext"",
    ""module"": ""ESNext"",
    ""allowImportingTsExtensions"": true,
    ""moduleResolution"": ""Bundler"",
    ""noEmit"": true,
    ""esModuleInterop"": true,
    ""strict"": true
  }
}`"
2502927180,3737,zod import triggers an error in typescript,"tsx v4.19.0
node v22.7.0
zod version: ""^3.23.8""

tsconfig:

```json
{
  ""compilerOptions"": {
    ""target"": ""ESNext"",
    ""module"": ""NodeNext"",
    ""allowImportingTsExtensions"": true,
    ""moduleResolution"": ""NodeNext"",
    ""noEmit"": true,
    ""esModuleInterop"": true,
    ""strict"": true
  }
}
```


code:

```ts
import { z } from ""zod"";
```

yields in vscode

```txt
Cannot find module 'zod' or its corresponding type declarations.ts(2307)
```

but running it works",2344950121,actually now it works. weird.
2502066097,3736,question: How can I show fielderrors as hints?,"Hi,

I have a password field with many rules. The rules should be displayed as hints below the textfield to help the user to get it right in the first instance.

what I have done now was validating the schema with an empty string to get all possible errors for that field

```js
const schema = z.object({
  firstname: z.string().min(3),
  lastname: z.string().min(3),
  email: z.string().email(""Invalid email""),
  password: z
    .string()
    .min(8)
    .refine((password) => /[A-Z]/.test(password), {
      message: ""Add one uppercase"",
    })
    .refine((password) => /[0-9]/.test(password), {
      message: ""Add one number"",
    })
    .refine(
      (password) => /[`!@#$%^&*()_\-+=Â§\[\]{};':""\\|,.<>\/?~ ]/.test(password),
      {
        message: ""Add one special character"",
      }
    ),
});

// get all errors for password field
const result = schema.safeParse({ password: """" });
const passwordHints = result.error.flatten().fieldErrors.password;
```
 is this the way to go or there are other solutions to get the errors?

----------------

This is the rest of my code. not really a question. just asking for feedback if this is ok or there are other ways to solve this with Zod....

To update the rules, I created a function where I match the list of all errors with the current validated error

```js
//passwordHints enriched with states if rule is fulfilled
const passwordHintsWithStates = ref();

//live validation
const onInput = (e) => {
  passwordStrength(e.target.value);
};
//check password rules
const passwordStrength = (value) => {
  let result = schema.safeParse({ password: value });
  result = result.error.flatten().fieldErrors.password;

  passwordHintsWithStates.value = passwordHints.map((hint) => {
    let error = false;
    if (result) {
      error = result.includes(hint);
    }
    return {
      message: hint,
      error: error,
      init: init.value,
    };
  });
};

//init state used to display hints in gray
const init = ref(true);
const onBlur = (e) => {
  init.value = false;
  passwordStrength(e.target.value);
};
```

```html
<div class=""flex flex-col gap-1 mt-2"">
    <span
        v-for=""hint in passwordHintsWithStates""
        :class=""
          hint.init && hint.error
            ? 'text-gray-400'
            : hint.init && !hint.error
            ? 'text-success-base'
            : hint.error
            ? 'text-error-base'
            : 'text-success-base'
        ""
    > {{ hint.message }}</span>
</div>
 ```
 
 any feedback is highly appreciated
 
 cheers,
 gregor

",,
2501486499,3735,Incorrect type derivation when using z.array() with z.transform(),"In a much bigger project, I have a compile error where it complains that a type ""string | boolean"" can't be assigned to ""boolean.""
I want to define a boolean field that can coerce from string.
Unfortunately, ""coerce"" doesn't work, because the string ""false"" is coerced to true, because it's JavaScript truthy.
Thus, I tried using transform() instead.

Here is the small reproduction case:

```
import { z } from ""zod"";

export const ZInner = z.strictObject({
        a_string: z.string(),
        a_boolean: z.boolean().or(
                z.string().transform((v, ctx) => {
                        if (v === ""true"") return true;
                        if (v === ""false"" || v === """") return false;
                        ctx.addIssue({ code: z.ZodIssueCode.custom, message: ""invalid boolean value: "" + v });
                        return false;
                })
        ),
});
export type IInner = z.infer<typeof ZInner>;

export const ZOuterList: z.ZodType<IInner[]> = z.lazy(() => z.array(ZInner));
export type IOuterList = z.infer<typeof ZOuterList>;
```

This gives the following error:

```
> tsc --build --pretty

src/index.ts:16:14 - error TS2322: Type 'ZodLazy<ZodArray<ZodObject<{ a_string: ZodString; a_boolean: ZodUnion<[ZodBoolean, ZodEffects<ZodString, boolean, string>]>; }, ""strict"", ZodTypeAny, { ...; }, { ...; }>, ""many"">>' is not assignable to type 'ZodType<{ a_string?: string; a_boolean?: boolean; }[], ZodTypeDef, { a_string?: string; a_boolean?: boolean; }[]>'.
  Types of property '_input' are incompatible.
    Type '{ a_string?: string; a_boolean?: string | boolean; }[]' is not assignable to type '{ a_string?: string; a_boolean?: boolean; }[]'.
      Type '{ a_string?: string; a_boolean?: string | boolean; }' is not assignable to type '{ a_string?: string; a_boolean?: boolean; }'.
        Types of property 'a_boolean' are incompatible.
          Type 'string | boolean' is not assignable to type 'boolean'.
            Type 'string' is not assignable to type 'boolean'.

16 export const ZOuterList: z.ZodType<IInner[]> = z.lazy(() => z.array(ZInner));
```

It is my assumption that, if `IInner` is boolean-only, then `z.array(ZInner)` should also be.
However, this doesn't seem to hold true.
",2325226657,"Also, the `lazy()` doesn't matter (happens without it,) and trying to tack on `.pipe(z.coerce.boolean())` doesn't work, same error."
2501486499,3735,Incorrect type derivation when using z.array() with z.transform(),"In a much bigger project, I have a compile error where it complains that a type ""string | boolean"" can't be assigned to ""boolean.""
I want to define a boolean field that can coerce from string.
Unfortunately, ""coerce"" doesn't work, because the string ""false"" is coerced to true, because it's JavaScript truthy.
Thus, I tried using transform() instead.

Here is the small reproduction case:

```
import { z } from ""zod"";

export const ZInner = z.strictObject({
        a_string: z.string(),
        a_boolean: z.boolean().or(
                z.string().transform((v, ctx) => {
                        if (v === ""true"") return true;
                        if (v === ""false"" || v === """") return false;
                        ctx.addIssue({ code: z.ZodIssueCode.custom, message: ""invalid boolean value: "" + v });
                        return false;
                })
        ),
});
export type IInner = z.infer<typeof ZInner>;

export const ZOuterList: z.ZodType<IInner[]> = z.lazy(() => z.array(ZInner));
export type IOuterList = z.infer<typeof ZOuterList>;
```

This gives the following error:

```
> tsc --build --pretty

src/index.ts:16:14 - error TS2322: Type 'ZodLazy<ZodArray<ZodObject<{ a_string: ZodString; a_boolean: ZodUnion<[ZodBoolean, ZodEffects<ZodString, boolean, string>]>; }, ""strict"", ZodTypeAny, { ...; }, { ...; }>, ""many"">>' is not assignable to type 'ZodType<{ a_string?: string; a_boolean?: boolean; }[], ZodTypeDef, { a_string?: string; a_boolean?: boolean; }[]>'.
  Types of property '_input' are incompatible.
    Type '{ a_string?: string; a_boolean?: string | boolean; }[]' is not assignable to type '{ a_string?: string; a_boolean?: boolean; }[]'.
      Type '{ a_string?: string; a_boolean?: string | boolean; }' is not assignable to type '{ a_string?: string; a_boolean?: boolean; }'.
        Types of property 'a_boolean' are incompatible.
          Type 'string | boolean' is not assignable to type 'boolean'.
            Type 'string' is not assignable to type 'boolean'.

16 export const ZOuterList: z.ZodType<IInner[]> = z.lazy(() => z.array(ZInner));
```

It is my assumption that, if `IInner` is boolean-only, then `z.array(ZInner)` should also be.
However, this doesn't seem to hold true.
",2325426709,"Looking at this some more, the problem here is that the `z.ZodType<Output, Def, Input>` typedef defaults `Input` to `Output` and in this case, `Input` is something else.
So, I have to indirect another type for the `z.input<typeof ZInner>` and pass that to the `ZodType` definition, and then it works.
"
2499245240,3734,Add Optional Descriptions to Enums in Zod for Enhanced Schema Clarity,"Enums are widely used to represent a fixed set of values but cannot currently carry additional metadata such as descriptions. Adding optional descriptions would make schemas more informative and easier to understand, especially in complex applications where context is key.

``` ts

import { z } from ""zod"";

// Current approach without descriptions
export const ProductCategorySchema = z.enum([""electronics"", ""clothing"", ""furniture""]);

// Descriptions would be managed separately
const categoryDescriptions = {
    electronics: ""Devices and gadgets such as smartphones, laptops, and cameras."",
    clothing: ""Apparel including shirts, pants, dresses, and accessories."",
    furniture: ""Home and office furnishings like chairs, tables, and sofas.""
};

// Usage example
const selectedCategory = ""electronics"";
const description = categoryDescriptions[selectedCategory] || ""No description available"";
console.log(`Category: ${selectedCategory}`);
console.log(`Description: ${description}`);

```

### Proposed Implementation
**Extend Zodâ€™s Enum Schema:** Add optional description support directly within Zodâ€™s enum definitions, allowing for cleaner and more integrated schema management.

``` ts
import { z } from ""zod"";

// Define a schema with optional descriptions
export const ProductCategorySchema = z.enum([
    { value: ""electronics"", description: ""Devices and gadgets such as smartphones, laptops, and cameras."" },
    { value: ""clothing"", description: ""Apparel including shirts, pants, dresses, and accessories."" },
    { value: ""furniture"", description: ""Home and office furnishings like chairs, tables, and sofas."" }
]);

// Accessing descriptions directly
const category = ProductCategorySchema.enumValues.find(v => v.value === ""electronics"");
console.log(`Category: ${category.value}`);
console.log(`Description: ${category.description}`);

```
**Backward Compatibility**
**Non-Disruptive Change:** This feature introduces descriptions as an optional addition to enums. Existing code using enums without descriptions will remain unaffected.
**Optional Descriptions:** The feature will be available but not required, allowing developers to adopt it at their own pace.",,
2497366972,3732,Feature Proposal: Allow Support for alternative field names ,"# What

Extend zod by a possibility to provide alternative or secondary field names. Those secondary field names are considered when parsing an object and the primary field name is not found in an object. This would be a great addition to ease renaming fields in a schema without backward incompatible changes

This could look like this

```ts
const schema = z.object({
  myField: z.string().secondaryName('myOldField'),
});
```

Parsing the following objects would result in the same output
```ts
schema.parse({myField:'some'}) // result is {myField:'some'}

schema.parse({myOldField:'some'}) // result is {myField:'some'}
```",,
2494077055,3731,Help about zod arrays and strings,"i am working on a simple project and i got stuck in working with zod arrays:
currently i am pushing a zod string into the array then it works with the input element but the form won't submit bcz of the field and the field isn't validated.

```
export const formSchema = z.object({
        origins: z.array(z.string().min(1).max(256)
//      origins: z.string().array().min(1).max(256)
});
```

```
<script lang=""ts"">
	import { zodClient } from ""sveltekit-superforms/adapters"";
	import { superForm } from ""sveltekit-superforms"";
	import { formSchema } from ""./schema.js"";
	import { loadStore } from ""$lib/store"";
	import { z } from ""zod"";
	export let data;

	// HERE IS THE ISSUE SO PLS HLP
	function addOrigin() {
		if ($formData.origins.length >= 5) {
			toast.error(""Reached the origins limit."", {
				action: {
					label: ""Close"",
					onClick: () => { return; }
				}
			})
			return;
		}

		$formData.origins.push(z.string().min(1).max(256)) // ONCE PUSHED THE FIELD SHOWS '[object Object]'
		$formData.origins = [...$formData.origins]
	}

	const form = superForm(data.form, {
		validators: zodClient(formSchema),
	});
	const { form: formData, message, enhance } = form;
	$: if ($message) toast.error($message)

	addOrigin()
	$: for (let i = 0; i < $formData.origins.length; i += 1) {
		console.log($formData.origins[i])
	}
</script>

<form method=""POST"" use:enhance>
		<label>Origin</label>
		{#each $formData.origins as origin, index}
			<div class=""flex w-full flex-row"">
				<input type=""text"" placeholder=""Http Origins"" autofocus=""1""bind:value={$formData.origins[index]} />
				<button on:click={remOrigin}>
					Remove a Field
				</button>
			</div>
		{/each}
		<button on:click={addOrigin}>
			Add a Field
		</button>
		<button type=""submit"">Continue</button>
</form>
```",2317967417,"Uh, If I understand correctly, there seems to be a misunderstanding. Zod is used to generate schemas. The `$formData.origins` requires actual data, while a schema is used to validate that data. A schema itself cannot be treated as data, so it's important not to mix these two concepts together."
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"HelloðŸ‘‹,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2318204702,"I found the relevant code, and since they used `undefined extends T`, if they had used `assertEqual<undefined, T>`, the optional situation wouldn't have occurred. So I believe this was intentional.

https://github.com/colinhacks/zod/blob/8552233c77426f77d3586cc877f7aec1aa0aa45b/src/helpers/util.ts#L107-L109"
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"HelloðŸ‘‹,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2337744535,I have the same issue
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"HelloðŸ‘‹,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2380631058,ran into the same issue ... i partially agree with it being optional but would need something like a `.required()` then?! are there any workarounds? 
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"HelloðŸ‘‹,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381138080,The feature [existed](#494) but was [rolled back](#519).  ðŸ˜…
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"HelloðŸ‘‹,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381274856,Workaround from another thread https://github.com/colinhacks/zod/issues/1628#issuecomment-1338136697
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"HelloðŸ‘‹,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381331254,"> Workaround from another thread [#1628 (comment)](https://github.com/colinhacks/zod/issues/1628#issuecomment-1338136697)

this does not seem to resolve the problem:

<img width=""338"" alt=""image"" src=""https://github.com/user-attachments/assets/cc3eb868-8f35-4b93-8d1f-d90b054d093e"">
"
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"HelloðŸ‘‹,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381338776,`z.custom<someTypeHere>(x => x !== undefined)`
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"HelloðŸ‘‹,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381341798,"nope

<img width=""482"" alt=""image"" src=""https://github.com/user-attachments/assets/c6714646-9d73-49eb-a931-c0048287a3ba"">
"
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"HelloðŸ‘‹,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381344755,"@schwarmco You can try any type, except for `unknown` and `any`."
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"HelloðŸ‘‹,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381345200,"> @schwarmco You can try any type, except for `unknown` and `any`.

of course! but the whole topic on this issue is to have non-optional any and unknown!?"
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"HelloðŸ‘‹,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381346676,`z.custom<object>(x => x !== undefined)` works
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"HelloðŸ‘‹,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381346968,":sob: Oops, I lost track of the topic."
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"HelloðŸ‘‹,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381351702,"`z.custom<Required<unknown>>(x => x !== undefined)`
`z.custom<Required<any>>(x => x !== undefined)`

Maybe â˜ï¸ is ok"
2493836724,3730,Issue: z.any() and z.unknown() are optional by the default.,"HelloðŸ‘‹,
I face an issue with the default behavior of `z.any()` and `z.unknown()` schemas. I expect these fields to have consistant behavior in line with other supported schemes: `required` after the type is inferred. The actual result is that these fields are optional.

**Question:** Is the current behavior expected or is it a bug?

**Unit test coverage that misses this case:**
https://github.com/colinhacks/zod/blob/main/src/__tests__/object.test.ts#L292

**Type inference example (screenshot)**
<img width=""530"" alt=""Screenshot 2024-08-29 at 10 52 37"" src=""https://github.com/user-attachments/assets/341d1ce3-0528-4ad4-aef3-847bdb4fa8a8"">

**Code example:**
```
import { z } from 'zod';

/**
 * Replace `z.any()` with the appropriate Zod schemas.
 * @see {myConfig}, @see {myQuery}, @see {myQueryResult}
 */
const mySchema = z.object({
  myConfig: z.any(),
  myQuery: z.any(),
  myQueryResult: z.unknown(),
  hasRestrictedFields: z.boolean(),
})

type MyDTO = z.infer<typeof mySchema>

export {
  mySchema,
  MyDTO
}
```
",2381355840,"> `z.custom<Required<any>>(x => x !== undefined)`

this is actually a valid workaround - really appreciate your efforts @darky and @sunnylost :) really think, there should be a zod-way of doing that though.
"
2486967236,3726,Question: How to extend/copy array schema but only change the containing type,"Hello

I have a question regarding arrays.

Given following simple example

```typescript
const myObjSchema = z.object({
  name: z.string(),
});

const arrayOfMyObj = z.array(myObjSchema).min(1).max(2);
```

What i wanna do is kind of changing the containing type of the array like this.

```typescript
const arrayOfMyObjExt = arrayOfMyObj.changeType(myObjSchema.extend({ foo:z.string()}));
```

but i want to keep the constraints of **min** and **max** of the original array.

Why do i need this?

I want to extend and existing schema with some OpenAPI documentation and i **do not have access to the original
schema definitions**. I want to keep as much from the original schema as possible to not run out of sync.
For **z.object** i can use **extends** but there is nothing like this for **z.array**.

Any hints?

Thank you so much for help.

",2315363586,"Maybe you can try something like this:

```ts
const arrayOfMyObj = z.array(myObjSchema).min(1).max(2);

const newSchema = arrayOfMyObj.and(
  z.array(
    z.object({
      foo: z.string(),
    })
  )
);
```

Transforms original schema into an Intersection type."
2486452258,3725,Unable to Chain .min() and Other Validation Methods After .refine() on z.string(),"Zod version: 3.23.8

When writing the following Zod schema:
```typescript
z.string()
  .refine((val) => val === ""John"", {
    message: ""String must be equal to 'John'"",
  })
  .min(1)
```
I expected this validation code to be valid and check whether the string has a minimum length of 1. However, instead of that, I get an error stating that `.min()` is not a function. This error suggests that chaining `.min()` or other validation methods after `.refine()` is not supported.

**Expected Behavior:**

I expect to still be able to use `.min()` and other validation methods (such as `.max()`, etc.) after using `.refine()`. This would allow me to build more complex validation rules without running into method chaining issues.

**Current Behavior:**

Currently, attempting to chain `.min()` (or similar validation methods) after `.refine()` on `z.string()` results in an error: `TypeError: .min is not a function`. This behavior limits the flexibility of combining custom validation logic with built-in methods.

**Use Case:**

In my codebase, I rely on the ability to combine custom validation logic using `.refine()` with built-in methods such as `.min()`. Being able to chain these methods makes the code more concise and maintainable.

**Proposed Solution:**

It would be helpful if `.min()`, `.max()`, and similar validation methods were still accessible after using `.refine()`, or if there were an alternative approach to achieve the same result.

**Request for Feedback:**

I would appreciate feedback on whether this behavior is intentional, and if so, whether there are recommended workarounds or plans to support this kind of chaining in the future.",2309955424,"I've come up with a temporary workaround using an `if` statement to check whether the `.min()` method is available:
```javascript
import z from ""zod"";

let schema = z.string();

schema = schema.refine((val) => val === ""John"", {
  message: ""String must be equal to 'John'"",
});

if (schema.min) {
  console.log(""min is available to use"");
  schema = schema.min(1);
} else {
  console.log(""min is NOT available to use"");
  schema = schema.refine((val) => val.length >= 1);
}

console.log(schema.safeParse(""John""));
```
While this approach works, it adds unnecessary complexity and feels a bit messy. It would be much more straightforward if chaining methods like `.min()` after `.refine()` were supported natively in Zod."
2486452258,3725,Unable to Chain .min() and Other Validation Methods After .refine() on z.string(),"Zod version: 3.23.8

When writing the following Zod schema:
```typescript
z.string()
  .refine((val) => val === ""John"", {
    message: ""String must be equal to 'John'"",
  })
  .min(1)
```
I expected this validation code to be valid and check whether the string has a minimum length of 1. However, instead of that, I get an error stating that `.min()` is not a function. This error suggests that chaining `.min()` or other validation methods after `.refine()` is not supported.

**Expected Behavior:**

I expect to still be able to use `.min()` and other validation methods (such as `.max()`, etc.) after using `.refine()`. This would allow me to build more complex validation rules without running into method chaining issues.

**Current Behavior:**

Currently, attempting to chain `.min()` (or similar validation methods) after `.refine()` on `z.string()` results in an error: `TypeError: .min is not a function`. This behavior limits the flexibility of combining custom validation logic with built-in methods.

**Use Case:**

In my codebase, I rely on the ability to combine custom validation logic using `.refine()` with built-in methods such as `.min()`. Being able to chain these methods makes the code more concise and maintainable.

**Proposed Solution:**

It would be helpful if `.min()`, `.max()`, and similar validation methods were still accessible after using `.refine()`, or if there were an alternative approach to achieve the same result.

**Request for Feedback:**

I would appreciate feedback on whether this behavior is intentional, and if so, whether there are recommended workarounds or plans to support this kind of chaining in the future.",2321241066,"After you use something like refine() or transform(), the return value will be a `ZodEffect`, not a `ZodType` anymore. While you can use pipe() to chain another schema, it can seem verbose in this scenario.

```ts
z
  .string()
  .refine((val) => val === ""John"", {
    message: ""String must be equal to 'John'"",
  })
  .pipe(z.string().min(10));
```"
2485647700,3724,Bug: Defining schema shape causes a TS error when it shouldn't,"### Description
When defining the schema shape using a type (`const Schema: z.ZodType<MyType> = ...`) Typescript is raises an error when using a schema and the pipe method.

I believe it to be a bug as the correct type is inferred from the schema.

### Example
Zod Version 3.23.8

```
import { z } from ""zod"";

export const StringListSchema = z.string().transform((input) => input?.split("",""));

export type InputType = {
  strings?: string[];
};

const Schema: z.ZodType<InputType> = z.object({
  strings: StringListSchema.pipe(z.array(z.string())).optional(),
});
// Type Error: Type 'string | undefined' is not assignable to type 'string[] | undefined'.

export type OutputType = z.infer<typeof Schema>;
// Infered Type: type OutputType = { strings?: string[] | undefined; }

console.log(Schema.parse({ strings: ""one,two"" }));
// Output: { strings: [ 'one', 'two' ] }
```",,
2480606390,3721,Question: is it correct to assume that ZodIssue[] will always equal NonEmptyArray<ZodIssue> if the result of safeParse(schema).succes is false?,I can't find in the source code what criteria will determine whether to return success as true or false. i want to assume that if issues.length===0 then it returns success as true in which case casting ZodIssue[] as NonEmptyArray<ZodIssue> would be fine. but i want to be sure instead of checking everytime,,
2478928992,3720,Problems with .superRefine using discriminated unions,"I'm new to Zod, but I seem to be having an issue where something is breaking one of the schemas that I'm using for a discriminated union. The code below is causing an error in the final line (the error states that (type at position 1 of source isn't compatible with position 1 of target):
````   
// Anchor event case
const anchorEventTimeRange = z
	.object({
		timeRange: z.literal(""Anchor""),
		yearsToInclude: z.array(z.string()),
		anchorEvent: anchorEvent,  // a base object with properties preDurationMonth and postDurationMonth, among others
		trialPopulation: z.object({
			displayName: z.string().min(1, { message: ""Participant Population is required."" }),
			url: z.string(),
			guid: z.string(),
		}),
		alterControlPostCosts: z.string().min(1, { message: ""Cost-Capped Modification is required."" }),
		minimumEligibleDays: z.number().min(0, { message: ""Must be a positive integer."" }),
	})
	.superRefine((values, context) => {
		const monthsPre = values.anchorEvent.preDurationMonth;
		const monthsPost = values.anchorEvent.postDurationMonth;
		const monthsPrePostMin = monthsPre < monthsPost ? monthsPre : monthsPost;
		if (monthsPrePostMin > 0 && values.minimumEligibleDays > 30 * monthsPrePostMin) {
			context.addIssue({
				message: `Must be less than or equal to ${30 * monthsPrePostMin}`,
				code: z.ZodIssueCode.custom,
				path: [""minimumEligibleDays""],
			});
		}
	});

// Year over year event case
const yearOverYearTimeRange = z.object({
	timeRange: z.literal(""YOY""),
	anchorEvent: anchorEvent.optional(),
	yearsToInclude: z
		.array(z.string())
		.length(2, { message: ""Select 2 years to use for Year Over Year comparison."" })
		.refine(
			function (val) {
				const valNumeric = val.map(item => parseInt(item));
				valNumeric.sort((a, b) => a - b);
				return valNumeric[1] - valNumeric[0] === 1;
			},
			{ message: ""Selected years must be consecutive."" },
		),
	trialPopulation: z.object({
		displayName: z.string().min(1, { message: ""Participant Population is required."" }),
		url: z.string(),
		guid: z.string(),
	}),
	isPopulationCompatible: z.boolean({ coerce: true }).nullable(),
	alterControlPostCosts: z.string().nullable(),
	minimumEligibleDays: z
		.number({ message: ""Must be a positive integer."" })
		.min(0, { message: ""Must be a positive integer."" })
		.max(365, { message: ""Must be less than or equal to 365."" }),
});

const timeRangeUnion = z
	.discriminatedUnion(""timeRange"", [yearOverYearTimeRange, anchorEventTimeRange]);
	
````

If I try to use this, then I get a red line under anchorEventTimeRange in the discriminated union. If I move the .superRefine from the anchorEventTimeRange definition to after the discriminated union definition (append it to the end of the final line), it will allow the union to form, but the validation errors aren't consistently firing the correct max value.

To give more info about what I'm doing, in the year over year case, the max value for minimumEligibleDays is 365. However, if it is an anchor event case, then max values of minimumEligibleDays is (30 * the lesser of anchorEvent.preDurationMonth or anchorEvent.postDurationMonth). 

Any ideas about what is going wrong with this that causes the discriminated union objects to not be compatible? I've tried adding a .superRefine to both of objects for each case, but that causes the year over year case to have an error that it is missing a bunch of properties that are truncated, and if I add it to the anchor event case as shown above, then I get the error mentioned above.",,
2476531764,3719,Workarounds for TS 7056?,"Hi guys. I'm pretty new to Zod. I have a project with some large schemas and I am frequently running into this error:
```
TS7056: The inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed.
```

It seems that it has to do mainly with typescript hitting a hard maximum for schemas of a certain size, as I can trigger it just by adding or removing one property on a schema. Splitting the big schema into multiple variables or files does not help.

Would like to know if there are any good workarounds to this. There has been a [past issue](https://github.com/colinhacks/zod/issues/1040) but none of the solutions in that thread have helped for me. The only thing I haven't tried is to monkey-patch tsc, but I would like to avoid that.

Thanks!",,
2476482365,3718,`z.lazy` docs,"`z.lazy` is not mentioned in docs website and I would love to see some docs added. I think it may be useful for what I'm trying to do, and I see it used in various examples, but I have no idea what it does...",,
2472196141,3716,Improve regex DX by adding babel-plugin-transform-regex as dev dependency,"What do you think about adding the [regex](https://github.com/slevithan/regex) package's [Babel plugin](https://github.com/slevithan/babel-plugin-transform-regex) to devDependencies? Since Zod uses a lot of complex regexes, this would allow writing them it a readable and maintainable way that gets transpiled away into native JS regex literals.

From `regex`'s [readme](https://github.com/slevithan/regex#readme):

> `regex` is a template tag that extends JavaScript regular expressions with features from other leading regex libraries that make regexes more powerful and dramatically more readable. It returns native `RegExp` instances that run with native performance, and can exceed the performance of regex literals you'd write yourself. It's also lightweight, has no dependencies, supports all ES2025 regex features, has built-in TypeScript declarations, and can be used as a [Babel plugin](https://github.com/slevithan/babel-plugin-transform-regex) to avoid any runtime dependencies or user runtime cost.
>
> Highlights include support for free spacing and comments, atomic groups via `(?>â€¦)` and possessive quantifiers (e.g. `++`) that can help you avoid [ReDoS](https://en.wikipedia.org/wiki/ReDoS), subroutines via `\g<name>` and subroutine definition groups via `(?(DEFINE)â€¦)` that enable powerful subpattern composition, and context-aware interpolation of regexes, escaped strings, and partial patterns.
>
> With the `regex` library, JavaScript steps up as one of the best regex flavors alongside PCRE and Perl, possibly surpassing C++, Java, .NET, Python, and Ruby.

Note that all of `regex`'s syntax is a strict superset of JS, and its syntax extensions work identically in PCRE (the regex library used by PHP and many others), so there is nothing magical or surprising.

This would allow changing e.g. the unreadable/unmaintainable `ipv4Regex` from `src/types.ts`:

```js
/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
```

To the much nicer:

```js
regex`^
  (?<byte> 25[0-5] | 2[0-4]\d | 1\d\d | [1-9]?\d)
  (\. \g<byte>){3}
$`
```

That would then get transpiled into a native regex literal (you can try it [here](https://slevithan.github.io/babel-plugin-transform-regex/demo/)), without any added runtime dependency or run-time cost for users.

Some of the other regexes in `src/types.ts` would benefit more significantly. To give one more example, here's the `ipv6Regex` regex that's currently used:

`/^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/`

And here is the same regex refactored using `regex`, taking advantage of subroutines and a subroutine definition group:

```js
regex`
  ^ \g<ipv6> $

  (?(DEFINE)
    (?<ipv6>
      ( \g<part>{7}
      | :: \g<part>{0,6}
      | \g<part>    : \g<part>{0,5}
      | \g<part>{2} : \g<part>{0,4}
      | \g<part>{3} : \g<part>{0,3}
      | \g<part>{4} : \g<part>{0,2}
      | \g<part>{5} : \g<part>?
      )
      (\g<segment> | \g<ipv4>)
    )
    (?<part>    \g<segment> :)
    (?<segment> [a-f\d]{1,4})
    (?<ipv4>    \g<byte> (\. \g<byte>){3})
    (?<byte>    25[0-5] | 2[0-4]\d | 1\d\d | [1-9]?\d)
  )
`
```

Written like this, mortals can understand it, spot bugs, and maintain it (e.g. if you wanted to add support for IPv6 zone identifiers), and other mortals can review those changes. The regex literal emitted for this by `regex` also runs faster, because it avoids all the unnecessary capturing groups in the original (by default, `regex` implicitly uses flag `n` or ""named capture only"" mode).

To demonstrate that regex readability matters, after rewriting it like this I easily spotted several errors. For example, it doesn't match the following valid addresses:

- 2001:db8:3:4:5:6:1.2.3.4
- 2001:db8::
- ::

Also, it thinks the following addresses are valid (they aren't since there should be 6 IPv6 segments rather than 7 in mixed addresses):

- 1:2:3:4:5:6:7:1.2.3.4
- ::2:3:4:5:6:7:1.2.3.4

Good luck to anyone who wants to fix these bugs in the original version of the regex. Personally, I don't want to touch it. ðŸ˜– And I'm in the 99th percentile of developers comfortable with reading and editing complex regexes. Perhaps these issues could have been caught with more tests, but tests are no substitute for readability since being able to understand the regexes helps people know where the gaps might be that need testing, and it allows far more people to spot issues.

If you think this could be helpful, I'd be happy to submit a PR that that adds the dev dependency and updates all of the regexes (at least those that would benefit) for readability. My recommendation would be to extract the regexes out of `src/types.ts` into `src/regex.ts`, which `types.ts` would import. Then the Babel plugin would run only on `regex.ts`.",,
2471929185,3715,`z.ref`,"There is a special usage in JSON Schema:

```json
{
  ""$schema"": ""http://json-schema.org/draft-07/schema#"",
  ""properties"": {
    ""root"": {
      ""type"": ""object"",
      ""properties"": {
        ""type"": {
          ""type"": ""string""
        },
        ""arguments"": {
          ""type"": ""array""
        },
        ""children"": {
          ""type"": ""array"",
          ""items"": {
            ""$ref"": ""#/properties/root""
          }
        },
      }
    }
  },
  ""required"": [
    ""root""
  ]
}
```

`$ref` means use a defined structure in the tree.

Have zod a similar function or not? If not, there is any posibility add it?

I try to use a defined structure in Zod, but the ts-server says the types are loop used",,
2470905793,3711,Add support for `base64url` strings,"The `.base64()` function validates strings that contain binary information encoded in Base 64. A modification of Base 64 that can safely be used in URLs and filenames is given by the `base64url` standard specified in [RFC 4648 Â§ 5](https://datatracker.ietf.org/doc/html/rfc4648#section-5). As summarized [here](https://base64.guru/standards/base64url), 

> it uses the same algorithm as the main standard, but differs in the following:
> - Replaces â€œ+â€ by â€œ-â€ (minus)
> - Replaces â€œ/â€ by â€œ_â€ (underline)
> - Does not require a padding character
> - Forbids line separators

I propose a method `.base64url()` that is similar to `.base64()`, but instead matches against a regular expression that describes `base64url`-encoded values.",,
2465327140,3710,Inferred type imported from library has all fields as optional,"I've got a schema and inferred type in a library:
```ts
const schema = z.object({
  name: z.string(),
  address: z.string(),
});

type SchemaType = z.infer<typeof schema>;
```
I'm importing this inferred type into a project, and for some reason all of the fields are showing as potentially undefined. It's got an enum in there and it also shows undefined.

The type signature for the schema in the library looks like this:

```ts
const schema = z.ZodObject<{
  name: z.ZodString;
  addresss: z.ZodString;
}, ""strip"", z.ZodTypeAny, {
  name: string;
  address: string;
}, {
  ...;
}>
```

The type signature for the schema when imported into the project looks like this:

```ts
const schema = z.ZodObject<{
  name: z.ZodString;
  addresss: z.ZodString;
}, ""strip"", z.ZodTypeAny, {
  name?: string | undefined;
  address?: string | undefined;
}, {
  ...;
}>
```

I've got `strict: true` in both `tsconfig.json` files (the library and the project). `strictNullChecks` is not set in either.

Library: 
  Zod 3.23.8
  TS 5.4.5

Project:
  Zod 3.23.8
  TS 4.9.5

Where am I going wrong?
",,
2464729078,3708,variadic rest in the tuple with min & max capability,"I have a scenario, where I need to define the schema in the form of a tuple with certain restrictions in length of min, and max on the variadic rest.

```
const TypeOneSchema = z.object({
  name: z.string(),
  value: z.number(),
});

const TypeTwoSchema = z.object({
  title: z.string(),
  amount: z.number(),
});


const TupleSchema = z.tuple([
  TypeOneSchema, **// First element: TypeOneSchema**
  z.array(TypeTwoSchema).min(1).max(3) **// Rest elements: 1 to 3 TypeTwoSchema**
]);
Note: The above syntax of the tuple isn't supported, adding it here for a better understanding of the use case.
```

Say something like this:
**For example:** the scenario is that a tuple can be a minimum of 2 items & at max, it can have 4 items in the array.

**// Example usage** 
### Valid
const validTuple1 = [
  { name: 'John', value: 20 },
  { title: 'Title 1', amount: 100 }
];

const validTuple2 = [
  { name: 'John', value: 20 },
  { title: 'Title 1', amount: 100 },
  { title: 'Title 2', amount: 150 }
];

### Invalid
const invalidTuple1 = [
  {name: 'John', value: 20 }
];

const invalidTuple2 = [
  { name: 'John', value: 20 },
  { title: 'Title 1', amount: 100 },
  { title: 'Title 2', amount: 150 },
  { title: 'Title 3', amount: 200 },
];

Please suggest how to achieve this using tuple, because it also gives the benefit of auto-suggestion in the code-editor. ",,
2464466553,3707,"Email validation fails on ""="" equals sign","`z.string().email()` incorrectly marks emails using a `=` as invalid. `=` should be valid for the local-part of an email address.

Version: 3.23.8

Testing with the following code:
```
  // Define email validation schema with Zod
  const zodEmailSchema = z.string().email()

  // Function to validate email using Zod
  function validateWithZod(email: string) {
    console.log(`Testing email: ${email}`)
    try {
      zodEmailSchema.parse(email)
      console.log(""Zod: Email is valid"")
    } catch (error) {
      console.log(""Zod: Email is invalid"", error.errors)
    }
  }

  const testEmails = [""something@example.com"", ""some=thing@example.com""]

  for (const testEmail of testEmails) {
    validateWithZod(testEmail)
  }
```

Which outputs:
```
Testing email: something@example.com
Zod: Email is valid
Testing email: some=thing@example.com
Zod: Email is invalid [
  {
    validation: 'email',
    code: 'invalid_string',
    message: 'Invalid email',
    path: []
  }
]
```",,
2460221017,3704,Using generic schemas from generic functions makes enum fields optional,"Reopen https://github.com/colinhacks/zod/issues/995.

```typescript
import { z } from 'zod';

function makeSchema<T extends string>(values: readonly [T, ...T[]]) {
  return z.object({
    e: z.enum(values),
    s: z.string(),
  });
}

function useSchema<T extends string>(values: readonly [T, ...T[]], input: unknown): void {
  const schema = makeSchema(values);
  const result = schema.parse(input);
  let { e, s } = result;
  s = e;
}
```

`e` is a string enum. `s` is a string. `e` should be assignable to `s`, but TypeScript disagrees:
```
zod.ts:14:3 - error TS2322: Type 'addQuestionMarks<baseObjectOutputType<{ e: ZodEnum<[T, ...T[]]>; s: ZodString; }>, any>[""e""] | undefined' is not assignable to type 'string'.
  Type 'undefined' is not assignable to type 'string'.

14   s = e;
     ~
```

`e` is declared as a required field. It can't be undefined.",,
2459789379,3703,z.infer<> fails to infer nested union type.,"Hey everyone, I seem to have run into an issue but I'm unsure if this is by design or there's a way around this.
z.infer<exampleSchema> seems to skip an entire schema and only shows a schema of shared fields only for a nested field with a union type. 

```
field: z
        .union([zod1Schema, zod2Schema])
        .nullable()
        .optional(),
```
The result is a type that only shows what's shared between the two schemas and ignores fields from zod2Schema.",,
2459479748,3702,"The above code how to verify whether newPwd and confirmPwd are consistent, and can get a custom message when the verification fails, just like two passwords are inconsistent; Just like if this check doesn't pass, it gets it in errors.message","`export const zr_colorsize_reset_pwd_FormScheme = z
    .object({
        oldPwd: z.string().min(8, { message: ""8+ characters required"" }).trim(),
        newPwd: z.string().min(8, { message: ""1+ characters required"" }).trim(),
        confirmPwd: z
            .string()
            .min(8, { message: ""4+ characters required"" })
            .trim()
    })
`
The above code how to verify whether newPwd and confirmPwd are consistent, and can get a custom message when the verification fails, just like two passwords are inconsistent; Just like if this check doesn't pass, it gets it in errors.message
`.min(8, { message: ""4+ characters required"" })`
",,
2459268498,3701,File zod/index.d.ts is not a module.,"When using zod@3.23.8 on importing I receive the following error:

![image](https://github.com/user-attachments/assets/93c9d570-e03b-4dad-8d18-1f2f9946d517)

3.23.7 works with no errors",,
2457937139,3698,Creating a large schema from a subset,"Hello, how correct this approach is for creating a large schema from a subset?

```
export const createCampaignSchema = z.object({
    ...campaignSetupSchema.shape,
    ...campaignTargetingSchema.shape,
    ...budgetBiddingSchema.shape
});
```",,
2446860887,3687,"Misleading Error: ""Property 'infer' Does Not Exist"" When Using const Instead of type in Zod","I got the Typescript error:

Property 'infer' does not exist on type 'typeof import(.../node_modules/zod/lib/external)

`const CampaignForm = z.infer<typeof CampaignSchema>;`

Looking at the docs and node_modules the property is there.

The issue was using const instead of type.

Expected:
` type CampaignForm = z.infer<typeof CampaignSchema>;`

Actual:
 `const CampaignForm = z.infer<typeof CampaignSchema>`;

The error is misleading.

although i have this issue but for sake of clearity i have copy pasted from stack overflow 
here is the link
[stack overflow question on this issue](https://stackoverflow.com/questions/76111305/zod-property-infer-does-not-exist-on-type-typeof-import-node-modules-zo)
",,
2439778828,3685,Proper inference of a string to typeof keyof Object,"Hello,

I'm starting using Zod and I haven't figure out how  to proper infer string union type from key of an object without using a type guard.

Here is a sample Zod schema : 
```ts
const obj = z.object({
  foo: z.optional(z.boolean()),
  bar: z.optional(z.boolean()),
})
```

And then I have a function that take a string in parameter and I would like to validate it's a key of the object and infer it.

```ts
function checkKey(key: string) {
  if (key in obj.keyof()) {
    // key is still of type 'string', should be 'foo' | 'bar'
}
```

Example stackblitz : https://stackblitz.com/edit/stackblitz-starters-qfu3yi?file=index.ts

Is this something possible without using type guard right now ? Maybe a potential feature ?",,
2437249907,3683,Feature: support multiple parameters in `.startsWith()`,"Currently it quite verbose to define a string that can start with multiple different prefixes:

```js
const schema = z
  .string()
  .startsWith('foo_')
  .or(z.string().startsWith('bar_'))
  .or(z.string().startsWith('baz_'));
```

it would be great if `.startsWith()` would support an array of strings like
```js
const schema = z
  .string()
  .startsWith(['foo_', 'bar_', 'baz_']);
```

maybe I am also missing an alternative solution for the problem.",,
2435036225,3682,String is hex,"Be able to check if string is hex

Could also be done with regex
```js
z.string().regex(/[0-9A-Fa-f]+/g)
```",,
2434841711,3681,ipv6: case insensitive comparison,"I might be mistaken, but I think the `ipv6` comparison is case sensitive.
From what I can see on wiki:
```
The hexadecimal digits are always compared in case-insensitive manner, but IETF recommendations suggest the use of only lower case letters. For example, 2001:db8::1 is preferred over 2001:DB8::1;
```
Maybe a `toLowerCase` should be added? I just ran into an issue because i got an ip that was mixed case ðŸ˜ž ",,
2434012542,3680,z.string().base64() validation matches non-base64 strings,"**Actual behavior:**
The `z.string().base64()` validation matches non-base64 strings even when a string is empty.

**Expected behavior:**
The `z.string().base64()` validation matches only valid base64 strings.

**Environment:**
- windows 10 22H2;
- node 20.9.0;
- pnpm 8.6.0;
- zod 3.23.8;

**Reproduction:** https://zod-playground.vercel.app?appdata=N4IgzgxgFgpgtgQxALhALwHRgC4CcCWAdgOYAUAlBgEYJgwBsALBQNwgA0IAbggDYCuMMCgDaIAOTiOEwgjgwpncfkTFFEmnSkBdTlxi4w%2BAPaEUIAMwYATFYAcIAL5A

UPD:
According to the [spec](https://datatracker.ietf.org/doc/html/rfc4648#section-10) I see the empty string is valid base64. Additionally, I see it's [tested](https://github.com/colinhacks/zod/blob/821d45b9ed1f3376f3912de15933c92dc926ccbd/src/__tests__/string.test.ts#L167) with the empty string as well, but I think the rest of values in my repro are still non-valid base64 strings.",,
2432939403,3676,Extending zod schema with branded type produces typescript error,"I have a brand in a base schema, which I extend to add additional data, like so:
```ts
import { z } from ""zod"";

const agentBaseSchema = z.object({
  id: z.string().uuid().brand(""Uuid""),
})

enum AgentType {
  CODE_FREE = ""CODE_FREE"",
  MACHINE_CODE = ""MACHINE_CODE"",
}

type AgentBase = z.infer<typeof agentBaseSchema> & {
  type: AgentType 
}

const codeFreeAgentSchema = agentBaseSchema.extend({
  type: z.literal(AgentType.CODE_FREE),
  // Other specific things
})

const machineCodeAgentSchema = agentBaseSchema.extend({
  type: z.literal(AgentType.MACHINE_CODE),
  // Other specific things
})

// ERROR! Type 'string' is not assignable to type string & 'BRAND<""Uuid"">'
const agentSchema = z.union([codeFreeAgentSchema, machineCodeAgentSchema]) satisfies z.ZodSchema<AgentBase>

type Agent = z.infer<typeof agentSchema>
```

[TS playground](https://www.typescriptlang.org/play/?ts=5.4.5&ssl=28&ssc=41&pln=1&pc=1#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFAxhAHYDO8AhgOYCmdMAQsw+wGVqAC3YhmcALwoAdBABGAK3bUYACgQU4cYMQBcsplGB1WagJQyArld0WZ8qMzrE1+AKq3S5gDQU05lScVngAghxcACoAnmDsiFpwAMIA8gAiAKIA+gBiAEoZGVIEqZm5BRn4ftoAsqFJABIAkgBy2aVF0vh1ja3t6ZV+aFQwsfHhnDx88dLIMiaY7FAAPKNxEJhwbJO8-EKi4gB8cABkCdpr7AYTUWNw-lS0jPC0xOw5UOzsNzD7YhLSbZcXaCET-GTsAAeME4rk0FzGBjmABtgDCnMi1D8YnEZB1yoVfIkAPTEuApGCiKBwBhxajATDAahwSkmVgMfyBGj0JhwcQiEzsJIkb4RX5g8TFIFTPYS5gQ6GwjSJS5ImSo9HMTHYsYyHrNNpZDpE7Sk8mUpY0ukMpks4RsjkBR48lhiv6S2bWOjAehqADar3en1Fk3dzB8fOYAroQpFPzDAF1zDTmDBgAxGewGLIAFokMPLH4gw4jO4-YpzBZLVZjDZbN1yktAA)

The `agents` are consumed as a discriminated union on the `type`, as you can see. I'm doing the `satisfies` bit to ensure that new schemas are created properly by other people in the team.

Is there a way to do this? Should I not be doing this?

It seems to be the same idea as https://github.com/colinhacks/zod/issues/2076, but I don't really understand how to apply the solution to my use case since I don't have input/output schemas.",,
2431066838,3675,z.union() ignores custom error message,"```typescript
import { z } from 'zod';

const schema = z.union([z.boolean(), z.number()], { message: 'custom error message' });

const result = schema.safeParse('hello');

if (!result.success) {
    console.log(result.error.errors);
}
```

In this code, I expect that `result.error.errors` emit my custom error message. But I got

```
[
  {
    code: 'invalid_union',
    unionErrors: [ [ZodError], [ZodError] ],
    path: [],
    message: 'Invalid input' // <- this should be 'custom error message'
  }
]
```

Is this specification or bug?",,
2430043008,3673,Support `enumDescriptions`,"The VSCode JSON schema integration supports a custom field [`enumDescriptions`](https://github.com/microsoft/vscode-json-languageservice/blob/fe686d59243664c413654dd6778878c7e0e0ce69/src/jsonSchema.ts#L81) to describe each enum value individually. This is used by various other editors as well. It would be neat if Zod supports this field too, for example:

```js
const kin = z
  .enum([
    'elf',
    'dwarf',
    'human'
  ])
  .describe('Your character lineage', [
    'Elves are a magical people of otherworldly grace',
    'Bold and hardy, dwarves are known as skilled warriors, miners, and workers of stone and metal',
    'Humans are the most adaptable and ambitious people among the common kin'
  ])

console.log(kin.enumDescriptions)
// [
//   'Elves are a magical people of otherworldly grace',
//   'Bold and hardy, dwarves are known as skilled warriors, miners, and workers of stone and metal',
//   'Humans are the most adaptable and ambitious people among the common kin'
// ]
```",,
2428312021,3672,Recursive types with an intermediate object,"Suppose I have a structure like the following:

```ts
const sample = {
  type: 'bulletList',
  content: [
    {
      type: 'listItem',
      content: [{ type: 'bulletList', content: [{ type: 'listItem', content: [{ type: 'paragraph' }] }] }]
    },
    {
      type: 'listItem',
      content: [{ type: 'paragraph' }]
    }
  ]
};
```

The general constraints are as follows:

- Nodes of type `bulletList` can contain ONLY nodes of type `listItem`s as items in `content`
- Nodes of type `listItem` can contain BOTH nodes of type `bulletList` AND `paragraph` as items in `content`

I've tried to solve this using the recursive types [documentation](https://zod.dev/?id=recursive-types) but I can't figure out how to define the types and schemas with this `listItem` being an ""intermediate"" type.

Is it possible to do this with Zod? If so, how?

 ",,
2427440081,3670,Interest in codemods for migrating from v3 to v4?,"Hello there ðŸ‘‹ 

I know that Zod v3.23 was the latest release until v4 which is in the works. 

To help with adoption, I was wondering if you would be interested in me contributing by **developing Zod codemods that users could run to help them automate the migration?** Similar to what the React team did with [the React 19 upgrade guide](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#codemods). 

I'm not working at [Codemod](https://codemod.com/) myself, but the recipes are open-source. I reached out to them and they would be happy if I did as I'm familiar both with Zod and writing codemods in generalâ€”I used to lean on jscodeshift, but Codemod is building [an interesting platform to help share the recipes](https://codemod.com/registry). This project would intersect 2 of my personal interests ðŸ˜„

I'd like to have your green light or concerns before diving in since this is something that may not be part of your vision for v4â€”which I would respect ðŸ‘ 

If you like the idea, I can start working on a POC with automated tests, to show you how it would look like from a user perspective.

Thanks!",,
2426026554,3669,Using nullable() or nullish() alone,"For a specific use case involving a custom type with a complex type union, I need to ensure that a key is defined, but its value can sometimes be undefined or null. I attempted to create a dummy type like this:

```typescript
const myZodObject = z.object({ test: z.nullish() });
// or
const myZodObject = z.object({ test: z.nullable().optional() });
```
However, in both cases, I encountered an error stating that the functions nullable or nullish do not exist.

I can work around this issue by adding a primitive type as shown below, but this solution isn't entirely satisfactory. I am curious to understand why this occurs. Is it due to a technical constraint, such as TypeScript inference, or is it a bug that can be fixed?

If it is a bug, I am willing to investigate further and potentially open a PR to address it. However, I wanted to ask for clarification before proceeding.

Thank you for your help and for this great library, which has already saved me hundreds of hours of work.",,
2425407404,3668,Infer new schema from parsed output,"I have a schema something like this:

```js
UserPost = z.object({
  username: z.string(),
  password: z.string().min(8).transform(val => hash(val))
})
```

What I'd like to do is create a new schema based on the output of `UserPost.parse()`.

Something like this:

```js
UserRecord = UserPost.output()
```

so that when I read the data again at a later time, I can parse it to be confident that it has not been corrupted.

I am aware that a _type_ can be inferred this way:

```js
type output = z.output<typeof UserPost>
```

But is it possible to infer a new Zod schema in a similar way?

(This is just an example by the way, it doesn't really represent my auth strategy!)",,
2423717444,3667,refinement chains unexpectedly violate type safety,"```ts
z.string()
  .refine((s): s is FooBarString => ...)
  .refine((s: FooBarString) => // no TS error, but this can get called with a non-FooBarString
    ...
  )
```
I don't personally understand the benefit of the existing behavior, but if it's kept that way, the types should at least be fixed to where the same type is used for the value argument to each `.refine` predicate in the chain, instead of the output of the previous `.refine`.

I think the existing behavior is especially unfortunate in cases like this:
```ts
z.string().url().refine(
  // this should be okay, s is definitely a url right?
  s => new URL(s).protocol === 'https:'
).parse('foo')
```

Surprise, nope:
```
Uncaught TypeError: Invalid URL
    at new URL (node:internal/url:775:36)
    at REPL39:3:8
    at Object.refinement (/Users/andy/gh/clarity/node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/types.js:217:28)
    at executeRefinement (/Users/andy/gh/clarity/node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/types.js:3178:39)
    at ZodEffects._parse (/Users/andy/gh/clarity/node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/types.js:3198:17)
    at ZodEffects._parseSync (/Users/andy/gh/clarity/node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/types.js:146:29)
    at ZodEffects.safeParse (/Users/andy/gh/clarity/node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/types.js:176:29)
    at ZodEffects.parse (/Users/andy/gh/clarity/node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/types.js:157:29) {
  code: 'ERR_INVALID_URL',
  input: 'foo'
}
```

I don't think anyone would naively expect Zod to try the refinement on non-URLs, since the behavior of other Zod nodes besides refinements is to abort the chain if one node fails parsing.",,
2423103153,3665,[BUG] Generic Function with Object Extend/Merge not treating optional properties as optional and expecting them anyways.,"The following is my code, where in the `createParser` function, where on the return it wants all properties in the schema from the `ResultCreator`/`createResult` function even though the omitted properties are optional and shouldn't be required.

The two Errors look the following in order of lines:
![Code_WxPNisx1AF](https://github.com/user-attachments/assets/ef461556-9971-4cad-9986-d641e9252842)

![Code_CtU0jRz4W8](https://github.com/user-attachments/assets/87b5066a-8dde-4cad-8cdc-deeb8cd51344)


`Result.ts`:
```ts
import { z } from ""zod"";

export const VResultOptions = z.object({
  success: z.boolean(),
  message: z.string().optional(),
  errors: z.array(z.any()).optional(),
});

export type ResultOptions = z.infer<typeof VResultOptions>;

export function ResultCreator<T extends z.ZodTypeAny>(data_schema: T) {
  let merged = VResultOptions.extend({ data: data_schema.optional() });
  return function (options: z.input<typeof merged>) {
    let res = merged.safeParse(options);
    if (!res.success) throw res.error;
    return res.data;
  };
}
```

`Parser.ts`
```ts
import { ResultCreator } from ""./Result"";
import { fromError } from ""zod-validation-error"";
import { z } from ""zod"";

export function createParser<T extends z.ZodTypeAny>(schema: T) {
  const createResult = ResultCreator(schema);
  return function (item: z.input<typeof schema>) {
    const parsed = schema.safeParse(item);
    if (!parsed.success) return createResult({ success: false, message: `${fromError(parsed.error).toString()}` }); //EXPECTS DATA AND ERROR PROPERTY ANYWAYS
    return createResult({ success: true, message: ""Parsed without problems"", data: parsed.data }); //EXPECTS THE ERROR PROPERTY ANYWAYS
  };
}
```

I believe this is not the expected behavior, since the properties should be optional as defined and not required. Also I hope I am not a big dumb dumb, and this behavior is normal.

> *Side note I did try setting every property even as undefined and then it worked, so it really does want all the properties even though some are optional*",,
2421317465,3661,[Feature Request]  take regular expressions to support progressive improvement,"Well, it would be nice to add a function that could pull a regular expression from the validation scheme, at least for strings, so that if js is disabled, the pattern in input can work:

![image](https://github.com/user-attachments/assets/1239893b-d0b7-4025-972d-e226bee4dab4)

To somehow unify verification on the client (even if there is no js) and validation on the server

```jsx
const regExp = z.string().email()
...

return (
<input 
   pattern={regExp}
/>
)
```
",,
2421278487,3660,CI lint checks can be simplified,"Hi,

I was looking through the v4 branch and I noticed in your GitHub workflow that you run these two script as part of your [`lint` job](https://github.com/colinhacks/zod/blob/5a3b5f3d966f4ae654f2f18076aa6b0ccc51f18a/.github/workflows/test.yml#L34-L48):

https://github.com/colinhacks/zod/blob/5a3b5f3d966f4ae654f2f18076aa6b0ccc51f18a/.github/workflows/test.yml#L47-L48

The scripts are defined like this:

https://github.com/colinhacks/zod/blob/5a3b5f3d966f4ae654f2f18076aa6b0ccc51f18a/package.json#L49-L52

The `biome check` command actually combines `lint` and `format`:
> [biome check](https://biomejs.dev/reference/cli/#biome-check)
Runs formatter, linter and import sorting to the requested files.
> Usage: biome check [--write] [--unsafe] [--staged] [--changed] [--since=REF] [PATH]â€¦

https://biomejs.dev/reference/cli/#biome-check

So `lint:check` could actually be removed from the `lint` job.

Furthermore, there is also a `biome ci` command:
> [biome ci](https://biomejs.dev/reference/cli/#biome-ci)
Command to use in CI environments. Runs formatter, linter and import sorting to the requested files. 
> Files wonâ€™t be modified, the command is a read-only operation.
>Usage: biome ci [--formatter-enabled=<true|false>] [--linter-enabled=<true|false>] [--organize-imports-enabled=<true|false>] [--changed] [--since=REF] [PATH]â€¦

So if you have the `*:check` scripts are only needed for CI, they could be replaced by using `biome ci`.",,
2417622283,3654,Support custom discriminators in `z.discriminatedUnion`,"Currently `z.discriminatedUnion` only supports a restricted range of types for the discriminator field â€“ mostly literal values.

There are use-cases for wanting to use other possible values (e.g. a union of values), or even custom types.

For example, an object might have different fields depending on the value of the `type` property, but we might also need a fallback case for any unknown value (i.e. any value other than the known values), e.g.:
```typescript
enum Species {
  Cat = 'cat',
  Dog = 'dog',
}

const zPet = z.discriminatedUnion('species', [
  z.object({ species: z.literal(Species.Cat), lives: z.number() }),
  z.object({ species: z.literal(Species.Dog), breed: z.string() }),
  z.object({
    species: z.custom<string>(val => typeof val === 'string' && Object.values(Species).indexOf(val) < 0),
  }),
})
```

",,
2416424709,3651,Use arrays to create unions,"Trying to something like this, just to reduce noise of lots of potential literal values:

```
const unionSchema = z.union(([0,2,5,7]).map(i =>z.literal(i)))
type UnionType = z.infer<typeof unionSchema>
```

but right now, `UnionType` resolves to `any`",,
2415490151,3649,IP Validation + optional is behaving unexpectedly,"Hello,

I've encountered an issue a couple of days ago and did not find any related topics or issues to that. Maybe my assumption is wrong but I've created a simple example to show what is currently not working as (I) intended it will do:

[Sandbox](https://codesandbox.io/s/vigilant-bogdan-vdr7rn?file=/src/index.ts)

It is possible to chain ip() with optional() - however the validation will fail for an empty string. I've also checked the docs on any exceptions for the usage of optional() but did not find any limitations to that.

Is this a bug or expected behaviour and if so, how can others be made aware of this behaviour?

",,
2414072384,3645,"Property 'pick' does not exist on type 'ZodType<Output, ZodTypeDef, Input>'.","Found a related issue here: https://github.com/colinhacks/zod/issues/2403 - but it doesn't provide a proper solution

I have a zod schema that uses `.lazy` and needs explicit typing with `z.ZodType<Output, z.ZodTypeDef, Input>`. All is well in that regard and that works, but considering that the schema is an object, I'm losing some typing here when I try to `.pick` from my explicitly typed schema.

Is there an alternative to `z.ZodType` that can be used on object schemas, such that pick and omit remain available and no types are lost?

Example code:

```
const nested = z.object({
  bar: z.string(),
}).transform((data) => {
  // transform...
});

const base = z.object({
  foo: z.string(),
}).transform((data) => {
  // transform...
});

type Input = z.input<typeof base> & { nestedObj: z.input<typeof nested> }
type Output = z.output<typeof base> & { nestedObj: z.infer<typeof nested> }

const extendedBase: z.ZodType<Output, z.ZodTypeDef, Input> = base.extend({
  nestedObj: z.lazy(() => nested.optional())
});

const derivedFromExtendedBase = extendedBase.pick({
  foo: true
});

// ^ Property 'pick' does not exist on type 'ZodType<Output, ZodTypeDef, Input>'.
```

Essentially, I'm looking for an alternative to `z.ZodType`. Perhaps `z.ZodObjectType<TOutput, TTypeDef, TInput>`? ",,
2412959414,3644,z.instanceOf error with class with private constructor,"Hi guys,

I'm starting to use ZOD on DDD-oriented classes, and I'm struggling to use the z.instanceof method to type my schema; here is an example

```tsx 
const userSchema = z.object({
    id: z.number().int().positive(),
    firstName: z.string(),
    lastName: z.string(),
});

export type UserInputProps = z.input<typeof userSchema>;
export type UserProps = z.infer<typeof userSchema>;

export class User {
    public readonly __brand = ""User"" as const;

    get id(): number {
        return this.props.id;
    }

    get firstName(): string {
        return this.props.firstName;
    }

    get lastName(): string {
        return this.props.lastName;
    }

    get fullName(): string {
        return `${this.props.firstName.trim()} ${this.props.lastName.trim()}`;
    }

    private constructor(private readonly props: Readonly<UserProps>) {}

    static validate(
        props: UserInputProps,
    ): null | UserProps {
        const result = userSchema.safeParse(props);

        if (result.success) {
            result.data;
        }

        return null
    }

    static create(
        props: Readonly<UserInputProps>,
    ): null |  User {
        const validateResult = User.validate(props);
        if(!validateResult) return null;

        return new User(validateResult );
    }
}
```

Then if I try to use this class on another schema for a list of paginated related data: 

```tsx
export const usersSchema = z.object({
    items: z.array(z.instanceof(User)),
    count: z.number().int().positive(),
});
```

I got this error message

![image](https://github.com/user-attachments/assets/71f8ed80-2c9a-42f8-8f76-e8b50ece4461)

The problem seems to come from here 

![image](https://github.com/user-attachments/assets/29901c0b-e239-47cc-9441-a82d348c3b68)

My private constructor approach comes from the idea of preventing invalid instances and handling it on my create static method that acts as my constructor

Thank you for your time",,
2411671154,3643,z.date({ coerce: 'iso' }),"hi - I find `z.date({ coerce: true })` very useful when using with trpc or another tool that uses JSON to cross an i/o boundary. Because, it forces the client to use a `Date` value - which is then serialized via its `toJSON` method into an ISO string and correctly converted back to a `Date` on the other side. So you get nice `Date` types on either side of the boundary.

But a not-ideal effect of using that trick is that it will also accept values like `null` and `0` which both parse to `1970-01-01T00:00:00.000Z`, so it's a bit dangerous.

So suggestion here is to change `coerce: boolean` to `coerce: boolean | 'iso'`, then update this block: https://github.com/colinhacks/zod/blob/9257ab78eec366c04331a3c2d59deb344a02d9f6/src/types.ts#L1798-L1800

An easy change to that block which should give the right results:

```ts
if (this._def.coerce === 'iso') {
  const coerced = typeof input.data === 'string' ? new Date(input.data) : null;
  if (coerced && coerced.toISOString() === input.data) {
    input.data = coerced;
  }
} else if (this._def.coerce) {
  input.data = new Date(input.data);
}
```

This just makes sure that the ISO string exactly matches the parsed `Date`'s ISO string, but it could also use a regex or some other ISO string validation technique.",,
2411417445,3642,Proposal: Ability to extract certain values from the validated objects while parsing,"I'm working on a project with a large number of Zod schemas. The objects we're validating contain IDs of different database entities. After calling parse(), we additionally go over all objects and collect all IDs of the same kind in an array to bulk-load them from the database in a single query.

While exploring other validation libraries, I found a very interesting `any.artifact(id)` [method in Joi](https://joi.dev/api/?v=17.13.3#anyartifactid) that would allow me to simplify the validation code significantly by shifting the responsibility of value extraction onto the validation schema.

I searched through Zod's documentation but haven't found anything similar. Here's a simple example of how I imagine this feature in Zod:
```javascript
const transferSchema = z.object({
  senderId: z.number().collect('userIds'), // 'userIds' is the name of the collection to which the value should be added
  recipientId: z.number().collect('userIds'),
  amount: z.number(),
});

const parseResult = transferSchema.safeParse({ // using safeParse as it returns the data wrapped in an object that can be extended
  senderId: 1,
  recipientId: 2,
  amount: 200
});

const userIds = parseResult.collections.userIds; // accessing values of the userIds collection - [1, 2]

const users = await getUsers(userIds); // loading users from the DB
```
I've already implemented this in Zod as a proof-of-concept: [see my commit](https://github.com/nikrabaev/zod/commit/4642e36b0fdf624423cfcf9cc604304f8cf3896a). However, a lot of work still needs to be done before it can be submitted to the official repo. I need to know if my proposal aligns with the maintainer's vision of Zod before further investing in the development of this feature.

I'd also love to hear what the community thinks about it.",,
2405951501,3638,z.union() inside of z.array repeats the same issue multiple times,"Let's say I have a schema like this

```ts
const questionsSchema = z.array(
  z.union([
    z.object({
      code: z.string(),
      value: z.enum(['Yes', 'No']),
    }),
    z.object({
      code: z.string(),
      value: z.enum(['Yes', 'No']),
      meta: z.object({
        something: z.number(),
      }),
    }),
    z.object({
      code: z.string(),
      value: z.enum(['Yes', 'No']),
      meta: z.object({
        somethingElse: z.boolean(),
      }),
    }),
  ]),
);
```

And the following array which I try to validate:
```ts
const questions = [
  {
    code: 'Q1',
    value: 'No',
    meta: {
      something: 123,
    },
  },
  {
    code: 'Q2',
    value: 'Yes',
    meta: {
      somethingElse: false,
    },
  },
  { code: 'Q3', value: 'No' },
];
```

If there are no errors, as in the example above, it all looks good. But if I mess up one of the values, e.g. 'No' -> 'Nooo' for Q1, I'd expect to get a single issue, instead of the issue being repeated multiple times and wrongly interpreting the type of one of the items.

```json
[
  {
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""received"": ""Nooo"",
            ""code"": ""invalid_enum_value"",
            ""options"": [""Yes"", ""No""],
            ""path"": [0, ""value""],
            ""message"": ""Invalid enum value. Expected 'Yes' | 'No', received 'Nooo'""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""received"": ""Nooo"",
            ""code"": ""invalid_enum_value"",
            ""options"": [""Yes"", ""No""],
            ""path"": [0, ""value""],
            ""message"": ""Invalid enum value. Expected 'Yes' | 'No', received 'Nooo'""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""received"": ""Nooo"",
            ""code"": ""invalid_enum_value"",
            ""options"": [""Yes"", ""No""],
            ""path"": [0, ""value""],
            ""message"": ""Invalid enum value. Expected 'Yes' | 'No', received 'Nooo'""
          },
          {
            ""code"": ""invalid_type"",
            ""expected"": ""boolean"",
            ""received"": ""undefined"",
            ""path"": [0, ""meta"", ""somethingElse""],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      }
    ],
    ""path"": [0],
    ""message"": ""Invalid input""
  }
]
```",,
2404366852,3636,datetime validation fails if seconds are missing,"Have an issue with a valid datetime value, as produced by the browser in a datetime picker field, is not accepted by the `datetime()` validation. After some digging I figured that when the seconds `:00` are added the validation passes.

But according to ISO 8601, just the hour is required for a valid time. Also as the timestamp is produced like this `""2024-07-18T11:00""`, I feel it would be really great if this is accepted by the library as also the Date constructor doesn't have any issue with this.

For now I had to put in a quite ugly `preprocess` to make the validation pass on the value provided by the browser:
```
z.preprocess(input => `${input}:00`,
            z.string().datetime({ local: true }))
``` ",,
2400878184,3633,.color() function to validate that a string is a valid color.,"Hi, I would want a `.color()` function that you append on a `z.string()` to validate that it's a valid color. 

This feature would be useful in many cases. For example if you want to make sure that payload coming from client/frontend contains valid color codes, directly with zod. 

I believe that by default `.color()` should accept all of the standard forms of colors eg: 

- [rgb](https://en.wikipedia.org/wiki/RGB_color_model) 
- [rgba](https://en.wikipedia.org/wiki/RGBA_color_model)
- [hex](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet )
- [hsl](https://en.wikipedia.org/wiki/HSL_and_HSV)
- [hsv](https://en.wikipedia.org/wiki/HSL_and_HSV)
- [Extended colors eg. `green` `coral` `steel blue`](https://en.wikipedia.org/wiki/Web_colors#Extended_colors)

But also offer some way to only accept (a) certain color type(s), alternatively filter out unwanted color types. 

Might not be that of a realistic feature, but some way to convert the payload to a specified color type. For example if a hex value gets inputted, it gets converted to the specified type, rgb for example . I know this might cause some inaccuracy when converting from certain types to others, but still a feature i would want.

I am open to make this feature myself later on if it gets decided that it's a needed feature.",,
2400498373,3632,Create an error map in pt-br,"First, I would separate the translation texts into a json, which would be passed as a parameter to the errorMap function.

I would move the errorMap function that is in the en.ts file to the root, or we could even create a folder called errors, to place the files that deal with errors.

Then, I would create a pt-br file within the locales, with the translation of the error content.

This would initially make it easier for Brazilians to use, but it would also be easier to implement in other languages â€‹â€‹as well.",,
2398205335,3630,required not work,"```
const User = z
  .object({
    username: z.string(),
  })
  .required();

User.parse({ username: ""Ludwig"" });

type User = z.infer<typeof User>;
// actual { username?: string }
// expected  { username: string }
```
typescript version: Version 5.5.3
zod version: 3.23.8",,
2396523524,3628,Recursive schema with lazy() doesn't seem to work,"**reproduction** https://github.com/dearlordylord/zod-recursive-problem

**similar problems** exist https://github.com/colinhacks/zod/issues/3560 , https://github.com/colinhacks/zod/issues/3331

but they seem to yield different errors and have different reasons

**Context**

I have a file system-like structure where a node is a discriminated union of a leaf (file) or a node with n leaves (directory)

(**the type signature** goes further in the code example and in the repo )

I tried another parser library https://github.com/effect-ts/effect/tree/main/packages/schema and can pull it off with both compile time and runtime

however, Zod doesn't seem to compile this correctly, but it does run and validate correctly runtime:

(the same code is in counter.tsx of https://github.com/dearlordylord/zod-recursive-problem )

```ts

import { z } from 'zod';

type FileSystem = (
  | {
  readonly type: 'directory';
  readonly children: readonly FileSystem[];
}
  | {
  readonly type: 'file';
}
  ) & {
  readonly name: FileSystemName;
};

const fileSystemNameSchema = z.string().min(1).max(255).brand('fileSystemName');
type FileSystemName = z.infer<typeof fileSystemNameSchema>;

const fileSystemBaseSchema = z.object({
  name: fileSystemNameSchema
});

const fileSystemDirectoryBaseSchema = fileSystemBaseSchema.extend({
  type: z.literal('directory')
});

type FileSystemDirectory = z.infer<typeof fileSystemDirectoryBaseSchema> & {
  readonly children: readonly FileSystem[];
}

const fileSystemDirectorySchema: z.ZodType<FileSystemDirectory> = fileSystemDirectoryBaseSchema.extend({
  children: z.lazy(() => z.array(fileSystemSchema))
});

const fileSystemFileSchema = fileSystemBaseSchema.extend({
  type: z.literal('file')
});

export const fileSystemSchema = z.discriminatedUnion('type', [
  fileSystemDirectorySchema,
  fileSystemFileSchema
]);

```

the error is 

```
src/counter.ts:30:7 - error TS2322: Type 'ZodObject<extendShape<extendShape<{ name: ZodBranded<ZodString, ""fileSystemName"">; }, { type: ZodLiteral<""directory"">; }>, { children: ZodLazy<ZodArray<ZodDiscriminatedUnion<""type"", [...]>, ""many"">>; }>, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<FileSystemDirectory, ZodTypeDef, FileSystemDirectory>'.
  Types of property '_type' are incompatible.
    Type '{ type: ""directory""; name: string & BRAND<""fileSystemName"">; children: { [x: string]: any; type?: unknown; }[]; }' is not assignable to type 'FileSystemDirectory'.
      Type '{ type: ""directory""; name: string & BRAND<""fileSystemName"">; children: { [x: string]: any; type?: unknown; }[]; }' is not assignable to type '{ readonly children: readonly FileSystem[]; }'.
        Types of property 'children' are incompatible.
          Type '{ [x: string]: any; type?: unknown; }[]' is not assignable to type 'readonly FileSystem[]'.
            Type '{ [x: string]: any; type?: unknown; }' is not assignable to type 'FileSystem'.
              Type '{ [x: string]: any; type?: unknown; }' is not assignable to type '{ readonly type: ""directory""; readonly children: readonly FileSystem[]; } & { readonly name: string & BRAND<""fileSystemName"">; }'.
                Property 'children' is missing in type '{ [x: string]: any; type?: unknown; }' but required in type '{ readonly type: ""directory""; readonly children: readonly FileSystem[]; }'.
```

zod `^3.23.8`



",,
2394243279,3626,Zod/ React Hook Form - Dynamic Field Array - Conditional Field,"I am trying to create a validation scheme for conditional fields within a field array.

For example, the data can include a list of `persons`, where first and last name are always required, but address is only required if a box is checked off indicating 'different from above'.

Valid data can look like this:

```
[
  {
      'firstName': 'John', //required string
      'lastName': 'Smith', //required string
      'addressSameAsAbove': false, //required bool,
      'address': //required string
 },
 {
      'firstName': 'John', //required string
      'lastName': 'Smith', //required string
      'addressSameAsAbove': true, //required bool,
      //address not required
 }
```

I was able to accomplish this using `refine`, however, since the form structure is created dynamically, I need to be able to create the schema dynamically as well based on a form schema like this:

```
[
  {
    'type': 'Array',
    'children': [
       { type: 'text', name: 'firstName', required: true },
       { type: 'text', name: 'lastName', required: true },
       { type: 'bool', name: 'addressSameAsAbove', required: true },
       { type: 'text', name: 'address', required: { field: 'addressSameAsAbove', condition: false } },
   ]
]
```

I am able to create the schema dynamically for all fields by creating an object for each 'type' of field, however, I am unable to create the conditional validation based on another field.

Any direction / insight would be appreciated. Is this possible using zod?",,
2392897150,3623,idea: leverage module augmentation to reduce bundle size,"I like how Zod has great auto-completion, but it currently results in unused code being loaded which increases bundle sizes (e.g. see #2596).

[Module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation) could be a great way to reduce the core Zod size and allow developers to optionally load additional schema methods. Zod can still be a large library. In fact, it can grow as much as wanted with lots of methods. Consumers will still only load what they want. Their bundle sizes will remain small and only grow as they opt-into more methods. This results in faster loading web pages, cloud function (e.g. AWS Lambda), etc.

This could be a breaking change or Zod could continue to export everything together but provide alternative import paths for this module augmentation leveraging approach.

Here is an oversimplified example that only loads desired methods:

```ts
import { z } from ""./zod"";
import ""./zod/string"";
import ""./zod/string/max"";

console.log(z.string().max(12).parse(""abc"")); // => ""abc""

// cannot use .number() unless it is loaded by importing ./zod/number""
// console.log(z.number().parse(42));
//               ^^^^^^ error TS2339: Property 'number' does not exist on type 'Zod'.

```

<details>
<summary>zod/index.ts</summary>

```ts
export class Zod {}

export const z = new Zod();

type ZodCheck<T> = (value: T) => void;

export abstract class ZodSchema<T> {
  #checks: ZodCheck<T>[];

  constructor(checks: ZodCheck<T>[] = []) {
    this.#checks = checks;
  }

  protected abstract typeCheck(value: unknown): asserts value is T;

  parse(value: unknown) {
    this.typeCheck(value);
    for (const check of this.#checks) check(value);
    return value;
  }

  refinement(check: ZodCheck<T>): this {
    type Self = this;
    return new (this.constructor as { new (checks: ZodCheck<T>[]): Self })([
      ...this.#checks,
      check,
    ]);
  }
}

```

</details>

<details>
<summary>zod/number.ts</summary>

```ts
import type { Zod } from ""."";
import { z, ZodSchema } from ""."";

export class ZodNumber extends ZodSchema<number> {
  protected typeCheck(value: unknown): asserts value is number {
    if (typeof value === ""number"") return;
    throw new Error(""value is not a number"");
  }
}

declare module ""."" {
  interface Zod {
    number(): ZodNumber;
  }
}

z.number = function (this: Zod) {
  return new ZodNumber();
};

```

</details>

<details>
<summary>zod/string.ts</summary>

```ts
import type { Zod } from ""."";
import { z, ZodSchema } from ""."";

export class ZodString extends ZodSchema<string> {
  protected typeCheck(value: unknown): asserts value is string {
    if (typeof value === ""string"") return;
    throw new Error(""value is not a string"");
  }
}

declare module ""."" {
  interface Zod {
    string(): ZodString;
  }
}

z.string = function (this: Zod) {
  return new ZodString();
};

```

</details>

<details>
<summary>zod/string/max.ts</summary>

```ts
import { ZodString } from ""../string"";

declare module ""../string"" {
  interface ZodString {
    max(maxLength: number): ZodString;
  }
}

Object.defineProperty(ZodString.prototype, ""max"", {
  value(this: ZodString, maxLength: number) {
    return this.refinement((value) => {
      if (value.length <= maxLength) return;
      throw new RangeError(""max length exceeded"");
    });
  },
});

```

</details>
",,
2390756346,3622,GitHub Stars links to NPM,"Shouldn't the GitHub Stars shield link to GitHub instead of NPM?

https://github.com/colinhacks/zod/blob/4641f434f3bb3dab1bb8cb07f44dd2693c72e35e/README.md?plain=1#L16",,
2390278576,3621,cuid validation,"parse() function is not throwing an exception for this string `cly63t164000245zw008pggon';select 1;`

```js
const idSchema = z.array(z.string().cuid(), {
    message: ""Each ID must be a valid CUID"",
}).optional();

try {
    idSchema.parse(params.folders);
} catch (error) {
    throw new Error('Invalid IDs');
}
```",,
2388920360,3617,Using the key of string enum using nativeEnum?,"So I have been using this Country enum and wondering if we can validate the keys instead of the value?

https://gist.github.com/evolkmann/740d24889c509c08484a8ff72af5dd64

Currently, the nativeEnum validates the value and could not find an option to make it validate the key instead.",,
2387482945,3614,.default() should apply default if wrapped schema transforms to undefined,"This may seem strange, but it's because I've been dealing with AWS CloudFormation parameters, where you can only have empty strings, not null or undefined values...

I was trying to do

```ts
// helper used in place of `.optional()` for my schema for parsing CloudFormation metadata
function optional<T extends z.ZodTypeAny>(schema: T) {
  return z
    .union([z.literal('').transform(() => undefined), schema.optional()])
    .optional()
}

const parameter = optional(z.string()).default('test')
```

I expected `parameter.parse('')` to be `'test'` but instead it's `undefined`.  This violates the output type of `.default('test')`, so I think even if the input is defined, `ZodDefault` should check that the parse output is too.
",,
2386134327,3612,"PanelOn: z.coerce.boolean(), is generating an optional field PanelOn. How can we require it?","```
Payload: z.object({
        PanelOn: z.coerce.boolean(),
]}
```

having the previous object definition, if we pass a Payload withput the field PanelOn, it will be assumed as boolean false. 

How can I force boolean to be __first__ required __and then__ coerced to javascript boolean __only if they are present__ in the object?

I must ensure that validation DO NOT PASSES if field is missing",,
2385010658,3611,Enum parsing error: TypeError: Cannot read private member from an object whose class did not declare it (codesandbox repro included),"Reproduction: https://codesandbox.io/p/sandbox/zod-test-d6y6ts

I recently upgraded to 3.23.x from 3.22.4 and starting getting this error: 
```
TypeError: Cannot read private member from an object whose class did not declare it.
``` 

After some digging, I narrowed it down to ZodEnums parsing under specific circumstances. It happens when a ZodEnum has been deep cloned (in this case with lodash) and is then added as value of a ZodObject.

See the reproduction for details and some cases that do and don't work.  It's the parsing on the last line that causes the error. Comment it out, and the error goes away.

Edit the package.json to 3.22.4 and the error also disappears. 

I think this might be a related issue: https://github.com/colinhacks/zod/issues/3520

Thanks!",,
2384128345,3608,zod parsing bug ,"This is my complex object zod definition

```
import { z } from 'zod'
import { FieldDataType } from '../../enums/filed-data-type'
import { FieldDataChromoShow } from '../../enums/field-data-chromo-show'
import { EventCategory } from '../../enums/event-category'

const genericAlarmEventFieldDataPayloadSchema = z.object({
    NtpError: z.coerce.boolean(),
    DeviceNotFound: z.coerce.boolean(),
    MasterNotFound: z.coerce.boolean(),
})

const hammamAlarmEventFieldDataPayloadSchema = z.object({
    BoilerFullTooSoon: z.coerce.boolean(),
    EvLoad: z.coerce.boolean(),
    EvDrain: z.coerce.boolean(),
    VinBus: z.coerce.boolean(),
    Ntc: z.coerce.boolean(),
    Fan: z.coerce.boolean(),
    Slave: z.coerce.boolean(),
    HeaterFail: z.coerce.boolean(),
    Capacitive: z.coerce.boolean(),
    CabTemp: z.coerce.boolean(),
    Door: z.coerce.boolean(),
})

const saunaAlarmEventFieldDataPayloadSchema = z.object({
    StoveTemp: z.coerce.boolean(),
    VinBus: z.coerce.boolean(),
    Ntc: z.coerce.boolean(),
    ThermalProtection: z.coerce.boolean(),
    CabTemp: z.coerce.boolean(),
    Potentiometer: z.coerce.boolean(),
})

const eccIotInfoSchema = z.object({
    Id: z.string(),
    Ts: z.coerce.date(),
    Type: z.nativeEnum(FieldDataType),
    HostId: z.string(),
    Payload: saunaAlarmEventFieldDataPayloadSchema
       .or(genericAlarmEventFieldDataPayloadSchema)
       .or(hammamAlarmEventFieldDataPayloadSchema),
})

export const rawEventFieldDataSchema = z.object({
    App: z.string(),
    Cat: z.nativeEnum(EventCategory),
    EccIOTEvent: eccIotInfoSchema,
})

export type RawEventFieldData = z.infer<typeof rawEventFieldDataSchema>
```

When I use this definition, in my code, zod parses it wrongly

```
 const body = { 
                ""App"": ""EccIOT"", 
                ""Cat"": ""Event"", 
                ""EccIOTEvent"":  
                    {  
                    ""Id"": ""ecc-D8E39657C"", 
                    ""Ts"": ""2020/02/28 10:14:10"", 
                    ""Type"":""HAlarm"", 
                    ""HostId"":""0A229332"",
                    ""Payload"":{ 
                        ""BoilerFullTooSoon"" : 0, 
                        ""EvLoad"": 0, 
                        ""EvDrain"": 0, 
                        ""VinBus"": 0, 
                        ""Ntc"": 0, 
                        ""Fan"": 0, 
                        ""Slave"": 0, 
                        ""HeaterFail"": 0, 
                        ""Capacitive"": 0, 
                        ""CabTemp"": 0, 
                        ""Door"": 0 
                    } 
                }  
            }

const rawData: RawEventFieldData = rawEventFieldDataSchema.parse(body)

console.log(rawData);

```

In the console I found this:

```
{
  App: 'EccIOT',
  Cat: 'Event',
  EccIOTEvent: {
    Id: 'ecc-D8E39657C',
    Ts: 2020-02-28T10:14:10.000Z,
    Type: 'HAlarm',
    HostId: '0A229332',
    Payload: {
      StoveTemp: false,
      VinBus: false,
      Ntc: false,
      ThermalProtection: false,
      CabTemp: false,
      Potentiometer: false
    }
  }
}
```

What am I doing wrong ?

> Zod version is 3.23.8 

> Compiler options already includes 
> ```
>""compilerOptions"": {
>        ""strict"": true   
>    }
> ```
",,
2383517975,3607,ZodObject with generic key (i.e. [key: string]: xx) and specific key (i.e. {debug: xx}) don't _seem_ to work as expected,"Hey, I'm trying to take type that is defined like:

```
type A = {
  [x: string]: AllowedZodType;
  debug: z.ZodDefault<z.ZodBoolean>; // One of the allowed zod types
};
```

And convert it to a ZodObject, which I can later use `z.infer` on to get a native type out. I'm having some problems though. First this is how my `AllowedZodType` is defined (it's for defining command arguments schemas for a CLI)

```
type BaseZodType =
  | z.ZodString
  | z.ZodNumber
  | z.ZodBoolean
  | z.ZodEnum<[string, ...string[]]>
  | z.ZodRecord<z.ZodString, z.ZodString | z.ZodNumber>
  | z.ZodArray<z.ZodString | z.ZodNumber, 'many'>;

type NativeType = z.infer<BaseZodType> | undefined;

type WrappedZodType = z.ZodDefault<BaseZodType> | z.ZodOptional<BaseZodType>;

type AllowedZodType = BaseZodType | WrappedZodType | z.ZodEffects<WrappedZodType | BaseZodType, unknown, NativeType>;
```

So what I would like to do is is take type `A` defined above, and:
```
type X = z.ZodObject<A>
type Y = z.infer<X>

// Where Y ends up looking like:
type Y = {
  [x: string]: NativeType;
  debug: boolean;
}
```

But what I actually get is:
```
type X = z.ZodObject<aaa, z.UnknownKeysParam, z.ZodTypeAny, {
    [x: string]: unknown;
    debug?: unknown;
}, {
    [x: string]: NativeType;
    debug?: unknown;
}>

type Y = {
    [x: string]: unknown;
    debug?: unknown;
}
```

I'm thinking there might be something I can use or do, or is this just being interpreted incorrectly by zod's utility types or am I doing something totally dumb?

Thank you!

",,
2383516902,3606,Support for curly braces around UUID/GUID,"Curly braces around UUID's are very common in Microsoft applications also interchangeably referred to as GUIDs it would be great if these could also be validated, maybe a separate GUID validator or some options?

As far as I can see the PR by @jeansibelius merged in v4 for GUIDs also does not cater for the curly braces https://github.com/colinhacks/zod/pull/2872

> PostgreSQL also accepts the following alternative forms for input: use of upper-case digits, the standard format surrounded by braces, omitting some or all hyphens, adding a hyphen after any group of four digits. Examples are:
> 
> A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
> {a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
> a0eebc999c0b4ef8bb6d6bb9bd380a11
> a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
> {a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}
> 

https://www.postgresql.org/docs/current/datatype-uuid.html

Microsoft refer to this here https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/a66edeb1-52a0-

> 4d64-a93b-2f5c833d7d92#gt_b753d3f3-f3b7-4fee-bf4d-63085e108ec9): 
> curly braced GUID string: The string representation of a 128-bit globally unique identifier ([GUID](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/a66edeb1-52a0-4d64-a93b-2f5c833d7d92#gt_f49694cc-c350-462d-ab8e-816f0103c6c1)) using the form {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}, where X denotes a hexadecimal digit. The string representation between the enclosing braces is the standard representation of a GUID as described in [[RFC4122]](https://go.microsoft.com/fwlink/?LinkId=90460) section 3. Unlike a GUIDString, a curly braced GUID string includes enclosing braces.

and here https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/222af2d3-5c00-4899-bc87-ed4c6515e80d

> 2.3.4.3 GUID--Curly Braced String Representation
> 
> The curly braced GUID string representation is a format commonly used for a string representation of the [GUID](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/a66edeb1-52a0-4d64-a93b-2f5c833d7d92#gt_f49694cc-c350-462d-ab8e-816f0103c6c1) type (as specified in section [2.3.4.1](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/49e490b8-f972-45d6-a3a4-99f924998d97)) is described by the following ABNF syntax, as specified in [[RFC5234]](https://go.microsoft.com/fwlink/?LinkId=123096).
> 
>  CurlyBraceGuidString  =  ""{"" UUID ""}""
>  Where [UUID](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/a66edeb1-52a0-4d64-a93b-2f5c833d7d92#gt_c4813fc3-b2e5-4aa3-bde7-421d950d68d3) represents the string form of a UUID, as specified in [[RFC4122]](https://go.microsoft.com/fwlink/?LinkId=90460) section 3. The non-terminal symbol CurlyBraceGuidString represents (that is, generates) strings that satisfy the definition of [curly braced GUID string](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/a66edeb1-52a0-4d64-a93b-2f5c833d7d92#gt_b753d3f3-f3b7-4fee-bf4d-63085e108ec9).
> 
> By way of illustration, the UUID string specified in [RFC4122] section 3 as an example would have the following representation as a curly braced GUID string.
> 
>  {f81d4fae-7dec-11d0-a765-00a0c91e6bf6}

",,
2381767809,3604,Schema evolutions using zod?,"I'm trying to achieve schema versioning / schema evolution / schema migration using zod. I guess zod isn't meant to be used this way, however I got a simple working prototype and wanted to get an opinion if this approach works, scales or if I should drop it and try to use different zod APIs or a completely different library. I would like to stick with zod though as its works quite nice and we already use it for our schema validations.

Basically, what I try to achieve is having different versions of a schema, which would be able to map all versions to the ""latest"" type - allowing me to modify types and schemas over time and still be able to parse ""old"" objects from a previous version of the schema.

For example, imagine a User type with only one string property `id`. Objects of type User are written to some persistence layer.  Over time, Users are extended by another string property `name`. Again after some time, the `name` field is renamed to `userName`. There are possibly three different versions of type User in the persistence layer and I am not able to do database migrations. So we end up with these versions:

v1: { id: string }
v2: { id: string, name: string }
v3 (latest): { id: string, userName: string }

In my application, I only want to deal with latest User type
```ts
type User = {
  id: string,
  userName: string,
}
```

Parsing objects conforming the ""latest"" schema obviously works, but will break for older objects

```ts
const userSchema: z.ZodType<User> = z.object({ id: z.string(), userName: z.string() })

userSchema.parse({ id: '1' }) // fails
userSchema.parse({ id: '2', name: 'alice' }) // fails
userSchema.parse({ id: '3', userName: 'alice' }) // works
```

So my idea was to use a combination of `.transform()`, `.or()` and `.pipe()` to basically create ""schema migrations"", which would be able to lift v1 to v2, v2 to v3, and so on. In the end, I came up with the following solution:

```ts
export const createSchemaEvolution = <T, S>(
  oldSchema: z.ZodType<T>,
  _: z.ZodType<S>,
  mapper: (value: T) => S,
): z.ZodEffects<z.ZodType<T>, S> => oldSchema.transform(mapper)

export const createSchema = <T>(
  latest: z.ZodType<T>,
  evolutions: z.ZodTypeAny[],
): z.ZodType<T> => {
  let schemaEvolutionPipeline = latest
  for (let i = evolutions.length - 1; i >= 0; i--) {
    let currentPipeline = evolutions[i]
    for (let j = i + 1; j < evolutions.length; j++) {
      currentPipeline = currentPipeline.pipe(evolutions[j])
    }
    schemaEvolutionPipeline = schemaEvolutionPipeline.or(currentPipeline)
  }
  return schemaEvolutionPipeline
}
```

Concrete solution for the different versions of User:

```ts
const userSchemaV1 = z.object({ id: z.string() })
const userSchemaV2 = userSchemaV1.extend({ name: z.string() })
const userSchemaV3 = userSchemaV2.omit({ name: true }).extend({ userName: z.string() })

const V1toV2 = createSchemaEvolution(userSchemaV1, userSchemaV2, v1 => ({
  ...v1,
  name: `${v1.id}-defaultName`,
}))
const V2toV3 = createSchemaEvolution(userSchemaV2, userSchemaV3, v2 => ({
  id: v2.id,
  userName: v2.name,
}))

const userSchema = createSchema<User>(userSchemaV3, [V1toV2, V2toV3]) // userSchemaV3.or(V2toV3).or(V1toV2.pipe(V2toV3)) as z.ZodType<User>

userSchema.parse({ id: '1' }) // result: { id: '1', userName: '1-defaultName' }
userSchema.parse({ id: '2', name: 'alice' }) // result: { id: '2', userName: 'alice' }
userSchema.parse({ id: '3', userName: 'alice' }) // result: { id: '3', userName: 'alice' }
```

One can already see, that this approach might be prone to errors and mistakes, `createSchema` is not really typesafe, especially regarding the `evolutions` array and also the order is really important.

Is there a better approach using zod?",,
2381001824,3602,Add `invalid_literal` ZodIssueCode to documentation,"Hello there, new to zod and super happy with it, thank you so much for your work!

As I was playing around with implementing zod into my ts projects I realized I was getting some `invalid_literal` error codes in my zod issues array (mostly in union validation errors). I tried looking up the `invalid_literal` code in the general project gh docs as well as your [error handling docs](https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#zodissuecode) to see what extra fields I can expect and it seems to be missing from those docs. I do see this error code in the [source code](https://github.com/colinhacks/zod/blob/main/src/ZodError.ts) so I'm assuming I didn't find a bug, just possibly some missing docs.

Figured I'd bring it up in case you weren't aware or in the case I'm missing/confused about how the `invalid_literal` code is supposed to be used.",,
2374844934,3597,Refine removes null from schema,"Hello. I don't quite understand what happens but when I use typescript 5.5 (does not happen with 5.2)the refine removes null from union in my schema. 
Proof:
![image](https://github.com/colinhacks/zod/assets/67366321/d55703f8-7933-4e2e-822b-b0f3c5ca8cc9)


If I remove the refine segment, now _null_ is added to the type union and the error is gone.
![image](https://github.com/colinhacks/zod/assets/67366321/d496ada0-5f5e-425d-a2f6-5b61a0710f5d)

If I switch the refine function arguement with a boolean constructor,then the error is gone, but that is because typescript does not use Boolean as a type predicate, so perhaps this further proves that ts's 5.5 inferred predicates work on refine now too.
![image](https://github.com/colinhacks/zod/assets/67366321/fff86e67-4a8b-4f0a-a20f-ff8e8a4f1bd6)

So obviously refine is doing something here...
**But**, I am unable to duplicate this error when I upload it on stackblitz, here -
https://stackblitz.com/edit/typescript-ebur5x?file=index.ts


I am not sure what is going on... Why is refine suddenly removing nulls from the union? it doesn't do it in older typescript versions, and I can't seem to replicate this in stackblitz so maybe it's just me? I guess the question is why is refine removing the null from my union and how can I make it stop... I am using strict mode.",,
2374714988,3596,Add support for `example`,"In our project, we would like to use Zod in combination with [zod-to-json-schema](https://github.com/StefanTerdell/zod-to-json-schema). One feature that we are missing is a parameter to pass an example value for a field.

Here is an example:
```ts
const apiSchema = {
  params: z.object({
    id: z.string({
      description: 'An identifier for the resource.',
      example: '9c235211-6834-11ea-a78c-6feb38a34414',
    }),
  }),
};
```

Which after conversion, it will look like this:
```json

 {
    ""name"": ""id"",
    ""in"": ""path"",
    ""required"": true,
    ""schema"": {
       ""type"": ""string"",
       ""example"": ""9c235211-6834-11ea-a78c-6feb38a34414"",
    },
    ""description"": ""An identifier for the resource.""
 }
```
And here is the representation of this schema in Swagger:

<img src=""https://github.com/colinhacks/zod/assets/12370520/80e5eb06-d0c9-4a21-9f1e-5a6cc5fc77a2"" width=400 />
",,
2366175406,3592,Overloaded function return schema with z.union,"We are using zod with  ts-rest and node express. 

I created and endpoint that uses a function which can return 3 different types based on one argument. 
The function is `getFile` and the argument is `serveAs: 'stream' | 'url' | 'data'`. The way I coded it is function overload statements.

```
export async function getFile(serveAs: 'data'): Promise<File>;
export async function getFile(serveAs: 'stream'): Promise<{ file: File, fileStream: SdkStream<IncomingMessage> }>;
export async function getFile(serveAs: 'url'): Promise<{ url: string }>;
export async function getFile(serveAs: 'data' | 'file' | 'url' = 'file' ) { ... }
```

Because we are using sequelize v6, the model is still ""in js code"" and lacks proper and robust typing. The model is simply the `File` returned from the topmost overload, and at that point is a JSON object (calling `toJSON` after getting the response from the db).

The contract for this endpoint is declared as a `z.union`

```typescript
z.union([
  // For serveAs: url
  z.object({ url: z.string() }),
  // For serveAs: file
  z.instanceof(Stream),
  // For serveAs: data
  FileDto
])
```
where FileDto is the schema reflecting the db model `z.object({ ... })`.

Localy it runs fine. No problems whatsoever. But once I pushed the code for a PR our github action for testing failed complaining.

```
Error: Jest: Got error running globalSetup - /codebuild ... testSetup.js, reason: [TSError: app/controllers/emi/files.controller.ts:32:14 - error TS2322: Type '({ params, res, query }: { params: { id: string; }; query: { serveAs?: ""data"" | ""file"" | ""presigned-url"" | undefined; expiresIn?: number | undefined; }; headers: { [x: string]: string | string[] | undefined; [x: number]: string | ... 1 more ... | undefined; authorization?: string | undefined; ""x-product-name""?: stri...' is not assignable to type 'AppRouteQueryImplementation<{ metadata: { 'x-audience': Audience; tags: string[]; operationId: string; }; method: ""GET""; description: ""Get file by id""; query: ZodObject<{ serveAs: ZodOptional<ZodEnum<[""file"", ""presigned-url"", ""data""]>>; expiresIn: ZodOptional<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>; ... 4 ...'.
  Type 'Promise<{ status: 200; body: Stream; } | { status: 200; body: string; } | { status: 200; body: File; }>' is not assignable to type 'Promise<Prettify<AppRouteResponses<{ metadata: { 'x-audience': Audience; tags: string[]; operationId: string; }; method: ""GET""; description: ""Get file by id""; query: ZodObject<{ serveAs: ZodOptional<ZodEnum<[""file"", ""presigned-url"", ""data""]>>; expiresIn: ZodOptional<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>;...'.
    Type '{ status: 200; body: Stream; } | { status: 200; body: { url: string }; } | { status: 200; body: File; }' is not assignable to type 'Prettify<AppRouteResponses<{ metadata: { 'x-audience': Audience; tags: string[]; operationId: string; }; method: ""GET""; description: ""Get file by id""; query: ZodObject<{ serveAs: ZodOptional<ZodEnum<[""file"", ""presigned-url"", ""data""]>>; expiresIn: ZodOptional<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>; ... 4 m...'.
      Type '{ status: 200; body: File; }' is not assignable to type 'Prettify<AppRouteResponses<{ metadata: { 'x-audience': Audience; tags: string[]; operationId: string; }; method: ""GET""; description: ""Get file by id""; query: ZodObject<{ serveAs: ZodOptional<ZodEnum<[""file"", ""presigned-url"", ""data""]>>; expiresIn: ZodOptional<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>; ... 4 m...'.
        Type '{ status: 200; body: File; }' is not assignable to type '{ status: 200; body: string | Stream | { key: string; location: string; id: string; metadata: { key: string; value: string; }[]; path: string; size: number; createdAt: Date; updatedAt: Date; ... 5 more ...; cdnLing?: string | undefined; }; }'.
          Types of property 'body' are incompatible.
            Type 'File' is not assignable to type '{ url: string } | Stream | { key: string; location: string; id: string; metadata: { key: string; value: string; }[]; path: string; size: number; createdAt: Date; updatedAt: Date; bucket: string; ... 4 more ...; cdnLing?: string | undefined; }'.
              Type 'File' is missing the following properties from type '{ key: string; location: string; id: string; metadata: { key: string; value: string; }[]; path: string; size: number; createdAt: Date; updatedAt: Date; bucket: string; mimeType: string; originalName: string; extension: string; version?: string | undefined; cdnLing?: string | undefined; }': metadata, extension

32 export const findFileById: AppRouteImplementation<
                ~~~~~~~~~~~~]
    at runGlobalHook
```
If I were to give up, I would just split the endpoint into three separate endpoints for each type. Just not sure if the problem wont be the same in the one that returns `FileDto/File`

Can anyone tell me what am I doing wrong here?

PS: 
I can't fix the typo `cdnLing` - it does not appear in code anymore but pops up in the log on github...",,
2365043468,3590,Zod .partial() no longer able to use programmatically,"Apologies, I never post issues, very long-time lurker first time poster.

I've been previously using Zod 3.8.17 and decided we should upgrade to the latest. Upon upgrading, I noticed that .partial() expects an argument of Record<string | number, never> which I'll admit I don't fully understand, but is no longer assignable to { [index: string]: boolean }

It seems like this was done in favor to have exact definitions for the partial argument.

I think this is fine, but this is a breaking change is it not? In our use-case, we have subsets of required fields based on specific conditions, and previously it was working really well creating a programmatic object { [index: string]: boolean } that could then mark various fields required based on those conditions. Now it seems we have to know exactly what the object looks like in order to use .partial().

Example:
```
private getPartialObjectForSection(fieldConfiguration: FieldConfigurationSection, state: States): { [index:string]: boolean } {
  const requiredFieldsArray = getFieldsForStateOfTypeInSection(fieldConfigSection.fieldConfigurations, state, ValidationType.REQUIRED);
  constAllFieldsForSection = fieldConfigSection.fieldConfigurations.map(configurations => configuration.fieldName);
  const partialFieldsObject: { [index:string]: boolean } = {};

  for (const field of allFieldsForSection) {
    if (!requiredFieldsArray.find(requiredField => field === requiredField)) {
      partialFieldsObject[field] = true;
    }
  }

  return partialFieldsObject;
}
```

then this is followed up in various places with schema.partial(partialFieldsObject)

I know I'm not topping the charts of leetcode anytime soon, but is there an alternative way to achieve this?
",,
2364495562,3589,Request to support 'hostname' string validation,"**Issue:**
I am working on a use case where I need to validate hostname strings before passing them to a database. While Zod supports URL validation, I could not find any built-in support for validating hostnames specifically.

For example, I need to validate strings such as:
```
www.example.com
mail.google.com
```

**Current Workaround:**
Currently, I am using a regular expression to validate hostnames. However, having built-in support in Zod for hostname validation would be more efficient and reliable.

**Request:**
I would like to request the addition of hostname validation support in Zod, this would be beneficial.  If this request makes sense, I am willing to contribute to adding this feature to the library.
",,
2361767931,3587,Changelog.md looks abandoned since version 3.10,"Hi guys,

It would be awesome, if Changelog.md could be updated together with new version releases.
At the moment last record for 3.10 version, it looks kind of abandoned.

Thanks in advance",,
2360831074,3584,Valid union-of-partials data does not parse even though it conforms to one (or more) of the union members,"Consider this example:
```ts
import { z } from ""zod"";

const FooASchema = z.object({
  type: z.literal(""A""),
  a: z.number(),
});

const FooBSchema = z.object({
  type: z.literal(""B""),
  b: z.number(),
});

// const FooSchema = z.union([FooASchema, FooBSchema]);
const PartialFooSchema = z.union([FooASchema.partial(), FooBSchema.partial()]);

const input: unknown = { b: 12 };

const typed = PartialFooSchema.safeParse(input);

console.log(""Input:"", input);
console.log(""Error:"", typed.error);
console.log(""Data:"", typed.data);
```

Here I would expect that `typed.data` would be `{ b: 12 }` since `input` should validate against `FooBSchema.partial()`. However, the actual behavior is (1) no error; and (2) `typed.data` is `{}`.
",,
2359626268,3582,Lowercase ULIDs should be considered valid ULIDs,"Hello everyone.

For a project at work our API uses ULIDs. I noticed Zod comes with a ULID validator built in, however, it always marks our ULIDs as invalid. After a short investigation, I learned that only uppercase ULIDs are considered valid by Zod.

I think the regex Zod uses to check ULID validity, should also allow lowercase ULIDs (or even mix of upper and lower case) as the ULID spec indicates they are [case insensitive](https://arc.net/l/quote/ynqlibva).

The simple workaround we use right now is `z.string().toUpperCase().ulid()` (we used to use `refine()` and a custom validation function), but imo it's not ideal as it affects other validation checks and it might be confusing to other users why lowercase ULIDs are considered invalid. wdyt?

I don't mind working on this myself, as I believe it's just updating the regex to be case insensitive and making sure tests still succeed.",,
2357553169,3579,Generic type function converting property with a default value to optional,"I have written a helper function that allows me to validate FormData objects using Zod. Since this can be used for various schemas, I have used a generic type.

The problem I'm having is, when using the helper function it seems to be turning the properties with default values set in the schemas to optional:

```typescript
export const createUserSchema = z.object({
    name: fullName(),
    email: email(),
    sendEmail: z.boolean().default(true)
});
``` 
![Screenshot 2024-06-17 at 15 39 38](https://github.com/colinhacks/zod/assets/40760694/b6dfeff5-813c-43d8-a5f5-1ee5f281c761)

Here is the code for the validate helper function:
```typescript
export function validate<T>(
    formData: FormData,
    schema: z.ZodSchema<T>
): { validatedData: T; errors: null } | { validatedData: null; errors: ActionErrors<T> } {
    const body = parseFormData(formData);
    const validated = schema.safeParse(body);

    if (!validated.success) {
        return {
            validatedData: null,
            errors: formatZodErrors<T>(validated.error),
        };
    }

    return { validatedData: validated.data, errors: null };
}
``` 

The fact this is being returned with an optional property just doesn't make any sense to me. Any explanation or help would be much appreciated ðŸ˜Š.

Worth noting that if I don't run this through the helper function and parse it directly in the action, it isn't returning as optional which you would expect.",,
2355278508,3577,ZodReadonly missing methods to manipulate schema shape,"Several methods for manipulating the shape of a schema are conspicuously missing just by marking a schema as read-only:

```typescript
import { z } from ""zod"";

export const EDITION = z.enum([""bedrock"", ""java""]);

export const VERSION = z.object({
	id: z.string().uuid(),
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
	edition: EDITION,
	version: z.string(),
	cycle: z.tuple([z.number().nonnegative(), z.number().nonnegative()]),
	releasedOn: z.coerce.date(),
	releaseNotesUrl: z.string().url(),
	isPublished: z.boolean().default(false).optional()
});

export const LATEST_VERSION = VERSION.extend({
	isLatest: z.boolean(),
	isLatestInCycle: z.boolean()
}).readonly();

export const RARITY = z.enum([""common"", ""uncommon"", ""rare"", ""epic""]);

export const ITEM = z.object({
	id: z.string().uuid(),
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
	identity: z.string(),
	wikiUrl: z.string().url(),
	rarity: RARITY.default(""common"").optional(),
	stackSize: z.number().positive().default(64).optional(),
	isRenewable: z.boolean()
});

export const VERSIONED_ITEM = ITEM.and(
	z.object({
		// unrelated, but if there's a better way to rename a property, i'd like to know
		versionId: LATEST_VERSION.shape.id // .shape isn't available because LATEST_VERSION is read-only
	})
)
	.and(
		LATEST_VERSION.pick({ // .pick() isn't available because LATEST_VERSION is read-only
			edition: true,
			version: true,
			cycle: true,
			isLatest: true,
			isLatestInCycle: true
		})
	)
	.readonly();
```

Everything is fine if I remove `.readonly()` from `LATEST_VERSION` and `VERSIONED_ITEM`. However these schemas represent views in the database, so they are inherently read-only. Shouldn't we be able to mark schemas as read-only and still be able to use helpers like `.pick()`, `.omit()` and `.shape`?

---

Edit: formatting",,
2352812477,3573,"If object with nested refine fails, it doesn't apply transform before superRefine, causing superRefine to not be typesafe","Object with nested define doesn't apply transform before superRefine, causing superRefine to not be typesafe.

```typescript
  const res = z
    .object({
      name: z.string(),
      age: z.number().refine((data) => {
        return data > 18;
      }), // Fails refine
    })
    .transform((data) => {
      return {
        userName: data.name,
        userAge: data.age,
      };
    })
    .superRefine((data) => {
      // Data here is { ""name"": ""John"", ""age"": 6 }, Expected { ""userName"": ""John"", ""userAge"":  6} after transformation
      console.log(""superRefine"", JSON.stringify(data, null, 2));
    })
    .safeParse({
      name: ""John"",
      age: 6,
    });
  console.log(res);
```

This parsing should abort early or perform the transformation anyway. Transform isn't applied here.",,
2350572411,3570,safeParse not working server sider with z.union() : Error: Attempted to call indexOf() from the server but indexOf is on the client.,"I am working on a next js app with the directory page system.
I have a folder called [[...options]], which enable to get url segments in the url, more details about that [here](https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#optional-catch-all-segments)

I would like parse the string[] containing the segments with zod server side.

```ts
export const VIEW_OPTIONS = ['day', 'week', 'month', 'year'] as const;

type ViewOption = (typeof VIEW_OPTIONS)[number];
type Segments = ['booking', ViewOption, number, number, number] | [ViewOption, number, number, number];

const calendarOptionsSchema = z.union([
    z.tuple([z.literal('booking'), z.enum(VIEW_OPTIONS), z.number(), z.number(), z.number()]),
    z.tuple([z.enum(VIEW_OPTIONS), z.number(), z.number(), z.number()]),
    z.undefined(),
]);

const extractSegments = (options: Segments) => {
    if (!calendarOptionsSchema.safeParse(options).success) {
        // redirect to 404 page
        notFound();

    }
    // other stuff here
}
```

I get this issue : 

<img width=""983"" alt=""Screenshot 2024-06-13 at 10 48 38"" src=""https://github.com/colinhacks/zod/assets/96651063/6fbb66e0-196e-4679-9375-4f2bf82fbd68"">

I looked on the internet, I have see nothing about this issue.
If you have an idea/an explanation, you are welcome. :)",,
2349068575,3565,[Bug]: ZodFormattedError type breaks for ReadonlyArrays.,"The following TypeScript code gives a compiler error:

```ts
    type Foo = {
      ids: ReadonlyArray<string>;
    };

    const error: ZodFormattedError<Foo> = {
      _errors: [],
      ids: { _errors: [] },
    };
```

The error:

```
[Filename]: error TS2322: Type '{ _errors: never[]; }' is not assignable to type 'ZodFormattedError<readonly string[], string>'.
  Type '{ _errors: never[]; }' is missing the following properties from type 'readonly ({ _errors: string[]; } | undefined)[]': length, concat, join, slice, and 26 more.

85       ids: { _errors: [] },
         ~~~

[Filename]:
    80       ids: ReadonlyArray<string>;
             ~~~
    The expected type comes from property 'ids' which is declared here on type 'ZodFormattedError<Foo>'
```

The weird thing is if I change my type `Foo` to use an `Array` instead of a `ReadonlyArray` the error goes away. This works:

```ts
    type Foo = {
      ids: Array<string>;
    };

    const error: ZodFormattedError<Foo> = {
      _errors: [],
      ids: { _errors: [] },
    };
```",,
2348136656,3564,How to use discriminatedUnion with multiple conditions?,"I need to create a model to apply schema with multiple conditions. For example

Parent type

- event
- webinar

Sub event type

- group
- round_robin

But I am unable to merge it in add it in `discriminatedUnion[]` and getting TS error. Any suggestion?

```
const eventSchema = z.discriminatedUnion('event_type', [
  oneOnOneSchema,
  groupEventSchema,
]);

export const mainSchema = z.discriminatedUnion('type', [
  eventSchema,
  webniarSchema,
]);

```


![image](https://github.com/colinhacks/zod/assets/6106479/c620d75b-5cd5-4aa9-8c04-83f7f122fb80)


TS error - 

![image](https://github.com/colinhacks/zod/assets/6106479/70ee1b43-73e1-4fe6-95a4-beab86e82627)

",,
2344597909,3562,[Bug ?] Zod union ignoring zod object when fields are z.optional(),"Hi,

Basically, when doing zod objects and doing an union on that, when the second object of the union has optional fields, parsing just ignore it ! Is that normal ? I can't find any information about that. I've came with a solution using discriminatedUnion but that feels a little bit dirty ...

I've created a reproduction environment for replaying the issue  
https://stackblitz.com/edit/typescript-f8ppcz?file=schemas%2FschemaWithDefaultType.ts
```js
import { z } from 'zod';

const say = console.info;

function zod_optional_union_ignored() {
  // ! when one and two are optional,
  const type2 = z.object({
    one: z.number().optional(),
    two: z.number().optional(),
  });

  const type1 = z.object({
    three: z.number().optional(),
  });

  const type2or1 = z.union([type1, type2]);

  const test_data = {
    one: 1,
    two: 2,
  };

  const validatedTestData = type2or1.parse(test_data);

  // ! type2 is ignored, why is that ??
  say('zod optional type2 object ignored', { validatedTestData });

  const test_data2 = {
    three: 3,
  };

  // type1 is parsed correctly
  const validatedTestData2 = type2or1.parse(test_data2);
  say('zod optional type1 object not ignored', { validatedTestData2 });
}

function zod_union_not_ignored() {
  const type2 = z.object({
    one: z.number(),
    two: z.number(),
  });

  const type1 = z.object({
    three: z.number(),
  });

  const type2or1 = z.union([type1, type2]);

  const test_data = {
    one: 3,
    two: 2,
  };

  const validatedTestData = type2or1.parse(test_data);

  // type2 is parsed correctly here, certainly because there is no optional
  say('zod optional ingored', { validatedTestData });
}

zod_optional_union_ignored();
zod_union_not_ignored();

```
![image](https://github.com/colinhacks/zod/assets/77932724/e6490799-8d58-459e-94ff-1343ecf7d2bf)




",,
2344338171,3561,Does anyone know how to conditionally validate form fields?,"I've been using Zod for about 2 weeks now and I spend way more time googling how to do stuff.

I'm implementing basic form functionality yet Zod feels like it makes it 1000 times more difficult than it needs to be.

I have a form that contains
- start date
- end date
- checkbox (I currently work here)

I want to make the end date required only when the checkbox is false. I am using `react-hook-form` + `zod`. Can anyone help?",,
2342463351,3560,Documentation example for recursive types gives type error,"# Issue
Type hints made for recursive types `z.lazy( ... )` make all properties optional. I made a minimal reproducible example repo with the example of recursive types given [in the documentation](https://zod.dev/?id=recursive-types) and this error is present.

## Error Output
```
Type 'ZodObject<extendShape<{ name: ZodString; }, { subcategories: ZodLazy<ZodArray<ZodType<Category, ZodTypeDef, Category>, ""many"">>; }>, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<Category, ZodTypeDef, Category>'.
  Types of property '_type' are incompatible.
    Type '{ name?: string; subcategories?: Category[]; }' is not assignable to type 'Category'.
      Type '{ name?: string; subcategories?: Category[]; }' is not assignable to type '{ subcategories: Category[]; }'.
        Property 'subcategories' is optional in type '{ name?: string; subcategories?: Category[]; }' but required in type '{ subcategories: Category[]; }'. ts(2322)
```
## tsconfig.json
```json
{
	""compilerOptions"": {
		""outDir"": ""dist"",
		""declaration"": true,
		""target"": ""ES6"",
		""module"": ""CommonJS"",
		""moduleResolution"": ""Node10""
	}
}
```
## Example
https://github.com/alligatorjazz/recursive-error",,
2341785499,3559,Feature Request: Autoscroll to Input Field on Validation Error,"#### Description

I would like to propose a new feature for the Zod library: autoscrolling to the input field when a validation error occurs. This enhancement aims to improve user experience by automatically directing users to the specific form field that has failed validation, thereby reducing confusion and enhancing usability.

#### Motivation

When a form submission fails due to validation errors, especially in lengthy forms, users often find it challenging to identify which specific field contains the error. Implementing an autoscroll feature would address this issue by smoothly scrolling the user to the erroneous input field and focusing on it. This makes the error more visible and the form more user-friendly.

#### Proposed Implementation

1. **Modify the `ZodError` class**: Add a new method to handle the autoscroll functionality.
2. **Scroll to First Error**: On validation failure, scroll to the first erroneous input field and focus on it.
3. **Integration with Form Libraries**: Ensure compatibility with popular form handling libraries like `react-hook-form`.

Here is a conceptual example of how the method might look:

```typescript
export class ZodError<T = any> extends Error {
  issues: ZodIssue[] = [];

  // Existing methods...

  // New method to scroll to the first error
  scrollToError(form: HTMLFormElement) {
    if (this.issues.length === 0) return;

    const firstIssue = this.issues[0];
    const fieldName = firstIssue.path.join(""."");
    const input = form.querySelector(`[name=""${fieldName}""]`);

    if (input) {
      input.scrollIntoView({ behavior: ""smooth"" });
      (input as HTMLInputElement).focus();
    }
  }

  // Existing methods...
}
```

#### Request for Guidance and Authorization
I am very interested in contributing this feature to the Zod library. I would appreciate any guidance or suggestions on how to best implement this feature according to the project's standards. Additionally, I would like to request authorization to proceed with developing this feature.",,
2341530420,3558,Recursive types losing types and get `any`,"Hi everyone,

I'm trying to represent some HTML tags and the `div` can contain children tags, but `div` loses its type and becomes `any`.

The types I want with Typescript:

```ts
type H1 = { _tag: ""h1"", id: string }
type H2 = { _tag: ""h2"", id: string }
type H3 = { _tag: ""h3"", id: string }
type Div = { _tag: ""div"", id: string, children: Tag[] }

type Tag = H1 | H2 | H3 | Div
```

The types with Zod:

```ts
const h1 = z.object({ _tag: z.literal(""h1""), id: z.string() })
const h2 = z.object({ _tag: z.literal(""h2""), id: z.string() })
const h3 = z.object({ _tag: z.literal(""h3""), id: z.string() })
const div = z.object({ 
  _tag: z.literal(""div""), 
  id: z.string(), 
  children: z.lazy(() => z.array(tag)) 
})

const tag = z.lazy(() => z.union([h1, h2, h3, div]))
type Tag = z.infer<typeof tag>
```

ðŸ˜¬ **The errors:**

on `const div` and `const tag`:
```ts
'div' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.ts(7022)

'tag' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.ts(7022)
```

ðŸŒ **The code:**

[Stackblitz](https://stackblitz.com/edit/html-tags-with-zod?file=src%2Fmain.ts) 

ðŸ”Ž **Some links:**

- [Zod.dev docs about recursive types (using ZodType and not ZobObject ðŸ˜¢)](https://zod.dev/?id=recursive-types)
- [Stack Overflow about recursive types (using DiscriminatedUnion)](https://stackoverflow.com/questions/74706608/zod-recursive-type-with-discriminated-union)
- [GitHub issue about recursive types (using ZobObject)](https://github.com/colinhacks/zod/discussions/3004)
",,
2340735497,3553,Add a Real Example of File Upload Validation to Documentation,"**Description**:
We need to add a real example of file upload validation to our project documentation. This will help users better understand how to utilize the file validation functionality in our application.

**Tasks**:
1. Create a code example that demonstrates file upload validation.
2. Describe the checks performed during validation (file size, format, data type, etc.).
3. Add the code example to the appropriate section of the documentation.
4. Ensure the code example is clear and easily adaptable to different use cases.

**Expected Result**:
The documentation should include a section with a real example of file upload validation, providing a detailed description of the validation process and a code example. This will make it easier for users to understand and implement the validation functionality in their projects.",,
2340032800,3552,add `actual` for `invalid_string` error in `.regex()`,"it would be nice to see the actual value when a regex doesn't match rather than having to look at the full object value for the schema that didn't parse

any objections to adding something like this?",,
2339288784,3551,Type Inference not working ,"I am trying to create a simple form schema using zod, and wants to infer the type so that I can get some helpers and autocomplete. However, the process of doing so resulted in this. 

**My Code**
![image](https://github.com/colinhacks/zod/assets/145012063/9d84c4cd-e0ae-460a-a385-a01f7a9619d7)

** Inferred Type** 
![image](https://github.com/colinhacks/zod/assets/145012063/79b5ad71-80a7-4d3c-9450-b708270cd6e1)


Any advice as to why this is happening? I am using 3.23.8
",,
2337081357,3548,Zod refine is not working ,"I have tried this two method of refine, but both of  it are not working.

![image](https://github.com/colinhacks/zod/assets/169644815/5bf3e009-35c0-40f3-8e38-35d3304fa0b9)
",,
2336546592,3547,Strip checks and effects,"Given a schema with many checks and/or effects, I need to be able to parse an object without using any of the checks or effects.  Take the following contrived schema
```
const schema = z.object({
  name: z.string().nonempty().max(6).refine((val) => val !== 'bob'),
  hobbies: z.object({ name: z.string().nonempty() }).array().min(1),
});
```
The schema is defined, I don't want to re-write it. I don't want to have to declare a base schema without checks/effects and extend it with checks/effects. I want to strip the checks and effects so that the resulting schema looks like this
```
const schema = z.object({
  name: z.string(),
  hobbies: z.object({ name: z.string() }).array(),
});
```

I've tried doing this manually, but I can't strip the checks and effects without modifying the original schema. I would have to be able to deep clone the schema. My hacky attempt looks like this
```
function stripChecksAndEffects<TSchema extends ZodTypeAny>(schema: TSchema): TSchema {
  if (schema instanceof ZodEffects) return stripChecksAndEffects(schema._def.schema);
  if (schema instanceof ZodArray)
    return z.array(stripChecksAndEffects(schema.element)) as unknown as TSchema;
  if (schema instanceof ZodObject) {
    let dictionary = z.object({});
    for (const [key, value] of Object.entries(schema.shape)) {
      dictionary = dictionary.extend({ [key]: stripChecksAndEffects(value as any) });
    }
    return dictionary as unknown as TSchema;
  }
  if (schema._def.innerType) {
    schema._def.innerType = stripChecksAndEffects(schema._def.innerType);
  }
  if (schema._def.checks) schema._def.checks = [];
  return schema;
}

const strippedSchema = stripCheckAndEffects(schema)
```
While this does successfully strip the checks and effects, the input schema is also modified. Hence the need for a deep clone method. Alternatively, it would be even better if, similar to `.deepPartial`, there were methods like `.stripEffects` and `.stripChecks` that could provide this functionality.

My particular use case is letting me validate unkown json to set default form data. As long as the unkown json is in the correct shape, the validation would pass and the form populated. The more important and complex validation wouldn't occur until the form is submitted.",,
2336253905,3546,Required key inferred as optional in mutually recursive tree structure,"Hello! We're working on a project that involves modeling something akin to a generic mutually recursive expression tree with Zod. Here's a simplified example:

```typescript
import { z } from 'zod';


export type AndNode<TBase> = {
  type: 'and',
  children: Tree<TBase>[],
};

export type OrNode<TBase> = {
  type: 'or',
  children: Tree<TBase>[],
};

export type NotNode<TBase> = {
  type: 'not',
  child: Tree<TBase>,
};


export type Tree<TBase> =
  | TBase
  | AndNode<TBase>
  | OrNode<TBase>
  | NotNode<TBase>;

function treeOf<
  TBaseSchema extends z.ZodTypeAny,
>(
  baseSchema: TBaseSchema,
): {
  AndNode: z.ZodType<AndNode<z.infer<TBaseSchema>>>,
  OrNode: z.ZodType<OrNode<z.infer<TBaseSchema>>>,
  NotNode: z.ZodType<NotNode<z.infer<TBaseSchema>>>,
  Tree: z.ZodType<Tree<z.infer<TBaseSchema>>>,
} {
  let Tree: z.ZodType<Tree<z.infer<TBaseSchema>>>;

  const AndNode = z.object({
    type: z.literal('and'),
    children: z.lazy(() => Tree.array()),
  });

  const OrNode = z.object({
    type: z.literal('or'),
    children: z.lazy(() => Tree.array()),
  });


  const NotNode = z.object({
    type: z.literal('not'),
    child: z.lazy(() => Tree),
  });

  Tree = z.union([
    baseSchema,
    AndNode,
    OrNode,
    NotNode,
  ]);

  return {
    AndNode,
    OrNode,
    NotNode,
    Tree,
  };
}
```

This example fails to type check because `NotNode` doesn't satisfy the return type:
```
Type 'ZodObject<{ type: ZodLiteral<""not"">; child: ZodLazy<ZodType<Tree<TypeOf<TBaseSchema>>, ZodTypeDef, Tree<TypeOf<TBaseSchema>>>>; }, ""strip"", ZodTypeAny, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }, { [k_1 in keyof baseObjectInputType<...>]: baseObjectInputType<...>[k_1]; }>' is not assignable to type 'ZodType<NotNode<TypeOf<TBaseSchema>>, ZodTypeDef, NotNode<TypeOf<TBaseSchema>>>'.
  Types of property '_type' are incompatible.
    Type '{ [k in keyof addQuestionMarks<baseObjectOutputType<{ type: ZodLiteral<""not"">; child: ZodLazy<ZodType<Tree<TypeOf<TBaseSchema>>, ZodTypeDef, Tree<TypeOf<TBaseSchema>>>>; }>, any>]: addQuestionMarks<...>[k]; }' is not assignable to type 'NotNode<TypeOf<TBaseSchema>>'.
      Property 'child' is optional in type '{ [k in keyof addQuestionMarks<baseObjectOutputType<{ type: ZodLiteral<""not"">; child: ZodLazy<ZodType<Tree<TypeOf<TBaseSchema>>, ZodTypeDef, Tree<TypeOf<TBaseSchema>>>>; }>, any>]: addQuestionMarks<...>[k]; }' but required in type 'NotNode<TypeOf<TBaseSchema>>'.ts(2322)
test.ts(33, 3): The expected type comes from property 'NotNode' which is declared here on type '{ AndNode: ZodType<AndNode<TypeOf<TBaseSchema>>, ZodTypeDef, AndNode<TypeOf<TBaseSchema>>>; OrNode: ZodType<...>; NotNode: ZodType<...>; Tree: ZodType<...>; }'
```

It seems like the inferred type for `NotNode` types `child` as optional, which it should not be. I've seen issues similar to this reported here before and for the most part, they've been solved by enabling strict mode, but that doesn't seem to work here.
Here's the `tsconfig.json` I'm using for this example:

```json
{
    ""compilerOptions"": {
        ""strict"": true,
    }
}
```

and the `package.json`:
```json
{
    ""dependencies"": {
        ""zod"": ""^3.23.8""
    },
    ""devDependencies"": {
        ""typescript"": ""^4.8.4""
    }
}
```

I've also tried constraining `TBaseSchema`, e.g `TBaseSchema extends z.ZodType<object>`. This doesn't seem to affect anything.

Is there something incorrect about the way this is being modeled?",,
2334796390,3544,"object.props ""required"" but z.infer<T> returns  ""optional"" type?","deps:
typescript@4.9.4
zod@3.23.8

code:
<img width=""466"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/14211764/228e391b-1a1f-4018-b1a7-30aec76826fa"">

ps: the ""parse"" & ""safeParse"" method works well",,
2325439267,3537,Zod Preprocess returning unknown type,"The type returned from [z.preprocess](https://zod.dev/?id=preprocess) is giving out type `unknown`

```
export const string_validation = z.preprocess(
  (value) => {
    if (typeof value !== 'string') return value;
    return value.trim().replace(/\s\s+/g, ' ');
  },
  z.string().min(1)
);

export const boolean_validation = z.preprocess((bool) => {
  if (typeof bool === 'boolean') return bool;
  return bool === 'true';
}, z.boolean());

export const number_validation = z.preprocess(
  (num) => (!num && num !== 0 ? num : Number(num)),
  z.number()
);
```

It's annoying but don't use preprocess in too many places so for now fixing by setting the type explicitly

```
// Before
export const string_validation: .ZodEffects<z.ZodString, string, unknown>
export const boolean_validation: z.ZodEffects<z.ZodBoolean, boolean, unknown>
export const number_validation: z.ZodEffects<z.ZodNumber, number, unknown>

// After
export const string_validation: .ZodEffects<z.ZodString, string, string>
export const boolean_validation: z.ZodEffects<z.ZodBoolean, boolean, boolean>
export const number_validation: z.ZodEffects<z.ZodNumber, number, number>
```",,
2324674610,3536,Importing `infer` type makes all props `unknown`?,"I'm having an issue where I have one package to define Zod schemas and types, and I import those types in other packages. The issue I'm having is that the exported `type` drops all property types and makes them unknown.

```ts
// refresh.ts - exported package
import { GrantType } from '@/types/GrantType';
import z from 'zod';

export const refreshTokenParams = z.object({
  refresh_token: z.string(),
  scope: z.string().optional(),
  client_id: z.string(),
  grant_type: z.literal(GrantType.RefreshToken),
});
export type RefreshTokenParams = z.infer<typeof refreshTokenParams>;
```

Importing the type where is its needed results in all property types being wiped away:
![image](https://github.com/colinhacks/zod/assets/17836372/d5b14aea-aa1d-4d6a-9b9e-33465da0ea99)

If I take the exact same Zod schema and type and declare them in the package where I am importing them, the type information is persisted. I feel like this is something to do more with TS typings than Zod, but I've hit a wall with how to move forward.

*edit*
It appears my issue is due to using a an `enum` type within `z.literal`. Changing this to a regular string fixes type-inference, but then I lose the ability to reference my source enum for the value. This is further complicated because I'm using these types as part of a discriminatedUnion, with the enum values being used as the discriminator.",,
2319031009,3534,Is it possible to create a zod enum from a string literal type,"What zod fn should I use to make the BarSchema valid?

```ts
type Foo = 'foo' | 'bar'; // generated

interface Bar {
 foo: Foo,
 id: string,
}

export const BarSchema = z.object({
  foo: z.enum(Foo), // what should this be?
  id: z.string()
}) satisfies z.ZodSchema<Bar>;

```

I know I can redefine the Foo type like:
```
foo: z.enum(['foo', 'bar'])
```

But the point is not to redefine the generated types.
",,
2316958544,3532,How make field optional but have minimal character,"I want field optional or non required but if it is not blank then it minimal 3 character, and if it is blank then permitted

I have do this
```
z.string().min(field.min, {
                message: `${field.label} must be at least ${field.min} characters.`,
}).optional();
```

But, if field empty, appear warning ""must be at least 3 characters"" :(

I have do with nullable, nullish but still same error",,
2316587607,3529,Descriptions from root schema carry over to schemas created with a chained `.array()`,"Related to changes made in #1756.

The above PR addresses an issue where descriptions would not carry over to schemas created using the chaining helper methods, like `.optional()`.

```typescript
// Before the above changes
z.string().describe(""a description"").description // ""a description""
z.string().describe(""a description"").optional().description // undefined

// After
z.string().describe(""a description"").description // ""a description""
z.string().describe(""a description"").optional().description // ""a description""
```

The changes to fix this issue were also applied to `.array()`, which results in some unexpected behavior.

```typescript
// With this bug,
z.string().describe(""a description"").array()
// is equivalent to:
z.string().describe(""a description"").array().describe(""a description"")
// but this works as expected
z.array(z.string().describe(""a description""))
```

The fix was super simple, I'll open a PR shortly!",,
2315753434,3527,zod safeparse not working with nextjs server action useFormState hok,"Im using zod for velidation, the form doesnt send correct data to server action function. it always returns **invalid fields**

This is form component:

```ts
'use client';

import * as z from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import {
	Form,
	FormControl,
	FormField,
	FormItem,
	FormLabel,
	FormMessage,
} from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { loginFormInput } from '@/constants/form';
import Link from 'next/link';
import { loginSchema } from '@/validators/auth.schema';
import FormError from '../feedback/FormError';
import FormSuccess from '../feedback/FormSuccess';
import { loginAction } from '@/actions/auth/login.action';
import { useSearchParams } from 'next/navigation';
import { FaArrowLeft } from 'react-icons/fa';
import Submit from '../buttons/submit';
import { useFormState } from 'react-dom';

const LoginForm = () => {
  const [formState, formAction] = useFormState(loginAction, {
    error: '',
    success: '',
  });

  const searchParams = useSearchParams();
  const urlError =
    searchParams.get('error') === 'OAuthAccountNotLinked' &&
    'Please sign in with the same account you used originally.';

  const form = useForm<z.infer<typeof loginSchema>>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: '',
      password: '',
    },
  });

  return (
    <>
      <Form {...form}>
        <Link href={'/login'}>
          <FaArrowLeft size={20} />
        </Link>

        <form action={formAction} className=""flex flex-col gap-4"">
          {loginFormInput.map((data) => (
            <FormField
              key={data.id}
              control={form.control}
              name={data.name}
              render={({ field }) => (
                <FormItem>
                  <FormLabel>{data.label}</FormLabel>
                  <FormControl>
                    <Input
                      className=""border-none bg-slate-100 py-6 shadow-none""
                      type={data.type}
                      placeholder={data.placeholder}
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          ))}
          <Link
            className=""text-right text-sm font-semibold text-slate-500 hover:underline""
            href={'/forgot-password'}
          >
            Forgot Password?
          </Link>
          <FormError message={formState.error || urlError} />
          <FormSuccess message={formState.success} />
          <Submit title=""Login"" loadingTitle=""Logging In..."" />
        </form>
      </Form>
    </>
  );
};

export default LoginForm;
```

This is server action

```ts
'use server';
import { signIn } from '@/auth';
import { getUserByEmail } from '@/data/user';
import { sendVerificationMail } from '@/lib/mail';
import { generateVerificationToken } from '@/lib/tokens';
import { DEFAULT_LOGIN_REDIRECT } from '@/routes';
import { loginSchema } from '@/validators/auth.schema';
import { AuthError } from 'next-auth';
import * as z from 'zod';

interface LoginFormState {
  error?: {};
  success?: {};
}

export const loginAction = async (
  formState: LoginFormState,
  formData: z.infer<typeof loginSchema>,
): Promise<LoginFormState> => {
  const validateFields = loginSchema.safeParse(formData);
  if (!validateFields.success) return { error: 'Invalid Fields!' };

  const { email, password } = validateFields.data;

  const existingUser = await getUserByEmail(email);

  if (!existingUser || !existingUser.email || !existingUser.password) {
    return { error: 'Email doesnt exist!' };
  }

  if (!existingUser.emailVerified) {
    const verificationToken = await generateVerificationToken(
      existingUser.email,
    );
    await sendVerificationMail(
      verificationToken.token,
      verificationToken.email,
      existingUser?.name as string,
    );
    return { success: 'Confirmation email sent' };
  }

  try {
    await signIn('credentials', {
      email,
      password,
      redirectTo: DEFAULT_LOGIN_REDIRECT,
    });
  } catch (error) {
    if (error instanceof AuthError) {
      switch (error.type) {
        case 'CredentialsSignin':
          return { error: 'Invalid credentials' };

        default:
          return { error: 'Something went wrong' };
      }
    }
    throw error;
  }
  return { success: 'Email sent successfully!' };
};

```


This is schema
```ts
export const loginSchema = z.object({
	email: z.string().email({ message: 'Must be a valid email' }),
	password: z.string().min(3, {
		message: 'Password is required',
	}),
});

```",,
2315701366,3526,Add a .precision(number) option to numbers which checks the number of digits after the decimal point,"- Add a `.precision(min, max)` option to numbers which passes only if the number of digits after the decimal point is between the two arguments.
- It'll also support negative numbers.
- The default value of min will be 1 so if only one argument was inserted, it is inferred to be the max value.
- If no values are inserted, the default value of max is to be decided by the maintainers.
- The reason I'm not proposing a `.min()` and `.max()` to the `.precision()` option is the conflict that will arise with the current `.min()` and `.max()` options for numbers. 
- An option for rounding the inserted number to the desired precision is to be considered, maybe with an option in the function itself.

- For example:
```ts
const schema1 = z.number().precision(2, 5);
schema1.parse(23.766); // pass
schema1.parse(-1234.9); // fail
schema1.parse(4976.3479023); // fail

const schema2 = z.number().precision(,3);
schema2.parse(-12.34); // pass 
schema2.parse(34.1234) // fail
schema2.parse(68.0000) // I think it should fail
```
- Note: This option won't be allowed to be used with `.int()`.
- Note: It is similar to `Joi.precision()` but with the addition of a range instead of only an Upper bound.

@colinhacks I think it would be a nice addition and lead to some users changing to zod for validating their numbers.",,
2315651266,3525,infer literal in discriminatedUnion fails typecheck but not parse,"I want to typecheck the object before parsing it to validate it.
But the type generated from a discriminatedUnion does not seem to match the zod parse() result.

```TypeScript
const myUnion = z.discriminatedUnion(""status"", [
  z.object({ status: z.literal(""success""), data: z.string() }),
  z.object({ status: z.literal(""failed""), error: z.instanceof(Error) }),
]);

const data = { status: ""success"", data: ""yippie ki yay"" };

type TypeFromSchema<T> = T extends ZodType<infer U> ? U : never;

function test<T extends ZodType>(data: TypeFromSchema<T>, schema: T) {
  return myUnion.safeParse(data); // works
}

const result = test(data, myUnion);  // typecheck fails
```
Result:
```
Argument of type '{ status: string; data: string; }' is not assignable to parameter of type '{ status?: ""success""; data?: string; } | { status?: ""failed""; error?: Error; }'.
  Type '{ status: string; data: string; }' is not assignable to type '{ status?: ""success""; data?: string; }'.
    Types of property 'status' are incompatible.
      Type 'string' is not assignable to type '""success""'.
```
Expected result:

I'm probably wrong here but I would expect no type errors. Having the type of status be a literal too and not a string.

[codesandbox.io](https://codesandbox.io/p/devbox/zod-playground-forked-z6v6np?workspaceId=1308f168-9fd5-4b3a-895b-efe2385373cb&layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522cln3s5wur00073b6hpvdyzdd7%2522%252C%2522sizes%2522%253A%255B51.07255520504731%252C48.92744479495269%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522cln3s5wur00033b6h80ute5zp%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522cln3s5wur00053b6h90wtxxns%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522cln3s5wur00063b6h1y81405t%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B61.68772109412797%252C38.31227890587203%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522cln3s5wur00033b6h80ute5zp%2522%253A%257B%2522id%2522%253A%2522cln3s5wur00033b6h80ute5zp%2522%252C%2522tabs%2522%253A%255B%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.ts%2522%252C%2522id%2522%253A%2522cln3s60zq002v3b6hm2cfn9qk%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fpackage.json%2522%252C%2522id%2522%253A%2522cln3sh8u0007x3b6g1r8nttu6%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%255D%252C%2522activeTabId%2522%253A%2522cln3s60zq002v3b6hm2cfn9qk%2522%257D%252C%2522cln3s5wur00063b6h1y81405t%2522%253A%257B%2522id%2522%253A%2522cln3s5wur00063b6h1y81405t%2522%252C%2522activeTabId%2522%253A%2522clwkqp34l004a2e68qnlkq5vd%2522%252C%2522tabs%2522%253A%255B%257B%2522type%2522%253A%2522UNASSIGNED_PORT%2522%252C%2522port%2522%253A2222%252C%2522id%2522%253A%2522clwkqp34l004a2e68qnlkq5vd%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522path%2522%253A%2522%252F%2522%257D%255D%257D%252C%2522cln3s5wur00053b6h90wtxxns%2522%253A%257B%2522id%2522%253A%2522cln3s5wur00053b6h90wtxxns%2522%252C%2522activeTabId%2522%253A%2522clwkrgaeu00ng2e68yf4b5xw9%2522%252C%2522tabs%2522%253A%255B%257B%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522start%2522%252C%2522id%2522%253A%2522clwkrgaeu00ng2e68yf4b5xw9%2522%252C%2522mode%2522%253A%2522permanent%2522%257D%252C%257B%2522id%2522%253A%2522clwkssdtf00wx2e68yyub9301%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TERMINAL%2522%252C%2522shellId%2522%253A%2522clwkssdvq000xdkey8fsnbbjm%2522%257D%255D%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)",,
2314555785,3522,Usage of .nonstrict() which is deprecated instead of .passthrough() in some tests,"### Just a small cosmetic fix
![×¦×™×œ×•× ×ž×¡×š 2024-05-24 135937](https://github.com/colinhacks/zod/assets/124673921/39eed78d-9801-4a3b-8881-6e53720bbb03)
![image](https://github.com/colinhacks/zod/assets/124673921/332fdf11-bd32-4992-87a1-df0a0971d1f7)
![image](https://github.com/colinhacks/zod/assets/124673921/df15eaf5-12d7-434a-b1c0-8ac6be8c5636)

",,
2314548228,3521,"literal uses `\""` in error message","It seems a bit strange to me that the error message for a literal contains `\""` rather than using a single quote, or another option

```typescript
const testSchema = z.object({
  foo: z.literal('bar'),
});

const testData = { foo: 'badval' };
testSchema.parse(testData);
```
![image](https://github.com/colinhacks/zod/assets/93682696/28982910-2a6b-4184-aefa-52c9a40c65c8)
its especially ugly in api responses (at least imo) 
![image](https://github.com/colinhacks/zod/assets/93682696/4247beea-615c-4c2a-a79c-2a04f16fcc2c)

also compared to enums, which use `'`
```typescript
const testSchema = z.object({
  foo: z.enum(['bar', 'baf']),
});

const testData = { foo: 'badval' };
testSchema.parse(testData);
```
![image](https://github.com/colinhacks/zod/assets/93682696/766fdd3a-a221-44bb-9798-dc6bfad1710a)
",,
2313903548,3520,`#cache` private field in ZodEnum makes it incompatible with Proxy,"Hi,

first I want to emphasize, that I am no expert in JS/TS land and very new to Zod too - I just learned about those private fields today, lol!

In https://github.com/colinhacks/zod/pull/2659, the private field `#cache` was added to ZodEnum.

I am using Vue 3, which uses Proxies to implement [reactivity](https://vuejs.org/guide/extras/reactivity-in-depth.html).
On top, I am using `vee-validate` library, that has [zod support](https://vee-validate.logaretm.com/v4/integrations/zod-schema-validation/) to validate form fields based on Zod schemas.

Just bumped from `3.22.5` to `3.23.X` and noticed some of our form views got broken. 

Seems it is the combination of having ""dynamic schema"" and using `z.enum` - dynamic schema here being that we change the format of zod schema based on conditions X, and using the Vue's reactivity system that new schema is updated to `vee-validate`, which basically does `parse` calls with the form values against the full schema.

The error we are seeing is:
```
 index.mjs:531 Uncaught (in promise) TypeError: Cannot read private member from an object whose class did not declare it
     at __classPrivateFieldGet (index.mjs:531:1)
     at Proxy._parse (index.mjs:3481:1)
     ...
```

So it blows when it tries to access the `#cache` field. 

I _think_ in this case the schema is somehow wrapped as Proxy and thats why we are seeing this error - will try to dig a little deeper in upcoming days... It might be that we are Doing Something Wrong and there is a way to avoid the Proxy behavior, but that needs little bit more understanding atm ðŸ˜ƒ 

There seems to be more depth discussion about private fields vs Proxies [here](https://github.com/tc39/proposal-class-fields/issues/106), with some [workaround examples](https://es.discourse.group/t/a-simple-way-to-implement-protected/1110) on managing `this`.

Nevertheless, maybe I just wanted to make sure, if using the private field was a weighed decision, or if use case like this Vue example might lead to some improvements so that Proxy cases might be supported...? I was trying to checkout the `src/types.ts`, but did not find any other usages of private fields.

Thanks for any inputs, that might help me to learn more about these topics! ðŸ™‚ Props for your efforts so far!",,
2313856208,3519,Zod Async Refine always returning false,"Hello,

I am trying to validate a form with an async request to a server route that works fine when tested on its own, however, in the zod validation always returns false.

I am trying to prevent user from attempting to register with an email that has already been taken, and so validating email inside a nuxtui form by calling this async server route. 

testing the server route  works just fine and return expected true or false
`http://localhost:3000/user/is_email_available?email=er.ttt@gmail.com` returns true or false as expected
but for some reason always returns false in the zod schema validation. 


```
const schema = z.object({
  tenant_name: z.string({ required_error: ""Business Name is required"" }).
    min(2, { message: ""Must be at least 2 characters"" }).
    refine(async (val) => await tenantSlugAvailable(slugify(val)), (val) => ({ message: `${val} is not available` })),
  email: z.string({ required_error: ""Business Email is required"" }).email({ message: ""Invalid email address"" }).
    refine(async (val) => { await useFetch('user/is_email_available', { query: { email: val } }) }, (val) => ({ message: `${val} is not available` })),
  password: z.string({ required_error: ""Password is required"" }).min(8, { message: 'Must be at least 8 characters' }),
  confirmPassword: z.string({ required_error: ""Password Confirmation is required"" }).min(8, { message: 'Must be at least 8 characters' })
}).refine((values) => values.password === values.confirmPassword,
  {
    message: ""Passwords must match!"",
    path: [""confirmPassword""],
  }
);
```

Please can someone take a look and show me what I am doing wrong? have spent a day on this already and not making any headway.

Thanks",,
2311873985,3517,ZodFormattedType does not include the fields in TypeScript,"## Description
The `zodError.format()` method is of type `ZodFormattedError`. The `ZodFormattedError` seems to be:
```TypeScript
{
  _errors: string[]
}
```
even though it has types for all the particular fields in the object:
```TypeScript
{
  name: { _errors: string[]; };
  iso2: { _errors: string[]; };
  iso3: { _errors: string[]; };
  _errors: string[]
}
```
which should be reflected in TypeScript.

## Code snippet
```TypeScript
try {
    newCountry = CountryCreateSchema.parse(await request.formData());
} catch (e) {
    logger.info('[database-example] Invalid form data: ', e);
    return fail(400, {
        message: 'Invalid form data',
        errors: e instanceof ZodError ? e.format() : null
    });
}
```

## Potential workaround
Create a custom generic type:
```TypeScript
type ZodErrorObject<T> = {
	[P in keyof T]: {
		_errors: string[];
	};
} & { _errors: string[] };
```
and cast your formatted error:
```TypeScript
(e.format() as ZodErrorObject<CountryCreateSchema>)
```

or, use `error.flatten()` which seems to work as expected: https://zod.dev/ERROR_HANDLING?id=flattening-errors

## Version
- TypeScript: 5.0.0
- Zod: 3.23.8",,
2311692068,3516,Zod error always blank in latest version of Chrome,"I am using Zod inside Redux Toolkit Query to validate fetched data.

In the latest version of Chrome, the Zod error is always blank (only in this use-case).

Browser that isn't working as expected:
- Chrome 125.0.6422.77 (arm64, macOS)

![Screenshot 2024-05-22 at 8 02 28â€¯PM](https://github.com/colinhacks/zod/assets/10248395/f3acdfcf-8de1-4644-bfa7-6f27f71f5b55)

Browsers that work as expected:
- Chrome 124.0.6367.209 (arm64, macOS)
- Safari 17.4.1 (19618.1.15.11.14)

![Screenshot 2024-05-22 at 8 02 38â€¯PM](https://github.com/colinhacks/zod/assets/10248395/ed537a56-003b-4168-b7d7-0f97a194304d)

Minimal reproduction:
https://github.com/agusterodin/zod-error-not-appearing-in-chrome-bug/tree/main",,
2310791562,3512,IPv6 validation error,"IPv6 validation fails when the last two parts of the IPv6 are compressed, both when one or both are omitted. It does not happen if it is any other part. I have checked the regex you use in https://github.com/colinhacks/zod/blob/1247caf58d1c189155bd04c068be1c758ab77c1c/src/types.ts#L613 and I have also checked it in external tools and the zod behavior is reproduced.

```ts
const ip = '2001:4888:50:ff00:500:d::';
const schema = z.string().ip();
const { success } = schema.safeParse(ip); // false
```

```ts
const ip = '2001:4888:50:ff00:500:d:0:0';
const schema = z.string().ip();
const { success } = schema.safeParse(ip); // true
```

```ts
const ip = '2001:4888:50:ff00::d:0:0';
const schema = z.string().ip();
const { success } = schema.safeParse(ip); // true
```",,
2310445555,3510,Unable to pass `z.ZodType` as argument to `merge`,"Hi all,

Following the advice for circular references, I've built this schema for a table-of-contents in the sphinx-external-toc Python package:
```typescript
import { z } from 'zod';

const TOCTreeOptions = z
  .object({
    caption: z.string(),
    hidden: z.boolean(),
    maxdepth: z.number(),
    numberted: z.boolean(),
    reversed: z.boolean(),
    titlesonly: z.boolean(),
  })
  .partial();

const FileEntry = z.object({
  file: z.string(),
  title: z.string().optional(),
});

const URLEntry = z.object({
  url: z.string(),
  title: z.string().optional(),
});

const GlobEntry = z.object({
  glob: z.string(),
});

/** Basic TOC Trees **/
type NoFormatSubtreeType = z.infer<typeof TOCTreeOptions> & {
  entries: z.infer<typeof NoFormatEntry>[];
};
const NoFormatSubtree: z.ZodType<NoFormatSubtreeType> = TOCTreeOptions.extend({
  entries: z.lazy(() => NoFormatEntry.array()),
});

type NoFormatShorthandSubtreeType = {
  entries: z.infer<typeof NoFormatEntry>[];
  options?: z.infer<typeof TOCTreeOptions>;
}
const NoFormatShorthandSubtree: z.ZodType<NoFormatShorthandSubtreeType> = z.object({
  entries: z.lazy(() => NoFormatEntry.array()),
  options: TOCTreeOptions.optional(),
});

const NoFormatHasSubtrees = z.object({
  subtrees: NoFormatSubtree.array(),
});

const NoFormatEntry = z.union([
  FileEntry.merge(NoFormatShorthandSubtree),
  FileEntry.merge(NoFormatHasSubtrees),
  FileEntry,
  URLEntry,
  GlobEntry,
]);

const NoFormatTOCBase = z.object({
  root: z.string(),
  defaults: TOCTreeOptions.optional(),
});

const NoFormatTOC = z.union([
  NoFormatTOCBase.merge(NoFormatShorthandSubtree).strict(),
  NoFormatTOCBase.merge(NoFormatHasSubtrees).strict(),
  NoFormatTOCBase.strict(),
]);
```

This fails on the calls to `merge` that pass `NoFormatShorthandSubtree` as an argument. 

I can understand why this fails (`ZodType` _isn't_ `ZodObject`), but is there a way to solve this using `merge`?

In my specific case, I can probably drop the `strict` requirement, and thus use `and` instead of `merge`, but it's not ideal!",,
2305439570,3505,Wrong default branch in github actions files,"According to the contribution guide : https://github.com/colinhacks/zod/blob/3156ccac0f38f9f13b43b89af69f4f3defc98e74/CONTRIBUTING.md?plain=1#L3

`main` is now the default branch, so `master` needs to be replaced in workflows files.

see: https://github.com/colinhacks/zod/blob/3156ccac0f38f9f13b43b89af69f4f3defc98e74/.github/workflows/test.yml#L6

I can open a PR if needed.",,
2305120639,3504,is not assignable to parameter of type 'AnyZodObject'.   Types have separate declarations of a private property '_cached',"We have this custom function

```ts
import type { Handler, NextFunction, Request, Response } from 'express';
import type { AnyZodObject, ZodError, ZodIssue } from 'zod';

import type { Logger } from '../logger/logger';

export interface ZodErrorResponse {
  success: false;
  error: {
    code: number;
    message: 'Invalid body, query or params';
    zodError: ZodIssue[];
  };
}

/**
 * Returns a function to validate request against Zod-defined schema
 * @param schema - Zod-defined schema
 * @param logInstance - Instance of Logger class
 * @param handler - Name of handler for logging purposes
 * @returns A middleware handler to validate requests
 */
export const validate =
  (schema: AnyZodObject, logInstance: Logger, handler: string): Handler =>
  async (req: Request, res: Response<ZodErrorResponse>, next: NextFunction) => {
    try {
      await schema.parseAsync({
        body: req.body as unknown,
        query: req.query,
        params: req.params,
      });
      next();
    } catch (error) {
      logInstance.errorRequest(handler, error, req, 400);

      const zodError = error as ZodError;
      res.status(400).send({
        success: false,
        error: {
          code: 400,
          message: 'Invalid body, query or params',
          zodError: zodError.issues,
        },
      });
    }
  };
```

However when I try to use it it says

```bash
Argument of type 'ZodObject<{ query: ZodObject<{ roleId: ZodOptional<ZodNumber>; hirerId: ZodOptional<ZodNumber>; page: ZodOptional<ZodNumber>; pageSize: ZodOptional<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to parameter of type 'AnyZodObject'.
  Types have separate declarations of a private property '_cached'

```

I'm not sure what does _cached mean?",,
2304134012,3502,coerce.date() is not respected by safeParse,"We have a schema:

```js
z.object({
  created_at: z.string().datetime().pipe(z.coerce.date())
})
```

and data:

```js
{ created_at: '2024-05-17T01:08:19.550454Z' }
```

If call `.parse`, the `created_at` field is converted to `Date`, which is correct, but if call `.safeParse`, the `created_at` is still a string.",,
2304115485,3501,Add public API introspection of the element schema for `z.ZodSet`,"Currently, `z.ZodSet` lacks any public API to access the schema of the set elements. I'm not sure if any is an oversight, but it would be a great addition.

Currently `z.ZodArray`, `z.ZodRecord`, and `z.ZodMap` all support such features. Doesn't seem to be too great an ask for a similar feature for `z.ZodSet`.",,
2304114637,3500,Add runtime introspection of the constructor provided to `z.instanceof`,"# Introduction

When using other tooling with Zod, it would be great if that tooling could introspect the schema for `z.instanceof` to determine the constructor that was provided to it. This would allow such tooling to act on that constructor in many ways; for example, a serialization library may want to support some instances of certain built-ins for which Zod does not have dedicated schema factories.

# Solution

Create a dedicated `z.ZodInstanceOf` class to handle `instanceof` validation. Add a `ctor` or other appropriate name to store a reference to the constructor or class. Note that `constructor` cannot be used as it would collide with the existing shape of the prototype of any instance.

# Rational

Currently, `z.instanceof` creates a schema via `z.custom` which is just a `superRefine` against `z.ZodAny`. This eliminates any data that could be used for introspection since non is passed on to the `z.ZodAny`. Creating a dedicated class for the `instanceof` schema would allow introspection of the what constructor it was created with.

# Caveat

Changing current implementation of `z.instanceof` could be a major breaking change, but it is also likely very little of the tooling community built around Zod really does much with `z.ZodAny` in relation to custom schema since introspection is very limited. This could be a Zod v4 feature where breaking changes are expected.",,
2301698042,3498,Website Redesign ?,Hey are you planning  to redo the website ? ,,
2300229850,3496,3.22.5 exists on npmjs but not on github,"Hi. Thanks for all the great work on zod. I noticed that 3.22.5 exists on npm, but does not have a tag or release here on github. ",,
2299428307,3495,Can't chain transform then default,"I have the following code:

```typescript
const schema = z.unknown().transform(() => {
    return undefined
}).default(1);

const value = schema.parse(undefined);

if (value !== 1) {
    throw new Error(`Expected value to be 1, got ${ value }`)
}
```

This gives me the error:

```typescript
Uncaught Error: Expected value to be 1, got undefined
```

Shouldn't the default() catch the unknown value here?",,
2297407746,3491,lazy doesn't compile when used with default,"here is example from tutorial, but with added field with default:
```
const baseCategorySchema = z.object({
  name: z.string(),
  val: z.number().default(0),
});

type Category = z.infer<typeof baseCategorySchema> & {
  subcategories: Category[];
};

const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
  subcategories: z.lazy(() => categorySchema.array()),
});
```
Compiler complains
```
Type 'ZodObject<extendShape<{ name: ZodString; val: ZodDefault<ZodNumber>; }, { subcategories: ZodLazy<ZodArray<ZodType<Category, ZodTypeDef, Category>, ""many"">>; }>, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<Category, ZodTypeDef, Category>'.
  Types of property '_input' are incompatible.
    Type '{ name: string; subcategories: Category[]; val?: number | undefined; }' is not assignable to type 'Category'.
      Type '{ name: string; subcategories: Category[]; val?: number | undefined; }' is not assignable to type '{ name: string; val: number; }'.
        Types of property 'val' are incompatible.
          Type 'number | undefined' is not assignable to type 'number'.
            Type 'undefined' is not assignable to type 'number'.ts(2322)
```
I believe this is valid case",,
2294797767,3489,"[FEAT] add ""afterRefine"" method","Let's say i have schema like this:

```typescript
const validationSchema = z.object({
  name: z.string().min(1),
  lowerBound: z.number(),
  upperBound: z.number(),
});
```

i want to check if ""upperBound"" is greaterThan ""lowerBound""

current solution (as far as i understood from searching) is to do something like this:
```typescript
const baseSchema = z.object({
  name: z.string().min(1),
});
const extendedSchema = baseSchema.extend({
  lowerBound: z.number(),
  upperBound: z.number(),
}).refine((item) => baseSchema.safeParse(item) && item.upperBound > item.lowerBound);
```

i want to have method which will do ""current checks"" and will allow me to add my own on top, like this:
```typescript
const validationSchema = z.object({
  name: z.string().min(1),
  lowerBound: z.number(),
  upperBound: z.number(),
}).afterRefine((item, result) => result && item.upperBound > item.lowerBound);
```",,
2290810057,3486,multipleOf acts wrong starting with 7 decimal places,"If you want to enforce a max amount of decimal places you can use `multipleOf()`. If you want to enforce a max amount of 3 decimal places you can use `multipleOf(0.001)` which works perfectly fine. 
- 2.234 / 0.001 = 2234 :white_check_mark:
- 2.2345 / 0.001 = 2234.5 :bangbang:

So while this works up to 6 decimals (`multipleOf(0.000001)`) fine, it stops working with 7 decimals and above. To make it parse with 7 decimal places and above, the number to parse must contain exactly the amount of decimal places as specified in multpleOf.A small showcase:

```
  const number3 = 5.123;
  const number6 = 5.123456;
  const number7 = 5.1234567;
  const number8 = 5.12345678;
  let schema6 = z.number().multipleOf(0.000001);
  let schema7 = z.number().multipleOf(0.0000001);
  console.log(schema6.parse(number3));  // OK
  console.log(schema6.parse(number6));  // OK
  console.log(schema6.parse(number7));  // Error --> OK
  console.log(schema6.parse(number8));  // Error --> OK
  console.log(schema7.parse(number3));  // Error --> Bug
  console.log(schema7.parse(number6));  // Error --> Bug
  console.log(schema7.parse(number7));  // OK
  console.log(schema7.parse(number8));  // Error --> OK
```

The bug happens because of how JavaScript handles complex numbers. Zods internal function floatSafeRemainder tries to parse its parameter. While it works fine with 0.000001, it stops working fine with 7 and more decimals because then step becomes 1e-7 instead of 0.0000001 and the parsing logic stops working.

![grafik](https://github.com/colinhacks/zod/assets/4688427/7955417b-d1a9-4898-ba24-cd025fcd70f8)

A possible fix which accounts exponential representation of complex numbers could be the following drop-in replacement logic for stepDecCount:

```
    let stepDecCount = (step.toString().split(""."")[1] || """").length;
    if(stepDecCount === 0 && /\d?e-\d?/.test(step)) {
      stepDecCount = step.toString().match(/\d?e-(\d?)/)[1];
    }
```
Seems to work fine for me.....
",,
2290641546,3485,Intersection of object and record fails if function is used as a value for both,"I want to replicate the following type in zod:
```typescript
{
  foobar: () => {},
  [key: string]: () => {} | string
}
```

I believe something like the following should do it:
```typescript
z.object({
  foobar: z.function(),
}).and(
  z.record( z.union([ z.function(), z.string() ]) )
)
```

And indeed that pattern does work fine if you replaced `z.function()` with something like `z.number()`:
```typescript
const schema = z.object({
  foobar: z.number(),
}).and(
  z.record( z.union([ z.number(), z.string() ]) )
)

// Succeeds!
schema.parse({ foobar: 100, test: 42 })
```

But unfortunately this does not work with `z.function()`:
 ```typescript
const schema = z.object({
  foobar: z.function(),
}).and(
  z.record( z.union([ z.function(), z.string() ]) )
)

// Fails with error ""invalid_intersection_types: Intersection results could not be merged"" :(
schema.parse({ foobar: () => {}, test: () => {} })
```

**My understanding/best guess of why it's failing:**
When ZodIntersection is passed it calls the [mergeValues function](https://github.com/colinhacks/zod/blob/ca42965df46b2f7e2747db29c40a26bcb32a51d5/src/types.ts#L3245C10-L3245C21) which determines that `foobar` is a key shared in both `a` and `b`. Because of this it will then [recursively call mergeValues on the values of the `foobar` property from both `a` and `b`](https://github.com/colinhacks/zod/blob/ca42965df46b2f7e2747db29c40a26bcb32a51d5/src/types.ts#L3262). In the case above where `z.number()` is used this will succeed because the number `100` from both `a` and `b` will `===` each other and thus [the merge will be marked as valid](https://github.com/colinhacks/zod/blob/ca42965df46b2f7e2747db29c40a26bcb32a51d5/src/types.ts#L3252). But in the case of `z.function()` both `a.foobar` and `b.foobar` are considered different objects (since it looks like zod creates a different object wrapped around the original `() => {}` object or something like that, I'm not really sure) and thus they are not consided equal and will fail.

Thanks for reading and for such an extremely useful library!",,
2290160738,3484,New Restriction in .pick()/.omit() restrict using of dynamic property in the object,"Here I am trying to pick only the necessary schema field inside the zod object, and parse it.
```typescript
  const { watch,  } = useForm<FormSchemaType>({
    resolver: zodResolver(formSchema),
  });

React.useEffect(() => {
    const subscription = watch((value, { name }) => {
      if (name) {
        const newValue = value[name as keyof FormSchemaType] as string;
        const validate = formSchema
          .pick({ [name]: true })
          .safeParse({ [name]: newValue }).success;

        if (validate) {
          // The required field is validated
        }
      }
    });
    return () => subscription.unsubscribe();
  }, [watch]);
``` 

This was working fine for me in ```v3.22.x``` but not in ```v3.23.x```.
```typescript
 .pick({ [name]: true })
``` 
This particular line is now throwing me error that ```Argument of type '{ [x: string]: boolean; }' is not assignable to parameter of type 'Exactly<{ field1?: true | undefined;.....}>```

I'm guessing this has to do with the changes made in https://github.com/colinhacks/zod/pull/3255.",,
2289895544,3482,"Using .default with z.object doesn't do anything, and neither does .required  if z.object has defaults","Hi, thanks for the great library.

I am to have two version of a schema, one with the fields optional and default values, the other with all fields required.

If I start from the optional version...

```js
var allOptionals = z.object({
  hero: z.string().default(""rick""),
  sidekick: z.string().default(""morty""),
})
var allRequired = allOptionals.required();

allRequired.parse({});
// expected: error
// actual: { hero: ""rick"", sidekick: ""morty"" }
```

and if I start from the required version

```js
var allRequired = z.object({
  hero: z.string(),
  sidekick: z.string(),
})
var allOptionals = allRequired.default({
  hero: ""rick"",
  sidekick: ""morty"",
});

allOptionals.parse({});
// expected: { hero: ""rick"", sidekick: ""morty"" }
// actual: error
```

How can I add a bunch of defaults to a `z.object` in one go, without definiing them individually? (I get them from an api call)

EDIT: I am aware of .transform and .refine, but they return a ZodEffect and not a ZodObject. I also need to use those schemas in .merge. I could use sourceType or innerType but it still doesn't come our right. 

Thanks",,
2289888683,3481,Looking for a way to reuse the same schema with `.merge`,"Hi,
Hope you're fine!

I would like some guidance here, because I did not find any answer through multiple researches, and it is maybe a bug. I would like to know if I'm doing wrong or if a bug is  likely to be suspected here or inside nestjs/swagger

Here are my schemas:

```typescript
// Some utils I would like to reuse

export const stringToDateString = z
	.string()
	.refine(val => !Number.isNaN(Date.parse(val)), {
		message: 'Invalid datetime string',
	})
	.transform(val => new Date(val).toISOString());

export const dateToDateString = z.date().transform(date => date.toISOString());

export const dateToDatelike = z.union([stringToDateString, dateToDateString]);

export const startAndEndDates = z
	.object({
		start_date: dateToDatelike,
		end_date: dateToDatelike,
	})
	.refine(
		({ start_date, end_date }) =>
			isBefore(new Date(start_date), new Date(end_date)),
		{
			message: 'La date de dÃ©but dÃ©passe la date de fin',
		}
	);
	
// ##### Phase schema #####

const base = z.object({
	// Some properties
});

export const PhaseSchema = base.merge(startAndEndDates.innerType());

// ##### Cycle Schema #####

const base = z.object({
	// Some properties
});

export const CycleSchema = base.merge(startAndEndDates.innerType());
```

If I'm doing this, I'm getting this error:

`Error: A circular dependency has been detected (property key: ""start_date""). Please, make sure that each side of a bidirectional relationships are using lazy resolvers (""type: () => ClassType"").`

This error is generated by `@nestjs/swagger`, but I'm not sure this is related, and I think the root cause is my schema.

It's worth noting that I also tried using `z.lazy()`, according to the mentionned error, in many ways but **without success**.

Is anyone can help here ? It could be interesting to have this kind of usecase directly in the documentation ðŸ˜„ 

Have a nice day",,
2289811109,3480,z.merge not inferring types properly,"The `CombinedType` in this code:

```ts
import { z, ZodObject } from 'zod'

const schema1 =  z.object({ providerId: z.string() })
const schema2 = z.object({ serviceId: z.string() })
const schema3 =  z.object({ date: z.date() })

function combineSchemas<
	T extends ZodObject<any, any, any>,
	U extends ZodObject<any, any, any>,
	V extends ZodObject<any, any, any>,
>(s1: T, s2: U, s3: V) {
	return s1.merge(s2).merge(s3)
}
const CombinedSchema = combineSchemas(schema1, schema2, schema3)
type CombinedType = z.infer<typeof CombinedSchema>
```

is not properly inferring the type. It should be 

```ts
{
  providerId: string;
  serviceId: string;
  date: Date
}
```

But the inferred type is:

```
type CombinedType = {
    [x: string]: any;
    serviceId?: unknown;
    date?: unknown;
}
```

[See Playground](https://www.typescriptlang.org/play/?#code/JYWwDg9gTgLgBAbzgLwDRwFoQCYHkBGAVgKYDG8AvnAGZQQhwDkyOjAUG6RAHYDO8vUgAtiIAIYBGOAF44KAHQQiZGAAokYOgDdg2YlACS2AFwL+UYNwDmqgJRwKtzj35xBI8QCYZCpSXLqbvo6pMRGpsjy5pY29o7OfALComIAzD6+ygFI2GIwxBHyufl2Dk5s1ACu3OTAPHBcIPiWxADKyeK8ADxsAJAAKnDEAB753Ni8mDgE-jBdYtwAnugLy3CrAHyofQCqQ6PE45NYeFlzqytLl4tbfQBq+2MTU6ez81frH5vbG6q8EqZ+uheJ5TDtgalTHd7Ag+lBiDBKlBuG4JPIQPorMQ-p5bOjMdjeKknBQEq4AML0ZrcYjYdoeMQ+RrUtodMS8P5siTAtmeHkM4lsGCLMDEOCUpotbD9EVi2SRSzUfRdYWiiDUcVUqX0lIbNhAA)",,
2286586082,3475,Organizational GitHub Account & Profile,"Hello,

I'd like to put this suggestion on the table if may I.

I suggest to move Zod to a dedicated, organizational GitHub like, so it becomes something like `github.com/zod/zod` or `github.com/zod-org/zod`. I believe this way it can help make the project's size, integrity, marketing, longevity, and ambition up to higher standards.",,
2286136336,3474,Passing `RawCreateParams` to `z.tuple()` doesn't apply to all errors generated by `z.tuple()`.,"Example: 

```example.ts
const schema = z.tuple([z.string(), z.number()], { message: 'this doesnt look right' });
schema.parse([]); 
```
This will throw with a ZodIssue of `{ too_short, 'Array must contain at least 2 elements' }` instead of the supplied message.",,
2285303800,3473,Can not use branded enum options,"Hi team,

Thanks for a great amount of work delivered!

_Not sure if it makes sense to use branded enums at all, but here is my case._

I have met an issue with my types: I am unable to use branded enum's options in TypeScript.

Minimal example:
```
export const AgentStatus = z.enum([""offline"", ""online""]);

console.log(AgentStatus.enum.offline);

export const AgentStatusBrand = z
	.enum([""offline"", ""online""] as const)
	.brand<""AgentStatus"">();

console.log(AgentStatusBrand.enum.offline);
```

The last line gives the error:
```
src/domain/servers.ts:51:30 - error TS2339: Property 'enum' does not exist on type 'ZodBranded<ZodEnum<[""offline"", ""online""]>, ""AgentStatus"">'.

51 console.log(AgentStatusBrand.enum.offline);
```",,
2284324447,3472,Large declaration files for flattened zod schema,"[luluNextData.txt](https://github.com/colinhacks/zod/files/15241501/luluNextData.txt)

When emitting declaration files for a complex nested json the resulting declaration file can end up being quite large. I've shared a schema above generated from a large json (next data from a lululemon page) using https://transform.tools/typescript-to-zod. This results in a 17mb declaration file (.d.ts).

 A quick look at the .d.ts file shows very large const declaraions of the the zod objects. Anything I can do to reduce this file size? If naively doing this as a human I could just modify the zod schema into an interface/type and avoid declaring the large consts, as the declaration files for inferred types don't need the zod context. 

This is in a typescript project with the following tsconfig settings

```
{
  ""compileOnSave"": true,
  ""compilerOptions"": {
    ""declaration"": true,
    ""declarationMap"": true,
    ""composite"": true,
    ""downlevelIteration"": true,
    ""experimentalDecorators"": true,
    ""incremental"": true,
    ""lib"": [""esnext""],
    ""module"": ""commonjs"",
    ""moduleResolution"": ""node"",
    ""noErrorTruncation"": true,
    ""noImplicitReturns"": true,
    ""noUnusedLocals"": true,
    ""skipLibCheck"": true,
    ""sourceMap"": true,
    ""strict"": true,
    ""target"": ""esnext""
  }
}
```",,
2282741076,3468,Inability to retrieve keys from z.nativeEnum type,"Hello,

I am using zod to work with TypeScript enums and have encountered an issue when trying to retrieve the keys from an enum using `z.nativeEnum`. The `z.nativeEnum` function does not seem to provide a method to retrieve the keys of the enum, unlike the standard TypeScript keyof type operator.

Here's an example illustrating the issue:
```ts
// Definition of SomeEnum using TypeScript
enum SomeEnum {
    PNG = 1,
    APNG = 2,
    Lottie = 3,
    GIF = 4,
};

// Attempt to use keyof on SomeEnum directly
type SomeEnumKeyof = keyof typeof SomeEnum;  // This works as expected

// Using z.nativeEnum with SomeEnum
const SomeEnumSchema = z.nativeEnum(SomeEnum);

// Attempting to use keyof on z.nativeEnum result
// The following line throws an error because .keyof() method does not exist
const keySomeEnum = SomeEnumSchema.keyof(); // This does not work
```

Could you provide guidance on how to properly retrieve the keys from an enum defined with `z.nativeEnum`? Is there a workaround or a method that I might be missing?

Thank you for your assistance, and apologies for any confusion caused by my language skills.",,
2279676417,3464,Add Search Bar Functionality to zod,"![image](https://github.com/colinhacks/zod/assets/98454866/b5c2fc41-d7be-4b0c-a53e-575f76c36ad7)



We would like to implement a search bar feature in zod web application to enhance user experience and facilitate easier navigation through our content.",,
2278051534,3462,`z.literal` message not customizable,"When I try to customize the message of a `z.literal`, I get the following output:

```js
try {
  z.literal('correct', { message: 'must match' }).parse('incorrect');
} catch (err) {
  console.log('err: ', err);
}

//  err:  ZodError: [
//    {
//      ""received"": ""incorrect"",
//      ""code"": ""invalid_literal"",
//      ""expected"": ""correct"",
//      ""path"": [],
//      ""message"": ""Invalid literal value, expected \""correct\""""
//    }
//  ]
```
when I would expect to get
```js
//  err:  ZodError: [
//    {
//      ""received"": ""incorrect"",
//      ""code"": ""invalid_literal"",
//      ""expected"": ""correct"",
//      ""path"": [],
//      ""message"": ""must match""
//    }
//  ]
```",,
2277970603,3461,Issue with inferring types from pipes.,"Using code that is almost verbatim lifted from docs:
```typescript
const forceNumber = z.union([z.string(), z.number()]).pipe(z.coerce.number())
```
Idea being to accept a number or string, and coerse to string or fail. The function works, unit tests are all fine, but type inference falls over like so:

```typescript
const forceNumber = z.union([z.string(), z.number()]).pipe(z.coerce.number())

const dataSchema = z.object({
  numberOrString: forceNumber,
})

type Data = z.infer<typeof dataSchema>

// parse any data into schema or fail
const parseSchema = <U>(data: any, schema: z.ZodType<U>): U => {
  return schema.parse(data)
}

// log Data
const logSchemaData = (data: Data) => {
  console.log(data)
}

function processDataAndLog(data: any) {
  const parsedData = parseSchema(data, dataSchema)
  logSchemaData(parsedData)
}

```

this gives us the following error:

![image](https://github.com/colinhacks/zod/assets/196705/a29b0833-870e-4ead-98fd-5ab677c77b6a)
",,
2276642067,3459,zod  a field whose type is jsonLogic.RulesLogic. From type to zod,"Hi.
What the best `zod` function to check for a type `jsonLogic.RulesLogic` [https://github.com/jwadhams/json-logic-js/](https://github.com/jwadhams/json-logic-js/)

I use `type` and would like to derive the `zod` schema from iit.

```ts
export type Permission = {
  actions: string[];
  resources: string[];
  condition: jsonLogic.RulesLogic;
}
```
what should be a schema for this type.

Thanks ",,
2275327844,3456,feat: single method to comine `.unwrap().unwrap()`,"Currently, if you have a schema with both optional and nullable, you have to call unwrap twice in order to get the base type. It would be nice to get it immediately.

I propose adding something like `.nonnullable()` (to match TypeScript's `NonNullable<T>` type) that does this in one shot:

Sandbox: https://stackblitz.com/edit/vitejs-vite-ursctp?file=src%2Fmain.ts",,
2275045560,3455,Reversing nullable on schema,Im using integration that calls nullable on produced schemas. I tried using required() on produced schema but it doesn't do anything.,,
2269477931,3452,question: can I generate a zeroed out object from a schema with validation?,"Hey I'm trying to find out if I can generate an object with zero values using a zod schema with validation. Anyone ever tried this? (If this is an anti-pattern please let me know)

Let's say I have this schema
```ts
const fooSchema = z.object({
  foo: z.string().default('')
})
```

I could use `fooSchema.parse({})` and generate the default object for this schema
```ts
const defaultObj = fooSchema.parse({}) // { foo: '' }
```

But when adding validation to the schema I can no longer safely use `fooSchema.parse({})` because it throws an error when validating the object.
```ts
const fooSchema = z.object({
  foo: z.string().min(1, 'Foo is required').default('')
})

const defaultObj = fooSchema.parse({}) // throws zod error
```

And rightfully so, this I think is expected behavior. But is there any way I could still use this schema to generate a fulfilled object? Or is it impossible when adding validation to the same schema?",,
2267222416,3451,z.literal with objects,"z.literal should allow objects so it can check that only these objects are allowed with exact match.

```
z.literal([
  { ...props },
  { ...differentProps }
])
```",,
2266834921,3448,Override safeParse and parse behavior at a given key,"I'm looking to implement a Zod schema that supports ""hard"" and ""soft"" type definitions in the same schema with little boilerplate. What I mean by that is combining the behaviors of parse and safeParse in the same schema. 

For example, given a schema 
```
export const simpleSchema = z.object({
  errorIfNotString: z.string(),
  warnIfNotString: z.string(),
});
```

If the parsed object doesn't have a string value for `errorIfNotString` I want to throw an error. If `warnIfNotString` is undefined, number type etc. I want to follow safeParse behavior and return an error message, but not throw. I understand this would be possible right now, I could define two separate schemas and call safeParse for one & parse with the other. However this can get complex for large objects, so I'd prefer an API that is something like the below:

```
export const simpleSchema = z.object({
  errorIfNotString: z.string().assert(),
  warnIfNotString: z.string().warn(),
});
```

The expected behavior would be an override of the called parse method. I.e. if I call parse() on simpleSchema, zod should still not throw an error in the event of mismatch on warnIfNotString. And if I call safeParse zod should still error if errorIfNotString ends up being a mismatch.

Happy to look into this and come back with a PR too, just wanted to get the discussion started!

Some quick things to note:
- the response type likely should always match safe parse if using this approach. It might be simplest to add a third .parse type, i.e. .multiParse that behaves like parse + ",,
2265825455,3446,Huge memory and performance gap between `parse` and `parseAsync`,"Running `parseAsync` instead of `parse` seems to have massive differences in resource consumption for larger objects.

I'd expect some overhead of async operations for sure, however in our production env. and in the benchmark as well the difference is 100x in time consumption and 10x in memory consumption.
Larger objects even OOM the entire node app with `parseAsync` whereas `parse` hovers at around 300mb.

The reproduction of a minimal bench setup can be found here: https://github.com/warflash/zod-async-perf

Tested on 2 machines with node 18 and 20.

Logs:
```
Benchmarking with 1000 elements
Validation time sync: 17.801ms
Validation time async: 36.208ms

Benchmarking with 10000 elements
Validation time sync: 63.467ms
Validation time async: 216.365ms

Benchmarking with 50000 elements
Validation time sync: 305.788ms
Validation time async: 1.778s

Benchmarking with 100000 elements
Validation time sync: 665.208ms
Validation time async: 4.917s

Benchmarking with 150000 elements
Validation time sync: 1.164s
Validation time async: 8.275s

Benchmarking with 200000 elements
Validation time sync: 1.273s
Validation time async: 22.556s

Benchmarking with 250000 elements
Validation time sync: 1.746s
Validation time async: 1:51.280 (m:ss.mmm)
```
",,
2263438517,3442,"Password match validation don't hide error, when input name not mentioned in refine() 'path' has changed","```
export const PasswordSchema = z.object({
  password: z.string(),
  password_confirmation: z.string(),
}).refine(
  (values) => values.password === values.password_confirmation,
  {
    message: 'Error',
    path: ['password_confirmation'],
  }
);```

This scheme is used like an example in docs. But if you: 
1. validate form
2. got error that passwords does not match
3. change ""password_confirmation"" field to valid
Everything is ok, error is gone now.

This scheme is used like an example in docs. But if you: 
1. validate form
2. got error that passwords does not match
3. change ""password"" field to valid
Error remains!",,
2263191309,3441,Zod dealing with image object,"I'm working with react-file-base64 which gives metadata of files such as name, type of files, size, base64 encoding, i registered the zod validation, even though i uploaded the image, zod throws ""image required error"". I cross verified, zod isn't accepting any image object to verify, How to deal with this error.

```ts
interface featured_image_types {
    name: string;
    type: string;
    size: string;
    base64: string
}

 const schema = z.object({
        blog: z.any({ required_error: ""Please enter a blog content, it cannot be empty!!!"" }),
        title: z.string().min(5, { message: ""Title should be atleast minimum 5 characters"" }).refine((val) => console.log(val)),
        reading_time: z.string({ required_error: ""Reading Time required"" }),
        featured_image:  z
        .any()
        // Custom refinement function to log files
        .refine((files) => {
        console.log(files, ""this not rertriviing files here"");
          // Return null to ensure the validation continues
        return true;
        })
        // To not allow empty files
        .refine((files) => files?.length >= 1, { message: 'Image is required.' })
        // To not allow files other than images
        .refine((files) => ACCEPTED_IMAGE_TYPES.includes(files?.[0]?.type), {
        message: '.jpg, .jpeg, .png and .webp files are accepted.',
        })
        // To not allow files larger than 5MB
        .refine((files) => files?.[0]?.size <= MAX_FILE_SIZE, {
        message: `Max file size is 5MB.`,
        }),
        blog_cat: z.string({ required_error: ""Please select one of blog cateogry"" }).min(6, { message: ""Please select one of blog cateogry"" }),
        tags: z.any()
    })
    
<div>
<label className=""block mb-2 text-sm font-bold"" htmlFor=""file_input"">Featured Image</label>

 <FileBase
     type = 'file'
     {...register('featured_image')}
     multiple={false}
     onDone={(file: featured_image_types) => setSomething({ ...something, featured_image: file })}
                            />

    {errors.featured_image && <p className=""text-red-500"">{errors?.featured_image?.message?.toString()}</p>}

                        </div>
                        
                        
// This part return undefined
.refine((files) => {
        console.log(files, ""this not rertriviing files here"");
          // Return true to ensure the validation continues
        })
```
",,
2262720261,3439,Default enum generic,"If you have existing string union types, enum requires both generics to be defined in order to type guard against the input. Example:

```ts
import { z } from 'zod';

type TColors = 'Red' | 'Green' | 'Blue';

// Type error
z.enum<TColors>([""Red"", ""Green"", ""Blue""]);

// Success
z.enum<TColors, [TColors, ...TColors[]]>([""Red"", ""Green"", ""Blue""]);
```

To get around this, the  `createZodEnum`  overrides need a default generic for the second parameter
```ts
function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]> = Readonly<[U, ...U[]]>>(
  values: T,
  params?: RawCreateParams
): ZodEnum<Writeable<T>>;
function createZodEnum<U extends string, T extends [U, ...U[]] = [U, ...U[]]>(
  values: T,
  params?: RawCreateParams
): ZodEnum<T>;
```",,
2260464124,3437,JSDoc hints are lost after using `.extend`,"Once you use `.extend`, any JSDoc hints are lost.

```ts
import { z } from 'zod';

const v1 = z.object({
    /** this works */
    userId: z.string(),
});

const v2 = z.object({
    /** this doesn't */
    itemId: z.string(),
}).extend(v1.shape);

const instance1: z.infer<typeof v1> = {
    userId: '2' // has hint on hover
}

const instance2: z.infer<typeof v2> = {
    itemId: '1',
    userId: '2'
}

```

Playground - https://tsplay.dev/w2oKzN",,
2259264919,3435,"""Type instantiation is excessively deep and possibly infinite."" when using Zod versions 3.23.0 and 3.23.1 together.","We have multiple projects using Zod, and are currently tripping over a compatibility issue between a project which is still on zod 3.23.0 and one which we're attempting to upgrade to 3.23.3.

Consuming the 3.23.0 schemas from 3.23.3 results in the following error, which I've also reproduced between 3.23.0 and 3.23.1.

```
error TS2589: Type instantiation is excessively deep and possibly infinite.
```

Full reproduction [here](https://github.com/kerrigan-nm/zod-type-instantiation-error-replication), with a summary in the readme.",,
2258017923,3434,Type changes in 3.23 breaks some code,"We have a code base, where we've used branded strings for a long time. (before ZodBranded was added).
And to make that work, I believe the recommended way at the time was for them to be cast as `ZodSchema<BrandedStringType>`

We also have a function requiring a ZodObject with a defined Input and Output. (we need the .shape property)
After upgrading to 3.23, what's the best workaround for this, here's an example where the type checking is getting angry:

Exemple:
```typescript
type BrandedString = Branded<string, ""BrandedString"">;
const aBrandedString = z.string() as unknown as z.ZodSchema<BrandedString>;

const helloSchema = z.object({
    name: aBrandedString,
});
type Hello = z.infer<typeof helloSchema>;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const func = (hello: z.ZodObject<any, any, any, Hello, Partial<Hello>>) => {
    // ...
}

const funcResult = func(helloSchema); // this type errors out
```

The call to func doesn't like the helloSchema since 3.23 because it now thinks name of hello could be `{ name?: unknown }`
```typescript
Argument of type 'ZodObject<{ name: ZodType<BrandedString, ZodTypeDef, unknown>; }, ""strip"", ZodTypeAny, { name: string & _BrandedTagged<""BrandedString"">; }, { ...; }>' is not assignable to parameter of type 'ZodObject<any, any, any, { name: string & _BrandedTagged<""BrandedString"">; }, Partial<{ name: string & _BrandedTagged<""BrandedString"">; }>>'.
   Type '{ name?: unknown; }' is not assignable to type 'Partial<{ name: string & _BrandedTagged<""BrandedString"">; }>'.
     Types of property 'name' are incompatible.
       Type 'unknown' is not assignable to type '(string & _BrandedTagged<""BrandedString"">) | undefined'.ts(2345)
``` 


We could get around this by doing something like (to mimic zodtypes/zodschema old behavior (Input = Output):

```typescript
const aBrandedString = z.string() as unknown as z.ZodSchema<BrandedString, ZodTypeDef, BrandedString>;
```

or maybe for convenience:
```typescript
type ZodSchemaOf<T> = ZodSchema<T, ZodTypeDef, T>
const aBrandedString = z.string() as unknown as ZodSchemaOf<BrandedString>;
```

So my question is, what is the recommended way of getting around and solving these new type issues when upgrading to 3.23? (I should perhaps add that the real `func` is generic, and the `Hello` type is passed as a generic type). Is it reverting back to setting Input = Output manually like it was before the best way, or is there a better way to solve this for the future? Maybe there is a better way to accept a type safe ZodObject as a parameter? We could of course switch to AnyZodObject but then we would loose the type safety of the func hello parameter in the example. ðŸ¤” ",,
2255858017,3431,Type changes in 3.23 ,"Hi Colin,

@t3-oss/t3-env has started failing in zod@3.23: https://github.com/t3-oss/t3-env/issues/222

We're not using any internal types which made me think you've unintentionally broken semver for this release?

See the source, we're basically just using ZodType: 
- https://github.com/t3-oss/t3-env/blob/main/packages/core/src/index.ts
- https://github.com/t3-oss/t3-env/blob/main/packages/nextjs/src/index.ts

We're also not really using the ZodType generics, so I don't think that change is relevant here. We're only using ZodType as a constraint",,
2255840310,3430,[Feature Request] store validator function for z.refine,"Hi, thank you for building this powerful validation library~

## Feature Request

Could we store the user-defined validator in somewhere like `schema._def.effect`:

https://github.com/colinhacks/zod/blob/890556e/src/types.ts#L322

## Use case

I'm implementing a [zod-schema-faker](https://github.com/iendeavor/zod-schema-faker) library to generate fake data for zod.

Recently I am trying to support fake data generation for **custom schema (`.custom`)** and **custom validation logic (`.refine`)**, the strategy is to identify the schema/validator and execute user-defined faker to achieve the goal.

For example:

```ts
// user may have this validator:
const validator = (val: string) => val.length <= 255
const schema = z.string().refine(validator, {
  message: ""String can't be more than 255 characters"",
})

// they could generate data by register a custom validator:
function validatorFaker(fakeVal: string): string {
  return fakeVal.slice(0, 255)
}
installRefine(validator, validatorFaker)
const fakeData = fake(schema)
```

Further info about how custom schema to be supported:

```ts
import * as z from 'zod'
import { fake, installCustom, ZodTypeFaker, runFake, install } from 'zod-schema-faker'

const pxSchema = z.custom<`${number}px`>(val => {
  return typeof val === 'string' ? /^\d+px$/.test(val) : false
})

class pxFaker extends ZodTypeFaker<typeof pxSchema> {
  fake(): `${number}px` {
    return `${runFake(faker => faker.number.int({ min: 0 }))}px`
  }
}
install()
installCustom(pxSchema, pxFaker)
const data = fake(pxSchema)
// > '10px'
```

Thank you ðŸ˜„ 
",,
2255789695,3429,Error with `3.23.0` combined with package that uses `3.22.4`,"I am getting this error when using `z` from `3.23.0` with a package that is fixed on `3.22.4`:

```txt
Type 'ZodDefault<ZodNumber>' is not assignable to type 'ZodType<any, ZodTypeDef, any>'.
  The types of '_def.errorMap' are incompatible between these types.
```

When rolling back to `3.22.4` everything works again (with reloading the vscode ts-servers).


This goes for anything, not just `ZodNumber`.
",,
2253316314,3423,Zod validation for fields that are rendered optionally to DOM,"I am using ZOD, react-hook-form, axios in a next js form. I am facing difficulty regarding how to add validation logic to a password, confirm-password field in my form

- they are initially hidden by a boolean state value (this state can be toggled thus adding/removing the 2 password field to DOM)
- if rendered, then they are first required && secondly they should be same naturally
- if not rendered then they are not required


```tsx
type EditProfile = z.infer<typeof editProfileSchema>;


  const {
    control,
    register,
    handleSubmit,
    formState: { errors },
    setValue,
  } = useForm<EditProfile>({
    resolver: zodResolver(editProfileSchema),
  });


  const profileDetailsQuery = useQuery({
    queryKey: [""profile_details""],
    queryFn: getProfileData,
    refetchOnWindowFocus: false,
  });

  const editProfileMutation = useMutation({
    mutationFn: updateProfileData,
    onSuccess: () => {
      toast.success(""Profile edited successfully"", {
        duration: 1800,
      });
      router.replace(""/welcome"");
    },
  });


  const handleFormSubmit = (data: any) => {
    const { [""confirmPassword""]: excluded, ...actual } = data;
    const obj = { ...actual };
    if (croppedImage) {
      obj.profile_image = croppedImage;
    }
    editProfileMutation.mutate({
      profile: {
        ...obj,
      },
    });
  };

  return (
    <>
      <form  onSubmit={handleSubmit(handleFormSubmit)}>
         //...
         <AnimatePresence>
                        {pwdChange && (
                          <motion.div
                            className=""grow""
                            initial={{ scale: 0 }}
                            animate={{ scale: 1 }}
                            exit={{ scale: 0 }}
                            transition={{ duration: 0.3 }}
                          >
                            {/* pwd */}
                            <InputWrapper
                              backgroundColor=""#FECB46""
                              className=""mb-5""
                            >
                              <input
                                type=""password""
                                placeholder=""placeholder""
                                id=""password""
                                className=""input-primary peer h-14 w-full text-sm""
                                {...register(""password"")}
                              />
                              {errors.password && (
                                <p className=""mt-2 text-sm text-red-400"">
                                  {errors.password.message}
                                </p>
                              )}
                              <label
                                htmlFor=""password""
                                className=""label-primary""
                              >
                                password
                              </label>
                            </InputWrapper>
                            {/* confirm pwd */}
                            <InputWrapper backgroundColor=""#FECB46"">
                              <input
                                type=""password""
                                placeholder=""placeholder""
                                id=""confirmPassword""
                                className=""input-primary peer h-14 w-full text-sm""
                                {...register(""confirmPassword"")}
                              />
                              {errors.confirmPassword && (
                                <p className=""mt-2 text-sm text-red-400"">
                                  {errors.confirmPassword.message}
                                </p>
                              )}
                              <label
                                htmlFor=""confirmPassword""
                                className=""label-primary""
                              >
                                confirm password
                              </label>
                            </InputWrapper>
                          </motion.div>
                        )}
                      </AnimatePresence>
         //...
      </form>
    </>
  )

```

ZOD schema:


```ts
const editProfileSchema = z
  .object({
  //...

    password: z
      .string()
      .min(8, { message: ""min 8 chars required"" })
      .optional()
      .or(z.literal("""")),
    confirmPassword: z.string().optional().or(z.literal("""")),

   //...
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: ""password do not match"",
    path: [""confirmPassword""],
  });
```




What I did :

- I made them optinal or string, then checked they are equal or not with refine.

But I still think why should ZOD validation be applied something that is not in DOM?


My problems: 

- if i am not making those fields optional, ZOD is not letting me submit the form (I wonder why ? I mean these two inputs  not in DOM, so why validation applied to them ?)
",,
2252888571,3422,ZodError#message cannot deal with circular data structures in its `issues`,"# Example

A Mocha test that shows the issue:

```javascript
/* eslint-env mocha */

const { z, ZodError } = require('zod')

describe('zod', function () {
  it('cannot deal with circular data structures', function () {
    const AnObjectSchema = z.object({ someLiteralProperty: z.literal(1) })

    const cicrularObject = {
      aProperty: 'a property',
      anotherProperty: 137,
      anObjectProperty: { anObjectPropertyProperty: 'an object property property' },
      anArrayProperty: [{ anArrayObjectPropertyProperty: 'an object property property' }]
    }
    cicrularObject.anObjectProperty.cicrularObject = cicrularObject
    cicrularObject.anArrayProperty.push(cicrularObject.anObjectProperty)
    const violatingObject = { someLiteralProperty: cicrularObject }

    const { success, error } = AnObjectSchema.safeParse(violatingObject)

    success.should.be.false()
    error.should.be.an.instanceof(ZodError)
    error.message.should.be.a.String()
  })
})
```

This test fails with

```
TypeError: Converting circular structure to JSON
    --> starting at object with constructor 'Object'
    |     property 'anObjectProperty' -> object with constructor 'Object'
    --- property 'cicrularObject' closes the circle
    at JSON.stringify (<anonymous>)
    at get message [as message] (node_modules/zod/lib/ZodError.js:105:21)
    at Context.<anonymous> (test/00.zodIssue.js:23:11)
    at process.processImmediate (node:internal/timers:478:21)
```

# Analysis

[ZodError.ts](https://github.com/colinhacks/zod/blob/master/src/ZodError.ts), line 283:

```typescript
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
```

`JSON.stringify` is called on `this.issues`. `JSON.stringify` cannot cope with circular data structures. In the example, the circular data structure appears in the  `received` property of the issue.

`jsonStringifyReplacer` does not deal with this either:

[helpers/util.ts#jsonStringifyReplacer](https://github.com/colinhacks/zod/blob/master/src/helpers/util.ts), line 91:

```typescript
  export const jsonStringifyReplacer = (_: string, value: any): any => {
    if (typeof value === ""bigint"") {
      return value.toString();
    }
    return value;
  };
```",,
2251879163,3420,Changelog for 3.22.5,"Hey Colin, was this an accidental release?

I was trying to spot a changelog or a diff but it doesn't look like anything changed? ðŸ˜… 

<img width=""667"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/18017094/002bb6bc-85ab-41a1-b635-577332e49e5e"">
",,
2250912296,3418,Feature Request: Runtime introspection of the output type of a zod schema,"Hi! 

Absolutely love zod, it's the first package I add to any TS project I'm working on.

I'm curious if zod has support / docs / examples of other projects that read schema types at runtime? Is depending on the internals of zod to do this a bad idea?

I'm the maintainer of the [`ERA` relational algebra library](https://newera.dev/). It ships with a runtime relational algebra type checker for type checking queries. I'd like to build a feature in `ERA` that roughly looks like this

```
class Relation {
  /* .. */
   
  compile<T extends z.ZodTypeAny>(zodSchema: T): () => Promise<z.infer<T>[]> {
      // at runtime, the relation class runs ERA typechecker and knows the type of the 
      // output of this sql query. Lets say the query returns rows of the form `{ foo: string | null, bar: number }`
      // I'd like to use `zodSchema` at runtime and make sure it can accept values of that form before
      // actually running the query.
      
      // Conceptual pseudo code
     for (const zodField of zodSchema.something) {
        assert(compatible(zodField, eraTypeCheck[zodField.name]))
     } 
  }
} 
```

Another way this could be accomplished is generating a zod schema from the era types and some sort of `z.implementsOutputOf` 

```
schemaA.implementsOutputOf(schemaB)
``` ",,
2250585258,3417,expose zod schema for parsing errors,"When using zod it can return [various errors](https://github.com/colinhacks/zod/blob/master/src/ZodError.ts) when parsing.

I would be nice if the zod library itself would expose a zod schema for these errors (dogfooding).

This could be very useful when e.g. using zod-openapi to use it as error response schema in a 400/422.

```
import * as z from ""zod"";

..

    responses: {
      200: {
        description: 'OK',
        content: {
          'application/json': {
            schema: PetSchema,
          },
        },
      },
      400: {
        description: 'Invalid request',
        content: {
          'application/json': {
            schema: z
              .object({
                errors: z.array(z.errorSchema), // <-- what is proposed to be exposed by zod
              }),
          },
        },
      },
```",,
2250536631,3416,The 'error' property does not exist in the type 'SafeParseReturnType,"I am trying to make a validator for my Config module  like this:

import { z as zod } from 'zod';

const validationSchema = zod.object({
  NODE_ENV: zod.string(),
  APP_PORT: zod.coerce.number().default(3000),
  DB_HOST: zod.string().min(4),
  DB_PORT: zod.coerce.number(),
  DB_NAME: zod.string(),
  DB_USER: zod.string(),
  DB_PASSWORD: zod.string(),
});

export type EnvVariables = zod.infer<typeof validationSchema>;

export const validate = (config: unknown) => {
  const result = validationSchema.safeParse(config);

  if (!result.success)
    return {
      error: result.error,
    };

  return { value: result.data };
};



![Captura de pantalla 2024-04-18 a las 14 11 53](https://github.com/colinhacks/zod/assets/55498983/6dfaf2e8-c84c-4ac8-90d2-4d6d972a57e6)




But I am getting this error:   Error' property does not exist in type 'SafeParseSuccess<{ NODE_ENV?: string; APP_PORT?: number; DB_HOST?: string; DB_PORT?: number; DB_NAME?: string; DB_USER?: string; DB_PASSWORD?: string; }>'.



Node Version: 20.11.0
Typescript Version: 5.4.5
Zod Version:  3.22.4",,
2249497843,3414,Option for strict objects by default,With deeply nested object `.strict` must be added on every `.object` to check all keys but is easy to forget that. Option should be on `parse` function to check all objects strict by default. Could disable that on a particular object with `z.object().strict(false)`. As example joi allows such option.,,
2247728924,3411,"Email validation fails on ampersand ""&"" sign","Hi there,

I noticed the z.string().email() fails when the email contains an ampersand sign. This should be allowed.

Example:
`z.string().email().parse(""test&test@test.com"")`",,
2247115698,3410,Match only true,"There should be way to match true or false not both with z.boolean(). Example is field that can be a string or the value true. Some examples how it can look

```
z.union([
  z.string(),
  z.enum([true])
])

z.union([
  z.string(),
  z.boolean(true)
])

z.union([
  z.string(),
  true
])
```",,
2247036251,3408,Better errors for wrong schema,"If you use `{}` instead of `z.object({})` you get `TypeError: keyValidator._parse is not a function` which is not clear. There should be understandable error message that says you need `z.object({})` instead of plain object.

Same thing on `z.enum('value', 'value')` there is error `TypeError: array.map is not a function` instead of telling you to wrap it in array like `z.enum(['value', 'value'])`.",,
2246798280,3407,RFC: Faster unions (vs `z.switch()`),"> This is a followup discussion to https://github.com/colinhacks/zod/issues/2106

Okay, I'm glad I didn't rush a `z.switch()` implementation, because I now think there's a better way forward. This is definitely *my own brilliant idea* and not something @gcanti suggested in a Twitter DM.

It's pretty simple, we just...make `z.union()` better. Here's the case for sticking with plain `z.union()`: 

- It's introspectable, unlike `z.switch()`. Code generation tools need a way to enumerate all elements of a union, and that isn't possible with `z.switch()`.
- It hews more closely to TypeScript conceptually (remember, TypeScript has no special concept of a ""discriminated union"")
- Implemented well, it can approach the performance of `z.discriminatedUnion` 

How? The idea is for Zod to do some ""pre-computation"" at the *schema creation time* to make parsing faster. 

- All Zod schemas will implement a `.getLiterals(): Set<Primitive>` method that returns the set of *known literal values* that will pass validation. For something like `z.string()`, this will be undefined (there are infinitely many valid inputs). For something like a ZodEnum or ZodLiteral, this will be a finite set of values. 
  - This method can also be implemented by user-defined subclasses, so this doesn't break extensibility!
- When you create a `z.union()`, Zod uses `getLiterals()` to extract a set of ""fast checks"" for each union element in the form `{[k: string]: Set<Primitive>`. 
- During parsing, Zod will do use these ""fast checks"" to quickly determine if the input has any chance of parsing properly against the schema.
- Ideally in most cases, only one schema will remain after the fast checks. Zod will use that schema to validate the input.
- If multiple union items pass the ""fast check"", the input will be validated against each one in succession (like a regular union). 
- Relatedly: Zod will implement a much-requested `abortEarly` mode to bail out ASAP in the event of validation errors. This mode will speed up ZodUnion performance even if there's no discrimination to be done. This was already on the Zod 4 roadmap but is made even more relevant now.

The API could also accept a ""discriminator hint"" to point the parser in the right direction. 

```ts
z.union([ ... ], {
  discriminator: ""someKey""
})
```

In retrospect, this is what the API always should have been. Discriminated unions are not a type unto themselves, just an optimization over unions, and the API should have reflected that. 


",,
2246246537,3406,how to validate external types,"is there a way in zod to validate external types not directly managed within my project?

in the example below I use a langgraph type to generate my own type. What I would like to do is create a zod schema to validate MyType.

```typescript
import { RunnableLike } from ""@langchain/core/runnables"";

export MyType = RunnableLike<string, number>
```",,
2246191167,3405,Error using .time(),"I'm trying to validate the date and time, but when I use .time() I get this error. Is there any alternative to using .time() to validate the time?

```js
export const appointmentSchema = z.object({
  clientHashId: z.string({ required_error: 'Client ID is required' }),
  employeeHashId: z.string({
    required_error: 'Employer ID is required',
  }),
  appointmentDate: z.coerce.date(),
  appointmentTime: z.string().time(),
})
```

**Error:** _The 'time' property does not exist in the 'ZodString' type._

To validate the date/time I'm using date-fns in the form submit, but could it be validated in zod as well or not necessarily?

Thank you in advance for your help.",,
2245476816,3404,How to merge a ZodEffect with a ZodObject,"I receive a type error saying that the first schema is of type ZodEffects, is there a way to infer the underlying object?

",,
2245294852,3402,Show failing value,"`parse` function shows errors like this but we can't see the failing value but it should be part of the error.

```
{
    ""code"": ""too_small"",
    ""minimum"": 5,
    ""type"": ""string"",
    ""inclusive"": true,
    ""exact"": false,
    ""message"": ""String must contain at least 5 character(s)"",
    ""path"": [
      ""path""
    ]
}
```",,
2242909683,3399,FEATURE REQUEST: verboseErrors to log out the object when parsing fails,"please give me an ability to globally enable to console error the whole object which failed validation. Currently it logs out only the validation error like this:

```Uncaught ZodError: [
  {
    ""expected"": ""'equals' | 'contains' | 'icontains' | 'javascript' | 'LLM'"",
    ""received"": ""undefined"",
    ""code"": ""invalid_type"",
    ""path"": [
      ""type""
    ],
    ""message"": ""Required""
  }
]

```

every time I am debugging this I typically need to go in and log it out this myself.
Ideal API would be something like

`z.verboseErrors()`

this would apply to both regular and safeParse ideally

",,
2241768683,3396,Issue in making required field optional in ZOD? would you please tell me where is the issue in below code?,"const schema = z.object({
  workType: z.string().min(1, { message: ""Please select work type"" }),
  workSubType: z.string().min(1, { message: ""Please select work sub type"" }),
  workTypeDescriptions: z.string().min(1, { message: ""Please select description"" }),
  radioButtonSelection: z.enum([""Yes"", ""No""], {errorMap: () => ({ message: ""Please select an option"" })}),
  policyNumber: z.string().refine((value , data) => {
      if (data.radioButtonSelection === ""Yes"") {
        return  typeof value === 'string' && value.length >= 7;
      }
      return true;
    }, {message: 'please enter policy number', path:['policyNumber']}).optional(),
});",,
2235770246,3394,parameters and return type validation for functions,"Is there a way in zod to validate a function's parameters and its return type?
In the following example I have defined an object schema.
In the object there is a function that takes two parameters as numbers and returns void.
Then I defined an object in which there is a function that accepts a string and returns a boolean.
As you can see the output of the safeParse is success:true but in reality it is not correct as a result.

```typescript

import * as z from ""zod"";

const obj = {
    fn: (n: string) => { return true; }
}

const schema = z.object({
    fn: z.function(
            z.tuple(
                [
                    z.number(),
                    z.number()
                ]
            ),
            z.void()
        )
})

 // expected {success:false, error: ...}
let result = schema.safeParse(obj);

console.log(result); // received {success:true, data: ...}
```

![image](https://github.com/colinhacks/zod/assets/28861452/f62f9b32-7c26-49f7-8618-bbcb72ffa64a)",,
2234337580,3393,refine() should not inherit type from custom(),"```ts
{
  id: z.string(),
  key: z.custom<""literal string"">().refine(key => typeof key === 'string', {
    message: 'Key must be a string'
  })
}
```

In this schema the type of `key` is `""literal string""` which isn't accurate as really it can be `any` since no validation has narrowed the type ",,
2233389038,3392,schema.safeParse,,,
2231287818,3389,z.string().email() allows invalid emails with a comma,"It seems that the zod validation for email is allowing commas through which does not match the RFC 5322 standards. 

I'm on version `3.22.4`

To reproduce ([playground link](https://stackblitz.com/edit/typescript-k85yrc?file=index.ts)):
```typescript
import { z } from 'zod';

const myschmea = z.object({
  email: z.string().email(),
});

const test = {
  email: 'test,dumb@company.com',
};

const parse = myschmea.safeParse(test);

console.log(parse);

const appDiv: HTMLElement = document.getElementById('app');
appDiv.innerHTML =
  `<h1>TypeScript Zod Playground<br>` + JSON.stringify(parse) + `</h1>`;
```

Workaround - Disable typing of commas into input fields",,
2229878299,3387,`z.string().date` is not a function,"I just installed zod version `3.22.4`. 

I'm trying to create a validator for an ISO8061 date string (`YYYY-MM-DD`). According to [the docs](https://zod.dev/?id=iso-date-time-amp-datetime-validation), this can be done as follows:

> The `z.string().date()` method validates strings in the format `YYYY-MM-DD`.

However, the date() method doesn't seem to exist on the object returned by `z.string()`.

## Steps to reproduce

```typescript
const { z } = require(""zod"")
const dateSchema = z.string().date();
```

My IDE yields a TypeScript error on the above code:

> TS2339: Property `date` does not exist on type `ZodString`

Also, when I run the code, an error is thrown:

> TypeError: z.string(...).date is not a function

This can be verified on runkit: https://runkit.com/embed/ph6clqi91sj2

Screenshot below for reference.

![image](https://github.com/colinhacks/zod/assets/3456755/c92ca6e6-4fe5-4e5b-ae69-ac42ec6b771e)

## Workaround

I'm using the `refine` method as a workaround

```typescript
z.string().refine((str: string) => {
  return (
    /^\d{4}-\d{2}-\d{2}$/.test(str) &&
    new Date(str).toISOString().startsWith(str)
  );
});
```",,
2228416001,3383,z.union allow ZodType array spread as argument,"I am attempting to use a dynamically generated array of strings to define a `z.union()` that validates that a string is included within said dynamic array.

To do this I am mapping each element of my dynamic array of strings to `z.literal()`, and then spreading this mapped array of literals to the union type.

```typescript
import { z } from ""zod""
const TILES = [""a1"",""a2"",""a3"",""b1"",""b2"",""b3""]

// ERROR:
// Argument of type 'ZodLiteral<string>[]' is not assignable to parameter of type 'readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
// Source provides no match for required element at position 0 in target.ts(2345)
const myUnion = z.union([
    ...TILES.map(tile => z.literal(tile))
])
```

This implementation results in typescript kicking up a fuss, as it is not sure that union has been provided any values. This is because zod's `union` type is hardcoded to have *atleast 2* ZodTypes provided to it. 
```typescript
declare const unionType: <T extends readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(types: T, params?: RawCreateParams) => ZodUnion<T>;
```

This means to prevent typescript from complaining, *2* literals must be hardcoded before we spread our array of literals into the union.
```typescript
const myUnion = z.union([
    z.literal(""a1""),
    z.literal(""a2""),
    ...TILES.map(tile => z.literal(tile))
])
```
This is evidently not ideal as we may not have two values which we always wish to be included in our union type.

Is there any way `z.union()` could be re-typed / changed in some way to better support spreading of ZodType arrays? ",,
2227803549,3382,ignore,,,
2225868609,3379,Support .empty(),"Can something like https://joi.dev/api/#anyemptyschema be added? It turns any value into undefined if it matches. `z.string().empty(""empty"")` would make `""empty""` become `undefined`.",,
2225250621,3378,[Feature] Add phone number parsing,"The idea is using a zod schema like
z.string().phone()
and let parse any phone number format valid world-wide.",,
2223057428,3376,`.parse()` and `z.output` does make `.optional().default()` undefined even tho it is always defined,"Consider the following:

```
export const catSchema = z.object({
  name: z.string().default('cat').optional(),
});

export type Cat = z.output<typeof catSchema>;
```

The name is `string | undefined` when using the schema but in the output of `.parse()` or when using `z.output` it is still `string | undefined` even tho it will always be `string` and cant possibly be undefined.",,
2222565160,3374,Alternatives to using strict mode?,"Zod changes its behavior depending on if Typescript is using strict mode.

For example:

```
const User = z.object({
  username: z.string(),
});

type User = z.infer<typeof User>;
```

Non-strict:

```
type User  {
   username?: string
}
```

Strict:

```
type User {
   username: string
}
```

I can't help feel this is unexpected behavior, since field optionality has nothing to do with what mode typescript is running in.


I'm trying to add zod to an existing typescript codebase that doesn't use strict mode. Porting the whole codebase right now would be infeasible.

Is there any way to get the strict type output without having to port my entire codebase over?",,
2222509508,3373,"""validation"" field should be optional on `ZodInvalidStringIssue` type","This is mainly a concern when using superRefine

```js
z.object({ one: z.string(), two: z.string() })
.superRefine((value, context) => {
    if (!value.one && !value.two) {
        context.addIssue({
            code: ZodIssueCode.invalid_string,
            message: 'Need to enter one or two',
            // I do not care what the format of the string is. I only care that a value exists.
            validation: { includes:'' }
        })
    }
});
```
The above example demonstrates why `validation` should be optional.

(Note this is a reduced test case, this one could be converted to a simple `.refine()` but my real world version cannot)",,
2218135584,3372,[Questtion] How do I make a mutually exclusive key?,"I would like to have a config with either a value or an object, but with a name that matches the type - e.g., `userId: z.string()` XOR `userIds: z.object()`. I need exactly one of them to exist, like an XOR of keys. Is there a way I can express this type with zod?

```jsonc
{
    // input can be a single value for all options, or specify a different value for each option
    ""userId"": ""abcd"",
    ""userIds"": {
        ""xyzw"": ""abcd"",
        ""ijk"": ""hjkl""
    }
}
```

I suppose I could wrap the entire thing in a `z.union()`, but that feels pretty unwieldy, especially if/when the number of fields (and thus the number of combinations) explodes:

```js
const schema = z.object({
    myMultiFormThing: z.union([
        z.object({ /* machineId = string, userId = string, groupId = string */ }),
        z.object({ /* machineId = string, userId = string, groupIds = array */ }),
        z.object({ /* machineId = string, userIds = array, groupId = string */ }),
        z.object({ /* machineId = string, userIds = array, groupIds = array */ })
    ])
});
```

Fortunately my config is not that complex yet, and worst case scenario I guess I can live with having the same key name for an object and value, but it would be nice if I can use the correct plurality for the key name.",,
2216905518,3370,OpenTelemetry support,"Hi, is there an opentelemetry instrumentation for the library?
Specially spans for parse and transform.",,
2215030567,3368,Not able to change state inside refine ,"When i try to submit the form at first, the **firstField** doesnot get updated but when i submit the form again, the firstField gets updated. Can i know why i have to resend the form again to get updated state.

```typescript
const formSchema = z.object({
    email_phone: z.string().refine(
      (value) => {
        if (emailRegex.test(value)) {
          setFirstField(""email"");
          return true;
        } else if (phoneRegex.test(value)) {
          setFirstField(""mobile_no"");
          return true;
        } else {
          setFirstField(""email"");
          return false;
        }
      },
      {
        message: ""Please enter a valid email or phone number"",
      }
    ),
  });
``` 
  
  ",,
2210123705,3364,z.union has no `_parseSync` method with bare literals,"I'm getting an error when trying to call parse on a union with primitive literals:

```
const schema = z.union(['a', 'b'])
schema.parse('a') // Throws Error: option._parseSync is not a function
```

Using numbers or booleans gives the same results.

Changing the `union` to an enum or wrapping the literals in `z.literal` fixes the issue.

Zod version 3.22.4",,
2209558506,3363,Branded types inferred improperly by function when inside `ZodObject` passed as `ZodSchema`,"# Description

When passing a `ZodObject` containing a branded type to a function as a `ZodSchema`, the function infers the type of the branded field without the brand(IE turning `foo: string & z.BRAND<'brand'>` into `foo: string`). This means functions which seek to validate using Zod schemas generically are effectively unable to work with branded types.
# Example

```ts
// Should return exactly what it's passed
const schemaId = <T>(schema: ZodSchema<T>) => schema;

const myObject = z.object({ foo: z.string().brand('brand') });
const shouldEqualMyObject = schemaId(myObject); // T inferred as { foo: string } instead of { foo: string & z.BRAND<'brand'> }

type MyObject = z.infer<typeof myObject>; // { foo: string & z.BRAND<'brand'> }
type ShouldEqualMyObject = z.infer<typeof shouldEqualMyObject>; // { foo: string }
```

# Workarounds

Notably, this does *not* occur when `schemaId` takes a `ZodObject` like so
```ts
const schemaId = <T extends ZodRawShape>(schema: ZodObject<T>) => schema;
// ...
type ShouldEqualMyObject = z.infer<typeof shouldEqualMyObject>; // { foo: string & z.BRAND<'brand'> }
```
or when the generic `T` is for the whole `ZodSchema`
```ts
const schemaId = <U extends ZodSchema>(schema: U) => schema;
// ...
type ShouldEqualMyObject = z.infer<typeof shouldEqualMyObject>; // { foo: string & z.BRAND<'brand'> }
```

",,
2209009103,3362,Safeparse doesn't give back the expected data,"### Discussed in https://github.com/colinhacks/zod/discussions/3361

<div type='discussions-op-text'>

<sup>Originally posted by **kapsule-studio** March 26, 2024</sup>
I have a `product` schema, that never returns the `secondaryImages` after the parsing. It gives an empty array whereas it is clear that it isn't empty before parsing. Any help would be greatly appreciated, thanks!

Here is my schema
```typescript
export const ZodProduct = z.object({
  name: z.string().min(1),
  slug: z.string(),
  collections: z.array(
    z.object({
      name: z.string(),
      parent: z.string().nullable(),
      products: z.array(z.string())
    })
  ),
  variants: z.array(
    z.object({
      id: z.string(),
      name: z.string().min(1),
      images: z.object({
        mainImage: z.string(),
        secondaryImages: z.array(z.string())
      }),
      price: z.number().min(0),
      comparedAt: z.number().min(0).optional(),
      weight: z.number().min(0).optional(),
      width: z.number().min(0).optional(),
      height: z.number().min(0).optional(),
      length: z.number().min(0).optional(),
      sku: z.string().min(1).optional()
    })
  )
})
```

Here is my implementation
```typescript 
const product = {
  name: name,
  slug: toSlugFormat(name),
  collections: prodCollections,
  variants: formattedVariants
}

console.log('before', product)

const productValidation = ZodProduct.safeParse(product)
if (productValidation.success) {
  console.log('valid', productValidation.data)
  createProduct(productValidation.data)
}
```

And here are the results

![image](https://github.com/colinhacks/zod/assets/77295465/d4dfb5a2-f895-41c2-9393-f9027fa77e22)

</div>",,
2204098342,3355,`z.string().max()` (and `min()`) don't count unicode characters,"This is more of a feature request than a bug. Currently `string().max()` (and other length validators) count the UTF-16 length of a string rather than the number of unicode characters. The latter can be calculated using `[...value].length` where `value` is the desired string, so a custom transformer can work, but this would probably benefit most users of this library seeing as the length people usually care about in validation is the number of unicode characters (also called Unicode Scalars), not the UTF-16 length.

We could either option this out, e.g. `.max(5, {char: true})`, or use a separate method, e.g. `.charMax(5)`.",,
2204085464,3354,"Safeparse on error return all valid data, any defaults, and the errors","Is there anyway to do this? In my schema, i have conditions and for certain fields default values.

calling safeParse(), I want to return all the errors, as well as the data that parsed successfully, and the data that had default applied.

Otherwise, I cant use safeParse and have to manually set defaults.",,
2202627121,3351,Question: superRefine on nested objects,"Hi, I tried to play around with`.superRefine` to add some custom issues. I found that zod only supports these on the first level of an object schema. Could someone confirm with me that this is true? Or am i missing something?

```
export const AnotherSchema = z.object({
    id: z.string(),
    clientId: z.string(),
});

export const BaseSchema = z.object({
    key1: z.string().superRefine((val, ctx) => {
        ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: 'trouble looking'
        });
    }),
    key2: AnotherSchema,
});
```

if I add 
```
export const BaseSchema = z.object({
    key1: z.string().superRefine((val, ctx) => {
        ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: 'trouble looking'
        });
    }),
    key2: AnotherSchema,
});
```
This works fine. I can see:
```
ZodError: [
      {
        ""code"": ""custom"",
        ""message"": ""trouble looking"",
        ""path"": [
          ""key1""
        ]
      },
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""key2"",
          ""clientId""
        ],
        ""message"": ""Required""
      }
    ]
```
However moving the superRefine to key2's schema won't print out any issues like above.

If this is expected behaviour, how can I make zod to throw a custom issue or error on nested objects then?

Thank you.
",,
2202039163,3350,Question: Is there any way to turn a schema nullable if it has required fields inside?,"Hello everyone! I have a schema like this:

```js
const firstSchema = z.object({
  field1: z.string().required(),
  field2: z.string().required(),
  field3: z.string().required(),
});

const secondSchema = z.object({
  myField: myCondition ? firstSchema : firstSchema.nullable(); // make a schema nullable() doesn't work because it has required fields inside. 
});
```
Is there any chance to make a schema fully nullable and ""override"" the required conditions of it? If not, would you suggest any workaround or ideas?

Thank you for your help! ðŸ’œ",2016100835,"This isn't your question, but there is no `.required()` method in Zod. All schemas are ""required"" unless you make them optional with `.optional()`.

Given that, I'm confused by what the problem is. If you call `.nullable()` on your schema, it will allow `null` no matter what. "
2201475244,3349,Broken overload in `z.record()`.,"There's a bug in the overloads for `z.record()` that lets you to pass in an arbitrary schema as the key schema into `z.record()`...whoops. 

```ts
const schema = z.record(z.object({ name: z.number() }), z.number());
// no TS errors
```

The expected behavior is that the first argument should conform to `type KeySchema = ZodType<string | number | symbol, any, any>;` but it currently doesn't. 

In order to fix it I need to remove the ""single argument"" shorthand: `z.record(z.number)`, which will land in Zod 4.",2014679823,"Did you write it backwards?

<img width=""1551"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/32638462/a51f270f-e07b-41f8-a717-01a51df82c96"">


```js
const User = z.object({ name: z.string() });

const UserStore = z.record(z.string(), User);
```
"
2201475244,3349,Broken overload in `z.record()`.,"There's a bug in the overloads for `z.record()` that lets you to pass in an arbitrary schema as the key schema into `z.record()`...whoops. 

```ts
const schema = z.record(z.object({ name: z.number() }), z.number());
// no TS errors
```

The expected behavior is that the first argument should conform to `type KeySchema = ZodType<string | number | symbol, any, any>;` but it currently doesn't. 

In order to fix it I need to remove the ""single argument"" shorthand: `z.record(z.number)`, which will land in Zod 4.",2016057090,"I did not. The point is that this code should throw an error when I try to pass a `ZodObject` as the key, but it doesn't. 
"
2201475244,3349,Broken overload in `z.record()`.,"There's a bug in the overloads for `z.record()` that lets you to pass in an arbitrary schema as the key schema into `z.record()`...whoops. 

```ts
const schema = z.record(z.object({ name: z.number() }), z.number());
// no TS errors
```

The expected behavior is that the first argument should conform to `type KeySchema = ZodType<string | number | symbol, any, any>;` but it currently doesn't. 

In order to fix it I need to remove the ""single argument"" shorthand: `z.record(z.number)`, which will land in Zod 4.",2080774566,"@colinhacks looks like this could be fixed like this:
```ts
static create<Value extends ZodTypeAny, Params extends RawCreateParams>(
  valueType: Value,
  params?: Params extends ZodTypeAny ? never : Params
): ZodRecord<ZodString, Value>;
```

Not super ideal but it will complain about it will `never` if the 2nd param is a `ZodTypeAny` forcing TS to choose the other overload.

Though if you're removing the single arg variant this would be moot"
2201398114,3348,mark bound methods with `this: void`,hello is it possible to mark the bound methods of `ZodType` and others with `this: void`? maybe with declaration merging or something i'm not sure. linter rules like [this one](https://typescript-eslint.io/rules/unbound-method/) make it cumbersome to pass references to those methods around because they're designed to detect situations where methods get detached from their instance,,
2200250035,3345,Form validation Regex doesn't work on the website app,"When you apply regex custom validation on a form, it works on the admin preview, and the validation array on the field appears to be empty.",,
2198136607,3343,Using discriminatedUnion with nativeEnum,"There is an issue when using `discriminatedUnion` in combination with `nativeEnum`s. (`enum`s work fine.)

I created a playground to reproduce this: https://stackblitz.com/edit/zod-discriminated-union-enums?file=schemas%2FschemaTests.ts

The native enums look like this:
```ts
enum Type1 {
  FirstType = 'firstType',
}
enum Type2 {
  SecondType = 'secondType',
  ThirdType = 'secondType',
}
```
The error message when using them to parse an object with `type: 'firstType'` is:
```
Invalid discriminator value. Expected 'FirstType' | 'SecondType' | 'ThirdType'
```

zod seems to use the enum **keys** instead of the values here, which is wrong from my perspective. When using a `nativeEnum` in simpler schemas, it takes the value (`firstType` etc.) as expected.

As a workaround, we now use `enum([Type1.FirstType])` etc., but that is not really a clean solution IMO.

Can you confirm this is a bug in zod?



---
<details><summary>Playground Code</summary>
<p>

```typescript
import { z } from 'zod';

const testData = { type: 'firstType', data: { something: 'test' } };

/**
 * NON-NATIVE ENUMS
 */

const schema1 = z
  .object({
    type: z.enum(['firstType']),
    data: z.object({ something: z.string() }),
  })
  .strict();

const schema2 = z
  .object({
    type: z.enum(['secondType', 'thirdType']),
    data: z.object({ somethingElse: z.string() }),
  })
  .strict();

export const schemaUnion = z.discriminatedUnion('type', [schema1, schema2]);

const validatedTestData = schemaUnion.safeParse(testData);

console.info('Validated non-native enums (success)', validatedTestData);

/**
 * NATIVE ENUMS
 *
 * It seems to take the enum key (left side) instead of the value (right side).
 */

enum Type1 {
  FirstType = 'firstType',
}
enum Type2 {
  SecondType = 'secondType',
  ThirdType = 'secondType',
}

const schema1Native = z
  .object({
    type: z.nativeEnum(Type1),
    data: z.object({ something: z.string() }),
  })
  .strict();

const schema2Native = z
  .object({
    type: z.nativeEnum(Type2),
    data: z.object({ somethingElse: z.string() }),
  })
  .strict();

export const schemaUnionNative = z.discriminatedUnion('type', [
  schema1Native,
  schema2Native,
]);

const validatedTestDataNative = schemaUnionNative.safeParse(testData);

console.info('Validated native enums (fails)', validatedTestDataNative);

``` 

</p>
</details> ",,
2197934810,3342,Add `zod-accelerator` to zod ecosystem.,"I want to congratulate you for creating zod. There is for me, no better library than yours in the field of parsing!

zodâ€™s two strengths are its statement and typing. Unfortunately, it is fishing for performance. ðŸ˜¬

Thatâ€™s why I created a library that solves this problem. Like that, no more excuses for not wanting to use zod (server side). ðŸ˜

repo : https://github.com/duplojs/duplojs-zod-accelerator

I thank you again for the work you have done ðŸ«¡
",,
2197443274,3341,z.infer<T> infers dynamic fields are required even if required prop is false.,"Environment:
- zod v. 3.22.4
- TypeScript v. 4.9.5

I have this props

```js
interface Props {
  additional_questions?: Question[]
}
```

Question is this type

```js
type TextQuestion = {
  id: number;
  title: string;
  type: ""text"";
  value: string;
  required?: boolean;
};
```

The property additional_questions is 

```js
[
 {
  id: 1, 
  title: ""Idade"", 
  value: """", 
  type: ""text"", 
  required: false 
 }
]
```

I have this zod form scheme

```js
const formSchema = z.object({
    email: z.string().email(""E-mail invÃ¡lido""),
    names: z.string().min(1, ""Campo obrigatÃ³rio""),
    surnames: z.string().min(1, ""Campo obrigatÃ³rio""),
    phonenumber: z.string(),
    attendance: z.enum([""yes"", ""no""], {
      required_error: ""Precisa de selecionar se aceita ou nÃ£o o convite."",
    }),
    message: z.string(),
    additional_questions: z.array(
      z.object({
        id: z.number(),
        answer: z.string().min(1),
        title: z.string(),
        type: z.string(),
        required: z.boolean()
      })
    ),
  });
```

and this is the form:

```js
const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      email: """",
      names: """",
      surnames: """",
      phonenumber: """",
      attendance: ""yes"",
      message: """",
      additional_questions: props.additional_questions
    },
  });
```

And this is the render section:
```js
{props.additional_questions && props.additional_questions?.map((question, index) => (
  <FormField
    key={question.id}
    control={form.control}
    name={`additional_questions.${question.id}.id`}
    render={({ field }) => (
      <FormItem>
        <FormLabel>{question.title}:</FormLabel>
        <FormControl>
          {
            question.type == ""text"" ? <Input disabled={loading} {...field} /> :
              question.type == ""textarea"" ? <TextArea rows={5} disabled={loading}  {...field} /> :
                <div></div>
          }

        </FormControl>
        <FormMessage />
      </FormItem>
    )}
  />
))}
```

I don't know why when I try to submit the form all the additional questions are required even if the props.additional_questions has questions with required a false. 

<img width=""566"" alt=""Screenshot 2024-03-20 at 12 37 24"" src=""https://github.com/colinhacks/zod/assets/48591110/a0984a22-83c2-404e-b588-e1879413735c"">


Can you help me?",,
2197205268,3340,[superRefine] how to convert a ZodError to ctx.addIssue(),"I have a schema where one of the properties (query) is too complex to validate to only use a zodSchema.

Yet, I made a `parseQuery` custom function that does the job and throw zodErrors as if it was a regular zodSchema.parse() execution.

here the implementation:
```ts
z.object({
  name: z.string(),
  query: z
    .custom<Query>(v => v)
    .superRefine((value, ctx) => {
      try {
        parseQuery(value);
      } catch (error) {
        if (error instanceof z.ZodError) {
          error.issues.forEach(issue => { // this feels wrong
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: issue.message,
            });
          });
        } else {
          const message =
            typeof error === 'object' &&
            error !== null &&
            'message' in error &&
            typeof error.message === 'string'
              ? error.message
              : 'Unknow query parsing error';
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: message,
          });
        }
      }
    }),
});
```

I have to iterate the initial `error.issues` produced by `parseQuery` and try to map them out to `ctx.addIssue`.
The example provided here does not map properly to many of the issues the parseQuery can have (many union errors).

I'm wondering, do we have a way to give the superRefine ctx, existing ZodErrors to get reported?",,
2192329083,3334,Object with Generic Properties makes the properties optional,"In the following code, if I use generic parameters to create some validators, as in `ValidatorFactory`, this makes all the non static properties optional. Is this a limitation on Typescript or Zod?

```ts
import { AnyZodObject, ZodType, z } from ""zod"";

type allowedStandardStringEnum=Record<string, string>
type EnumValues<Enum extends allowedStandardStringEnum> = Enum[keyof Enum]

function stringEnumValidator<Enum extends allowedStandardStringEnum>(enumParam:Enum):ZodType<EnumValues<Enum>>{
	return z.nativeEnum(enumParam);
}

function ValidatorFactory<StateEnum extends allowedStandardStringEnum, ZodDataObject extends AnyZodObject>(
	states:StateEnum,
	validator:ZodDataObject,
){
	return z.object({
    staticProp: z.string(),
		currentState    : stringEnumValidator(states),
		dataForFunction : z.unknown(),
		stateData       : validator,
	})
}

type FactoryReturn<StateEnum extends allowedStandardStringEnum, ZodDataObject extends AnyZodObject>=z.infer<ReturnType<typeof ValidatorFactory<StateEnum,ZodDataObject>>>


function execution<StateEnum extends allowedStandardStringEnum, ZodDataObject extends AnyZodObject>(instance:FactoryReturn<StateEnum, ZodDataObject>){
  let staticProp=instance.staticProp                // Correct
  let currentState=instance.currentState            // Incorrect
  let dataForFunction=instance.dataForFunction      // Incorrect
  let stateData=instance.stateData                  // Incorrect
}
```

I believe it may also be similar to https://github.com/colinhacks/zod/issues/2077


Also believing that it may be caused by https://github.com/colinhacks/zod/issues/3330, I can verify that `""strict"":true` has been set in tsconfig.json

Thanks in Advance for any help",,
2191088510,3333,How to validate FormData object?,is there proper way to validate FormData type without it converting to object?,,
2190927779,3332,z.undefined() behaves weird,"I was trying to create a schema verifier for one pre-existing interface and stumbled into a weird problem.

This works:
![image](https://github.com/colinhacks/zod/assets/50925676/325c2dd6-a210-4bd5-994b-cdc3f7055bb7)

But these aren't:
![image](https://github.com/colinhacks/zod/assets/50925676/418fd9af-12a4-480e-af0d-1738413cf0e8)
![image](https://github.com/colinhacks/zod/assets/50925676/bb22da54-3e40-4b4e-8f6f-fd9e6951ab8a)
![image](https://github.com/colinhacks/zod/assets/50925676/e387d084-7e9b-4fa5-8a9c-14e36ae683cb)

I find this behavior to be weird. I understand where it might come from, but describing some project types with this library becomes impossible. Also, I would like to point out that in the real project, I have no control over the interface, so this example is from the wild.",,
2190236795,3331,Recursive schema,"Hello,

I'm currently experiencing a problem that I can't solve.

I have a recursion problem between two schemas and I don't understand how to do it.

My first schema OrderResponseSchema:

```ts
export const OrderSchema = z.object({
  [...]
  account: CustomerSchema,
  [...]
});

export type OrderResponse = z.infer<typeof OrderResponseSchema>

export const OrderResponseSchema = z.object({
  count: z.number(),
  page_count: z.number(),
  page: z.number(),
  results: z.array(OrderSchema)
})
```

And my second CustomerSchema which extends the OrderResponseSchema in the orders object:

```ts
import { OrderResponseSchema } from ""./Order"";
import { z } from 'zod';

export type Customer = z.infer<typeof CustomerSchema>

export const CustomerSchema = z.object({
  [...]
  orders: z.optional(OrderResponseSchema),
});
```

This is the error I'm encountering:


```ts
'CustomerSchema' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.ts(7022)
const CustomerSchema: any
```

This error disappears if I comment out the orders object.

Thanks for your help

Versions:

```js
""typescript"": ""5.1.3"",
""zod"": ""^3.22.4""
```",,
2189273325,3330,z.infer<T> infers optional fields even though no .optional() is specified,"Environment:
- zod v. 3.22.4
- TypeScript v. 5.2.2

Reproduction: https://stackblitz.com/edit/react-ts-awcdlz?file=App.tsx

If I specify a Zod schema like this:
```ts
const RequiredNameSchema = z.object({
  requiredName: z.string(), // should infer required field
  optionalName: z.string().optional(),  // should infer optional field
});

type RequiredNameType = z.infer<typeof RequiredNameSchema>;
```

The inferred type of `RequiredNameType` is (note that both fields are optional):
```ts
type RequiredNameType = {
  requiredName?: string; // PROBLEM: infers optional field
  optionalName?: string;
}
```

Expected inferred type (e.g. as found in the example here: https://zod.dev/?id=basic-usage):
```ts
type RequiredNameType = {
  requiredName: string;
  optionalName?: string;
}
```

Or am I missing something?",,
2188352346,3328,coerce.boolean incorrect,"```js
import { z } from 'zod';

const schema = z.object({
	something: z.coerce.boolean(),
});

console.log(schema.parse({ something: 'false' }));
```

expected:
```
{ something: false }
```

got:
```
{ something: true }
```",,
2188302195,3327,Issue optional Email  z.string().email(),"if you assign the following to an input form it wont work, it works if you don't touch the field, but once you touch it it will ask you for an email because the email chaining comes before the optional chaining, and you can't put it backwards, it doesn't work with transform either.

```ts
const email = z.string().email().optional() 
```
",,
2187158970,3326,[Generic Types] zod doesn't extend zod? Does not return correct?,"Hello, please.
Shouldn't this work?

Shouldn't parse() return an object that extends zod?

![image](https://github.com/colinhacks/zod/assets/1591772/a276dd30-a195-4ad8-a0ce-13f25553fee0)



```typescript
import { z } from 'zod';

const zData = z.object({
  name: z.string(),
});
type zData = z.infer<typeof zData>;

const zTypeInParameters = <T>(params: z.ZodType<T>) => {
  return z.object({
    data: params,
  });
};
type zTypeInParameters<T> = z.infer<ReturnType<typeof zTypeInParameters<T>>>;

const zTypeInExtends = <T extends z.ZodType>(params: T) => {
  return z.object({
    data: params,
  });
};
type zTypeInExtends<T extends z.ZodType> = z.infer<ReturnType<typeof zTypeInExtends<T>>>;

const zTypeInExtendsTypeAny = <T extends z.ZodTypeAny>(params: T) => {
  return z.object({
    data: params,
  });
};
type zTypeInExtendsTypeAny<T extends z.ZodTypeAny> = z.infer<ReturnType<typeof zTypeInExtendsTypeAny<T>>>;

const zDataInst = zData.parse({ name: 'abc' });
const zTypeInParametersInst: zTypeInParameters<zData> = zTypeInParameters<zData>(zDataInst);
const zTypeInExtendsInst: zTypeInExtends<zData> = zTypeInExtends<zData>(zDataInst);
const zTypeInExtendsTypeAnyInst: zTypeInExtendsTypeAny<zData> = zTypeInExtendsTypeAny<zData>(zDataInst);

console.log(zTypeInParametersInst, zTypeInExtendsInst, zTypeInExtendsTypeAnyInst);

```",,
2186979941,3325,Allow `data` and `error` to be accessed on `SafeParseReturnType` even when they may not be present,"When using zod in react applications, the error property is often unused. Instead, the primary focus is on either getting back parsed data or `undefined` (which can then be overwritten with some default value). Currently this involves a pointless intermediate variable.

```typescript
import {MyThingParser} from '../parsers'

const useMyThing = () => {
	const myThingResult = MyThingParser.safeParse(localStorage.get('myThingKey'))
	const myThing = myThingResult.success ? myThingResult.data : defaultMyThing
	// ... further transformations, defaulting, etc.
}
```

These sorts of patterns also come up frequently in tests, where it is usually solved with very broad casting.

```typescript
test('myThing is parsed correctly', () => {
  const myThingResult = MyThingParser.safeParse(testData)
  expect((myThingResult as any).data).toEqual(testData)
})
```

Both of these would be unneccessary if we made a slight change to the safe parse output type, while keeping the discriminated union structure.

```typescript
type SafeParseSuccessOutput<Output> = { 
    success: true; 
    data: output; 
    error? : never
}

type SafeParseError<Input> = { 
    success: false; 
    error: ZodError<Input>; 
    data? : never
}
```

This was initially discussed in #3266 , but that was closed because the original suggestion in that thread involved removing the discriminated union structure. There is a PR for this work already (#3295 ).",,
2184677260,3324,url validation does not work as expected,"``` typescript
import { z } from ""zod"";
import isUrl from ""is-url"";

console.log(""zod"", z.string().url().safeParse(""javascript:void();""));
console.log(""is-url"", isUrl(""javascript:void();""));
```
that gave output like

```
zod {
  success: true,
  data: ""javascript:void();"",
}
is-url false
```

*zod@3.22.4*, *is-url@1.2.4*
",,
2182277442,3323,Transform strings to normalize URLs,"# Problem
Users typically do not include the protocol when hand-typing links. As such, applying `z.string().url()` leads to unintuitive use experience when validating user input. Further a custom transformation (ex: `z.string().transform(normalizeUrlLikeString).url()`) is not supported by Zod.

# Proposed solution
A `.toUrl()` transformation function that will--
1. Add `https://` if the string does not include a protocol
2. Validate the string as a URL
3. Return the new/valid string.",,
2179488325,3320,Warnings from schema,"Validators usually [require some fallback](https://en.wikipedia.org/wiki/Robustness_principle), and `.catch` doesn't quite cut it.

Consider schema

```
const Schema = z.object({
  foo: z.string().optional().catch(undefined),
  bar: z.string().optional().catch(undefined),
});
```

While it is possible to produce `{ foo: undefined, bar: undefined }` result for `{ foo: 1, bar: 2 }` input, there's no way to know where the failure happened.

I didn't find any API to extend parsing context with an extra array of ""warnings"" even if I were to extend `zod` with extra schema constructors. Even a private `_parseSync` API that seems to give a ternary output with `DIRTY` state doesn't seem to be possible to use here.

The options I have right now are

- create a separate schema without `.catch`, and run `parse` twice on it;
- define the whole schema inside of a function with a private mutable `warnings` state at expense of tree shaking and having `zod` to create a new schema on every input;
- implement my own version of `zod` that works with generic `ParseContext`.

Is there a way to do it with current API, and if not, can `zod` be extended with one?",,
2176914787,3313,Having `undefined` as a function that can be imported is a package design issue,"Hi everyone,

  First of all, we like `zod` a lot, it is an excellent tool for its job. However I feel that having an `undefined` function that can be imported separately (see example below) is a metaphorical rake lying in the grass that I am stepping on _way too frequently_. After a while my subjective opinion is that there should be no separately importable `undefined` variables in `zod`, because it just creates much confusion.

```typescript
// This just happens and then ðŸ’¥ 
import { undefined } from 'zod';
```

Any postfix/prefix could fix it, in my opinion.

If it's only me who is stepping on this rake, then just close this.",,
2176498552,3310,unable to catch errors,"I use promise, but I can't get the error in catch.

```ts
zod.number({
  required_error: 'title is required',
}).promise().parse(title).catch(() => {});
```

<img width=""680"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/10768858/777fb37d-086d-4f38-94db-130976a655c0"">
",,
2176472001,3309,Type inference is too loose in combination with generic functions,"## Motivation

I am trying to use Zod to validate and transform data received from an external API. It's shape nests lots of information in objects with a single key called `data`. For example, instead of

```js
[""a"", ""b"", ""c""]
```

we might receive
```js
[{data: ""a""}, {data: ""b""}, {data: ""c""}]
```

Transforming `{data: ""a""}` to `""a""` works as expected via the schema

```ts
z.object({ data: z.string() }).transform((a) => a.data)
```

## Problem

Since this pattern is so common, I want to extract this into a function:

``` typescript
function dataObj<T extends z.ZodTypeAny>(schema: T) {
  return z.object({ data: schema }).transform((a) => a.data);
}
```
According to [the documentation](https://zod.dev/?id=writing-generic-functions), I understand this to be the correct usage of generic parameters.

Unfortunately, the type inferring capabilities of TypeScript seem to fail, as the resulting type (determined by hovering over it in VS Code) always contains an unwanted `undefined`:

``` typescript
const test = dataObj(z.string())
z.infer<typeof test> // string|undefined, should be string
```

## Workaround
I can work around the problem by adding a type assertion in `transform`. But I assume, it should also work without this, since it works if the function is inlined.

``` typescript
function otherDataObj<T extends z.ZodTypeAny>(schema: T) {
  return z.object({ data: schema }).transform((a) => a.data as z.infer<T>);
}

const test = otherDataObj(z.string())
z.infer<typeof test> // string, ok
```

## Additional information
I am using TypeScript 5.4.2 and Zod 3.22.4.

I have prepared the example on [codesandbox.io](https://codesandbox.io/p/devbox/relaxed-framework-7npypx?file=%2Fsrc%2Findex.ts%3A5%2C2&layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522cltiwcgn200062v6gnc7vbsj4%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522cltiwcgn200022v6gurks998r%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522cltiwcgn200042v6gw08vynab%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522cltiwcgn200052v6g57l4b0yw%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522cltiwcgn200022v6gurks998r%2522%253A%257B%2522id%2522%253A%2522cltiwcgn200022v6gurks998r%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522cltiwcgn200052v6g57l4b0yw%2522%253A%257B%2522tabs%2522%253A%255B%255D%252C%2522id%2522%253A%2522cltiwcgn200052v6g57l4b0yw%2522%257D%252C%2522cltiwcgn200042v6gw08vynab%2522%253A%257B%2522id%2522%253A%2522cltiwcgn200042v6gw08vynab%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cltiwcgn200032v6gjgx0efpb%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522start%2522%257D%252C%257B%2522id%2522%253A%2522cltiwkjon00cx2v6geowrneo7%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TERMINAL%2522%252C%2522shellId%2522%253A%2522cltiwkjpl00q2dag63pig2dci%2522%257D%255D%252C%2522activeTabId%2522%253A%2522cltiwkjon00cx2v6geowrneo7%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D).

I hope, you can help me with this problem. Thanks for investing your time.",,
2176430047,3308,Show discriminatorValue in discriminatedUnion error message,"Could we get the [discriminatorValue](https://github.com/colinhacks/zod/blob/master/src/types.ts#L2950) in the error message as well?

Please take a look at the following example:

```typescript
const schema = z.discriminatedUnion(""type"", [
  z.object({ type: z.literal(""apple"") }),
  z.object({ type: z.literal(""orange"") }),
]);

schema.parse({ type: ""banana"" });
```

Current error message (version 3.22.4):
```
â€‹ Uncaught ZodError: [
  {
    ""code"": ""invalid_union_discriminator"",
    ""options"": [
      ""apple"",
      ""orange""
    ],
    ""path"": [
      ""type""
    ],
    ""message"": ""Invalid discriminator value. Expected 'apple' | 'orange'""
  }
]
```

Expected:
```
...
    ""message"": ""Invalid discriminator value. Expected 'apple' | 'orange', got 'banana'.""
...
```

https://playground.solidjs.com/anonymous/230fe5d4-25b0-41dd-b854-8b1b8f99b029
(PS. would love a zod playground, but did not find one suitable)",,
2176282166,3307,[Feature]: Allow Customizing the Error Message for `z.instanceof`,"## The Problem
Just like many others seem to be doing (#387, #3256), I'm trying to use Zod to validate files that are sent to the server via a web form. My schema looks like this:

```ts
// Server Side
const schema = z.object({ 
  picture: z.instanceof(Blob),
  // Other form field requirements ...
});
```

I'd like the error message that I send back to the client to be clear for users.

Something like
> File is required

is much more clear to users than
> Input not instance of Blob

Unfortunately, Zod doesn't seem to support custom error messages for the `instanceof` validator.

## The Solution
Developers could be allowed to specify a custom error message for this validator.

```ts
z.instanceof(Blob, ""File is required"")
```

Since many of the other validators allow customizing error messages, I was hoping that this would be an easy change?",,
2175432265,3306,z.string() got issue with polyline6 encoded string ,"Input value: 
```
c_hjS}s{`A{C}`@
```
Error code: 
```bash
ZodError: [
  {
    ""code"": ""invalid_type"",
    ""expected"": ""string"",
    ""received"": ""object"",
    ""path"": [
      ""paths"",
      0,
      ""points""
    ],
    ""message"": ""Expected string, received object""
  },
  {
    ""code"": ""invalid_type"",
    ""expected"": ""string"",
    ""received"": ""object"",
    ""path"": [
      ""paths"",
      0,
      ""snapped_waypoints""
    ],
    ""message"": ""Expected string, received object""
  }
]
```
We're using zod for our api package, but the z.string detect our string is an object and the test run failed.
",,
2172018853,3303,[question] comparison to ajv v8 validator,"Hi,

I did not find any information about the comparison of the validation features of ajv v8 to zod.

Are there any information about this ? 

Regards,

Lars  ",,
2170141747,3302, message,,,
2167634425,3300,Migrate to JSR,"Hello. It would be nice if this package could be [migrated to JSR](https://jsr.io/docs/migrate-x-to-jsr), Deno's new preferred registry.",,
2164553824,3293,Property 'x' is optional in z.ZodType but required in TypeScript type?,"I have this [CodeSandbox](https://codesandbox.io/p/devbox/zod-playground-forked-g9t87m?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522cln3s5wur00073b6hpvdyzdd7%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522cln3s5wur00033b6h80ute5zp%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522cln3s5wur00053b6h90wtxxns%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522cln3s5wur00063b6h1y81405t%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522cln3s5wur00033b6h80ute5zp%2522%253A%257B%2522id%2522%253A%2522cln3s5wur00033b6h80ute5zp%2522%252C%2522tabs%2522%253A%255B%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.ts%2522%252C%2522id%2522%253A%2522cln3s60zq002v3b6hm2cfn9qk%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fpackage.json%2522%252C%2522id%2522%253A%2522cln3sh8u0007x3b6g1r8nttu6%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%255D%252C%2522activeTabId%2522%253A%2522cln3s60zq002v3b6hm2cfn9qk%2522%257D%252C%2522cln3s5wur00063b6h1y81405t%2522%253A%257B%2522id%2522%253A%2522cln3s5wur00063b6h1y81405t%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522cln3s5wur00053b6h90wtxxns%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cln3s5wur00043b6h3lhgss80%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522start%2522%257D%255D%252C%2522id%2522%253A%2522cln3s5wur00053b6h90wtxxns%2522%252C%2522activeTabId%2522%253A%2522cln3s5wur00043b6h3lhgss80%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D), which has the following code. Notice that both in the TypeScript type, and the zod type, all properties are required. I am getting an error (shown below the code) which says that zod type is optional, which it shouldn't be.

```ts
import * as z from ""zod"";

export const FFMPEG_AUDIO_CODEC = [""foo"", ""bar""] as const;

export type FfmpegAudioCodec = (typeof FFMPEG_AUDIO_CODEC)[number];

export const FFMPEG_SUBTITLE_CODEC = [""foo"", ""bar""] as const;

export type FfmpegSubtitleCodec = (typeof FFMPEG_SUBTITLE_CODEC)[number];

export const FFMPEG_VIDEO_CODEC = [""foo"", ""bar""] as const;

export type FfmpegVideoCodec = (typeof FFMPEG_VIDEO_CODEC)[number];

export type ConvertVideoWithFfmpeg = {
  input: ArrayBuffer;
  output: ArrayBuffer;
  audioBitRate: number;
  audioChannels: number;
  audioCodec: FfmpegAudioCodec;
  audioSamplingFrequency: number;
  duration: number;
  endTime: number | string;
  frameRate: number;
  rotation: number;
  scaleHeight: number;
  scaleWidth: number;
  startTime: number;
  strict: boolean;
  subtitleCodec: FfmpegSubtitleCodec;
  videoBitRate: number;
  videoCodec: FfmpegVideoCodec;
};

export const FfmpegAudioCodecModel: z.ZodType<FfmpegAudioCodec> =
  z.enum(FFMPEG_AUDIO_CODEC);

export const FfmpegSubtitleCodecModel: z.ZodType<FfmpegSubtitleCodec> = z.enum(
  FFMPEG_SUBTITLE_CODEC,
);

export const FfmpegVideoCodecModel: z.ZodType<FfmpegVideoCodec> =
  z.enum(FFMPEG_VIDEO_CODEC);

export const ConvertVideoWithFfmpegModel: z.ZodType<ConvertVideoWithFfmpeg> =
  z.object({
    input: z.instanceof(ArrayBuffer),
    output: z.instanceof(ArrayBuffer),
    audioBitRate: z.number().int(),
    audioChannels: z.number().int(),
    audioCodec: z.lazy(() => FfmpegAudioCodecModel),
    audioSamplingFrequency: z.number(),
    duration: z.number().int(),
    endTime: z.union([z.number(), z.string()]),
    frameRate: z.number().int(),
    rotation: z.number(),
    scaleHeight: z.number().int(),
    scaleWidth: z.number().int(),
    startTime: z.number().int(),
    strict: z.boolean(),
    subtitleCodec: z.lazy(() => FfmpegSubtitleCodecModel),
    videoBitRate: z.number().int(),
    videoCodec: z.lazy(() => FfmpegVideoCodecModel),
  });
```

The last `export const ConvertVideoWithFfmpegModel` is throwing a TypeScript error:

```
Type 'ZodObject<{ input: ZodType<ArrayBuffer, ZodTypeDef, ArrayBuffer>; output: ZodType<ArrayBuffer, ZodTypeDef, ArrayBuffer>; ... 14 more ...; videoCodec: ZodLazy<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<ConvertVideoWithFfmpeg, ZodTypeDef, ConvertVideoWithFfmpeg>'.
  Types of property '_type' are incompatible.
    Type '{ input?: ArrayBuffer; output?: ArrayBuffer; audioBitRate?: number; audioChannels?: number; audioCodec?: ""foo"" | ""bar""; audioSamplingFrequency?: number; duration?: number; ... 9 more ...; videoCodec?: ""foo"" | ""bar""; }' is not assignable to type 'ConvertVideoWithFfmpeg'.
      Property 'input' is optional in type '{ input?: ArrayBuffer; output?: ArrayBuffer; audioBitRate?: number; audioChannels?: number; audioCodec?: ""foo"" | ""bar""; audioSamplingFrequency?: number; duration?: number; ... 9 more ...; videoCodec?: ""foo"" | ""bar""; }' but required in type 'ConvertVideoWithFfmpeg'.typescript(2322)
```

I follow this pattern everywhere in my large codebase of doing:

```ts
export const MyModel: z.ZodType<MyType> = z.object(...)
```

Because I use `z.lazy` in many many places, so I ned to use `z.ZodType`. But for some reason it is saying the type is not required in the zode type, even though it is required in the TypeScript type. How do I fix this? Is this a bug, or what am I doing wrong?

Thanks for the help! Please let me know how to make the properties all required, _while still specifying the `z.ZodType<T>`.

Note, I get a different but similar error locally (it errors on a different property):

<img width=""724"" alt=""Screenshot 2024-03-01 at 7 25 41â€¯PM"" src=""https://github.com/colinhacks/zod/assets/28718/1c3968a2-52d4-46d9-bfdc-5643478e7e53"">
",,
2163621896,3291,How to have .optional() survive during transform(),"How would I keep a property as truly optional (`{ a?:..}`) in my resulting object after doing a `.transform()`. 

Take the example below, the property is correctly inferred as optional (`a?:...`) **after** parsing **but before** transforming. 
However, after transforming, it no longer is optional.


```
const objectA = z.object({ a: z.number().optional() })

type A = z.infer<typeof objectA>;
// { a?: number  | undefined } <-- optional


const objectB = z.object({ a: z.number().optional() }).transform((x) => {
  return { a: x.a?.toString() };
});


type B = z.infer<typeof objectB>;
// { a: string  | undefined } <-- no longer optional

```

",,
2162810343,3290,superRefine don't work,"`console.log('superRefine',values) `  doesn't even occur

```
export const getBaseManagementGateFormSchema = () =>
  z
    .object({
      name: z.string().min(1, _translate('message_required_name')),
      gateModeId: z.nativeEnum(TerminalClientMods),
      gatePeriodTimeMinutes: z.coerce.number(),
      gatePeriodPrice: z.coerce.number(),
      gatePeriodFreeTimeMinutes: z.coerce.number(),
      coords: z.string().min(1, _translate('message_required_coords')),
      latitude: z.number().optional(),
      longitude: z.number().optional(),
      externalId: z.number().refine((v) => Boolean(v), _translate('message_required_external_gate')),
      terminals: z.array(
        z.object({
          name: z.string().min(1, _translate('message_required_terminal_name')),
          externalId: z.number().refine((v) => Boolean(v), _translate('message_required_external_terminal')),
          typeId: z.number().refine((v) => Boolean(v), _translate('message_required_terminal_type')),
          terminalPeriodTimeMinutes: z.coerce.number().optional(),
          terminalPeriodPrice: z.coerce.number().optional(),
          terminalPeriodFreeTimeMinutes: z.coerce.number().optional(),
          terminalMode: z.number().optional(),
        }),
      ),
    })
    .superRefine((values, ctx) => {
      console.log('superRefine', values)
      console.log(
        'values.gateModeId === TerminalClientMods.PARKING_PREPAYMENT ||' +
          'values.gateModeId === TerminalClientMods.PARKING_POSTPAID',
        values.gateModeId === TerminalClientMods.PARKING_PREPAYMENT ||
          values.gateModeId === TerminalClientMods.PARKING_POSTPAID,
      )
      if (
        values.gateModeId === TerminalClientMods.PARKING_PREPAYMENT ||
        values.gateModeId === TerminalClientMods.PARKING_POSTPAID
      ) {
        if (values.gatePeriodTimeMinutes < 0 || (!values.gatePeriodPrice && values.gatePeriodTimeMinutes !== 0)) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: _translate('message_required_periodTimeMinutes'),
            path: ['gatePeriodTimeMinutes'],
          })
        }
        if (values.gatePeriodPrice < 0 || (!values.gatePeriodPrice && values.gatePeriodPrice !== 0)) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: _translate('message_required_periodPrice'),
            path: ['gatePeriodPrice'],
          })
        }
        if (
          values.gatePeriodFreeTimeMinutes < 0 ||
          (!values.gatePeriodFreeTimeMinutes && values.gatePeriodFreeTimeMinutes !== 0)
        ) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: _translate('message_required_periodFreeTimeMinutes'),
            path: ['gatePeriodFreeTimeMinutes'],
          })
        }
      }
      if (values.gateModeId === TerminalClientMods.MANUAL) {
        values.terminals.forEach((terminal, index) => {
          if (
            terminal.terminalPeriodTimeMinutes < 0 ||
            (!terminal.terminalPeriodPrice && terminal.terminalPeriodTimeMinutes !== 0)
          ) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: _translate('message_required_periodTimeMinutes'),
              path: [`terminal[${index}].terminalPeriodFreeTimeMinutes`],
            })
          }
          if (
            terminal.terminalPeriodPrice < 0 ||
            (!terminal.terminalPeriodPrice && terminal.terminalPeriodPrice !== 0)
          ) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: _translate('message_required_periodPrice'),
              path: [`terminal[${index}].terminalPeriodPrice`],
            })
          }
          if (
            terminal.terminalPeriodFreeTimeMinutes < 0 ||
            (!terminal.terminalPeriodFreeTimeMinutes && terminal.terminalPeriodFreeTimeMinutes !== 0)
          ) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: _translate('message_required_periodFreeTimeMinutes'),
              path: [`terminal[${index}].terminalPeriodFreeTimeMinutes`],
            })
          }
          if (!terminal.terminalMode) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: _translate('message_required_terminal_mode'),
              path: [`terminal[${index}].terminalMode`],
            })
          }
        })
      }
    })
```",,
2162744746,3289,Validation rules are getting applied for hidden fields. How can I handle that.,"Based on the selection I am hiding/showing some of the form fields. But when I submit the form hidden fields validation is also triggering and I am not able to submit the form.  I have tried with "".partial()"" also but still it's not working. Please let me know how we can resolve this issue. ",,
2162736873,3288,Not able to provide custom error message for MUI Autocomplete control,"I am using MUI Autocomplete + React hook form + Zod for the validation. When I tried to apply validation to the MUI control I am getting ""Expected object, received null"" message when I use the validation rule like  fieldName: z.object({}),

![image](https://github.com/colinhacks/zod/assets/75621605/93ed7d56-df9c-433b-b57a-258aa9c6eeb0)

But when I use fieldName: z.string(), it is throwing below error (""Expected string, received object"")even though I select the item.
![image](https://github.com/colinhacks/zod/assets/75621605/027eb0b8-6a98-46bc-b0f4-1ce567ae2fe6)

Please let me know How can I resolve it. ",,
2160481243,3284,feat: `z.valueof`,"Zod already has [`Objects.keyof`](https://zod.dev/?id=keyof), but is missing `Objects.valueof`.

One example [adapted from discussions](https://github.com/colinhacks/zod/discussions/839#discussioncomment-8142768) is:

```ts
function valueof<
  T extends Record<string, string>,
  V extends string = T extends Record<string, infer V> ? V : never,
>(input: T): z.ZodEnum<[V, ...V[]]> {
  const [firstKey, ...otherKeys] = Object.values(input) as [V, ...V[]];
  return z.enum([firstKey, ...otherKeys]);
}
```

It is important to note that this function only works with objects of shape `Record<string, string>` as the [docs](https://zod.dev/?id=basic-usage) say:

> `z.enum` is a Zod-native way to declare a schema with a fixed set of allowable string values.",,
2156898047,3279,Is it possible to make Zod throw custom errors rather than a ZodError?,"I have a predefined error that occurs when there is a bad arg in an API call. Trying to move validation over to use zod. Could I instead make it so zod throws a custom error?

```typescript
export class BadApiArgumentException extends OttException {
	name = ""BadApiArgumentException"";
	arg: string;
	reason: string;

	constructor(arg: string, reason: string) {
		super(`Bad argument: ${arg}: ${reason}`);
		this.arg = arg;
		this.reason = reason;
	}
}
```",,
2156242631,3277,Request to add Typescript 5.3 to test matrix,Testing the latest Typescript since that is what most people use when starting a new project.,,
2156233170,3276,Request to add Node 20 pipelines,"Request to add the LTS at this moment for Node.js [nodejs.org](https://nodejs.org/): 20.11.1
This will make for more up to date testing.",,
2155600907,3273,String length validation error messages can't distinguish between singular and plural count.,"<img width=""742"" alt=""Screenshot 2024-02-27 at 9 20 51â€¯AM"" src=""https://github.com/colinhacks/zod/assets/121621183/3978c27a-8bad-480f-ad7e-3fdc30f58d21"">

It always uses the ""(s)"" universally either it is 1 or 0 or >1. 

For example, if the zod schema is like this:

```
const SignUpFormSchema = z.object({
    alphabet: z.string().min(1)
});
```

If the user tries to submit the form without inputting anything the error message will be shown as:

`String must contain at least 1 character(s)`

The error message can be improved to:

`String must contain at least 1 character`
",,
2153823507,3272,Use Input type for refine & superRefine ,"I'm running into this: https://github.com/colinhacks/zod/issues/2192

I'm quite ok with the behaviour, it helps know all errors for a form. But the types seems to lies to me because they are using `Output` instead of `Inuput`.

In my case the type are different because I use this wrapper:

```ts
  value.transform((v, ctx) => {
    if (v === null) {
      ctx.addIssue({ code: ""custom"", message: ""Required"" });
      return z.NEVER;
    }
    return v;
  });
```

Should the issue above be considered a bug or should the types be updated?",,
2152767988,3271,How to set any zod schema as the attribute in z.object,"i am trying to create a zod object schema for generic REST api request def.  this schema is generated by codegen.
```
const apiRequestSchema = z.object({
  apiConfig: apiConfigSchema, // another zod schema that specifies url, body etc.
  outputSchema: z.zodAny() // schema that will be used to parse the response. it can be any zod schema
})

type APIRequest = z.infer<typeof apiRequestSchema>
```

APIRequest typescript sets `outputSchema` as any zod schema that can be used to parse the response.

is there a zod method e.g. `z.zodAny` to specity zod schema as the value of `outputSchema`?",,
2152637837,3269,nonPrimitive,"It would be nice if zod could parse ""extended"" functions (and also other extended types as well).

By extended function I mean an object that has a type of `function` and is an instance of `Function` and other methods not commonly found in a function object.

So, for example:

```js
function example () {}

example.displayName = 'some value'
```

Function (`Function.prototype`)s normally don't contain any `displayName` properties but this one does.

You could try to parse this in zod using `z.object({ displayName: z.literal('some value') })` but that would fail as `z.object`, instead of checking if the property isn't a primitive, checks if its type is of `object` (which it isn't, since it is of type `function) (and probably other stuff like not an array).

Having a `nonPrimitive` (or `weakObject` or similar) type here would be really helpful, as the following could be done:

```js
// or weakObject
z.nonPrimitive({
  displayName: z.literal('some value')
})
```

For more type safety you could also add a `typeof` (or `typeOf`):

```js
z.nonPrimitive({
  displayName: z.literal('some value')
})
  .typeof('function')
```",,
2152258188,3267,How to make a schema from dynamic and static fields,"Hi everyone. I have a form that creates a product for an online store. The product has certain fields, such as - title, description, photo. There is also a field that assigns the product to a certain category, and depending on which category the product is assigned to, the product has additional, dynamic fields based on options that come from the server. For example, if I select category 1 in the form, the product will have an option for color where I can select a specific color, and if I select category 2, the form should have a size field where I can select a size. Here is how it looks like in the code
Schema(these are the fields that the product always has)
```
export const productFormSchema = z.object({
  name: z
    .string()
    .min(3)
    .max(30)
    .transform((name) => name.trim()),
  description: z.string(),
  about: z.string(),
  img: z.array(z.string()),
  categoryList: z.array(
    z.object({
      id: z.string(),
    }),
  ),
});

export type ProductFormValues = z.infer<typeof productFormSchema>;
```
Here is the base component of the form
```
const getDefaultValues = (product?: ProductRelation) => ({
  name: product?.name ?? """",
  description: product?.description ?? """",
  about: product?.about ?? """",
  img: product?.img ?? [],
  categoryList: product?.categoryList ?? [],
});

export const ProductForm: FC<ProductFormProps> = (props) => {
  const {
    product,
    handleSubmit: onSubmit,
    submitText,
    isPending,
    categorySelectOptionList,
    categotySelectOptionListActive,
    optionSelectOptionList,
    handleCategorySelectOption,
  } = props;

  const form = useForm<ProductFormValues>({
    resolver: zodResolver(productFormSchema),
    defaultValues: getDefaultValues(product),
  });

  useEffect(() => {
    form.reset(getDefaultValues(product));
  }, [product, form, optionSelectOptionList]);

  const handleSubmit = form.handleSubmit(async (data) => {
    onSubmit?.(data);
  });

  const handleDeleteimg = (path: string) => {
    const list = form.getValues(""img"");
    const result = list.filter((item) => item !== path);
    form.setValue(""img"", result);
  };

  const isPendingAppearance = useAppearanceDelay(isPending);

  const handleSelect = useCallback((value: MultiSelectOptionItem[]) => {
    form.setValue(""categoryList"", handleCategorySelectOption(value));
  }, []);

  return (
    <Form {...form}>
      <form onSubmit={handleSubmit} className=""space-y-8"">
        <FormField
          control={form.control}
          name=""categoryList""
          render={({ field }) => {
            return (
              <FormItem>
                <FormLabel>Category list</FormLabel>
                <FormControl>
                  <MultiSelect
                    optionList={categorySelectOptionList}
                    optionActiveList={categotySelectOptionListActive}
                    onSelected={handleSelect}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            );
          }}
        />
        <FormField
          control={form.control}
          name=""name""
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <Input placeholder=""Enter product name..."" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name=""description""
          render={({ field }) => (
            <FormItem>
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Input placeholder=""Enter product description..."" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name=""about""
          render={({ field }) => (
            <FormItem>
              <FormLabel>About</FormLabel>
              <FormControl>
                <Textarea placeholder=""Enter product about..."" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name=""img""
          render={({ field }) => (
            <FormItem>
              <FormLabel>Avatar</FormLabel>
              <FormControl>
                <ImgField
                  value={field.value}
                  onChange={field.onChange}
                  onDelete={handleDeleteimg}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button type=""submit"" disabled={isPendingAppearance}>
          {isPendingAppearance && (
            <Spinner
              className=""mr-2 h-4 w-4 animate-spin""
              aria-label=""Profile updating...""
            />
          )}
          {submitText}
        </Button>
      </form>
    </Form>
  );
};
```
Now I want to add fields to it based on which categories are selected in categoryList
For this purpose the optionSelectOptionList props come to the form and based on it I add fields to the form, here is a simplified version with only select, but in the actual code there are also multiselect, checkbox and radio
```
        {optionSelectOptionList &&
          optionSelectOptionList.map((option) => {
            const { datatype } = option;
            if (datatype === OptionDataTypeEnum.SELECT) {
              return (
                <FormField
                  key={option.name}
                  control={form.control}
                  name={option.name}
                  render={({ field }) => {
                    console.log(""name"", option.name);
                    return (
                      <FormItem>
                        <FormLabel>{option.name}</FormLabel>
                        <Select onValueChange={field.onChange}>
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue placeholder=""placeholder"" />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            {option.optionList.map((row) => (
                              <SelectItem key={row.value} value={row.value}>
                                {row.label}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                     
                        <FormMessage />
                      </FormItem>
                    );
                  }}
                />
              );
            }
          })}

```
But the problem is that my original schema doesn't know anything about dynamic fields and I don't understand how to implement what I described. Here is an example of how optionSelectOptionList looks like
```
[
    {
        ""id"": ""option_eeesddfew789855"",
        ""name"": ""New"",
        ""datatype"": ""radio"",
        ""optionList"": [
            {
                ""value"": ""optionItem_77da558waew77YES"",
                ""label"": ""yes"",
                ""active"": false
            },
            {
                ""value"": ""optionItem_ew5da558waew22NO"",
                ""label"": ""no"",
                ""active"": false
            }
        ]
    },
    {
        ""id"": ""option_585fsddfew7898dd"",
        ""name"": ""Size"",
        ""datatype"": ""select"",
        ""optionList"": [
            {
                ""value"": ""optionItem_58ddtwaew7897dfeXS"",
                ""label"": ""XS"",
                ""active"": false
            },
            {
                ""value"": ""optionItem_d33ddtwaew68deS"",
                ""label"": ""S"",
                ""active"": false
            },
            {
                ""value"": ""optionItem_M68ddtwaew65687M"",
                ""label"": ""M"",
                ""active"": false
            },
            {
                ""value"": ""optionItem_L58ddtwaew65622L"",
                ""label"": ""L"",
                ""active"": false
            },
            {
                ""value"": ""optionItem_XL33ddtwaew65dd2eeXL"",
                ""label"": ""XL"",
                ""active"": false
            }
        ]
    },
    {
        ""id"": ""option_11fsddfew7898186"",
        ""name"": ""Color"",
        ""datatype"": ""mult"",
        ""optionList"": [
            {
                ""value"": ""optionItem_8fsddfew7898d857"",
                ""label"": ""Red"",
                ""active"": true
            },
            {
                ""value"": ""optionItem_d555fsddfew78981fe"",
                ""label"": ""Blue"",
                ""active"": false
            },
            {
                ""value"": ""optionItem_rs5fsd55846fptes"",
                ""label"": ""Yellow"",
                ""active"": false
            }
        ]
    }
]
```
",,
2152005827,3266,Different typing for SafeParseReturnType<T>,"## Behavior description

Nowadays, the **safeParse** and **safeParseAsync** - functions for parsing Zod schemas - return types are based on **SafeParseReturnType<T>**, this type is an union containing the following types:

- **SafeParseSuccess\<Output\>**

  ```ts
  export declare type SafeParseSuccessOutput<Output> = {
    success: true;
    data: output;
  }
  ```

- **SafeParseError\<Input\>**

  ```ts
  export declare type SafeParseError<Input> = {
    success: false;
    error: ZodError<Input>;
  }
  ```

## Behavior problem

This kind of behavior, besids applying bad practices by design - here I'm talking about having const values true and false for success instead of a boolean - also needs an explicit declaration on what type it should be. This situation causes more complexity in the user code - complexity that should be handled by the library itself and it's against the TypeScript idea of good inference and usability.

![307189632-6373aa6c-aa30-47f2-b511-56b028f866c8](https://github.com/colinhacks/zod/assets/70824102/19410396-b002-4ea5-b398-787810eb5960)

## Solution suggestion

My solution, for that case, would be implementing a single typing for **SafeParseReturnType<T>** without unions - in a way that will not break existing code and will correctly adapt to any situation that the previously implemented unions covered. 

Code:

```ts
export declare type SafeParseResult<InputOrOutput> = {
  success: boolean,
  data?: InputOrOutput,
  error?: ZodError<InputOrOutput>
}
```",,
2150146802,3263,Type for safeParseAsync not coming correctly,"The return type for safeParseAsync is not coming correctly, I can retrieve only the success item but not the error itself. I checked the typescript declarations and it contains some union (unnecessary because error or data could be added as optional fields - I mean, nullable ones). Is that the correct behavior? I'm kind of confused but I'm sure it is not.

![image](https://github.com/colinhacks/zod/assets/70824102/6373aa6c-aa30-47f2-b511-56b028f866c8)

![image](https://github.com/colinhacks/zod/assets/70824102/9cfef0a2-2e1e-45e8-8326-6b17816f3806)

They could just be like that:

![image](https://github.com/colinhacks/zod/assets/70824102/c133735d-e13e-40cb-9007-cf1c9ec45960)

",,
2145328507,3260,"Zod throws ""ReferenceError: x is not defined"" instead of ZodError with unions","I would expect z.union to throw a ZodError with a readable error message, instead I get `ReferenceError: x is not defined`

Created a small example to show and reproduce the error:

```typescript
import { describe, test, expect } from ""vitest"";
import { z, ZodError } from ""zod"";

const SchemaOne = z.object({
    foo: z.literal(""One""),
    bar: z.string(),
});

const SchemaTwo = z.object({
    other: z.literal(""Two""),
    hello: z.string(),
});

const BadTestSchema = z.union([SchemaOne, SchemaTwo]);

describe(""Test"", () => {
    test(""test"", () => {
        expect(() =>
            SchemaOne.parse({
                foo: ""One"",
                bar: ""Hello"",
            }),
        ).to.not.throw(); // Succeeds, does not throw

        expect(() =>
            SchemaOne.parse({
                foo: ""One"",
            }),
        ).toThrow(ZodError); // Succeeds, throws a ZodError

        expect(() =>
            BadTestSchema.parse({
                foo: ""One"",
            }),
        ).toThrow(ZodError); // Fails, throws ""ReferenceError: x is not defined""
    });
});
```

Error:
```
AssertionError: expected error to be instance of ZodError
Expected :[Function ZodError]
Actual   :[ReferenceError: x is not defined]
```

EDIT: I just discovered this issue existing on even the simplest unions, `z.string().or(z.number())`. I found that I do not have this issue when running directly in `node` but I do have the issue with vitest. ðŸ¤” I will see if I have the same issue with jest.",,
2142574612,3257,Map ZodEffects back to ZodObject,"I may be missing something, but there appears to be no way to assert that a `.preprocess`'d schema to a ZodObject again.

As a quick example:

```
// Preprocess so any usage of zWage first rounds to 4 decimal places
export const zWage = z.preprocess(x => isNumber(x) ? Math.round(x * 10000) / 10000 : x, z.number());

// Knowing that the schema is in actuality a z.number(), extend it using a .min()
zWage.min(34.345345).parse(myNumber);       // Property 'min' does not exist on type 'ZodEffects<ZodNumber, number, unknown>'.

```

Is there any way around this?",,
2142081166,3256,Custom error message shape,"Consider the following schema:
```ts
export const FileToUpload = z
  .instanceof(File)
  .refine((file) => file.size < FILE_SIZE_LIMIT, {
    message: `File size should be less than ${FILE_SIZE_LIMIT_MB} MB`,
  });
```
I'm using react-intl package from [FormatJS](https://github.com/formatjs/formatjs) for providing i18n and would like to be able to return a translation object instead of instead of a string, like:
```ts
export const FileToUpload = z
  .instanceof(File)
  .refine((file) => file.size < FILE_SIZE_LIMIT, {
    message: {
      id: 'uploaded_file_size',
      defaultMessage: `File size should be less than {max} MB`,
      values: { max: FILE_SIZE_LIMIT_MB },
    },
  });

```
The first solution that naturally comes to mind is this:
```ts
const useFileTuUploadSchema = () => {
  const intl = useIntl();

  return z.instanceof(File).refine((file) => file.size < FILE_SIZE_LIMIT, {
    message: intl.formatMessage({
      id: 'uploaded_file_size',
      defaultMessage: `File size should be less than {max} MB`,
      values: { max: FILE_SIZE_LIMIT_MB },
    }),
  });
};
```
Unfortunately, it doesn't solve my issue, because I need access to the actual translation object, not a formatted string (I render all translations in a custom component that allows admins to edit translations on the frontend)


Interestingly enough, returning a translation object instead of a string seems to work fine, but it's a terrible hack and would require shutting typescript errors, so do you have any suggestion here? 
Thanks a lot! ",,
2141198541,3254,Better understandable errors,"Let's take this simple example:

just put this anywhere in your codebase

`z.string().parse(5)`

this is the error you will get (as you should):

![image](https://github.com/colinhacks/zod/assets/47493928/f46c2534-6011-4bdf-9d79-a41e2fef5e25)

The default error needs to include the location of the error, line of code, and variable name... currently, I think it's really hard to locate errors without writing costume errors for everything (optional: if you don't want it to get to users we can throw an error with one message and return a simpler user-friendly error )",,
2139291130,3249,"'safeParse()' doesn't work in server component, complains about not being on the client-side.","Hello,
I'm getting this error, which I can't figure out.
```
Unhandled Runtime Error

Error: Attempted to call safeParse() from the server but safeParse is on the client. 
It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.
```
As far as I'm aware, safeParse is available to use on the server, please correct me if i'm wrong. I can't find any information at all about this error, nothing in GitHub issues or Google. Using parse() also returns the same error.
Here is my login.ts where I call safeParse:

```jsx
""use server"";

import * as z from ""zod"";
import { AuthError } from ""next-auth"";

import { signIn } from ""@/auth"";
import { LoginSchema } from ""../../ui/components/form/login"";
import { defaultLoginRedirect } from ""@/routes"";

export async function login(values: z.infer<typeof LoginSchema>,) {

        console.warn('Entering login function');
        console.warn('Execution context:', typeof window === 'undefined' ? 'server' : 'client');

        const validatedFields = LoginSchema.safeParse(values);    // This is where the error happens.
        console.log('Validation successful:', validatedFields);

        if ( ! validatedFields.success ) {

            return { error: ""Invalid fields!"" };

        };

        const { email, password } = validatedFields.data;

        try {

            await signIn(""credentials"", {
                email,
                password,
                redirectTo: defaultLoginRedirect,
            });

        } catch ( error ) {

            if ( error instanceof AuthError ) {
                switch ( error.type ) {
                    case ""CredentialsSignin"":
                        return { error: ""The username or password is incorrect."" }
                    case ""AdapterError"" || ""MissingAdapter"" || ""MissingAdapterMethods"":
                        return { error: ""The database is currently experiencing issues, please try again later."" }
                    case ""CallbackRouteError"":
                        return { error: ""The login failed to proceed. If you're using an external service such as GitHub, try making an account locally."" }
                    case ""InvalidCallbackUrl"":
                        return { error: ""The CallbackUrl was invalid. Make sure your browser allows cookies and doesn't change them."" }
                    case ""InvalidCheck"":
                        return { error: ""The login failed to proceed as some checks could not be performed. Make sure your browser isn't blocking cookies."" }
                    case ""InvalidEndpoints"":
                        return { error: ""Login via external providers is currently unavailable due to system issues."" }
                    case ""InvalidProvider"":
                        return { error: ""The system failed to recognise your authentication provider. Please retry the login process."" }
                }
            }

            throw error;

        };

}
```

and here is (part of) my login.tsx form, where I use login.ts: 
```jsx

    const onSubmit = (values: z.infer<typeof LoginSchema>) => {

        setError("""");
        setSuccess("""");

        startTransition(() => {
            login(values)
                .then((data) => {
                    setError(data?.error);
                    setSuccess(data?.success);
                })
        });
    };
```
Note that the form is a client component, so I wonder if that's it.",,
2138414001,3246,Type definition `ZodFirstPartySchemaTypes` is missing some first party schema types,"While trying to create an object which maps from `ZodFirstPartyTypeKind` to a function that takes the associated schema as argument, I found that `ZodReadonly` and `ZodSymbol` are missing from `ZodFirstPartySchemaTypes` union. The basic premise of the mapping is as follows.

```ts
type ZodFirstPartySchemaForType<T extends ZodFirstPartyTypeKind> = ZodFirstPartySchemaTypes extends infer Schema 
  ? Schema extends { _def: { typeName: T} } 
    ? Schema 
    : never
  : never;
type ZodSchemaMap = { [key in ZodFirstPartyTypeKind]: ZodFirstPartySchemaForType<key> };
```

Based on this mapping we could then infer which types are missing:

```ts
type MissingSchemaTypes = { [key in keyof ZodSchemaMap as ZodSchemaMap[key] extends { _def: never } ? key : never ]: true }
```

![image](https://github.com/colinhacks/zod/assets/11519728/93e7ca06-d7ce-4a0c-a4c4-662f4f4a7b69)

https://github.com/colinhacks/zod/blob/76c8ace1acd9fd713f99d3dca6a3f28320972eac/src/types.ts#L4941-L4976

Could be related to #2663",,
2137657238,3244,[Feature request] Reverse type inference,"First of all, I really love Zod! I tried a few validation libraries and Zod by far clicked with me the most. I especially love the TypeScript integration and how easy it is to create a pair of type/interface and validator (schema).

I think it would be amazing if (I'm not sure if this is implemented yet, I haven't found something similar) it would be possible to to _reverse type inference_. Something like this:

```typescript
interface MyType {
    firstName: string
    lastName: string
    age: number
    whatever?: boolean
}

const myTypeSchema = z.fromType<MyType>({
    firstName: z.string(),
    // error: lastName is missing
    age: z.string(), // error: invalid type
    extra: z.number() // error: extra
})
```

This would make using the library much easier if you already have a bunch of existing interfaces, especially if you cannot modify them. Basically, an equivalent of `z.object<T>` but instead of having an argument `schema: T` it would have an argument `schema: reverseInfer<T>`.

I currently use this pretty bad hack because I will never understand types in TypeScript, why are they even [turning complete](https://github.com/microsoft/TypeScript/issues/14833):

```typescript
({} as MyType) satisfies z.infer<typeof myTypeSchema>
({} as z.infer<typeof myTypeSchema>) satisfies MyType
```

This throws type errors if the schema isn't defined correctly.",,
2134262516,3239,"Union, can't access a field, as it does not exist in the other schema","I have this schema

```ts
const updateUserSchema = z.union([
  z.object({
    email: z.string().email().optional(),
    given_name: z.string().optional(),
    family_name: z.string().optional(),
    email_verified: z.enum(['true', 'false']).optional(),
    reset_password: z.enum(['true', 'false']).optional(),
  }),
  z.object({
    email: z.string().email().optional(),
    given_name: z.string().optional(),
    family_name: z.string().optional(),
    email_verified: z.enum(['true', 'false']).optional(),
    set_password: z.enum(['true', 'false']).optional(),
    password: z.string().optional(),
  }),
]);
```

After parsing, when I trie to check `data.reset_password`, I get the following error:

```bash
Property 'reset_password' does not exist on type '({ email?: string | undefined; given_name?: string | undefined; family_name?: string | undefined; email_verified?: ""true"" | ""false"" | undefined; reset_password?: ""true"" | ""false"" | undefined; } | { ...; }) & ({ ...; } | ... 1 more ... | undefined)'.
  Property 'reset_password' does not exist on type '{ email?: string | undefined; given_name?: string | undefined; family_name?: string | undefined; email_verified?: ""true"" | ""false"" | undefined; set_password?: ""true"" | ""false"" | undefined; password?: string | undefined; }'.ts(2339)
```

How am I supposed to check if a field exists?",,
2133762671,3237,Validations being skipped when using preprocessor,"I just came across an issue during an upgrade from 3.21.4 to 3.22.x that caused some of our tests to break. When validating an object, we expect to see an error object containing all of the failed validations. However, when using preprocessing functions, not all of the fields containing errors are appearing in the error object.

Example schema:
```ts
const schema = z.object({
  foo: z.string().min(4),
  bar: z.preprocess((val) => val, z.string().min(4)),
});

const values = {
  foo: ""abc"",
  bar: ""abc"",
};
```

Before 3.22.0, this would show errors in both `foo` and `bar`, but now only shows an error for `foo`. If you remove the preprocess, it works correctly and you get errors for both. If both fields have preprocessors, it seems a bit random -- maybe the order they are defined in determines where the validation stops, as we still only get `foo`.",,
2132907108,3235,[Feature Request] Allow preprocess even if schema validation fails,"our code has a very loose parse

```ts
const parseBasic = (data: any) => {
  const schema = z
    .object({
      name: z.string(),
      letter: z.preprocess(v => (v as string)?.toUpperCase(), z.enum(['A', 'B'])),
    })
    .describe('Basic');

  try {
    return schema.parse(data);
  } catch (error: any) {
    console.warn(schema._def.description + 'SchemaError', {
      ...error.issues,
    });

    return data;
  }
};

parseBasic({ name: 'Jay', letter: 'a' });
// { name: 'Jay', letter: 'A' }
 ```
 
 We love that it adds types to our json, and if the json schema is wrong it simply logs a warning. 
 
 
 But there is a few cases were we would like to preprocess the data prior to parsing incase the parsing fails, we would still like to have the preprocess. 
 Unfortunately there is no way to currently accomplish this. 
 
```ts
const parseBasic = (data: any) => {
  const schema = z
    .object({
      name: z.string(),
      letter: z.preprocess(v => (v as string)?.toUpperCase(), z.enum(['A', 'B'])),
      fieldThatDefDoesNotExisit: z.string(),
    })
    .describe('Basic');

  
  try {
    data = schema.preProcess(data);  // this does not currently exist
    return schema.parse(data);
  } catch (error: any) {
    console.warn(schema._def.description + 'SchemaError', {
      ...error.issues,
    });

    return data;
  }
};

parseBasic({ name: 'Jay', letter: 'a' });
// *logs warning*
// { name: 'Jay', letter: 'a' } <= ideally still would be  {name: 'Jay', letter: 'A' }'
```


   ",,
2131084432,3234,Parsing with a Zod.Default<> overwriting object with correct schema.,"Issue on my end, nevermind",,
2131071555,3233,"Using ""zod.infer"" in a specific object will cause the vs code typescript intellisense stuck forever in ""Loading...""","Hello gyes!

I'm new using zod as validator for objects. I have found a very frustrating bug! When I use zod infer to create a new type of object based on a zod object my visual studio code intellisense stops working. When this happen I got eternal vs code ""Loading..."" status message and in the bottom corner of the screen says ""Loading Intellisense Status..."" and this stays forever in this status when I try to use zod infer method.

Open the file ""src\app\comp1\constructionCompany\component\test.tsx"".

If we comment z.infer line the intellisense will work:
![Untitled](https://github.com/colinhacks/zod/assets/22732718/f238855a-d5a1-4d47-8a65-7d37c2972986)

If we uncomment z.infer line the intellisense will stop working in entire project:
![Untitled2](https://github.com/colinhacks/zod/assets/22732718/46cbe3f1-e45a-4721-bd37-56ae8afc4eda)

I created a repo where we can reproduce the error with the vs code intellisense. Basically to initialize the repo you should execute ""npm install"" and ""npx prisma generate"" to generate the schemas and objects from prisma database.

_**Repo: https://github.com/ADSNB/intellisense-bug-zod-infer**_

I'm very frustrated because I have spent some days to identify what exactly was breaking the intellisence in this project that I'm working and I was unable to find a fix yet on my own. I'm using zod with trpc prisma generator to create classes with automatic validation and this worked for simple tables without relation between them. But in this specific scenario we have a table called ""ConstructionCompany"" and another table ""ConstructionCompanyProject"" and this tables have an relation one to many. I guess when I use zod infer in this type of object for some reason this doesn't work. I tried to use developer console to check the console logs and analyse TS server logs but I didn't found anything that could indicates or solve this issue.

Any help is really appreciated. If you have any questions let me know.


",,
2129871320,3229,"Minimum length check does not work for numbers starting with 0, which is a problem for decimal numbers between 0 and 1","https://codesandbox.io/p/devbox/flamboyant-newton-lqcmtc?file=%2Fsrc%2Findex.ts%3A6%2C12&workspaceId=7d1f2f4a-ef98-44cd-8b46-d234f9380aba

Please refer the code sandbox link. 

Minimum length check works for 1, 1.42.  
It fails for all values starting with 0 e.g. 0, 0.42.

```ts
import test from ""node:test"";
import assert from ""node:assert/strict"";
import { z } from ""zod"";

const obj = z.coerce
  .number()
  .min(1, { message: `Field should have minimum 1 characters` });

const valid = 1;
const valid2 = 1.42;
const invalid = 0;
const invalid2 = 0.42;

test(""valid for 1"", () => {
  const result = obj.safeParse(valid);
  assert.ok(result.success);
  assert.equal(result.data, valid);
});

test(""valid for 1.42"", () => {
  const result = obj.safeParse(valid2);
  assert.ok(result.success);
  assert.equal(result.data, valid2);
});

test(""invalid for 0"", () => {
  const result = obj.safeParse(invalid);
  assert.ok(result.success);
  assert.equal(result.data, invalid);
});

test(""invalid for 0.42"", () => {
  const result = obj.safeParse(invalid2);
  assert.ok(result.success);
  assert.equal(result.data, invalid2);
});

```",,
2129188033,3228,z.infer return types any for my schema ,"I am attempting to create types with JSDoc from z.infer in my schema, but most of them are type any.

```js
//? -------- Sub Schema ---------
const tokenSchema = stringNonEmpty().length(128, { message: ""must be a 128-character string"" }).regex(hexRegex, { message: ""must be a hexadecimal string"" });
const tokenExpireSchema = stringNonEmpty(tokenExpireErrorMap).regex(durationRegex);
const numberSchema = z.coerce.number().int({ message: ""must be integer number"" }).positive({ message: ""must be positive number"" });


/**
 * @typedef {z.infer<typeof envSchema>} Env
 */

const envSchema = z.object({
	ACCESS_TOKEN_SECRET: tokenSchema,
	REFRESH_TOKEN_SECRET: tokenSchema,
	ACCESS_TOKEN_SECRET_EXPIRE: tokenExpireSchema,
	REFRESH_TOKEN_SECRET_EXPIRE: tokenExpireSchema,
	COOKIE_MAX_AGE: z.preprocess((x) => x || undefined, numberSchema.min(60_000)),
	DATABASE_URI: stringNonEmpty().regex(mongodbUriRegex, {
		message: ""must be a valid MongoDB URI"",
	}),
	DATABASE_NAME: stringNonEmpty(),
	NODE_ENV: z.enum([""development"", ""production""]).default(""development""),
	ALLOWED_ORIGINS: arrayFromString(z.string().url()),
	PORT: z.preprocess((x) => x || undefined, numberSchema.min(1).max(65_536).default(3000)),
});


try {
	/** @type {Env} */
	const ENV = envSchema.parse(process.env);
} catch (error) {
 ....
}

```

- `ENV`
![image](https://github.com/colinhacks/zod/assets/74573675/aab627c1-d06d-4b00-8627-1e384fad8852)

- `envSchema`
![image](https://github.com/colinhacks/zod/assets/74573675/b7cbaa35-4dbd-4531-becb-60b960c1dd74)


- utils functions used in my schema : 

```js
const stringNonEmpty = (errorMap = undefined) => {
	return z.string({ errorMap: errorMap }).min(1, { message: ""cannot be empty"" });
};

const arrayFromString = (schema, defult = """") => {
	return z.preprocess((obj) => {
		if (Array.isArray(obj)) {
			return obj;
		} else if (typeof obj === ""string"") {
			return obj.split("","");
		} else {
			return [defult];
		}
	}, z.array(schema).nonempty({ message: ""array cannot be empty"" }));
};
```",,
2127661961,3226,JavaToZod,"Hi,

Not sure if this is the wrong place to put this as it's not an issue as such. I am working on a Java/React project, so I wrote a parser to generate schemas automatically from my Java codebase. I though it might be useful to maybe one other person.

[https://github.com/buchananwill/javatozod](url)

Will #",,
2127506232,3225,Enum.extract() removes error messages,"If I declare an enum like

```ts
onst enumErrorMap = {
    errorMap: () => ({ invalid_type_error: ""Error Message"" }),
};

const TestEnum = z.enum(
    [
        ""value1"",
        ""value2"",
    ],
    enumErrorMap,
);
```

The error message works properly. However, if I do `const TestEnumTwo = TestEnum.exclude([""value1""]);`, the error map is lost. It looks like the code just creates a new enum and discards the `RawCreateParams` that were passed to the original enum.

https://github.com/colinhacks/zod/blob/a5a9d31018f9c27000461529c582c50ade2d3937/src/types.ts#L4065-L4076",,
2126428748,3222,Adding branded attribute in recursive type breaks compilation,"Let's take example with recursive types from README and add branded attribute:

~~~~~typescript
import { z } from 'zod'

const baseCategorySchema = z.object({
    branded: z.string().brand('Brand'),  // <--------------
    name: z.string(),
});

type Category = z.infer<typeof baseCategorySchema> & {
    subcategories: Category[];
};

const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
    subcategories: z.lazy(() => categorySchema.array()),
});
~~~~~

Now this code doesn't compile with following error:
~~~~~
.ts:12:7 - error TS2322: Type 'ZodObject<{ branded: ZodBranded<ZodString, ""Brand"">; name: ZodString; subcategories: ZodLazy<ZodArray<ZodType<Category, ZodTypeDef, Category>, ""many"">>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<Category, ZodTypeDef, Category>'.
  Types of property '_input' are incompatible.
    Type '{ branded: string; name: string; subcategories: Category[]; }' is not assignable to type 'Category'.
      Type '{ branded: string; name: string; subcategories: Category[]; }' is not assignable to type '{ branded: string & BRAND<""Brand"">; name: string; }'.
        Types of property 'branded' are incompatible.
          Type 'string' is not assignable to type 'string & BRAND<""Brand"">'.

12 const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
~~~~~

I'm using:
""zod"": ""^3.22.4""
""typescript"": ""^5.3.3""
",,
2119233048,3216,Dynamic error massage ,"```js
const schema: ZodType<FormData> = z.object({
  firstName: z.string().min(1, { message: ""First Name is required"" })
});

```

How can I include the field name in an error message when validating input? For example, predefined variable like PATH that will print the field name in the string, like this: 

```js
firstName: z.string().min(1, { message: ""First Name is required in PATH"" })
```",,
2115880627,3212,Officially support non-string error messages,"According to the typings error messages need to be strings. I'd love to use JSX here however to be more expressive (e.g. allow formatting, links, etc.). For historical reasons I'd like to not just use JSX, but actually a function that returns JSX, so I can pass some field specific meta data to the error message that is not available in the schema.

We used this pattern with yup in the past and I noticed that despite the typings this seems to actually work with zod as well:

```tsx
.refine(
  (value) => value === 17,
  () => ({
    message: (() => (
      <span>
        Cool error{' '}
        <span style={{ fontStyle: 'italic', color: 'green' }}>here</span>.
      </span>
    )) as any, // <--- any, because string is expected
  })
)
```

We use Formik currently and neither Formik or zod seem to make usage of the message. They pass it just forward and this pattern seems to work with all existing components that we have. It is just not ""officially"" supported and it would be awesome, if it could be. Thanks for all the work!

(FYI: I had the [same question](https://github.com/jquense/yup/issues/1233) some years ago with yup and they officially support this.)",,
2110311835,3205,Is there a way to have z.coerce.number() not nullable?,"As the title says. 

I'd like to use z.coerce.number() to be able to specify a number, and also parse it from path params into the number equivalent. But using z.coerce.number() it seems to set the `isNullable()` to true. Is there a way to not have that?",,
2110060855,3204,Documentation broken link,"In page https://zod.dev/ERROR_HANDLING?id=zodissue, when clicking on here ""You can see all the possible variants defined [here](https://zod.dev/src/ZodError.ts)."" 

I get

```src"" content=""https://opengraph.githubassets.com/1cac1150838995e1f7d1643c00eee51a5d884f2054f995c9d3225b07b0eddb39/colinhacks/zod"" /> alt"" content=""TypeScript-first schema validation with static type inference"" /> width"" content=""1200"" /> height"" content=""600"" />```",,
2109415810,3203,safeParse throws if catch throws,"This issue it related to the same problem described in #2401, but more specific to `.catch`.

My expectation of .catch was that I could catch some specific exceptions and then throw everything else, like every other catch statement in JS.

I get the point why in `.refine` every exception is considered an application-level bug, but I think in `.catch` it shouldn't be threated like that. The distinction could also be made that ZodError isn't an application-level bug.",,
2108370362,3201,"Is there a way to validate password and passwordConfirmation onChange, before other validations have passed? ","Is there a way to validate password and passwordConfirmation onChange, before other validations have passed? refine validates the passwordConfirmation after all validations.",,
2105271728,3199,How does it add ? in keys,"Hello, I am `Tahsin Ayman`. i was looking after solving a bug / contribute in this open source project but as i read the code i noticed something **confusing** ðŸ˜• . in the source code on line number `4464-4468`:
```ts
export class ZodOptional<T extends ZodTypeAny> extends ZodType<
  T[""_output""] | undefined,
  ZodOptionalDef<T>,
  T[""_input""] | undefined
> 
```
this is the code when i use `.optional()` class returns. here the `T[""_output""]` is the one causing the output hense it shows `undefined`
as mentioned in:
#3186 
but i'm not sure how does it even add `?` after keys when it's a object â“ 

e.g:
```ts
const schema = z.object({
  name: z.string().optional()
});
/*
type User = {
    name?: string | undefined;
}
*/
type User = z.infer<typeof schema>;
```
but when i create just `string().optional()`
```ts
const schema = z.string().optional()
/*
type User = string | undefined
*/
type User = z.infer<typeof schema>;
```
where does it even add `?` â” ",,
2103914670,3197,Bug: `z.record( z.any() )` filtering out `undefined` values,"`z.record( z.any() )` should allow any key and any value, but it seems to be filtering out `undefined` values.

```ts
console.log( z.object( { foo: z.any() } ).parse( { foo: undefined } ) ) // { foo: undefined }
console.log( z.record( z.any() ).parse( { foo: undefined } ) ) // {}, should be { foo: undefined }
```",,
2103642405,3196,"""Intersection results could not be merged"" does not mention the cause","### Discussed in https://github.com/colinhacks/zod/discussions/3194

<div type='discussions-op-text'>

<sup>Originally posted by **JoshuaKGoldberg** January 23, 2024</sup>
Zod is great and I'm enjoying the features around intersecting/merging objects. But for `.and`, when the intersections results can't be merged for some reason, the error message thrown at runtime doesn't provide any details.

> An error occurred.
> 
> ```plaintext
> Intersection results could not be merged
> ```
> 
> Stack Trace
> 
> ```plaintext
> ZodError: [
>   {
>     ""code"": ""invalid_intersection_types"",
>     ""path"": [],
>     ""message"": ""Intersection results could not be merged""
>   }
> ]
>     at get error [as error] (file:///Users/josh/repos/dot-com/node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs:538:31)
>     at ZodIntersection.parse (file:///Users/josh/repos/dot-com/node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs:638:22)
>     at /Users/josh/repos/dot-com/src/pages/rss.xml.ts:26:48
>     at Array.map (<anonymous>)

Not sure if this is a bug report or feature request, but: could the error message also include which field(s) are problematic?

Note that I'm not trying to report that the error is wrong. The error may be right - it just informative enough to explain why clearly.

Sorry that I'm not familiar enough with Zod to provide a standalone reproduction (I tried the Stackblitz Astro starter but couldn't get past TypeScript errors, amusingly). But here's how to get it on a real world project:

```plaintext
git clone https://github.com/JoshuaKGoldberg/dot-com
cd dot-com
git checkout 708081f # ncu-u-for-vite-5 branch
pnpm i
pnpm dev
open http://localhost:4321/rss.xml
```</div>",,
2103086279,3193,Proposal: Create a new schema with the types based on the describe value,"Is this possible or not?

seems the types are not showing here

```ts
export const Schema= z.object({
  __typename: z.literal('ProjectMember'),
  id: z.string(),
  attributeField: z.number().optional().nullable().describe('[attribute]'),
});
const SchemaWithAttributeOnly = Schema.pick(
  mapValues(
    Schema.shape,
    item => item.description?.startsWith('[attribute]') ? true : undefined,
  ),
);
```",,
2099564009,3187,Why is positive and negative functions uses zero as the minimum and maximum value?,"I'm reading different writings about if zero value is considered as `positive` but so far it all tells its neither positive nor negative.  Same goes with the `negative` function.  Although I can raise PR for this but just want to get the narrative first before I modify it. Thanks

```typescript
  positive(message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: ""min"",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }

  negative(message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: ""max"",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }
```
",,
2099316369,3186,optional should not add undefined to type signature,"I'm sorry if this is a duplicate, I could not find an existing issue or discussion that seemed to be exactly about the following. It's really rather simple: the following schema infers the wrong type

```typescript
const schema = z.object({
  foo: z.string().optional()
});
```
is inferred as
```typescript
type Schema = {
  foo?: string | undefined
};
```
when it should really be
```typescript
type Schema = {
  foo?: string
}
```

Let me showcase the issue with two different typescript playgrounds. They both have the same content, but the second has `exactOptionalPropertyTypes` enabled.

[`exactOptionalPropertyTypes: false`](https://www.typescriptlang.org/play?exactOptionalPropertyTypes=false#code/CYUwxgNghgTiAEYD2A7AzgF3nNBXCGAXPAN4BmSSA-MZjAJYoDmAvgFBv1kAUARBUl7xG2EHgIBKUm3izEqNEgggAdBCRNuOfBhUCVGJABkkYKMpMB3EDADCUNCG4SJAbjYsgA)

This playground errors, because even though we know that `foo` exists on `result` the compiler adds `undefined` to the set of possible types for `result.foo`.

[`exactOptionalPropertyTypes: true`](https://www.typescriptlang.org/play?exactOptionalPropertyTypes=true#code/CYUwxgNghgTiAEYD2A7AzgF3nNBXCGAXPAN4BmSSA-MZjAJYoDmAvgFBv1kAUARBUl7xG2EHgIBKUm3izEqNEgggAdBCRNuOfBhUCVGJABkkYKMpMB3EDADCUNCG4SJAbjYsgA)

And here we eliminated the error, because the compiler knows that **if** `foo` exists on `result` it **must** be exactly a `string`.

The problem to note here is that the decision to include `undefined` should be up to the **compiler**. Zod takes that decision away and subsequently makes it impossible to truly express optional keys.",,
2098736340,3185,Question: Type flow in a generic validator function,"Hey guys! I'm pretty new to Zod, I currently have a type issue while trying to create a typed generic validator function. It's about reflecting different status codes coming from an API service. It can receive different `method`s in the request body and delivers appropriate `status` in the response. The idea is to eventually have a generic fetch function, which automatically returns the correctly typed response and an union of all possible responses. As a first step, I'd like to define a generic validator function.

```ts
export const METHOD = {
  ADDRESS_CHECK: 'addressCheck',
  PHONE_CHECK: 'phoneCheck',
  EMAIL_CHECK: 'emailCheck',
  NAME_CHECK: 'nameCheck',
  POSTCODE_AUTOCOMPLETE: 'postCodeAutocomplete',
  CITY_AUTOCOMPLETE: 'cityNameAutocomplete',
  STREET_AUTOCOMPLETE: 'streetAutocomplete',
  FINISH_SESSION: 'doAccounting',
} as const

// getValues() lists all values of METHOD
export const MethodZ = z.enum(getValues(METHOD))

export type Method = z.infer<typeof MethodZ>

// Schemas in the values defined elsewhere (not relevant)
const StatusZ = z.object({
  [METHOD.ADDRESS_CHECK]: AddressCheckStatusSchema,
  [METHOD.PHONE_CHECK]: PhoneCheckStatusSchema,
  [METHOD.EMAIL_CHECK]: EmailCheckStatusSchema,
  [METHOD.NAME_CHECK]: NameCheckStatusSchema,
  [METHOD.POSTCODE_AUTOCOMPLETE]: GeneralStatusSchema,
  [METHOD.CITY_AUTOCOMPLETE]: GeneralStatusSchema,
  [METHOD.STREET_AUTOCOMPLETE]: GeneralStatusSchema,
  [METHOD.FINISH_SESSION]: GeneralStatusSchema,
})

const createStatusObjectSchema = <T extends Method>(method: T) => z.object({
  status: z.array(StatusZ.shape[method]),
})

const NameCheckStatusObjectZ = createStatusObjectSchema(METHOD.NAME_CHECK)

type NameCheckStatusObj = z.infer<typeof NameCheckStatusObjectZ>

// has any[] instead of the appropriate NameCheckStatus[]
type InnerStatus = NameCheckStatusObj['status']
```

Now, If `status` in `createStatusObjectSchema` is just `StatusSchema.shape[method]` (no array) the types flow correctly. But the API service returns a status array, so I need to have a `z.array(StatusZ.shape[method])`. This messes up the the type and `InnerStatus` is consequently `any[]`. 

I'm pretty sure that I'm missing something here but I can't figure it out on my own.

I'd appreciate any guidance. Thank you!",,
2098497621,3182,z.string().url() validates invalid urls,"zod: 3.22.4
nodejs: 20.11.0

I've encountered a couple of validations issue with urls:

```js
import { z } from 'zod';

const schema = z.string().url();

const res = schema.safeParse(""https://example"");

console.log('success', res.success)
console.log('error', res.error?.issues ?? [])
```

will return:
```
success true
error []
```

another case is:

```js
import { z } from 'zod';

const schema = z.string().url();

const res = schema.safeParse(""https://example.com/a b"");

console.log('success', res.success)
console.log('error', res.error?.issues ?? [])
```

that again will return:
```
success true
error []
```",,
2097828690,3180,Discriminated Union inside Discriminated Union,"I am trying to write a schema for the below type

```ts

type Bill = {
  billDate: string;
  billId: number;
  name: string;
  balance: number;
};

type MonthType = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;

type InvoiceDateType =
  | { isPartial: 0; invoiceMonth: 0; invoiceYear: 0 }
  | { isPartial: 1; invoiceMonth: MonthType; invoiceYear: number };

export type InvoiceType = Bill &
  (
    | ({ type: ""Invoice""; invoices: number } & InvoiceDateType)
    | {
        type: ""Payment"";
        paymentsAndCredits: number;
        isPartial: 0 | 1;
        invoiceMonth: MonthType;
        invoiceYear: number;
      }
  );
```

I am stuck here.

```ts
const billSchema = z.object({
  billDate: z.string(),
  billId: z.number(),
  name: z.string(),
  balance: z.number(),
});

const monthSchema = z.union([
  z.literal(1),
  z.literal(2),
  z.literal(3),
  z.literal(4),
  z.literal(5),
  z.literal(6),
  z.literal(7),
  z.literal(8),
  z.literal(9),
  z.literal(10),
  z.literal(11),
  z.literal(12),
]);

const invoiceDateSchema = z.discriminatedUnion(""isPartial"", [
  z.object({
    isPartial: z.literal(0),
    invoiceMonth: z.literal(0),
    invoiceYear: z.literal(0),
  }),
  z.object({
    isPartial: z.literal(1),
    invoiceMonth: monthSchema,
    invoiceYear: z.number(),
  }),
]);

const invTypeSchema = z.intersection( // I tried .and operator also
  z.object({
    type: z.literal(""Invoice""),
    invoices: z.number(),
  }),
  invoiceDateSchema,
);

const invoiceTypeSchema = z.discriminatedUnion(""type"", [
  invTypeSchema, // this always gives me error
  z.object({
    type: z.literal(""Payment""),
    paymentsAndCredits: z.number(),
    isPartial: z.union([z.literal(0), z.literal(1)]),
    invoiceMonth: monthSchema,
    invoiceYear: z.number(),
  }),
]);

export const invoiceSchema = billSchema.extend(invoiceTypeSchema); // still gives error
```",,
2097038180,3175,"""Intersection results could not be merged"" does not mention the cause","Zod is great and I'm enjoying the features around intersecting/merging objects. But for `.and`, when the intersections results can't be merged for some reason, the error message thrown at runtime doesn't provide any details.

> An error occurred.
> 
> ```plaintext
> Intersection results could not be merged
> ```
> 
> Stack Trace
> 
> ```plaintext
> ZodError: [
>   {
>     ""code"": ""invalid_intersection_types"",
>     ""path"": [],
>     ""message"": ""Intersection results could not be merged""
>   }
> ]
>     at get error [as error] (file:///Users/josh/repos/dot-com/node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs:538:31)
>     at ZodIntersection.parse (file:///Users/josh/repos/dot-com/node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs:638:22)
>     at /Users/josh/repos/dot-com/src/pages/rss.xml.ts:26:48
>     at Array.map (<anonymous>)

Not sure if this is a bug report or feature request, but: could the error message also include which field(s) are problematic?

Note that I'm not trying to report that the error is wrong. The error may be right - it just informative enough to explain why clearly.

Sorry that I'm not familiar enough with Zod to provide a standalone reproduction (I tried the Stackblitz Astro starter but couldn't get past TypeScript errors, amusingly). But here's how to get it on a real world project:

```plaintext
git clone https://github.com/JoshuaKGoldberg/dot-com
cd dot-com
git checkout 708081f # ncu-u-for-vite-5 branch
pnpm i
pnpm dev
open http://localhost:4321/rss.xml
```",,
2096942294,3174,I am working on a PHP library heavly inspired by zod.,"Are you interested (one the first stable version is ready) on a PR for the documentation to link it as something similar for another language?

https://github.com/chubbyphp/chubbyphp-parsing

About me: I switched from PHP to TS/JS about 3.5 Years ago and PHP is since then only a hobby, so i am a happy zod user.",,
2094063645,3170,make a new string-specific validations isLowerCase  &  isUpperCase,"I want to check whether the user input  ""username"" is in lowercase with Zod..but I couldn't find anything like isLowerCase, isUpperCase .",,
2093527416,3168,"I am getting ""Invalid email"" error with my company brand email address `<my name>@namespactit.com`.","I use `z` from zod and check my email like `z.string().email()`, but I am getting this error `Invalid email`. When I use my company email address as input `<my name>@namespaceit.com>`

#### Desc
> zod version `^3.22.4`
> nextjs version `^13.5.6`
> nodejs version `v20.10.0`
> tRPC version
>  ""@trpc/client"": `^10.38.4`,
    ""@trpc/next"": `^10.38.4`,
    ""@trpc/react-query"": `^10.38.4`,
    ""@trpc/server"": `^10.38.4`,

> error looks like

![email error](https://github.com/colinhacks/zod/assets/60110696/1d5e86d4-a4a2-4433-ba55-09201ff4084d)
![email error 2](https://github.com/colinhacks/zod/assets/60110696/e9b5d7f6-0c77-4a10-afca-47ee544583d7)



```ts
import { z } from ""zod"";


export const changeEmail = () => {
  return privateProcedure
    .input(
      z.object({
     // getting error from there---â†“â†“
        email: z.string().email(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const userWithTheEmail = await db.user.findFirst({
        where: { email: input.email },
      });

      if (userWithTheEmail) {
        throw new TRPCError({
          code: ""BAD_REQUEST"",
          message: ""Email already exists"",
        });
      }

      await db.user.update({
        where: {
          id: ctx.userId,
        },
        data: {
          email: input.email,
          isEmailVerify: email_verify_options === ""ON"" ? false : true,
        },
      });

      return { success: true, isEmailVerifyOption: email_verify_options };
    });
};
```

> What is the reason behind that?? How to solve the problem?",,
2092555084,3166,How to remove errors when input changed?,"the error now keeps

```
async function onSubmit(data: FormData) {
    setIsLoading(true);

    try {
      userAuthSchema.parse(data);

    } catch (error) {

    }
  }

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    // Reset errors when input value changes
   
  };

  return (
    <div className={cn(""mt-4 flex flex-col gap-4"")}>
      <form onSubmit={handleSubmit(onSubmit)}>
        <div className=""flex flex-col gap-2.5"">
          <div>
            <Label className=""sr-only"">
              Email
            </Label>
            <Input
              id=""acc""
              placeholder=""æ‰‹æœºå·""
              disabled={isLoading || isGithubLoading}
              {...register(""phone"")}
              onChange={handleInputChange}
            />
            {errors?.phone && (
              <p className=""mt-2 text-xs text-destructive"">
                {errors.phone.message}
              </p>
            )}
          </div>
```",,
2092091250,3164,"Constraining ZodTypeAny, for generic functions that receive some schema","Hello, I'm working in a project using NextJS 14, with server actions, and am trying to make a generic helper that parses FormData automatically for me, because it is super annoying to work with FormData and schemas by hand.

Currently I already have a solution that can automatically parse objects that don't have attributes that are arrays, but I will need those types of objects in the future, so the only way I could think of doing that is by checking if schema indexed at that key is an instance of a ZodArray.

But, because ZodTypeAny is essentially, an any, on strict mode, typecript doesn't let me do that. Here's the following code for the automatic parser, and it being used in a real case in my project.

### Parser

```ts
import { ZodArray, ZodTypeAny, z } from ""zod"";

export const parseFormData = <Z extends ZodTypeAny>(
  formData: FormData,
  schema: Z
) => {
  var data: z.infer<Z> = {};
  formData.forEach((_, key, parent) => {
    const value = parent.getAll(key);
    if (schema[key] instanceof ZodArray) {
      data[key] = value;
    } else {
      data[key] = value[0];
    }
  });
  if (schema.safeParse(data).success) throw new Error(""Invalid form data"");
  return data as z.infer<Z>;
};
```

### Use case

```ts
const credentialsSchema = z.object({
  email: z.string(),
  password: z.string(),
});

export const singIn = async (formData: FormData) => {
  const credentials = parseFormData(formData, credentialsSchema);
  const user =
    (await getUserByEmail(credentials.email)) ??
    (await saveUser(credentials.email, credentials.password));
  saveCookie(ACCESS_TOKEN, encode({ email: user.email, userId: user.id }));
};

```",,
2090498914,3162,deepPartial removes descriptions from optional and nullable fields,"The following simple schema loses its description after the `.deepPartial()` call. I found the cause to be the unwrapping happening in `deepPartialify`.

```js
const person = z.object({
        name: z.string(),
        age: z.number().optional().describe(""not everyone wants to say""),
}).deepPartial();
```

https://github.com/colinhacks/zod/blob/dd849254d1149bc1f2ef0f47f0f7607955e4db85/src/types.ts#L2215-L2243

To fix the issue there are multiple options:
- remove the checks for ZodOptional and ZodNullable meaning the resulting ZodObject could have nested ZodOptionals
- call `.describe()` on the unwrapped schema if the unwrapped schema has no description and the initial schema had a description

In our case both of these are valid helpful solutions and created a hotfix to a copy for the latter approach. Since we have a hotfix this issue has no prio at all. Just wanted to raise awareness to the issue and can gladly create a PR with a hotfix for the prefered approach.

Thanks for this amazing library!",,
2088632630,3157,z.input for .readonly should infer ZodReadonly,"Now `ZodReadonly` inferred from `z.output` or `z.TypeOf`, but not from `z.input`
IMO it's incorrect and `z.input` also should infer `ZodReadonly` when `.readonly` used",,
2088324746,3156,beginner question: z.infer(),"Hello,

i have a beginner question:
```js
const cb = () => z
    .function()
    .args(z.number())
    .returns(z.string());

const myCalculator1 = z
    .function()
    .args(z.number(), z.number(), cb()
    )
    .returns(z.string())
    .implement((num1, num2, cb) => {
        let sum = num1 + num2;
        let value = cb(sum);
        return value;
    });

type myFunction = z.infer<typeof myCalculator1>;
```

![image](https://github.com/colinhacks/zod/assets/44213573/57b19b56-abb7-401c-ab9c-c6b7cb0d3da8)
- what is here the problem?

best wishes.",,
2087741512,3155,Email validation does not validate emails according to RFC standards,"It seems that Zod email validation accepts emails that are not conforming to RFC specifications.

"" In addition to restrictions on syntax, there is a length limit on  email addresses.  That limit is a maximum of 64 characters (octets)  in the ""local part"" (before the ""@"") and a maximum of 255 characters (octets) in the domain part (after the ""@"") for a total length of 320 characters.  Systems that handle email should be prepared to process addresses which are that long, even though they are rarely  encountered."" 

So the issues is that Zod does not count total number of chars or separate ""local part"" and ""domain part"".

Should I open a PR or is this something that is already on someones table?",,
2087600479,3154,Missing invalid discriminator key in 'invalid_union_discriminator' error object,"When using `discriminatedUnion` and providing an invalid key, the error object does not contain the received invalid discriminator key. 

## Example

```ts
const schema = z.discriminatedUnion('__typename', [
  z.object({
    __typename: z.literal('block-1'),
  }),
  z.object({
    __typename: z.literal('block-2'),
  }),
]);

const data = {
  __typename: 'block-3',
};

const parsed = schema.safeParse(data);
```

The parsed error object currently returns:

```ts
{
    ""success"": false,
    ""error"": {
        ""issues"": [
            {
                ""code"": ""invalid_union_discriminator"",
                ""options"": [
                    ""block-1"",
                    ""block-2""
                ],
                ""path"": [
                    ""__typename""
                ],
                ""message"": ""Invalid discriminator value. Expected 'block-1' | 'block-2'""
            }
        ],
        ""name"": ""ZodError""
    },
}
```

Expected error object:

```ts
{
    ""success"": false,
    ""error"": {
        ""issues"": [
            {
                ""code"": ""invalid_union_discriminator"",
                ""options"": [
                    ""block-1"",
                    ""block-2""
                ],
                ""received"": ""block-3""
                ""path"": [
                    ""__typename""
                ],
                ""message"": ""Invalid discriminator value. Expected 'block-1' | 'block-2'. Received 'block-3'""
            }
        ],
        ""name"": ""ZodError""
    },
}
```
`zod 3.22.4`",,
2084653723,3149,[Help] How to create a union where the types' properties are required,"I'm trying to create a zod schema from either the union of 2 types, however, when using one of the types (e.g., `typeB` below), all of its properties must be included.
Any help? ðŸ˜ƒ
- See sandbox with unit tests

For the following these 2 types:

```ts
const typeA = {
    version: ""v1"";
    textSizeOffset: number;
};

const typeB = {
    version: ""v1"";
    textHorizontalAlign: ""left"" | ""center"" | ""right"";
    textVerticalAlign: ""center"" | ""top"" | ""bottom"";
};
```

I'd like the schema to validate against the following examples:

```ts
const valid1: Schema = {        // âœ… OK
  version: 'v1',
  textSizeOffset: 0,
  textHorizontalAlign: 'left',
  textVerticalAlign: 'top',
};

const valid2: Schema = {        // âœ… OK
  version: 'v1',
  textSizeOffset: 0
};

const valid3: Schema = {        // âœ… OK
  version: 'v1',
  textHorizontalAlign: 'left',
  textVerticalAlign: 'top',
};

const invalid: Schema = {        // âŒ NOT OK
  version: 'v1',
  textSizeOffset: 0,
  textHorizontalAlign: 'left',
};
```

I've unsuccessfully tried these two options:

```ts
const schema = z
  .intersection(textAligment, textSizeOffset)
  .or(textAligment)
  .or(textSizeOffset);

const schema = z.union([
  textAligment,
  textSizeOffset,
  textAligment.merge(textSizeOffset),
]);
```",,
2084562135,3147,Uncaught Error: ," [ERROR] service core:user:true-report-v2-development: Uncaught Error: (params) => {

    var _a;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a
  !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  } not implemented
    at null.<anonymous> (index.worker.js:75235:9) in y
    at null.<anonymous> (index.worker.js:75251:16) in b
    at null.<anonymous> (index.worker.js:75234:12) in y
    at null.<anonymous> (index.worker.js:75343:87) in getSchemaZod
    at null.<anonymous> (index.worker.js:75179:21)
    at null.<anonymous> (index.worker.js:84264:8)


X [ERROR] MiniflareCoreError [ERR_RUNTIME_FAILURE]: The Workers runtime failed to start. There is likely additional logging output above.",,
2084391319,3146,Enum error message cannot be customized,"According to #580 , custom error message for enum should be like this.

```ts
z.enum(['aaa', 'bbb', 'ccc'], {
  errorMap: () => ({ message: 'custom error message' })
})
```

which is counterintuitive. Though enum params also provided `required_error` and `invalid_type_error`, they are not working for custom errors.

Also, I assume `required_error` and `invalid_type_error` are the same for enum, so I hope custom error message should be like:

```ts
z.enum(['aaa', 'bbb', 'ccc'], { message: 'custom error message' })
```",,
2084099145,3144,Infer strict type for empty object,"With the following code, `Empty` is inferred as `{}`. But `{}` in TypeScript matches any object, not just the empty object. Is there any way to infer a more strict type, such as `Record<string, never>`?

```ts
const empty = z.object({});
type Empty = z.infer<typeof empty>;
const myObject: Empty = {
  foo: ""bar"", // I want this to fail!
};",,
2084056144,3143,"[Suggestion] Parse option that expects Output type as argument, to be used for casting default values","Hi,
I am trying to use Zod for both validation and casting tool, so that I can define my buissness logic default values there and then I can pass a partly object to it and it fill up the gaps, a.k.a default values.

for example:

```ts
const userSchema = z.object({
	id: z.string(),
	coins: z.number().int().nonnegative().default(0),
});

const parsedUser = userSchema.parse({
	id: '123'
});
```
now that would work as intended, but the problem is that if I will add another mandatory field, for example `firstName`, all the places where I used user.parse() for filling in default values would break, and I wouldn't know about it on build time.
A workaround that I can do is either wrapping it under my own function, or do:
```ts
const parsedUser = user.parse({
	id: '123'
} satisfies z.infer<typeof userSchema >);
```

But having this as a built in option would be really helpful.",,
2083294638,3142,Make `safeParse` always return a `data` property,"## Make `safeParse` always return a `data` property

Why? Because everytime I use `safeParse` I have to do this:

```ts
const handle = (data: any) => {
  // Can't destructure `data` here ðŸ˜”
  const parsed = mySchema.safeParse(data)

  if (!parsed.success) {
    return
  }

  // Have to destructure again here ðŸ˜”
  const { email, password } = parsed.data
}
```

I would like to do this instead:

```ts
const handle = (payload: any) => {
  // Can destructure everything here ðŸ˜Ž
  const { success, data, error } = mySchema.safeParse(payload)

  if (!success) {
    /**
     * In this case:
     * - `data` is `null`
     * - `error` is a `ZodError` instance
     * - `success` is `false`
     */
    return
  }

  /**
   * In this case:
   * - `data` is the parsed value
   * - `error` is `null`
   * - `success` is `true`
   */
  const { email, password } = data
}
```

This way, all the properties on the return value of `safeParse` can be destructured and used directly instead of having to do the `if` check and then destructuring the `data` property.",,
2081862616,3139,`Satisfies` fails when using `preprocess`,"Version: 3.22.4.

The following minimal example code snippet
```typescript
const testSchema = z.preprocess((value) => value, z.array(z.string())) satisfies z.ZodType<string[]>;
```
produces this error:
```
Type 'ZodEffects<ZodArray<ZodString, ""many"">, string[], unknown>' does not satisfy the expected type 'ZodType<string[], ZodTypeDef, string[]>'.
  Types of property '_input' are incompatible.
    Type 'unknown' is not assignable to type 'string[]'
```
If we remove `satisfies`, the type is inferred correctly (`string[]`). 


",,
2080525973,3136,Type error when combining `catchall` and `array`,"Hi everyone. Thank you very much for the great work on zod!

I am getting an error with the following code:

```typescript
const team = z
    .object({
        members: z.array(z.object({
            name: z.string(),
        })),
    })
    .catchall(z.array(z.string()));
type Team = z.infer<typeof team>;

const t1: Team = {
    members: [
        { name: 'Alice' },
    ],
    aliases: ['a', 'b'],
};
```

The error message is:

```
TS2322: Type
  {
    members: {
      name: string;
    }[];
    aliases: string[];
  }
is not assignable to type
objectOutputType<{
  members: ZodArray<ZodObject<{
      name: ZodString;
    }, 'strip', ZodTypeAny, {
      name: string;
    }, {
      name: string;
    }>, 'many'>;
  },
  ZodArray<ZodString, 'many'>,
  'strip'
>

Type
  {
    members: {
      name: string;
    }[];
    aliases: string[];
  }
is not assignable to type
{ [k: string]: string[]; }

Property members is incompatible with index signature.
Type { name: string; }[] is not assignable to type string[]
Type { name: string; } is not assignable to type string
```

It seems to be a bug to me - or is `catchall()` simply not designed to be used this way?

(I'd love to receive suggestions for a workaround.)",,
2080237963,3133,Type Narrowing Not Retained in Chained Array Methods with safeParse,"
When using Zod's safeParse in conjunction with TypeScript's array filter method, the type narrowing does not persist to the subsequent map method.
The workaround involves using mySchema.parse(item) in map, which correctly infers the type, but it seems redundant to call parse after safeParse has already been used. 
Is there a more streamlined way to achieve this without the additional parsing line? Ideally, the type should be correctly narrowed without requiring a second parsing step. 

**Example:**
```typescript
// Incorrectly inferred type
const result = myArray
    .filter(item => mySchema.safeParse(item).success)
    .map(item => item.property);  // Type of 'item' is not correctly narrowed

// Correctly inferred type with type assertion
const correctResult = myArray
    .filter(item => mySchema.safeParse(item).success)
    .map(item => mySchema.parse(item))
    .map(item => item.myField); // Type of 'item' is correctly inferred 
```

",,
2077201281,3130,String tag validation,"While I understand Zod tracks TypeScript closely, one important, as-yet-unsupported validation feature for the non-JSON JavaScript which Zod is capable of handling, is for string tag checks, i.e., the result of calling:

```js
Object.prototype.toString.call(obj).slice(8, -1)
```

...on an object and validating against the result). So something like:

```js
z.stringTag('ArrayBuffer');
```

This remains a well-used mechanism by which built-in types in the browser or server are distinguishable, and it is often such targeting which is desired by an app over duck-typing. While this could be added by refinement, I think it fits more as a fundamental feature.",,
2076662695,3129,Feature request: allow .required() and .partial() on discriminatedUnion,"My goal is to be able to achieve the following:

```ts
export const jwkSchema = z.discriminatedUnion('kty', [
  jwkRsaKeySchema,
  jwkEcKeySchema,
  jwkEcSecp256k1KeySchema,
  jwkOkpKeySchema,
  jwkSymKeySchema,
])

export const jwkWithKidSchema = jwkSchema.require({ kid: true })
```

Meaning that I want to be able to use `z.object` (namely `.required()`) methods on the result of a `discriminatedUnion` (all member of which are objects).",,
2074932520,3127,TypeScript Error in Discriminated Union,"### Code
```typescript
const paymentMethods = [
  ""COD"",
  ""CREDITCARD"",
  ""DEBITCARD"",
] as const;

const methodsEnum = z.enum(paymentMethods);

const PaymentValidator = z.discriminatedUnion(
  ""methods"",
  paymentMethods.map((pm) => {
    if (pm !== ""COD"") {
      return z.object({
        methods: z.literal(methodsEnum.enum[pm]),
        amount: z.number(),
        transaction_id: z.string(),
      });
    }
    return z.object({
      methods: z.literal(methodsEnum.enum.COD),
      amount: z.number(),
    });
  }),
);
```
### Issue Description
The provided TypeScript code for a discriminated union using Zod is producing the following error:
Given code is showing typeScript error 
```sh
Argument of type '(ZodObject<{ methods: ZodLiteral< ""CREDITCARD"" | ""DEBITCARD"">; amount: ZodNumber; transaction_id: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }> | ZodObject<...>)[]' is not assignable to parameter of type '[ZodDiscriminatedUnionOption<""methods"">, ...ZodDiscriminatedUnionOption<""methods"">[]]'.
Source provides no match for the required element at position 0 in the target.
```
However, the code seems to work as intended during runtime. When using PaymentValidator.safeParse, the validation results are as expected. Despite this, TypeScript errors persist.

### Expected Behavior
The TypeScript code should not produce the mentioned error, given that the runtime behavior appears correct.
### Additional Information
* Zod Version: 3.22.4
* TypeScript Version: 5.3.3

Any insights or suggestions to address this TypeScript error would be greatly appreciated. Thank you!",,
2074090247,3123,Order of z.object props with preprocess gives wrong parse results,"Version: **3.22.4**

It seems that Zod is unable of properly validating props with `preprocess` if they are not placed at the beginning of the Zod Object.

The following schema should always return an error for `second`.
```ts
const schemaWrong = z.object({
  first: z.string(),
  second: z.preprocess(() => undefined, z.string()),
});

schemaWrong.safeParse({}) // Shows only 1 error in `first`
```

If we switch the order of the props, then it works: 
```ts
const schemaFixed = z.object({
  second: z.preprocess(() => undefined, z.string()),
  first: z.string(),
});

schemaWrong.safeParse({}) // Correctly shows 2 errors.
```

Playground: https://stackblitz.com/edit/typescript-wqj5ep?file=schemas%2FschemaWithDefaultType.ts

Note: Version **3.21** works correctly",,
2073438821,3122,Discussion: Simplify `.safeParse()` response type to include `error: null` for a better dev experience,"Currently, `safeParse()` and `safeParseAsync()` have the following typings:

```typescript
safeParse(data: unknown, params?: Partial<ParseParams>): SafeParseReturnType<Input, Output>;
safeParseAsync(data: unknown, params?: Partial<ParseParams>): Promise<SafeParseReturnType<Input, Output>>;
```

`SafeParseReturnType<Input, Output>` is further defined into:

```typescript
type SafeParseReturnType<Input, Output> = SafeParseSuccess<Output> | SafeParseError<Input>;

type SafeParseSuccess<Output> = {
    success: true;
    data: Output;
};
type SafeParseError<Input> = {
    success: false;
    error: ZodError<Input>;
};
```

We use Jest heavily in our code base and we try to refrain from casting as much as possible (Granted there are use cases)

As a simple example:
```
      test('Expect Parse to Fail', () => {
        expect.assertions(3);
        const result = ExampleZodFilter.safeParse(input);
        expect(result).toBeTruthy();
        expect(result.success).toBeFalse();
        expect(result.error).toBeInstanceOf(ZodError); //TS Exception as error does not exist in the response type
      });
```

It has become somewhat of an annoyance having to add additional assertions to validate that `result.error` does exist on the returned type. Currently the easiest way this is being done is by essentially using `success` as a discriminator and casting the response type.
_(I am totally open to suggestions on better ways to go about this.)_

That being said, my question is why not simply add `error: null` on the success type to make it easier on the developer experience and type inference? 

If there is some other reason why the type is being handled this way I would genuinely be interested in understanding the ""Why"".
",,
2069136054,3119,feat: function implement with comment,"function implement has some issues: no parameter name ,no Generics,no comment.....
I have come up with a method to provide annotations for 'implement'

![image](https://github.com/colinhacks/zod/assets/9607121/5e52165b-8e6d-473b-8fa3-96f65a1ea30e)
```ts
  type FunctionWithComment<FNType , Comment > =FNType&Comment
  function mock<FNType extends (...args: any[]) => any, COMMENT extends string>(
    fn: FNType,
    comment: COMMENT
  ): FunctionWithComment<FNType, COMMENT> {
    return fn as any;
  }
  
  let withComment = mock(() => {}, 'this is comment');

  withComment()
```
I don't know if this implementation method is acceptable?

",,
2068482549,3114,The required error message is not functioning properly,"I have the same problem as mentioned [here](https://stackoverflow.com/questions/77118018/zod-schema-not-triggering-required-error-for-empty-strings#:~:text=The%20required_error%20property%20in%20Zod%20triggers%20only%20if,at%20least%201%2C%20ensuring%20the%20field%20isn%E2%80%99t%20empty.)

thing i have tried : 
- using  `required_error:`
- using `required()`
- using `{ required: ""lastName is required"" }`  in react hook form
- using `rules={{ required: ""first name is required"" }}`  in `Controller `component (react hook form)

```jsx
const registerSchema = z
	.object({
		email: z.string({ required_error: ""firstName is required"", invalid_type_error: ""firstName must be a string""}).email().trim().toLowerCase().min(3).max(20),
	.required() // makes all properties required.
	});
	
const {
		register,
		handleSubmit,
		control,
		formState: { errors, isSubmitSuccessful},
	} = useForm({
		mode: ""onBlur"", // when to validate the form
		resolver: zodResolver(registerSchema ),
	});
	
	....
<>
	<Controller
				defaultValue=""""
				rules={{ required: ""first name is required"" }}
				name=""firstName""
				control={control}
				render={({ field: { name, ...field }, fieldState: { invalid, error }, formState }) => <TextField {...field} label=""First Name"" error={!!error} helperText={error?.message} sx={{ gridColumn: ""span 2"" }} />}
		/>
		<TextField {...register(""lastName"", { required: ""lastName is required"" })} label=""Last Name"" error={!!errors.lastName} helperText={errors.lastName?.message} sx={{ gridColumn: ""span 2"" }} />	
		<TextField {...register(""location"")} label=""Location"" error={!!errors.location} helperText={errors.location?.message} sx={{ gridColumn: ""span 4"" }} />
		<TextField {...register(""job"")} label=""Job"" error={!!errors.job} helperText={errors.job?.message} sx={{ gridColumn: ""span 4"" }} />
		<TextField {...register(""picture"")} label=""Picture"" error={!!errors.picture} helperText={errors.picture?.message} sx={{ gridColumn: ""span 4"" }} />
</>
```",,
2068130797,3112,Feature Request | Question: Reference the input value in the error message?,"**On validation, I would like to be able to reference the input value in the error message.**

For example, given that my schema looks like this...
```
const mySchema = z.object({
  numberOfDays: z.number({
    invalid_type_error: ""Sorry, that is not a valid number.""
});
```

...then I would like to _instead_ be able to return an error message like:
**""Sorry, 'seven' is not a valid number.""**

I'm imagining something like either:

```invalid_type_error: ""Sorry, '{{value}}' is not a valid number.""```

Or better yet:

```invalid_type_error: (val) => `Sorry, '${val}' is not a valid number.""```

Is this already possible? If not, could this be added in the future?
",,
2067031002,3108,Wrong type after parse,"Hi all!

I have written this schema:

```ts
export const createEmployeeAbsence = z
  .object({
    startDate: z.date(),
    endDate: z.date().optional(),
    employeeId: z.string(),
    absence: absenceReasons,
  })
    .superRefine((val, ctx) => {
      if (val.absence !== ""LONGTERMSICK"" && val.endDate === undefined) {
        return ctx.addIssue({
          code: z.ZodIssueCode.invalid_date,
          message: ""Slutdato skal vÃ¦re udfyldt"",
          path: [""endDate""],
        })
      }

    if (
      val.endDate &&
      isBefore(val.endDate, val.startDate) &&
      val.absence !== ""LONGTERMSICK""
    ) {
      return ctx.addIssue({
        code: z.ZodIssueCode.invalid_date,
        message: ""Slutdato skal vÃ¦re efter startdato"",
        path: [""endDate""],
      })
    }
  })
  .transform((val) => {
    if (val.absence === ""LONGTERMSICK"") {
      return {
        ...val,
        endDate: generateUTC(new Date(2150, 0, 1)),
      }
    }

    return val
  })
  ```
  
I try to prompt the user to always provide an endDate unless absence of LONGTERMSICK is chosen, hence the first issue in the superrefine. If LONGTERMSICK is chosen, then I will transform the endDate to a date. So in every case, the endDate will be set.

When I try to parse the schema, the endDate type is set to Date | undefined. 

I dont know if this is an bug or just me?

Thank you in advance! :)",,
2064644707,3105,`custom` should exist on the method chain instead of only at the root,"Hello, and thanks for the excellent library.

I want to use Zod to type assert a value to a known type. For example:

```ts
const numPlayers = z.number().int().min(2).max(100);
type NumPlayers = z.infer<typeof numPlayers>;
type RealNumPlayers = IRange<2, 100>; // 2 | 3 | 4 | ... | 100
```

Here, `NumPlayers` is `number`, which is not really correct. It should actually be equal to `RealNumPlayers`.

I'm fine with Zod not doing this automatically under the hood, as that would probably have performance implications for large numbers. However, I want the ability to do it myself. So I need a way to type assert a value after Zod has already performed its validation.

## Existing Solution: `z.custom`

The `z.custom` function allows you to perform a type assertion. For the above example, it would look like this:

```ts
const numPlayers = z.custom<RealNumPlayers>(
  (val) => typeof val === ""number"" && Number.isInteger(val) && val >= 2 && val <= 100
);
```

But this is not ideal, because we are having to duplicate all of the Zod functionality ourselves in app-side TypeScript, which is much more verbose. It would be better if we could utilize Zod like this:

```ts
const numPlayers = z.number().int().min(2).max(100).custom<RealNumPlayers>();
```

But this pattern doesn't work because `custom` only exists at the root instead of along the method chain! Thus, this issue is to request that it be added there.

## Discussion on `z.refine`

Even though `z.custom` does not exist on the method chain, `z.refine` does. But unfortunately `z.refine` does not have the ability to take in a generic parameter. So we can't use it for this purpose. It might be possible for Zod to add a generic parameter to `z.refine` to fix this problem. But then it seems like we would just be duplicating the functionality of `z.custom`, which would be confusing.

Thus, I think `z.refine` should be used for ""extra validation without changing the type"" and I think `z.custom` should be used for ""changing the type, with or without additional validation steps"".",,
2064621815,3104,TypeScript Mismatch using Pick or Omit,"I have a NestJS application using Prisma and Zod, where I define a `StoreOwnerModel` representing a database table with all fields, and a `StoreOwnerEntity` which is a minimal representation containing only specific fields for frontend responses.

I have the following function to retrieve a single `StoreOwnerEntity` based on the `storeOwnerId`:

```typescript
async getOne(storeOwnerId: number): Promise<StoreOwnerEntity> {
  const storeOwnerOfTypeModel = await this.prismaService.storeOwner.findUniqueOrThrow({
    where: { id: storeOwnerId },
  });

  // My question is why TypeScript is not throwing an error here, even though
  // I'm trying to return a `StoreOwnerModel` instead of the expected `StoreOwnerEntity`.
  // Shouldn't there be a type mismatch error since the return type is declared as `StoreOwnerEntity`?

  // return storeOwnerOfTypeModel; // No TypeScript Error
  return this.storeOwnerEntityMapper.modelToEntity(storeOwnerOfTypeModel);
}
```

Additionally, I've defined a `StoreOwnerEntitySchema` using Zod with only the necessary fields:

```typescript
export const StoreOwnerEntitySchema = StoreOwnerSchema.pick({
  id: true,
  email: true,
});

export class StoreOwnerEntity extends createZodDto(StoreOwnerEntitySchema) {}
```

```typescript
export const StoreOwnerSchema = z.object({
  id: z.number().int(),
  email:  z.string().email();,
  createdAt: z.date().default(new Date()),
});
```

I would appreciate insights into why TypeScript is not throwing an error in this case and guidance on ensuring type safety when mapping and returning entities. Thank you!",,
2064163093,3103,add method to find if the given field is required,"I recently ran into a scenario where I need to know if the given field is required or not. but I was unable to find any solution for it. something like this would be nice. e.g.:
```ts
ZodSchema.isRequired(""fieldName"")
```",,
2063170407,3102,Getting a weird issue with parsing my zod schema,"So basically I've a Form with `email`, `password` and `confirm_password`. and bind values with each inputs.
and a zod schema:
```ts
const schema = z
    .object({
        email: z.string().email(""Please enter a valid email address""),

        password: z
            .string()
            .min(8, ""atleast_8"")
            .refine((val) => /(?=.*[!@#$%^&*()_+|~\-=?;:'"",.<>{}[\]\\/])/.test(val), ""missing_one_special_character"")
            .refine((val) => /(?=.*\d)/.test(val), ""missing_one_number"")
            .refine((val) => /(?=.*[A-Z])|(?=.*[a-z])/.test(val), ""missing_one_upper_or_lowercase""),

        confirm_password: z.string()
    })
    .superRefine(({ password, confirm_password }, ctx) => {
        if (!_.isEqual(password, confirm_password)) {
            ctx.addIssue({
                code: z.ZodIssueCode.custom,
                message: ""<b>Password</b> and <b>Confirm Password</b> doesn't match"",
                path: [""confirm_password""]
            });
        }
    });
```

Issue is when I type email first - it validates
then password - validates
but then confirm_password - not validating properly ( even tho value is same as password )

But the thing is, this isnt causing in order.
If I type password and confirm_password first ( not touching email ) then it validates. But if I type email after that ( not validating ).

Here is the visual modal:
![Screenshot from 2024-01-03 07-45-55](https://github.com/colinhacks/zod/assets/114811070/8d8ff012-cbc9-4a9a-94f2-dcdfd967bcf9)


And here is how I parse:

Form like:
```svelte
<form>
    <input bind:value={form_data.email} on:input={handleInput} name=""email"" />
    <input bind:value={form_data.password} on:input={handleInput} name=""password"" />
    <input bind:value={form_data.confirm_password} on:input={handleInput} name=""confirm_password"" />
</form>
```

Functions:
```ts
function handleInput() {
    try {
        schema.parse(form_data);
    } catch (err) {
        if (err instanceof z.ZodError) {
            form_errors = err.formErrors.fieldErrors;
            // console.log(err);
        }
    }
}
```

Variables:
```ts
let form_data = {
    email: """",
    password: """",
    confirm_password: """"
}, form_errors: {
    email?: string[],
    password?: string[],
    confirm_password?: string[]
} = {};
```

Error checking be like:
```svelte
{#if form_errors.email}
    <span>{form_errors.email[0]}</span>
{:else}
    <span>helptext</span>
{/if}
```

LMK if you need any more informations :) I already spend hours debugging this :"")",,
2062835304,3101,Empty error message gets evaluated as falsy and overriden,"Doing this

```ts
import z from 'zod';

z.number().min(0, { message: '' }).parse(-1);
```
Results in an error of 
```
Error: [
{
""code"": ""too_small"",
""minimum"": 0,
""type"": ""number"",
""inclusive"": true,
""exact"": false,
""message"": ""Number must be greater than or equal to 0"",
""path"": []
}
]
```
instead of having an empty message.

Would it be possible to explicitly check if the message is undefined rather than checking if it's falsy? After asking this on the Discord scotttrinh found the line causing this

https://github.com/colinhacks/zod/blob/3e4f71e857e75da722bd7e735b6d657a70682df2/src/helpers/parseUtil.ts#L31
",,
2062042026,3100,deepPartial doesn't work with superRefine,"Given a schema with an object child which has superRefine, the deepPartial on the parent schema does not make the child's entries optional",,
2061838919,3099,Cannot use z.infer. Property 'infer' does not exist on type ,"Version zod: `^3.22.4`
When I try to use` z.infer<typeof SomeSchema>` I don't have a `infer` in `z`

**All code**:
```
import  z  from ""zod"";

export const ProductsSchema = z.object({
  title: z.string().max(255),
  description: z.string().max(255),
  price: z.number(),
});


export const ProductsSchemaType = z.infer<typeof ProductsSchema>;
```

And have this error when trying to use infer:
`Property 'infer' does not exist on type 'typeof import(""/project/node_modules/zod/index"")'.`

+ My autocomplete doesn't see this infer when I type dot after `z` as if he doesn't exist at all",,
2061814992,3098,z.infer doesn't infer types correctly,"When i have the following:

```
export const test = z.object({
    one: z.string().startsWith(""test:""),
    two: z.literal(""thisisatest""),
});

export type testType = z.infer<typeof test>;
```

The type of testType is inferred as follows:

```
type testType = {
    one: string;
    two: ""thisisatest"";
}
```

When it should presumably infer to:

```
type testType = {
    one: `test:${string}`;
    two: ""thisisatest"";
}
```

Unless i'm missing something? Or is this a bug?

Thanks!",,
2061157658,3095,Default generates same value for object array when passed a function,"## Description

In an object array, default method when passed a function, does not call the function for each object. 

## Use case

Using default method to generate unique id in case it is not passed.

## Version

- zod: 3.22.4
- typescript: 5.3.3

## Sample code to reproduce the issue:

```javascript
import { z } from ""zod"";

const testSchema = z.object( {
  id: z.number().default(Math.random()),
  name: z.string(),
  books: z.object( {
    id: z.number().default(Math.random()),
    title: z.string(),
  } ).array(),
} );

const testObject = {
  name: ""John"",
  books: [
    { title: ""Book 1"" },
    { title: ""Book 2"" }
  ]
};

console.log(testSchema.parse(testObject));
```

## Output

```json
{
  ""id"": 0.6215207601546078,
  ""name"": ""John"",
  ""books"": [
    { ""id"": 0.06822490162582584, ""title"": ""Book 1"" },
    { ""id"": 0.06822490162582584, ""title"": ""Book 2"" }
  ]
}
```

In the output, the `books` object array has 2 ids with exact same value while `Math.random` generates unique value each time.
",,
2061029554,3093,Wrong type infered when using refine inside a merge,"## Description

I want to create a schema of three fields.
One is mandatory.
The other two are optional, but one or the other must be defined.

I'm trying to achieve that by merging two schemas.
The first one, with the mandatory field.
The second one, with the optional fields. I'm doing a refine to validate that one or the other is defined.

When doing so, the type I get from `z.infer` is not what I expect:

```ts
const schema = z
  .object({
    id: z.string().min(1)
  })
  .merge(
    z
      .object({
        name: z.string().min(1),
        description: z.string().min(1)
      })
      .partial()
      .refine((fields) => atLeastOneDefined(fields), {
        message: 'Name or description must be defined'
      })
  );

type T = z.infer<typeof schema>;
```

## Expected behavior

```ts
type T = {
  id: string;
  name?: string;
  description?: string;
}
```

## Actual behavior

```ts
type T = {
    [x: string]: any;
}
```

## Without refine

The refine inside the merge seems to be the problem.

If I remove the refine, the type gets inferred correctly:

```ts
const schema = z
  .object({
    id: z.string().min(1)
  })
  .merge(
    z
      .object({
        name: z.string().min(1),
        description: z.string().min(1)
      })
      .partial()
  );

type T = z.infer<typeof schema>;

// type T = {
//   id: string;
//   name?: string | undefined;
//   description?: string | undefined;
// }
```

If I do a refine without any merge, the type is also correct:

```ts
const schema = z
  .object({
    one: z.string().min(1),
    two: z.string().min(1)
  })
  .partial()
  .refine((fields) => atLeastOneDefined(fields));

type T = z.infer<typeof schema>;

// type T = {
//   one?: string | undefined;
//   two?: string | undefined;
// }
```",,
2060782973,3091,Add a `.message()` method to Zod schemas for a default error message,"## Description:
Currently, Zod allows us to specify error messages for each validation method like `min`, `max`, etc. However, there is no way to specify a default error message for a field that applies when any validation fails.

For example, consider this schema:

```typescript
const guestUserSchema = z.object({
  name: z
    .string({
      invalid_type_error: ""Invalid name"",
      required_error: ""Name is required"",
    })
    .min(3, {
      message: ""Name must be at least 3 characters long"",
    })
    .max(20, {
      message: ""Name must be at most 20 characters long"",
    }),
  username: z.string().min(3).max(20).startsWith(""guest_""),
  method: z.array(z.literal(""guest"")).default([""guest""]),
});
```

I would like to be able to specify a default error message for the name field that is shown when any validation fails, like this:
```typescript
const guestUserSchema = z.object({
  name: z
    .string()
    .min(3)
    .max(20)
    .message(""Name must be between 3 to 20 characters""),
  username: z.string().min(3).max(20).startsWith(""guest_""),
  method: z.array(z.literal(""guest"")).default([""guest""]),
});
```
In this example, the .message() method would set a default error message for the name field that is shown when the min or max validation fails.

## Use Case:
This feature would be useful for providing more general error messages when any validation fails for a field, instead of having to specify an error message for each validation method.

## Proposed Solution:
Add a .message() method to Zod schemas that sets a default error message for a field. This message would be shown when any validation fails for the field.

## Alternatives Considered:
An alternative is to use the `.refine()` method to add a custom validation that always passes but provides a custom error message when any other validation fails. However, this is more of a workaround than a solution, and it would be more convenient to have a built-in method for this purpose.",,
2060750680,3089,How to type the zod schema object based on a predefined type?,"I have the following code:
```ts
class MyModel {
  propA: string
  propB: number
  propC: boolean
  constructor() {
    this.propA = ''
    this.propB = 123
    this.propC = true
  }
}
```

I want to create a Zod schema object based on this class, so that the **keys** and the **values** will correspond to this type:
```ts
const mySchema = z.object<SOME_GENERIC_METHOD_HERE<MyModel>>({
propA: z.string(),
  propB: z.number(),
  propC: z
    .boolean()
    .optional()
    .transform((i) => i),
})
})
```

I have tried to create a simple generic function that worked perfectly when `strictNullChecks` option in the **tsconfig.json** is disabled:

```ts
type ZodSchemaKeysFrom1<E> = {
  [k in keyof E]: ZodType<E[k]>
}

const mySchema = z.object<ZodSchemaKeysFrom1<MyModel>>({
  propA: z.string(),
  propB: z.number(),
  propC: z
    .boolean()
    .optional()
    .transform((i) => i),
})

type MySchemaFields = z.infer<typeof mySchema>
```

In this case `MySchemaFields` type is being inferred correctly as:
```ts
type MySchemaFields = {
    propA?: string;
    propB?: number;
    propC?: boolean;
}
```
It's the same type that will be inferred if you remove the generic angle brackets from `z.object<xxx>()`

Now, the problem is, I don't want to disable this typescript flag, I want my code to be as  strict as possible to avoid future mistakes.

So when I remove this flag (`strictNullChecks`), I get the following error only on the propC in the zod schema:

[![enter image description here][1]][1]


The error messsage is:

```
Type 'ZodEffects<ZodOptional<ZodBoolean>, boolean | undefined, boolean | undefined>' is not assignable to type 'ZodType<boolean, ZodTypeDef, boolean>'.
  Types of property '_type' are incompatible.
    Type 'boolean | undefined' is not assignable to type 'boolean'.
      Type 'undefined' is not assignable to type 'boolean'.ts(2322)
index.ts(6, 3): The expected type comes from property 'propC' which is declared here on type 'ZodSchemaKeysFrom1<MyModel>'

(property) propC: ZodType<boolean, z.ZodTypeDef, boolean>

```

How can I avoid this error?

I have created a code sandbox for everyone to try it out.

[Click here to see and try it in my devbox codesandbox][2]


  [1]: https://i.stack.imgur.com/vXAqY.png
  [2]: https://codesandbox.io/p/devbox/zod-keys-schema-9krk5v?file=%2Fsrc%2Findex.ts",,
2057596775,3087,Different behavior for union() and or(),"## Steps to reproduce
1. Create a function that takes both the Zod schema and an object that should have that schema.
```
function testFunction<TypeValidator extends z.ZodFirstPartySchemaTypes>(
  value: z.infer<TypeValidator>,
  schema: TypeValidator
) {}
```

2. Create two schemas: one with union(), one with or().
3. Call that function with the two schemas and an object that does not conform to the schema (it should throw an error).

## Expected behavior
TS results in an `Argument of type [...] is not assignable to parameter of type [...]` error in both cases.

## Actual behavior
TS results in an `Argument of type [...] is not assignable to parameter of type [...]` error only when using the .or() operator.

## Note
For some reason, this only works when the schema is created directly as a function argument.
If the schema is assigned to a constant and then that const is passed to the function, everything works correctly.
See the sandbox link to see this behavior.

## Sandbox
https://codesandbox.io/p/sandbox/zod-union-or-issue-xj3tv9 (file `src/index.ts`).",,
2054838903,3084,playground.ts file throws error.,"When I run **yarn play** in the root of the project I get the following error.

```/home/user/Documents/programs/javaScriptProjects/forked/zod/playground.ts:31
const a = new Arg();
          ^


ReferenceError: Arg is not defined
    at <anonymous> (/home/babu/Documents/programs/javaScriptProjects/forked/zod/playground.ts:31:11)
    at Object.<anonymous> (/home/babu/Documents/programs/javaScriptProjects/forked/zod/playground.ts:32:3)
    at Module._compile (node:internal/modules/cjs/loader:1256:14)
    at Object.F (/home/babu/Documents/programs/javaScriptProjects/forked/zod/node_modules/@esbuild-kit/cjs-loader/dist/index.js:1:941)
    at Module.load (node:internal/modules/cjs/loader:1119:32)
    at Module._load (node:internal/modules/cjs/loader:960:12)
    at ModuleWrap.<anonymous> (node:internal/modules/esm/translators:169:29)
    at ModuleJob.run (node:internal/modules/esm/module_job:194:25)
```

Can I own this issue?",,
2054801228,3083,ZodBigInt#isOptional throws,"from using zod-openapi-library
```
âœ˜ [ERROR] TypeError: Cannot convert undefined to a BigInt
      at [object Object]
      at ZodBigInt._parse
  (file:///Users/moody/IdeaProjects/ekubo/api/node_modules/zod/lib/index.mjs:1570:26)
      at ZodBigInt._parseSync
  (file:///Users/moody/IdeaProjects/ekubo/api/node_modules/zod/lib/index.mjs:624:29)
      at ZodBigInt.safeParse
  (file:///Users/moody/IdeaProjects/ekubo/api/node_modules/zod/lib/index.mjs:654:29)
      at ZodBigInt.isOptional
  (file:///Users/moody/IdeaProjects/ekubo/api/node_modules/zod/lib/index.mjs:811:21)
      at OpenAPIGenerator.isOptionalSchema
  (file:///Users/moody/IdeaProjects/ekubo/api/node_modules/@asteasolutions/zod-to-openapi/dist/openapi-generator.js:588:26)
      at OpenAPIGenerator.generateSimpleParameter
  (file:///Users/moody/IdeaProjects/ekubo/api/node_modules/@asteasolutions/zod-to-openapi/dist/openapi-generator.js:193:32)
      at OpenAPIGenerator.generateParameter
```",,
2054419307,3082,type checking,"hello
I created schema and made required all fields but out put of z.infer<typeof mySchema> fields are optional

Thank you for your guidance",,
2054288424,3080,Issue with enum initiated with Array<Something> type,"I'm trying to migrate quite big types definitions library (100+ files) from superstruct to zod for following reasons
- readonly()
- discriminatedUnion()

So far it's been smooth ride I'm having issue with ""enum"" type. We mostly used 2 patterns in superstruct:
```
// (1) real enum
enum SomethingType {
  SOMETHING = 'SOMETHING'
}

// (2) fake enum 
const SomethingType = {
  SOMETHING: 'SOMETHING'
} as const

// both were used fine in superstruct enum - by simply converting then into Array of something
const sortedValues = Object.values(SomethingType) // Array<""SOMETHING"">
const superstructEnum = enums(sortedValues)

export const zodEnum = z.enum(SomethingType) // error Argument of type SomethingType[] is not assignable to parameter of type readonly [string, ...string[]]
```

Why we used fake enum is a bit out of scope of this question, but if you're curious: for migrating between the versions where enum members change. The issue I'm having with zod is that none of these ways of defining enums seem to work. I guess it's all because of the requirement of having first element in the tuple:

`createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>`

can I ask - what's the reason or benefit of having this?

Also, I know I probably could change from enum() to union() but for this I need to define all these strings as literals, which is quite big change and affects the library's public API. Is there any other way to define the enum in zod, which is similar to the one in superstruct?

Would this PR https://github.com/colinhacks/zod/pull/2338 fix my problem?",,
2053204669,3079,Typescript declaration file fails to infer type properly,"I notice that the behavior of inferred types using `z.infer` is different when using it on a local project, then when exporting it to a package and using typescript declaration files.

Here is what I noticed:

If I create a basic schema:

```typescript
export const MySchema = z.object({
  /**
   * This is a very important js doc comment
   */
  name: z.string(),
});
```

and create a type inferring from it: 
```typescript
export type MyType = z.infer<typeof MySchema>;
```

The type and comment work fine if I try to use it in the same project:

![image](https://github.com/colinhacks/zod/assets/34727800/8277600f-b470-4118-ac6c-5606b2a7391e)


However, the compiled file will look something like this:
```typescript
export declare const MySchema: ZodObject<{
    /**
     * This is a very important js doc comment
     */
    name: z.ZodString;
}, ""strip"", z.ZodTypeAny, {
    name: string;
}, {
    name: string;
}>;
export type MyType = z.infer<typeof MySchema>;
```

Notice that, the 5 components of `ZodObject` are not compatible making the `Schema['_output']` (which is used to inferring) not keep the comments from the original raw shape (likely due new types being created).
![image](https://github.com/colinhacks/zod/assets/34727800/0f98be35-0475-4857-a47c-cbf4885ade71)

Now, I noticed that if I remove `strip` and `z.ZodType` from the list of generics, it manages to resolve the comments again.

So I looked deep into the code and found the place where the output is being created at `objectOutputType` and replicated pretty much the same thing, except I did not add those 2 extra types:

This is my utility type:
```typescript
export type SchemaType<T extends ZodObject<any>> = objectUtil.flatten<
  objectUtil.addQuestionMarks<baseObjectOutputType<T[""shape""]>>
>;
``` 
And now the comments are back:
![image](https://github.com/colinhacks/zod/assets/34727800/691b659b-78f5-4957-9d4c-5cd241d2af60)



I am not very sure if this utility type could become something in zod itself.

Could `infer` or `TypeOf` stop using `_output` and do this instead? What would be the impact of losing those 2 extra types from the inferred type?

",,
2053140429,3077,Exception handling in transform or safeParse,"```
import { z } from ""zod"";

const invalidJson = '{""ax: 1}'

console.log(
  z
    .string()
    .transform((val) => JSON.parse(val))
    .safeParse(invalidJson)
);
```

--

Expected:
```json
{ ""success"": false, ""error"": ... }
```

--

Result:
It throws the exception. ""Unexpected end of JSON input"".

--

Basically exceptions are not handled in `transform` or `safeParse` as you would expect them to. 

I've checked the documentation and it doesn't mention anything about handling exceptions in `transform`.

There seem to be similar behaviour for `refine` as well.

zod package version - 3.22.4",,
2051642682,3075,is there any play support .example?,"Hi, i am doing an app with zodï¼Œ
i met a scenarioï¼Œi use zod to openapi jsonï¼Œnow i need add example in openapi
so, i was wondering if there support example for such scenario

like this
```
z.string().example('fldxxxx')
```",,
2050290425,3073,.email() does not respect UTF8SMTP Extension standard (which includes Ã¶Ã¤Ã¼ aka. Umlaute),"Hello,
the RFC standard https://www.rfc-editor.org/rfc/rfc5336#section-3.2 allows users to use ""Ã¶Ã¤Ã¼"" and other special characters as part of their Email.
Further information here: https://stackoverflow.com/questions/15121359/are-international-characters-e-g-umlaut-characters-valid-in-the-local-part-of

``.email()`` currently does not respect this nor does it provide the option to allow this extension specifically.

Therefore, the following email will fail unexpectedly: ``schÃ¤fer2@gmail.com``.
The expected behavior would be, that validation would succeed.

Other examples for failing Emails include:
- ``jÃ¶rg@gmail.com``
- ``cÃ¤cilia@gmail.com``
- ``bengÃ¼@gmail.com``
- ``jÃ¼rgen@gmail.com``

Via https://github.com/ajnart/homarr/issues/1747",,
2049507750,3072,The .transform method is throwing errors,"Hi,

I used the transform method to change some data after parsing. The implementation used to work before but now an error is thrown and i don't understand whats going on as i didn't change anything. here is an example of some code i have using .transform

```ts
const convertToStringsArray = (value: string) => {
    if (!value || value === '') return null;
  
    const array = value.split('\n');
  
    return array;
};

export const sheetArrays = z.string().transform(convertToStringsArray);
```

the error being thrown is this
```
TypeError: effect.transform is not a function
    at ZodEffects._parse (types.js:3375:31)
    at ZodObject._parse (types.js:1957:29)
    at ZodObject._parseSync (types.js:170:25)
    at eval (types.js:1811:23)
    at Array.map (<anonymous>)
    at ZodArray._parse (types.js:1810:34)
    at ZodArray._parseSync (types.js:170:25)
    at ZodArray.safeParse (types.js:207:25)
    at eval (products.ts:722:63)
    at step (products.ts:146:17)
```
",,
2047906827,3069,Zod is not able to catch decimal point error when it's optional(),"I have 2 numeric fields, one is required and the other is optional

First Field: `z.number()`
Second Field: `z.number().optional()`

The problem comes while writing decimal numbers ( e.g: "".9"", "".764""). On writing just ""."", the first field throws an error but the second field doesn't!

I tried refining it and super refining it, transforming string to number etc but ""."" is not catchable when optional, nullable, bullish methods are used

Label: Bug Report",,
2045361094,3066,Zod continues to throw errors while using async refinements with react hook form when zod resolver mode is set to async,"The title pretty much sums it up but, Zod throws errors when using async refinements via react hook form and Zod resolver even when you set mode to 'async'. This shouldn't be the case as it makes no sense. Refinements regardless of being async or not should not result in Zod throwing an error and instead should result in a validation error similar to any other function in Zod (e.g. min()). 


I don't think this is an issue with Zod (though maybe?) but, it absolutely is a failure of the docs to not cover this specific situation given that Zod is so commonly used with RHF.

EDIT: Messed something up on my end.",,
2045156065,3065,Project bottlenecks?,"Hi! Thank you for creating and maintaining this fantastic library! There didn't seem to be much visible development lately, and even though there are plenty of community submitted PRs, they seem to just be hanging in the review limbo.

Is there anything that could be done to help with this? I can contribute some of my time to help, e. g. with reviewing code or whatever is needed to move the needle. Zod is a critical piece for us, and it hurts to see it stagnate a bit.",,
2045018869,3064,Recursive schema that uses other schemas not working due to incompatible inputs and outputs,"Example:

```typescript
import { z } from 'zod'

const Column = z.union([
    z.object({
        type: z.literal('string'),
    }),
    z.object({
        type: z.literal('integer'),
    }),
])

const TableBase = z.object({
    name: z.string(),
    columns: z.record(Column).default({}),
})

type TableWithExtends = z.infer<typeof TableBase> & {
    extends: TableWithExtends
}

//    Error -- Type 'undefined' is not assignable to type 'Record<string, { type: ""string"" } | { type: ""integer"" }>'
//    ||||| 
//    vvvvv
const Table: z.ZodType<TableWithExtends> = TableBase.extend({
    extends: z.lazy(() => Table),
})
```

The error goes away if I change `z.infer` to `z.input` but then the output of `Table` changes to the input as well which is not what I need. It seems since `z.ZodType` assumes output will match input, this use case falls apart, but manually supplying input and output doesn't seem to work either. Could use some pointers here.",,
2042622708,3058,Adding .required does not make returned type have required field,"I have a type with a required field, for which I've generated a Zod schema.  The generated schema is coming from `openapi-to-zod`, but the small example below replicates the relevant code and demonstrates the problem.  In the documentation, the section on Objects leads off with sample code in which it is said that by default fields of `z.object` are required, and that the example is equivalent to a TypeScript definition where the fields are required.

As shown below, that's not the case today.

```js
import { z } from 'zod';

type E = {
    programID: string;
    eName?: string;
};

// Establish that programID is required
const badE: E = {};
// Property 'programID' is missing in type '{}' but required in type 'E'.
const goodE: E = { programID: '99' }
// No error

const parseE = z.object({
    programID: z
                .string()
                .regex(new RegExp(""^[a-zA-Z0-9_-]*$""))
                .min(1)
                .max(128)
                .describe(""URL safe VTN assigned object ID.""),
    eName: z.string().default('ZILCH').optional()
}); // .required(); // { programID: true });

// Generate Zod's view of the type described by the schema
type tE = z.infer<typeof parseE>;

// This is the type shown when hovering the mouse over `tE`
// Notice that programID is shown as optional.
// No addition of .required() in the parseE definition changes this
//
// type tE = {
//     programID?: string;
//     eName?: string;
// }

// tE should require programID, therefore this should give
// the same error as above
const badE2: tE = {};
// No error

const e: E = parseE.parse({
    // Commenting this out results in a parse error
    // saying that programID is required 
    programID: 'Program-ID-99'
});

console.log(e);
```

The field `E.programID` is required.  In `parseE` I'm trying to work out how to make `programID` be required as well.

Compiling the above gives the following error:

```
src/index.ts:30:7 - error TS2322: Type '{ programID?: string; eName?: string; }' is not assignable to type 'E'.
  Property 'programID' is optional in type '{ programID?: string; eName?: string; }' but required in type 'E'.

30 const e: E = parseE.parse({
```

The error message says the Zod schema returned by `parseE.parse` has `programID` as optional.  TypeScript complains that it is not assignable because `programID` is required.

No matter the setup of the `.required()` call, the error message does not change.

In Visual Studio Code, and hovering the mouse over things - the `parseE.parse` function shows `programID` as optional.

As noted in the comments, using `z.infer` to retrieve the type Zod thinks is correct shows `programID` to be optional.  No option for `.required()` changes this.

But, if the object passed to `parseE.parse` does not have `programID`, then when the program is run an error is thrown with this issue:

```js
{
      code: 'invalid_type',
      expected: 'string',
      received: 'undefined',
      path: [ 'programID' ],
      message: 'Required'
    }
```

So.. the parser knows that `programID` is required, while TYpeScript compiler is still giving the error saying `programID` is optional.

",,
2042533754,3057,Zod Lazy - optional recursion,"From the recursion example from the [docs](https://github.com/colinhacks/zod#recursive-types):

```
const baseCategorySchema = z.object({
  name: z.string(),
});

type Category = z.infer<typeof baseCategorySchema> & {
  subcategories: Category[];
};

const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
  subcategories: z.lazy(() => categorySchema.array()),
});
```

However, I'm getting a type error:

<img width=""594"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/9795404/80a29756-81c9-4282-a893-4b1428c59609"">
",,
2042514898,3056,Zod Tuple type shows,"On a zod tuple, there is an additional parameter at the end of the tuple. `...unknown[]`. Is this expected? Possibly in relation to the support for `.rest`, but shouldn't the spread items not even appear in the type of `.rest` is omitted?

```
import { z } from 'zod';

const athleteSchema = z.tuple([
  z.string(), // name
  z.number(), // jersey number
  z.object({
    pointsScored: z.number(),
  }), // statistics
]);
```

Here is the type I expect:

```
type Athlete = z.infer<typeof athleteSchema>;
// type Athlete = [string, number, { pointsScored: number }]
```

However, this is the type that I see (note the `...unknown[]`:
```
// type Athlete = [string, number, { pointsScored: number }, ...unknown[]]
```

From the type tuple, this should be invalid:
```
const a: Athlete = ['1', 2, { pointsScored: 3 }, 4];
```

Is this a bug, or expected behavior? Feels like a bug to me, but as a beginner-intermediate zod user, maybe there is an explanation.",,
2042406925,3055,Zod validator calls refine and ignoring other validators,"Hi, 
I need to validate presence of url, and that it has valid format. 
I know about url() validator, but I will need more fine grained checks.

So I tried to use refine().

```ts
validate: zodResolver(
    z.object({
        url: z.string()
            .min(1, ""This is a required field"")
            .refine((value) => {
                try {
                    new URL(value);
                    return true;
                } catch {
                    return false;
                }
            }, ""Invalid URL"")
    })
)
```

for some reason zod ignores '.min' validator and calls always refine(). 

Is this an issue or I just don't understand something? 

Thanks.",,
2041575134,3054,Nested schema w/ .default doesn't generate the default value if it is used with .optional,"Consider these three schema objects -- all generated by `ts-to-zod` from TypeScript source.

```js
export const dateTimeSchema = z.string().datetime().default(""0000-00-00"");

export const durationSchema = z
  .string()
  .regex(
    /^(-?)P(?=\d|T\d)(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)([DW]))?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/,
  )
  .default(""PT0S"");

export const intervalPeriodSchema = z.object({
  start: dateTimeSchema,
  duration: durationSchema.optional(),
  randomizeStart: durationSchema.optional(),
});
```

In `durationSchema` there is a default value, which is a Duration string for zero seconds.

Calling `intervalPeriodSchema.parse` with an object that does not include the `randomizeStart` field, I get the following:

```js
{
  // ...
  intervalPeriod: { start: '2023-02-20T00:00:00Z', duration: 'P3M' },
  // ...
}
```

What I'm reasoning is that `intervalPeriodSchema.parse` calls `durationSchema.parse` which notices the missing field, notices the `.optional`, and therefore does not call into `durationSchema.parse`, and therefore the `.default` value is not substituted.

I have generated the same schema using a different tool - `openapi-to-zod` - which generates the following schema, and in that case the default value shows up.

```js
    intervalPeriod: z
      .object({
        start: z.string().datetime().describe(""datetime in ISO 8601 format""),
        duration: z
          .string()
          .regex(
            new RegExp(
              ""^(-?)P(?=\\d|T\\d)(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)([DW]))?(?:T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?)?$""
            )
          )
          .describe(""duration in ISO 8601 format"")
          .default(""PT0S""),
        randomizeStart: z
          .string()
          .regex(
            new RegExp(
              ""^(-?)P(?=\\d|T\\d)(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)([DW]))?(?:T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?)?$""
            )
          )
          .describe(""duration in ISO 8601 format"")
          .default(""PT0S""),
      })
```

 
",,
2041146386,3053,cuid() considers the word corrigendum as a cuid,"![image](https://github.com/colinhacks/zod/assets/23259680/1669da9c-c904-4726-945e-50fdbd65c590)
",,
2040598336,3052,Cannot make discriminated unions with certain things / types break in weird ways,"It seems that trying to make discriminated unions with certain things breaks some types - errors look something like this:

Argument of type: 
```
ZodDiscriminatedunion<
	""code"",
	[
		ZodObject<
			{ code: ZodLiteral<""a"">; a: ZodNumber }.
			""strip"",
			ZodTypeAny,
			{ code: ""a""; a: number },
			{ code: ""a""; a: number }
		>,
		ZodObject<...>
	]
>
```

is not assignable to parameter of type `AnyZodObject`. 

Type:

```
ZodDiscriminatedunion<
	""code"",
	[
		ZodObject<
			{ code: ZodLiteral<""a"">; a: ZodNumber }.
			""strip"",
			ZodTypeAny,
			{ code: ""a""; a: number },
			{ code: ""a""; a: number }
		>,
		ZodObject<...>
	]
>
```

is missing the following properties from type:

```
ZodObject<
	any,
	any,
	any,
	{ [x: string]: any },
	{ [x: string]: any }
>
```

:
- _cahced
- _getCached
-  shape
- strict
and 14 more

Here is an example [codesandbox](https://codesandbox.io/p/sandbox/angry-parm-vm86j5?file=%2Fsrc%2Findex.ts%3A23%2C1&layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clq4cg0lq0006356jcyzpyh6r%2522%252C%2522sizes%2522%253A%255B100%252C0%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clq4cg0lq0002356jjc32u1u9%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clq4cg0lq0003356jsgnmwg3z%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clq4cg0lq0005356jdx873vru%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clq4cg0lq0002356jjc32u1u9%2522%253A%257B%2522id%2522%253A%2522clq4cg0lq0002356jjc32u1u9%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clq4chsdz0002356jyyh0ydqx%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522initialSelections%2522%253A%255B%257B%2522startLineNumber%2522%253A23%252C%2522startColumn%2522%253A1%252C%2522endLineNumber%2522%253A23%252C%2522endColumn%2522%253A1%257D%255D%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.ts%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%255D%252C%2522activeTabId%2522%253A%2522clq4chsdz0002356jyyh0ydqx%2522%257D%252C%2522clq4cg0lq0005356jdx873vru%2522%253A%257B%2522id%2522%253A%2522clq4cg0lq0005356jdx873vru%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clq4cg0lq0004356jbktmpqmd%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522UNASSIGNED_PORT%2522%252C%2522port%2522%253A0%252C%2522path%2522%253A%2522%252F%2522%257D%255D%252C%2522activeTabId%2522%253A%2522clq4cg0lq0004356jbktmpqmd%2522%257D%252C%2522clq4cg0lq0003356jsgnmwg3z%2522%253A%257B%2522tabs%2522%253A%255B%255D%252C%2522id%2522%253A%2522clq4cg0lq0003356jsgnmwg3z%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Afalse%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)",,
2039544988,3050,Support for KSUIDs,"We've already got validators for other types of UID (UUID, ULID, CUID etc.), so rather than having to use a regex when working with KSUIDs, it would be nice if we had the same experience:

```ts
const ksuid = z.string().ksuid()
```",,
2039009010,3048,Error message based on input value,"I need to generate error message based on the input value, now I have to use errorMap which is tedious.

I hope I can write code like this:

```ts
z
.string({ invalid_type_error: value => 'Expected a string, received: ' + String(value) })
.min(2, { message: value => 'Expected a string with at least 2 characters, received: ' + String(value) })
```",,
2038053248,3046,errorUtil code causes a TypeError when running in a Tauri app,"Steps to replicate:

1. `import { z } from ""zod"";` into a web app running in [Tauri](https://github.com/tauri-apps/tauri)
2. Run application using `npm run tauri dev`

Expected: Application runs as usual.
Observed: Application fails with `TypeError: Cannot assign to read only property` logged to console.

This seems to be because Tauri by default freezes `Object.prototype` for security. [This Tauri issue](https://github.com/tauri-apps/tauri/issues/3416) describes the same issue occurring with different libraries.

There is a workaround of disabling the freezing of `Object.prototype`, but ideally it would be better to leave this enabled and still have the ability to use zod with Tauri.

Looking at the code that causes the issue, it seems to be [errorUtil.ts](https://github.com/colinhacks/zod/blob/master/src/helpers/errorUtil.ts#L5). This ends up as something like this in js:

```js
var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === ""string"" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === ""string"" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil = exports.errorUtil || (exports.errorUtil = {}));
```

Specifically it seems to be the `errorUtil.toString = ...` assignment that causes the error - renaming the const avoids the issue.",,
2037553306,3045,Recursive types interpret transformed properties wrong,"Hello, first of all not sure if it's a bug, or if I'm doing something wrong, but I'll put it out there just in case.

Recursive types don't handle transformed properties
My recursive type follows this example: https://zod.dev/?id=recursive-types

```ts
const StringToNumSchema = z
  .string()
  // It works fine when you comment out the .transform method
  .transform((value, ctx) => {
    const number = Number(value);

    if (isNaN(number)) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: ""Value must be a number"",
      });

      return z.NEVER;
    }

    return { value: number };
  });

export type StringToNum = z.infer<typeof StringToNumSchema>;

const _BaseRecursiveObjectSchema = z.object({
  num: StringToNumSchema,
});

export type RecursiveObject = z.infer<typeof _BaseRecursiveObjectSchema> & {
  recursive_object: RecursiveObject;
};

export const RecursiveObjectSchema: z.ZodType<RecursiveObject> =
  _BaseRecursiveObjectSchema.extend({
    recursive_object: z.lazy(() => RecursiveObjectSchema),
  });
```

```shell
error TS2322: Type 'ZodObject<{ num: ZodEffects<ZodString, { value: number; }, string>; recursive_object: ZodLazy<ZodType<RecursiveObject, ZodTypeDef, RecursiveObject>>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<RecursiveObject, ZodTypeDef, RecursiveObject>'.
  Types of property '_input' are incompatible.
    Type '{ num: string; recursive_object: { num: { value: number; }; } & { recursive_object: RecursiveObject; }; }' is not assignable to type 'RecursiveObject'.
      Type '{ num: string; recursive_object: { num: { value: number; }; } & { recursive_object: RecursiveObject; }; }' is not assignable to type '{ num: { value: number; }; }'.
        Types of property 'num' are incompatible.
          Type 'string' is not assignable to type '{ value: number; }'.

32 export const RecursiveObjectSchema: z.ZodType<RecursiveObject> =
                ~~~~~~~~~~~~~~~~~~~~~

```

Live demo: https://codesandbox.io/p/devbox/musing-sanne-mg5hhm",,
2036179812,3043,Inferred type of Object catchall with boolean is empty object ,"```ts
const schema = z.object({}).catchall(z.boolean());
type T = z.output<typeof schema>;
//   ^? {}
```

I am expecting `type T = Record<string, boolean>`, but inferred type is empty object instead.
",,
2034063148,3035,Can we avoid .nonempty() changing the inferred input type?,"Take below example:

```ts
import { z } from 'zod';

const schema = z.number().array().nonempty();

// expected type to be number[], but instead is [number, ...number[]]
type inputType = z.input<typeof schema>;

// simplified for demo
const formValidation: (userInput: inputType) => boolean = (userInput) => {
  // ....
  return true;
};

// user input of either correct array or incorrect empty array...
const formData: number[] = Math.random() % 2 ? [2] : [];

// this should typecheck, but doesn't because the .nonemtpy() call pollutes the inferred input type.
const isValid = formValidation(formData);
```
Is this a bug? or intentional?

I can imagine zod being intentionally like this, as this behaviour is the one that utilises TS to the limit, but I would expect that this is the opposite of what the usual use case would demand.

Is there some elegant solution to this, that doesn't involve breaking typesafety with multiple schema definitions and/or forced casts especially when the array is actually in a nested zod object schema, so I can't easily just create a simple and a chained .nonemtpy variant?",,
2033448186,3030,cannot figure out how to create a schema from the discriminator key of a discriminated union,"Howdy, all. First off, thanks for the amazing library. We really enjoy using it here at the office.

Context: We'd like to create a Zod schema that represents the set of values used as discriminator keys in a discriminated union.

Given this code:

```js
const Result = z.discriminatedUnion(""status"", [
  z.object({ status: z.literal(""success""), data: z.string() }),
  z.object({ status: z.literal(""failed""), error: z.instanceof(Error) }),
]);

type Result = z.infer<typeof Result>;
```

We'd like to produce a new schema:

```js
const ResultStatus = Result.shape.type // does not compile

type ResultStatus = z.infer<typeof ResultStatus>;
```

There is no `shape` property on the thing returned from a call to `z.discriminatedUnion`. I surely must be doing this wrong.

Thanks in advance!",,
2031547875,3028,`@deprecated` JSDoc not applying to properties after compilation to .d.ts,"The `@deprecated` JSDoc is not applying to properties after compilation to .d.ts

The feature I am trying to take advantage of the `@deprecated` jsdoc annotation. 
1. It works in the same project that you are using it. 
2. It doesn't work if you export it in a library, because it loses the deprecated hinting, even though the annotation is still present in the type declaration.

<details><summary>My example code and setup</summary>
<p>

The original file:
> my-library/index.ts
```ts
export const purchaseDetailValidator = z.object({
  productId: z.string(),
  /** @deprecated use amount instead */
  number: z.number().optional(),
  amount: z.number(),
});

const purchaseDetail = purchaseDetailValidator.parse({
  productId: ""03830-01828"",
  amount: 1,
})

purchaseDetail.number
```

![Screenshot 2023-12-07 at 2 03 52 PM](https://github.com/colinhacks/zod/assets/71348224/2f4ebab3-6359-47c9-8f0c-a89b15cd21aa)

It compiles to:

> dist/index.d.ts
```ts
declare const purchaseDetailValidator: z.ZodObject<{
    productId: z.ZodString;
    /** @deprecated use amount instead */
    number: z.ZodOptional<z.ZodNumber>;
    amount: z.ZodNumber;
}, ""strip"", z.ZodTypeAny, {
    productId: string;
    amount: number;
    number?: number | undefined;
}, {
    productId: string;
    amount: number;
    number?: number | undefined;
}>;

export { purchaseDetailValidator };
```

But it doesn't show up in:

> consumer-project/example.ts
```ts
import { purchaseDetailValidator } from ""@my-library/shared"";

const purchaseDetail = purchaseDetailValidator.parse({
  productId: ""03830-01828"",
  amount: 1,
});
purchaseDetail.number
```
![Screenshot 2023-12-07 at 2 06 17 PM](https://github.com/colinhacks/zod/assets/71348224/04f06b90-0ed1-4d86-81c0-e130111949c2)

### Edit:
My build step is this:
`tsup src/index.ts --format cjs,esm --dts`

and my tsconfig.json is this:
```json
{
  ""compilerOptions"": {
    ""target"": ""es2016"", /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    ""module"": ""commonjs"", /* Specify what module code is generated. */
    ""esModuleInterop"": true, /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    ""forceConsistentCasingInFileNames"": true, /* Ensure that casing is correct in imports. */
    ""strict"": true, /* Enable all strict type-checking options. */
    ""skipLibCheck"": true, /* Skip type checking all .d.ts files. */
    ""noUncheckedIndexedAccess"": true,
    ""noEmit"": true,
    ""allowJs"": true,
  }
}
```

</p>
</details> 
",,
2031386211,3026,Bug: .merge changes schema to disallow extra props when importing commonJs build,"The following error occurs when the parser encounters an unexpected property:
`Expected never, received <type - array/string/etc.>`.
In other words, it's as if it has `.strict()`, even though that was never applied.

This happens in the following scenario:
- importing a schema from a commonJs file AND
- performing a `.merge` with that schema THEN
- with the new schema, parsing an object that has extra (unexpected) properties.

This issue can best be explained / understood by looking at the CodeSandbox. The CodeSandbox runs the tests to show which case fails. CodeSandbox: https://codesandbox.io/p/devbox/zod-vite-bug-y2qsc8?file=%2Fsrc%2Ftest.spec.ts

CodeSandbox test file:
```typescript
// baseSchema is a basic `z.object({ property1: z.string() })` that has been compiled to cjs and esm
// using tsup. This build occurs in the CodeSandbox.
import { baseSchema as baseSchemaCjs } from ""../external_package_mock_dist/index.cjs"";
import { baseSchema as baseSchemaEsm } from ""../external_package_mock_dist/index.js"";
import { z } from ""zod"";

it(""imported cjs zod schema parse - no extra properties (PASS)"", () => {
  expect(() =>
    baseSchemaCjs.parse({
      property1: ""1"",
    }),
  ).not.toThrow();
});

it(""imported cjs zod schema parse - extra properties (PASS)"", () => {
  expect(() =>
    baseSchemaCjs.parse({
      property1: ""1"",
      extraProperty: ""str"",
    }),
  ).not.toThrow();
});

it(""imported cjs zod schema merged parse - extra properties (FAIL)"", () => {
  const schema = baseSchemaCjs.merge(
    z.object({
      property2: z.string(),
    }),
  );

  expect(() =>
    schema.parse({
      property1: ""str"",
      property2: ""str"",
      extraProperty: ""str"",
    }),
  ).not.toThrow();
});

it(""imported esm zod schema merged parse - extra properties (PASS)"", () => {
  const schema = baseSchemaEsm.merge(
    z.object({
      property2: z.string(),
    }),
  );

  expect(() =>
    schema.parse({
      property1: ""str"",
      property2: ""str"",
      extraProperty: ""str"",
    }),
  ).not.toThrow();
});

it(""locally created zod schema merged parse - extra properties (PASS)"", () => {
  const baseSchemaLocal = z.object({
    property1: z.string(),
  });
  const schema = baseSchemaLocal.merge(
    z.object({
      property2: z.string(),
    }),
  );

  expect(() =>
    schema.parse({
      property1: ""str"",
      property2: ""str"",
      extraProperty: ""str"",
    }),
  ).not.toThrow();
});
```

**Expected result**

According to the docs, By default Zod object schema strip unknown keys from the output.",,
2031187614,3025,Specific condition on the schema method called transform,"When using the transform method, to exchange the keys of an object after it is validated.
```typescript
const SalesOrderProductSchema = z.object({
  integration_order_code: z.string().max(60),
  order_code: z.number().optional(),
  order_number: z.string().max(15).optional(),
}).transform((data) => ({
  code_pedido_integracao: data.integration_order_code,
  codigo_pedido: data.order_code,
  numero_pedido: data.order_number,
}))
```

At the output of this action, it was expected that the object would have the name of the keys equal to the items that are within the transform method.
however, this does not happen, the object is returning the same as the input object and there is no error occurring.

Is the form presented correct?
Is there any other way to get the expected result? or is it a bug found?",,
2030411420,3024,TypeScript error when pass schema to a function,"I've got an amazing type of error message today. 

```ts
export const timestampToDate = (data: number): Date => {
  const timestamp = new Date(data);
  if (isNaN(timestamp.getTime())) {
    throw new Error('Invalid timestamp');
  }
  return timestamp;
};

export const timestampToDateSchema = z.coerce.number().transform(timestampToDate);
  
  
export const MyUsersSchema = z.array(
  z.object({
    created: timestampToDateSchema,
  }),
);

  async do<T>(data, schema: z.ZodType<T>) {
    return schema.parse(data);
  }
  
const myUsers = MyUsersSchema.parseAsync([]);
const myUsers2 = this.do([], MyUsersSchema);
```

As you can see, both myUsers, and myUsers2 should be typed the same. But Typescript shows an error for myUsers2

```
Argument of type 'ZodArray<ZodObject<{ created: ZodEffects<ZodNumber, Date, number>; }, ""strip"", ZodTypeAny, { created: Date; }, { created: number; }>, ""many"">' is not assignable to parameter of type 'ZodType<{ created: Date; }[], ZodTypeDef, { created: Date; }[]>'.
  Types of property '_input' are incompatible.
    Type '{ created: number; }[]' is not assignable to type '{ created: Date; }[]'.
      Type '{ created: number; }' is not assignable to type '{ created: Date; }'.
        Types of property 'created' are incompatible.
          Type 'number' is not assignable to type 'Date'.
```

So it creates a type, which conflicts with the type itself. 

created has a Date type for ZodType Input, but also it has a number type for Output",,
2029401994,3022,An unsafe `instanceof`,"> Not much I can do about this. Without a public constructor there's no way for TypeScript to validate that the argument to `z.instanceof` is actually a class. 
>
> Here's the workaround (this is what `z.instanceof` does under the hood anyway):
>
> ```ts
> const txSchema = z.custom< TransactionAmount >(arg => arg instanceof TransactionAmount)
> ```

_Originally posted by @colinhacks in https://github.com/colinhacks/zod/issues/1065#issuecomment-1093557684_

---

Typescript allows `instanceof` on anything that implements `NewableFunction`, the constructor type implies that, but it is more restrictive than it needs. In fact if you pass a function with a private constructor and ignores typescript it works.

What could be done is provide a separate `unsafeInstanceOf<T extends NewableFunction>`.

Why make it a new function and call it unsafe instead of changing the existing one?

Because if you pass any class with a protected or private constructor there are cases where TS will reduce the type to any because there is no way to properly refer to ""an instance of this type that has a private constructor"". So it works exactly as anyone would expect, but the type may become any.",,
2027003484,3018,New Documentation Site,"Hi

I'm working on this new documentation site for Zod:

![Screenshot 2023-12-05 113542](https://github.com/colinhacks/zod/assets/44144724/d3b75741-0b8d-422b-9189-6394e5b14c21)

The problems I have with the current site are:

- Bad SEO
- Slow
- Bad UI

I'm using [VitePress](https://vitepress.dev) for documentation generation, which is fantastic. Some of the content in the screenshot is the demo content and will be changed. And yes, there will be a glow/gradient behind the logo :)

I would also link to build a playground (https://github.com/colinhacks/zod/issues/2710).

Please let me know what you guys think. If there is any useful info, please let me know.

Thanks",,
2023913948,3015,Zod preprocessor ignores default value,"* Use case
I'm trying to get the default value of a preprocessed input.

I tried

```typescript
const test_value = z.preprocess(stringParser, z.string().default(""test_key""));
const parsed_value = test_value.parse(undefined); // => void
```

and 

```typescript
const test_value = z.preprocess(stringParser, z.string().default(""test_key"")).default(""test_key"");
const parsed_value = test_value.parse(undefined); // => void
```

* Current behavior

The default value is not computed and `z.parse` returns nothing

* Expected behavior

Default value should be returned if input couldn't be preprocessed",,
2022269548,3014,"Module '""zod""' has no exported member 'ZodTypeAny'. ts(2305)","```ts
import type { ZodTypeAny } from ""zod"";
```

Causes this TypeScript error:

```
Module '""zod""' has no exported member 'ZodTypeAny'. ts(2305)
```

Any idea why it's doing that? Weird as hell.",,
2018572045,3009,Add support for extending an object with a (discriminated) union,"I would like to be able to do something like

```ts
const schema = z
  .object({ sharedProp: z.string() })
  .extend(
    z.discriminatedUnion('name', [
      z.object({ name: z.literal('A'), A: z.string() }),
      z.object({ name: z.literal('B'), B: z.string() }),
    ])
  );
```

and/or

```ts
const schema = z
  .discriminatedUnion('name', [
    z.object({ name: z.literal('A'), A: z.string() }),
    z.object({ name: z.literal('B'), B: z.string() }),
  ])
  .extend(z.object({ sharedProp: z.string() }));
```

Even if I extract `baseSchema` and do something like

```ts
const baseSchema = z.object({ sharedProp: z.string() });
const schema = z.discriminatedUnion('name', [
  baseSchema.extend(z.object({ name: z.literal('A'), A: z.string() })),
  baseSchema.extend(z.object({ name: z.literal('B'), B: z.string() })),
]);
```
or
```ts
const baseSchema = z.object({ sharedProp: z.string() });
const schema = z.discriminatedUnion('name', [
  z.object({ name: z.literal('A'), A: z.string() }).extend(baseSchema),
  z.object({ name: z.literal('B'), B: z.string() }).extend(baseSchema),
]);
```
TS is still complaining about a missing `name` ðŸ˜¢

The only way that's currently works (as far as I know) is copy/pasting the `baseSchema`.

```ts
const schema = z.discriminatedUnion('name', [
  z.object({ name: z.literal('A'), A: z.string(), sharedProp: z.string() }),
  z.object({ name: z.literal('B'), B: z.string(), sharedProp: z.string() }),
]);
```

In this small example that's fine, but in practice `baseSchema` is pretty big ðŸ˜•",,
2018263559,3008,Support single value in enum's `.exclude` & `.extract`,"```ts
const granularitySchema = z.enum([
  'day',
  'week',
  'fortnight',
  'month',
  'quarter',
  'semester',
  'year',
]);
```

Right now I need to always pass an array to these methods even if I just want to exclude/extract 1 value

```ts
const notDaySchema = granularitySchema.exclude(['day']);
const daySchema = granularitySchema.extract(['day']);
```

It would be nice if I could just do

```ts
const notDaySchema = granularitySchema.exclude('day');
const daySchema = granularitySchema.extract('day');
```",,
2018255879,3007,Add docs for enum's `.exclude` & `.extract`,"I was looking for these in the docs but couldn't find them, type hints made me aware of their existence though",,
2018236770,3006,`z.discriminatedUnion` does not work on 2 other descriminated unions,"```ts
const schema1 = z.discriminatedUnion('entity', [
  z.object({ entity: z.literal('A') }),
  z.object({ entity: z.literal('B') }),
]);
const schema2 = z.discriminatedUnion('entity', [
  z.object({ entity: z.literal('C') }),
  z.object({ entity: z.literal('D') }),
]);
```
When I then want to do
```ts
const schema3 = z.discriminatedUnion('entity', [schema1, schema2]);
```
I get TS errors `TS2740`",,
2016013576,3001,Error with infer when creating zod wrapper (TS2503: Cannot find namespace),"Hi, am I doing something wrong please? The end goal is to wrap zod so I can swap/adjust validator implementations, decorate with custom logging and other functions or methods, etc. I am new to JS/TS. Thanks in advance!

```js
import { z } from 'zod';

const myZ = z;

const SomeSchema = myZ.strictObject( {
	'type': myZ.union( [
		myZ.literal( 'hello' ),
		myZ.literal( 'world' )
	] )
} ); // <=== works

console.log( SomeSchema ); // <=== works

export type SomeType = myZ.infer<typeof SomeSchema>;  // <=== ERROR TS2503: Cannot find namespace 'myZ'
```

Here is my tsconfig.json:

```json
{
    ""include"": [""**/*.ts"", ""**/*.tsx"", ""types/""],
    ""compilerOptions"": {
        ""target"": ""ES6"",
        ""moduleResolution"": ""node"",
        ""strict"": true,
        ""jsx"": ""react-jsx"",
        ""esModuleInterop"": true,
        ""plugins"": [{ ""name"": ""typescript-plugin-css-modules"" }]
    }
}
```",,
2015160332,2999,Add a sub-code for Zod custom issue,"### Discussed in https://github.com/colinhacks/zod/discussions/2997

There are many zod standard errors, and just one single custom.

Adding a sub-code to custom errors would allow the users to extend the custom error and have their codes as well.

Like when a model defines a password form (where a user enters a new password twice - see details in the [discussion](https://github.com/colinhacks/zod/discussions/2997)) the custom errors for a `password-mismatch` is different from `password-complexity`. Why would these be squeezed into a single custom category?

In the discussion we came to the conclusion that it would be helpfull to have sub-codes in custom errors, in particular for i18n.

Something like that:

```typescript
export interface ZodCustomIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.custom;
  subCode?: string;          // <<<==== add this
  params?: { [k: string]: any };
}
```

This seems like a trivial change. I could try a PR if you like the proposal.
",,
2015083835,2998,`z.discriminatedUnion` does not work when key is `constructor`,"The same issue applies for other keys on `object` too:
```ts
interface Object {
    constructor: Function;
    toString(): string;
    toLocaleString(): string;
    valueOf(): Object;
    hasOwnProperty(v: PropertyKey): boolean;
    isPrototypeOf(v: Object): boolean;
    propertyIsEnumerable(v: PropertyKey): boolean;
}
```

A working fix is to add the keys as optional keys on `ZodRawShape`:
```ts
type ZodRawShape = { [k: string]: ZodTypeAny; constructor?: ZodTypeAny }
```

[TS Playground repro](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgNwBQAxhAHYDO8A7gBYCG8AvCgHTHD0qUUMFocApsQCqtYHQAU+GgxhQArlRjR8AGjgBtCnGO8IAIwBW4zfKTLG6zdABcvADbAY4qGzeK2+ACU6IE6RibIPOZWNnZ0DhpaUK6RHl4+fvhmQSFhALqB1PHM7DAATHDckfyCwiCiEtKyCvhaAMqqogDmugbhxpHR1jC2cO2dtF0pPGnevv45aKH9ppbDo+PCk9OzGYrZwUv5gUA)

Unfortunately `ZodRawShape` is `type { [k: string]: ZodTypeAny };`, rather than an interface, so this cannot be fixed in userspace by declaration-merging",,
2012531221,2996,Regression: z.refine type inside z.object returns (RefineType) & (RefineType | undefined),"Seems related to https://github.com/colinhacks/zod/issues/2203 (and others), but I haven't seen anyone mention this issue with `refine`.

This happens in **3.22.0** and worked fine in **3.21.0**.

```ts
const customIdSchema = z
  .string()
  .refine((value): value is `${number}` | `c${number}` =>
    /^c?\d+$/.test(value)
  );

const myObjectSchema = z.object({
  id: customIdSchema,
});

type MyObject = z.infer<typeof myObjectSchema>;

// Result
// {
//    id: (`${number}` | `c${number}`) & (`${number}` | `c${number}` | undefined);
// }

// Expected
// {
//    id: `${number}` | `c${number}`;
// }
```",,
2011102508,2994,Schema Object Contains Optional Properties,"I'm confused about the return type when creating a schema. For example, here is my schema:

```typescript
export const AuthorSchema = z
  .object({
    firstName: z.string().min(2),
    lastName: z.string().min(2),
  })
  .required();
```

This is the return type of `AuthorSchema`:

```typescript
const AuthorSchema: z.ZodObject<{
    firstName: z.ZodString;
    lastName: z.ZodString;
}, ""strip"", z.ZodTypeAny, {
    firstName?: string;
    lastName?: string;
}, {
    firstName?: string;
    lastName?: string;
}>
```
I don't want these properties to be optional, they are required. Inferring the type has this result:

`export type CreateAuthorDto = z.infer<typeof AuthorSchema>;`

```typescript
type CreateAuthorDto = {
    firstName?: string;
    lastName?: string;
}
```

My expectation is that it looks like this:
```typescript
type CreateAuthorDto = {
    firstName: string;
    lastName: string;
}
```

I'm obviously missing something, but haven't been able to track down what.
",,
2010559160,2991,TypeError: _missingExportShim is not a function at ZodSchema.getJsonSchema,"Following code taken from example and adopted to Deno https://github.com/lgrammel/modelfusion/blob/main/examples/middle-school-math-agent/src/MiddleSchoolMathOpenAITools.ts

```
const apiKey = Deno.env.get('OPENAI_API_KEY')

const input = { text: 'solve this' }

MathAgent();

async function MathAgent() {
  const { text: problem } = input;

  const { OpenAIApiConfiguration, OpenAIChatMessage, openai, useToolsOrGenerateText, Tool, ZodSchema } = await import(""https://dev.jspm.io/modelfusion"");
  const { z } = await import(""https://dev.jspm.io/zod"");

  const calculator = new Tool({
    name: ""calculator"",
    description: ""Execute a calculation"",

    parameters: new ZodSchema(
      z.object({
        a: z.number().describe(""The first number.""),
        b: z.number().describe(""The second number.""),
        operator: z.enum([""+"", ""-"", ""*"", ""/""]).describe(""The operator.""),
      })
    ),

    execute: async ({ a, b, operator }) => {
      switch (operator) {
        case ""+"":
          return a + b;
        case ""-"":
          return a - b;
        case ""*"":
          return a * b;
        case ""/"":
          return a / b;
        default:
          throw new Error(`Unknown operator: ${operator}`);
      }
    },
  });

  const messages = [
    OpenAIChatMessage.system(
      ""You are solving math problems. "" +
      ""Reason step by step. "" +
      ""Use the calculator when necessary. "" +
      ""The calculator can only do simple additions, subtractions, multiplications, and divisions. "" +
      ""When you give the final answer, provide an explanation for how you got it.""
    ),
    OpenAIChatMessage.user(problem),
  ];

  console.log(`PROBLEM: ${problem}\n`);

  const { text, toolResults } = await useToolsOrGenerateText(
    openai.ChatTextGenerator({
      api: new OpenAIApiConfiguration({ apiKey }),
      model: ""gpt-4-1106-preview"",
      temperature: 0,
      maxCompletionTokens: 500,
    }),
    [calculator],
    messages
  );

}
```

And probably the error is triggered when running around here https://github.com/lgrammel/modelfusion/blob/61562b19863b8ad7c990a0af920a93dc94594941/src/tool/generate-tool-calls-or-text/generateToolCallsOrText.ts#L139C45-L139C53

```
OPENAI_API_KEY=$(cat .openai-key) deno run --allow-all nov25-third.ts
PROBLEM: solve this

error: Uncaught (in promise) TypeError: _missingExportShim is not a function
        return _missingExportShim(this.zodSchema);
               ^
    at ZodSchema.getJsonSchema (https://dev.jspm.io/npm:modelfusion@0.80.0/_/EQpO4pnp.js:79:16)
    at https://dev.jspm.io/npm:modelfusion@0.80.0:7555:49
    at Array.map (<anonymous>)
    at OpenAIChatModel.doGenerateToolCallsOrText (https://dev.jspm.io/npm:modelfusion@0.80.0:7550:26)
```",,
2009317086,2990,z.function arguments can't be optional,"```
// Case1
function demo(value?: boolean) {
   console.log(value)
}
demo(); // work

const func = z
  .function()
  .args(z.boolean().optional())
  .implement((val) => {
    console.log(val);
  });

func(); // fail
```

```
// Case2
function demo(arg1: number, arg2?: boolean) {
   console.log(arg1, arg2)
}
demo(1); // work

const func = z
  .function()
  .args(z.number(), z.boolean().optional())
  .implement((arg1, arg2) => {
    console.log(arg1, arg2)
  });

func(1); // fail
```
",,
2008882755,2986,Throw own exception in catch block of Zod objects,"Instead of returning a value in a catch block, I'd rather throw my own exception.

Right now doing this would result in the `z.ZodCatch` type being assigned as a wrapper.

Ex:

```ts
export const IdField = z
    .string()
    .uuid()
    .readonly()
    .catch((ctx): string => {
        throw new InvalidIdError('v4', ctx.input);
    });
```

Although this works by itself, when using `z.merge` later on, this breaks in the input field of the context of another object.


```ts
const MyObject = z
    .object({
        id: IdField,
        name: z.string(),
    })
    .catch((ctx) => {
         throw new InvalidObjectError(ctx.input.id); <-- id is unknown
    })
```

Is there anyway we can do this in Zod?

IMO this is because ZodCatch doesn't extend ZodObject so we can't chain them together :(
",,
2008642190,2985,Parse a boolean value represented by string logically,"From https://github.com/colinhacks/zod/issues/1630#issuecomment-1824670600

Currently `z.boolean()` simply replesents `Boolean()` for coerce. So it handles string value as boolean along with the standard `Boolean()` specification.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean#boolean_coercion

```ts
const b = z.coerce.boolean()
b.parse(""true"");    // true
b.parse(""false"");   // true
b.parse(""True"");    // true
b.parse(""False"");   // true
b.parse(""1"");       // true
b.parse(""0"");       // true
b.parse("""");        // false
b.parse(undefined); // false
b.parse(""others"");  // true
```

However we often need to handle string as boolean, `""false""` or `""0""` as `false`, such as parsing environment valiables.

Current workaround is like

```ts
const b1 = z.string().toLowerCase().transform(JSON.parse).pipe(z.boolean());
b1.parse(""true"");   // true
b1.parse(""false"");  // false
b1.parse(""True"");   // true
b1.parse(""False"");  // false
b1.parse(""tRue"");   // true
b1.parse(""fAlse"");  // false
b1.parse(""1"");      // ZodError
b1.parse(""0"");      // ZodError
b1.parse(""others""); // ZodError
```

My suggestion is a new [string transformation](https://zod.dev/?id=strings): `z.string().boolean()`

The transforming specification in Go standard library's `strconv.ParseBool()` is good for it.

https://pkg.go.dev/strconv#ParseBool

>ParseBool returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error.

```ts
// Suggestions
const b1 = z.string().boolean()
b1.parse(""true"");    // true
b1.parse(""false"");   // false
b1.parse(""True"");    // true
b1.parse(""False"");   // false
b1.parse(""tRue"");    // ZodError in boolean transformation
b1.parse(""fAlse"");   // ZodError in boolean transformation
b1.parse(""1"");       // true
b1.parse(""0"");       // false
b1.parse("""");        // ZodError in boolean transformation
b1.parse(undefined); // ZodError by string() as required
b1.parse(""others"");  // ZodError in boolean transformation

// false for undefined string
const b2 = z.string().boolean().default(""false"")
b2.parse(undefined); // false

// false for any boolean transformation errors and string errors
const b3 = z.string().boolean().catch(false)
b3.parse(""tRue"");    // false
b3.parse(""fAlse"");   // false
b3.parse("""");        // false
b3.parse(undefined); // false
b3.parse(""others"");  // false
```
",,
2004713406,2983,"[Expo][Web][Metro] Unable to resolve ""zod""","I am having an issue with compiling `zod` under expo web project using metro bundler. 
However it works on mobile within the same repository.
This is a completely new project so it utilizes the latest versions of all libraries.



The only error that I can see is this error which metro throws.
I couldn't find any other related logs so if you have idea how I can find that please guide me.

<img width=""405"" alt=""Screenshot 2023-11-21 at 17 31 47"" src=""https://github.com/colinhacks/zod/assets/18654447/8d7d18cf-3310-4a4c-a1e6-dd566b229b84"">

The error that I can see in browser actually doesn't say much and most likely comes from lack of properly bundled package.
<img width=""944"" alt=""Screenshot 2023-11-21 at 17 32 53"" src=""https://github.com/colinhacks/zod/assets/18654447/b01a600b-c4cf-4574-96dd-6af1be1f6c1e"">



tsconfig:

```{
  ""extends"": ""expo/tsconfig.base"",
  ""compilerOptions"": {
    ""strict"": true,
    ""baseUrl"": ""./src"",
    ""paths"": {
      ""@/*"": [""*""]
    },
    ""skipLibCheck"": true
  },
  ""include"": [""**/*.ts"", ""**/*.tsx"", "".expo/types/**/*.ts"", ""expo-env.d.ts""]
}
```


babel.config.js

```
module.exports = function (api) {
  api.cache(true);

  return {
    presets: [""babel-preset-expo""],
    plugins: [
      ""expo-router/babel"",

      // optional, only if you ever use process.env
      ""transform-inline-environment-variables"",
      // NOTE: this is optional, you don't *need* the compiler
      [
        ""@tamagui/babel-plugin"",
        {
          components: [""tamagui""],
          config: ""./tamagui.config.ts"",
          logTimings: true,
          // @TODO: disable on production
          disableExtraction: true,
        },
      ],
      // NOTE: this is only necessary if you are using reanimated for animations
      ""react-native-reanimated/plugin"",
    ],
  };
};
```
",,
2004582902,2982,BUG: Wrong email validation,"There were introduced breaking changes in minor release for email validation.
Previously emails such as `som.el'user@example.com` were successfully validated using `z.string().email()`

In zod `3.21.4` such email is valid
But in zod `3.22.4` such email is invalid

Such emails should be valid, so this issue should be fixed I suppose.",,
1999503449,2975,Cannot figure how to work with existing types ZodType,"```
export const oidcSchema: z.ZodType<{ client_id: string, issuer: string}> = z.object({
  client_id: z.string(),
  issuer: z.string().url(),
});
```

```
Property 'client_id' is optional in type '{ client_id?: string; issuer?: string; }' but required in type '{ client_id: string; issuer: string; }'
```

What am I doing wrong?",,
1999226375,2974,Custom error messages don't work with z.literal,"## Code
```ts
const schema = z.literal(true, {
  invalid_type_error: ""Custom Error 1"",
  required_error: ""Custom Error 2"",
})
// ...
schema.safeParse(false)
```

## Expection Result
```
ZodError: [
  {
    ""received"": false,
    ""code"": ""invalid_literal"",
    ""expected"": true,
    ""path"": [],
    ""message"": ""Custom Error 1""
  }
]
```

## Actual Result
```
ZodError: [
  {
    ""received"": false,
    ""code"": ""invalid_literal"",
    ""expected"": true,
    ""path"": [],
    ""message"": ""Invalid literal value, expected true""
  }
]
```
",,
1995759828,2970,Zod schema validation with union fails when schema has missing fields,"I'm having some a hard time understanding why my schema with union is failing.

Here's the schema: 
```ts
export const reportFormSchema = () => {
  const { validator } = reportTemplateNameValidator();

  const fieldSchema = z.object({
    id: z.nativeEnum(ReportFieldName),
    content: z.string().min(1),
    isTransferDisabled: z.boolean().optional(),
    isIndicator: z.boolean()
  });

  const reportFormSchemaBase = z.object({
    direction: z.nativeEnum(ReportDirection),
    format: z.nativeEnum(ReportFormat),
    type: z.nativeEnum(ReportType),
    fields: z
      .array(fieldSchema)
      .refine((items) => items.some((item) => item.isIndicator)),
    daysBeforeDepartures: z.array(z.string())
  });

  const reportTemplateFormSchema = reportFormSchemaBase.extend({
    name: z.string().trim().refine(validator, {
      message: ""nameAlreadyExists""
    }),
    mode: z.literal(FORM_MODE.REPORT_TEMPLATE),
    scopeCode: z.undefined()
  });

  const reportGenerateFormSchema = reportFormSchemaBase.extend({
    name: z.string().trim().min(1, { message: ""fieldRequired"" }),
    mode: z.literal(FORM_MODE.REPORT_GENERATE),
    scopeCode: z.string().min(1)
  });

  return z
    .union([reportTemplateFormSchema, reportGenerateFormSchema])
    .refine((formData) =>
      formData.type === ReportType.OD_CLASS_DBD ||
      formData.type === ReportType.LEG_CLASS_DBD
        ? formData.daysBeforeDepartures.length > 0
        : formData.daysBeforeDepartures.length === 0
    );
};

export type ReportFormSchema = z.infer<ReturnType<typeof reportFormSchema>>;
```

I want `scopeCode` to be a `string` when in `FORM_MODE.REPORT_GENERATE` and `undefined` when in `FORM_MODE.REPORT_TEMPLATE`, however, when I try to parse this data:
```ts
const result = reportFormSchema();
    const parseResult = result.safeParse({
      scopeCode: ""SC0000000432"",
      mode: FORM_MODE.REPORT_GENERATE,
      daysBeforeDepartures: [],
    });
```
My test fails, which is expected since there are missing fields, however, `scopeCode` should not be on error since it is not `undefined` and I'm in `mode:  FORM_MODE.REPORT_GENERATE`, here's the error on field `scopeCode:
```ts
{
  ""code"": ""invalid_type"",
  ""expected"": ""undefined"",
  ""received"": ""string"",
  ""path"": [
    ""scopeCode""
  ],
  ""message"": ""Expected undefined, received string""
}
```
What's even stranger is that I get this error too:
```ts
{
  received: 'reportGenerate',
  code: 'invalid_literal',
  expected: 'reportTemplate',
  path: ['mode'],
  message: 'Invalid literal value, expected ""reportTemplate""',
},
```
I'm not sure why I'm getting this error and I suspect that's why I'm getting the error on `scopeCode`.

When validating the schema with all the required data, the test passes and `scopeCode` isn't on error anymore.
```ts
const result = reportFormSchema();
    const parseResult = result.safeParse({
    direction: ReportDirection.BY_COLUMN,
    format: ReportFormat.XLSX,
    type: ReportType.WEEK_AGGR,
    name: ""test"",
    fields: [
      {
        id: ReportFieldName.DEPARTURE_DATE,
        content: ""Operator"",
        isTransferDisabled: false,
        isIndicator: true,

      {
        id: ReportFieldName.DEPARTURE_WEEK,
        content: ""Departure Date"",
        isTransferDisabled: false,
        isIndicator: false,
      },
    ],
      scopeCode: ""SC0000000432"",
      mode: FORM_MODE.REPORT_GENERATE,
      daysBeforeDepartures: [],
    });
```
I dont know what I'm doing wrong, from my understanding of how `union` works in Zod, the schema should be working.

I've created a [codesandbox](https://codesandbox.io/p/sandbox/blissful-rui-52hx66?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522cloziuxm800073b6hbmdtfarm%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522cloziuxm800033b6ha3ld1hnk%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522cloziuxm800053b6hvjo15gfs%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522cloziuxm800063b6hum4d05m0%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B81.36440013442366%252C18.63559986557634%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522cloziuxm800033b6ha3ld1hnk%2522%253A%257B%2522id%2522%253A%2522cloziuxm800033b6ha3ld1hnk%2522%252C%2522activeTabId%2522%253A%2522clozj74u101gl3b6hng9icvjf%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cloziuxm800023b6hdfll1qbt%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Ftsconfig.json%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fjest.config.ts%2522%252C%2522id%2522%253A%2522clozixax400ae3b6h4hoz6izq%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.ts%2522%252C%2522id%2522%253A%2522clozj2xzu00n13b6hqi40tqie%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.test.ts%2522%252C%2522id%2522%253A%2522clozj74u101gl3b6hng9icvjf%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%255D%257D%252C%2522cloziuxm800063b6hum4d05m0%2522%253A%257B%2522id%2522%253A%2522cloziuxm800063b6hum4d05m0%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522cloziuxm800053b6hvjo15gfs%2522%253A%257B%2522id%2522%253A%2522cloziuxm800053b6hvjo15gfs%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cloziuxm800043b6hiz1mj1h2%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TERMINAL%2522%252C%2522shellId%2522%253A%2522cloziuxqe0009efd97phg3lq4%2522%257D%255D%252C%2522activeTabId%2522%253A%2522cloziuxm800043b6hiz1mj1h2%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D) with the schema and some testes, the one failing is `'should return a VALID SCHEMA object when report in ""reportGenerate"" mode and only ""scopeCode"" and ""daysBeforeDepartures""'`

Any help would be appreciated.",,
1994652411,2967,"Using a (big) enum in a type predicate for `refine` causes ""Expression produces a union type that is too complex to represent"" error and type predicate not taken in account (`3.21.2`-`3.22.5` only)","Hello!

I'm using the following schema to represent something that is ""likely enum"" so to speak (where `Enum` is an arbitrary TypeScript numeric non-const enum):

```ts
const EnumZod = z.number().int().refine((v): v is Enum | (number & {}) => true);
```

This makes TypeScript to show a bit more useful type than just `number`:

![2023-11-15 14_45_59-zod-big-enum-error - playground ts](https://github.com/colinhacks/zod/assets/6554045/e69c5a46-07e8-47e8-9a2b-6acde9831620)

After deciding to update zod from `3.20.2` to the latest version as of time I'm writing this (`3.22.4`), `z.infer` started to remove `Enum` part of the type, but **only if this schema is used within `z.object`**:

```ts
const Schema = z.object({
  a: z.object({
    b: EnumZod,
  }),
  c: EnumZod,
});
```

![2023-11-15 14_51_49-â— zod-big-enum-error - playground ts](https://github.com/colinhacks/zod/assets/6554045/660b99a3-8f4b-42f7-a00e-3c245fdedcec)

Moreover, if the enum contains more than 314 members (~related to Pi? :D~) AND the enum schema is used in a **nested** `z.object`, it's not even allowing to have such a schema:

![2023-11-15 14_55_46-â— zod-big-enum-error - playground ts](https://github.com/colinhacks/zod/assets/6554045/8e24ce55-9227-4f3c-b497-fe287d89d5e4)

If I remove `a` member of `Schema`, the error will move to `z.infer`:

![2023-11-15 14_59_54-zod-big-enum-error - playground ts](https://github.com/colinhacks/zod/assets/6554045/5e36df55-2f40-4f16-89c4-2804ecb91470)

---

The exact version after which this behaviour began to be observed is `3.21.2`: https://github.com/colinhacks/zod/compare/v3.21.1...v3.21.2

",,
1994091625,2966,Incorrect Type Inference for Non-Optional Field with z.unknown(),"I encountered an unexpected behavior in Zod's type inference system when using z.unknown(). The issue arises when defining an object schema with a field that should be required, but the inferred TypeScript type incorrectly marks it as optional.

```typescript
import { z } from 'zod';

const test = z.object({
  shouldExist: z.unknown(),
});
type Test = z.infer<typeof test>;
// Expected: { shouldExist: unknown }
// Actual: { shouldExist?: unknown } (Incorrect, field should not be optional)
```

**Expected Behavior:**
The expected behavior is for the type Test to be inferred as { shouldExist: unknown }, indicating that shouldExist is a required field of unknown type.

**Actual Behavior:**
The actual inferred type is { shouldExist?: unknown }, incorrectly suggesting that the shouldExist field is optional.


",,
1993177318,2965,Problems while parsing the models when consuming prisma-generated zod models for typescript : 'You may need an additional loader to handle the result of these loaders',"My issue is that I'm generating the zod models in the backend using the generator **zod-prisma** (link to the project here [here](https://github.com/CarterGrimmeisen/zod-prisma)), till here all good the types are working in the backend without problem. 
At this point I create a symbolic link between the folder in which i generate the types and from the frontend. 
Here things that to not work anymore and I'm getting this:

> ERROR in ../backend/src/db_types/listinoarticolo.ts 16:7
> Module parse failed: Unexpected token (16:7)
> File was processed with these loaders:
 > ./node_modules/@pmmmwh/react-refresh-webpack-plugin/loader/index.js
 > ./node_modules/source-map-loader/dist/cjs.js
 > You may need an additional loader to handle the result of these loaders. 
 
 > export interface MyModel extends z.infer<typeof AnotherModel> {
    .....
webpack compiled with 1 error `

Do you ever encounter any problem like this? I feel that the symbolic link is breaking something.
For reference:

Ract: 18.2.0
Zod: 3.22.4 (both frontend and backend) 

## UPDATE:

By copying the models folder instead of using a symbolic link solved the problem and so I start to think that is something related to CRA and the fact that is kind of outside the directory and so i created a config-override.js to solve this problem but still the problem persist with the symbolic link.



",,
1992579369,2964,Discrepancy between inferred type and z.ZodType when default() is used,"Given a type and a matching schema

```ts
type DurationRecord = {
  hours?: number | undefined;
  minutes: number;
};

const DurationRecordSchema: z.ZodType<DurationRecord> = z.object({
  hours: z.number().optional(),
  minutes: z.number().default(0),
}); 
```

I would expect no error, but instead I get the following typescript error:

```
Type 'ZodObject<{ hours: ZodOptional<ZodNumber>; minutes: ZodDefault<ZodNumber>; }, ""strip"", ZodTypeAny, { minutes: number; hours?: number | undefined; }, { ...; }>' is not assignable to type 'ZodType<DurationRecord, ZodTypeDef, DurationRecord>'.
  The types of '_input.minutes' are incompatible between these types.
    Type 'number | undefined' is not assignable to type 'number'.
      Type 'undefined' is not assignable to type 'number'.ts(2322)
```

If we instead infer the type from the schema, we get what *seems* to be the same type:

![image](https://github.com/colinhacks/zod/assets/434495/88950b4b-52d0-4014-be67-f8bc186e9fad)
",,
1992106121,2963,z.string().email() fails when email contains an exclamation mark,"`z.string().email()` fails with emails that contain an exclamation mark (`!`) e.g.

`a!test@googlecalender.com`

(This happened to me after upgrading from `3.21.4` to `3.22.0`.)",,
1992060423,2962,zod > 3.22.2 causes `JavaScript heap out of memory` when running `tsc`,"Versions:

nodejs: 18.17.0
typescript: 5.2.2

We get the following error when updating zod to 3.22.3 or 3.22.4 and running `tsc`:

```
$ tsc

<--- Last few GCs --->

[17523:0x160078000]    93868 ms: Scavenge 4044.0 (4128.4) -> 4036.7 (4128.9) MB, 4.5 / 0.0 ms  (average mu = 0.770, current mu = 0.506) allocation failure; 
[17523:0x160078000]    93875 ms: Scavenge 4044.2 (4128.9) -> 4037.0 (4129.4) MB, 4.5 / 0.0 ms  (average mu = 0.770, current mu = 0.506) allocation failure; 
[17523:0x160078000]    93882 ms: Scavenge 4044.5 (4129.4) -> 4037.3 (4145.4) MB, 4.7 / 0.0 ms  (average mu = 0.770, current mu = 0.506) allocation failure; 


<--- JS stacktrace --->

FATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory
 1: 0x1009666e4 node::Abort() [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 2: 0x1009668c8 node::ModifyCodeGenerationFromStrings(v8::Local<v8::Context>, v8::Local<v8::Value>, bool) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 3: 0x100abd60c v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 4: 0x100c67ec4 v8::internal::EmbedderStackStateScope::EmbedderStackStateScope(v8::internal::Heap*, v8::internal::EmbedderStackStateScope::Origin, cppgc::EmbedderStackState) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 5: 0x100c6686c v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 6: 0x100c5a900 v8::internal::HeapAllocator::AllocateRawWithLightRetrySlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 7: 0x100c5b144 v8::internal::HeapAllocator::AllocateRawWithRetryOrFailSlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 8: 0x100c410c4 v8::internal::Factory::NewFillerObject(int, v8::internal::AllocationAlignment, v8::internal::AllocationType, v8::internal::AllocationOrigin) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
 9: 0x100fe16c0 v8::internal::Runtime_AllocateInYoungGeneration(int, unsigned long*, v8::internal::Isolate*) [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
10: 0x10133104c Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit [/Users/p306268/.nodenv/versions/18.17.0/bin/node]
11: 0x1067ae514 
12: 0x106ed0fe8 
13: 0x106816574 
14: 0x106256010 
15: 0x106d26c70 
16: 0x106d0de3c 
17: 0x1070b89ac 
18: 0x106fb472c 
19: 0x106d295e8 
20: 0x106fd9008 
21: 0x106257c18 
22: 0x106d29538 
23: 0x106fd9008 
24: 0x106257c18 
25: 0x1070b96c8 
26: 0x106fb472c 
27: 0x106d295e8 
28: 0x106fd9008 
29: 0x106257c18 
30: 0x106d29538 
31: 0x106fd9008 
32: 0x106257c18 
33: 0x1070b96c8 
34: 0x106fb472c 
35: 0x106d295e8 
36: 0x106fd9008 
37: 0x106257c18 
38: 0x106d29538 
39: 0x106fd9008 
40: 0x106257c18 
41: 0x1070b96c8 
42: 0x106fb472c 
43: 0x106d295e8 
44: 0x106fd9008 
45: 0x106257c18 
46: 0x106d29538 
47: 0x106fd9008 
48: 0x106257c18 
49: 0x1070b96c8 
50: 0x106fb472c 
51: 0x106d295e8 
52: 0x106fd9008 
53: 0x106257c18 
54: 0x106d29538 
55: 0x106fd9008 
56: 0x106257c18 
57: 0x1070b96c8 
58: 0x106fb472c 
59: 0x106d295e8 
60: 0x106fd9008 
61: 0x106257c18 
62: 0x106d29538 
63: 0x106fd9008 
64: 0x106257c18 
65: 0x1070b96c8 
66: 0x106fb472c 
67: 0x106d295e8 
68: 0x106fd9008 
69: 0x106257c18 
70: 0x106d29258 
71: 0x106fd9008 
72: 0x106257c18 
73: 0x1070b96c8 
74: 0x106fb472c 
75: 0x106d295e8 
76: 0x106fd9008 
77: 0x106257c18 
78: 0x106d29538 
79: 0x106fd9008 
80: 0x106257c18 
81: 0x1070b96c8 
82: 0x106fb472c 
83: 0x106d295e8 
84: 0x106fd9008 
85: 0x106257c18 
86: 0x106d29538 
87: 0x106fd9008 
88: 0x106257c18 
89: 0x1070b96c8 
90: 0x106fb472c 
91: 0x106d295e8 
92: 0x106fd9008 
93: 0x106257c18 
94: 0x106d29538 
95: 0x106fd9008 
96: 0x106257c18 
97: 0x1070b96c8 
98: 0x106fb472c 
99: 0x106d295e8 
100: 0x106fd9008 
101: 0x106257c18 
102: 0x106d29538 
103: 0x106fd9008 
104: 0x106257c18 
105: 0x106d29538 
106: 0x106fd9008 
107: 0x106257c18 
108: 0x1070b96c8 
109: 0x106fb472c 
110: 0x106d295e8 
111: 0x106fd9008 
112: 0x106257c18 
113: 0x106d29258 
114: 0x106fd9008 
115: 0x106257c18 
116: 0x1070b96c8 
117: 0x106fb472c 
118: 0x106d295e8 
119: 0x106fd9008 
120: 0x106257c18 
121: 0x106d29258 
122: 0x106fd9008 
123: 0x106257c18 
124: 0x106993134 
125: 0x106257f30 
126: 0x106258058 
127: 0x106d29538 
128: 0x106fd9008 
129: 0x106257c18 
130: 0x106993134 
131: 0x106257f30 
132: 0x106d0ed60 
133: 0x106d29814 
134: 0x106fd9008 
135: 0x106257c18 
136: 0x106816618 
137: 0x106256130 
138: 0x1070b96c8 
139: 0x106fb472c 
140: 0x106d295e8 
141: 0x106fd9008 
142: 0x106257c18 
143: 0x106d29258 
144: 0x106fd9008 
145: 0x106257c18 
146: 0x10695fdd0 
147: 0x1070b77f4 
148: 0x106ee448c 
149: 0x1069a7c28 
150: 0x1069886e0 
151: 0x10681a4b0 
152: 0x106771878 
153: 0x10672afa0 
154: 0x10672046c 
155: 0x10680adb8 
156: 0x107089c98 
157: 0x106732df0 
158: 0x1067619d4 
159: 0x10676530c 
160: 0x10672ae84 
161: 0x10672046c 
162: 0x10680adb8 
163: 0x107089c98 
164: 0x10676eec4 
165: 0x10698a254 
166: 0x10681a4b0 
167: 0x106771878 
168: 0x10672afa0 
169: 0x10672046c 
170: 0x10680adb8 
171: 0x107089c98 
172: 0x106732df0 
173: 0x1067619d4 
174: 0x10676530c 
175: 0x10672ae84 
176: 0x10672046c 
177: 0x10680adb8 
178: 0x107089c98 
179: 0x10676eec4 
180: 0x10698a254 
181: 0x10681a4b0 
182: 0x106771878 
183: 0x10672afa0 
184: 0x10672046c 
185: 0x10680adb8 
186: 0x107089c98 
187: 0x106732df0 
188: 0x1067619d4 
189: 0x10676530c 
190: 0x10672ae84 
191: 0x10672046c 
192: 0x10680adb8 
193: 0x107089c98 
194: 0x10676eec4 
195: 0x10698a254 
196: 0x10681a4b0 
197: 0x106771878 
198: 0x10672afa0 
199: 0x10672046c 
200: 0x10680adb8 
201: 0x107089c98 
202: 0x106732df0 
203: 0x1067619d4 
204: 0x10676530c 
205: 0x10672ae84 
206: 0x10672046c 
207: 0x10680adb8 
208: 0x107089c98 
209: 0x10676eec4 
210: 0x10698a254 
211: 0x10681a4b0 
212: 0x106771878 
213: 0x10672afa0 
214: 0x10672046c 
215: 0x10680adb8 
216: 0x107089c98 
217: 0x106732df0 
218: 0x1067619d4 
219: 0x10676530c 
220: 0x10672ae84 
221: 0x10672046c 
222: 0x10680adb8 
223: 0x107089c98 
224: 0x10676eec4 
225: 0x10698a254 
226: 0x10681a4b0 
227: 0x106771878 
228: 0x10672afa0 
229: 0x10672046c 
230: 0x10680adb8 
231: 0x107089c98 
232: 0x106732df0 
233: 0x1067619d4 
234: 0x10676530c 
235: 0x10672ae84 
236: 0x10672046c 
237: 0x10680adb8 
238: 0x107089c98 
239: 0x10676eec4 
240: 0x10698a254 
241: 0x10681a4b0 
242: 0x106771878 
243: 0x10672afa0 
244: 0x10672046c 
245: 0x10680adb8 
246: 0x107089c98 
247: 0x106732df0 
248: 0x1067619d4 
249: 0x10676530c 
250: 0x10672ae84 
251: 0x10672046c 
252: 0x10680adb8 
253: 0x107089c98 
254: 0x10676eec4 
255: 0x10698a254 
[1]    17523 abort      tsc
```

I'm happy to add more information if someone tells me what to look for. Our project is fairly big. I have no idea which part might cause this.

Any help appreciated!",,
1991270683,2960,z.string().cuid2() validator doesn't conform to the upstream format,"Regex which is defined for cuid2 format validation doesn't conform to the one defined in the cuid2 library itself. 
It bothers me as i can't use this validator with ids generated by this elixir implementation of cuid2: https://github.com/joseph-lozano/cuid2

Said regex in the zod codebase:
https://github.com/colinhacks/zod/blob/master/src/types.ts#L549

Regex in the upstream cuid2 codebase:
https://github.com/paralleldrive/cuid2/blob/main/src/index.js#L105
",,
1989245828,2957,ZodError[] doesn't contain error from `refine()` or `superRefine()`,"Hi there âœŒðŸ¾,

Basically, I have set up my schema for `products` with a few custom error messages and a `superRefine()` to throw an error if the `comparedAt` price is lower than the actual `price`. I use `safeParse()` to do the validation and get the errors.

Everything is working fine until I have 2 errors not coming from the `superRefine()` AND the one coming from the `superRefine()`.
In that case, the error coming from `superRefine()` won't show up in the `ZodError[]`. I have tried the `refine()` and `superRefine()` ways, both lead to the same outcome.

Take a look at the logging of the errors (don't pay attention to the double rendering):

![image](https://github.com/colinhacks/zod/assets/77295465/18cc6892-0ac5-4611-9ba0-d361298f2bf0)

**1st step:** I have only 2 errors, both not coming from `superRefine()`

**2nd step:** I add another not-from `superRefine()` error to make sure that the `ZodError[]` is actually able to contain more than 2 errors.

**3rd step:** I add the `superRefine()` error. I had to solve the `price` error to make it higher than the `comparedAt` price. That's why the `price` error isn't present anymore, but the `comparedAt` one should be there.

**4th step:** I solve the `name` error and only then the `superRefine()` error shows up.

**5th step:** I add the `name` error again and the `superRefine()` one disappears from the `ZodError[]` whereas it is still invalid.

Here's my schema:

```typescript
export const ZodProduct = z
  .object({
    name: z.string({required_error: 'Please, set a name.'}).min(1),
    images: z.object({
      mainImage: z.string().min(1, 'Please, set a main image.'),
      secondaryImages: z.array(z.string().min(1)).optional(),
    }),
    price: z
      .number({required_error: 'Please, set a price.'})
      .min(0, 'The price cannot be negative.'),
    comparedAt: z.number().min(0, 'The compared price cannot be negative.'),
    weight: z.number().min(0),
    width: z.number().min(0),
    height: z.number().min(0),
    length: z.number().min(0),
    sku: z.string().min(1),
  })
  .partial({
    comparedAt: true,
    weight: true,
    width: true,
    height: true,
    length: true,
    sku: true,
  })
  .superRefine((data, ctx) => {
    if (data.comparedAt && data.comparedAt <= data.price) {
      ctx.addIssue({
        type: 'number',
        code: 'too_small',
        minimum: data.price,
        inclusive: false,
        path: ['comparedAt'],
        message: 'The compared price should be higher than the actual one.',
      })
    }
  })",,
1988325515,2953,zod OR doesn't work as expected when parsing.,"**Link to Repl**: https://replit.com/@jarrodmedrano/zod-Or-bug-Optional#index.ts

I have two types, animal and person. Animal species is optional.

```ts
const personResult = z.object({
  name: z.string()
});

// when species optional, result gives nothing {}
const animalResult = z.object({
  species: z.string().optional(),
});

// when species is not optional, result will be correct
const animalResultWorks = z.object({
  species: z.string(),
});

```
When you parse them...
```ts
const aPerson = {
  name: ""Jerry""
}

const animalorPerson = z.object({
  something: animalResult.or(personResult).optional(),
}).optional();

const parsed = animalorPerson.safeParse({
  something: aPerson
}); 
```
You will get this result:
```ts
 { success: true, data: { something: {} } }
 ```

What it should be:
```ts
{
  success: true,
  data: { something: { name: 'Jerry' } }
}
```

You will get the correct result if you take the 'optional' off of species.
You will get the correct result if you reverse the order of the .or operation
if Species is optional and aPerson contains something totally invalid, you won't see any error message.
",,
1987532407,2952,Built-in support for GeoJSON data,"Example:
```ts
import { z, object, number, literal } from 'zod';

/**
 * A Position is an array of coordinates.
 * https://tools.ietf.org/html/rfc7946#section-3.1.1
 * Array should contain between two and three elements.
 * The previous GeoJSON specification allowed more elements (e.g., which could be used to represent M values),
 * but the current specification only allows X, Y, and (optionally) Z to be defined.
 */
export const GeoJsonPositionSchema = number().array();
export type GeoJsonPosition = z.infer<typeof GeoJsonPositionSchema>; // [number, number] | [number, number, number];

/**
 * Point geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3.1.2
 */
export const GeoJsonPointSchema = object({
	type: literal('Point'),
	coordinates: GeoJsonPositionSchema,
});
export type GeoJsonPoint = z.infer<typeof GeoJsonPointSchema>;

/**
 * MultiPoint geometry object.
 *  https://tools.ietf.org/html/rfc7946#section-3.1.3
 */
export const GeoJsonMultiPointSchema = object({
	type: literal('MultiPoint'),
	coordinates: GeoJsonPositionSchema.array(),
});
export type GeoJsonMultiPoint = z.infer<typeof GeoJsonMultiPointSchema>;

/**
 * LineString geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3.1.4
 */
export const GeoJsonLineStringSchema = object({
	type: literal('LineString'),
	coordinates: GeoJsonPositionSchema.array(),
});
export type GeoJsonLineString = z.infer<typeof GeoJsonLineStringSchema>;

/**
 * MultiLineString geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3.1.5
 */
export const GeoJsonMultiLineStringSchem = object({
	type: literal('MultiLineString'),
	coordinates: GeoJsonPositionSchema.array().array(),
});
export type GeoJsonMultiLineString = z.infer<typeof GeoJsonMultiLineStringSchem>;

/**
 * Polygon geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3.1.6
 */
export const GeoJsonPolygonSchema = object({
	type: literal('Polygon'),
	coordinates: GeoJsonPositionSchema.array().array(),
});
export type GeoJsonPolygon = z.infer<typeof GeoJsonPolygonSchema>;

/**
 * MultiPolygon geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3.1.7
 */
export const GeoJsonMultiPolygonSchema = object({
	type: literal('MultiPolygon'),
	coordinates: GeoJsonPositionSchema.array().array().array(),
});
export type GeoJsonMultiPolygon = z.infer<typeof GeoJsonMultiPolygonSchema>;

// The same for Geometry, GeometryCollection, GeoJsonProperties, Feature, FeatureCollection, etc.
```

GeoJSON types: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/geojson/index.d.ts
GeoJSON specification: https://datatracker.ietf.org/doc/html/rfc7946",,
1984782814,2948,Add `pastel` to zod ecosystem,"I recently discovered [`pastel`](https://www.npmjs.com/package/pastel), a criminally underused library for creating CLIs with [react](https://react.dev/), [zod](https://zod.dev/), and [ink](https://term.ink/).

Could we add it to the ecosystem for others to find it more easily?

PR incomingâ€¦",,
1984770572,2947,"Simple fix to setErrorMap not working as expected, and be able to Translate error messages","Context:

z.setErrorMap let us define a function that will be called after have found an error and modify the final response. This could allow us to create localized messages for different languages, but the result of this function is getting overwritten with the error message defined on the schema, and is not working properly.

The problem is on the function makeIssue that prioritize the issueData message over the error returned from the error map.

```
export const makeIssue = (params: {
  data: any;
  path: (string | number)[];
  errorMaps: ZodErrorMap[];
  issueData: IssueData;
}): ZodIssue => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...(issueData.path || [])];
  const fullIssue = {
    ...issueData,
    path: fullPath,
  };

  let errorMessage = """";
  const maps = errorMaps
    .filter((m) => !!m)
    .slice()
    .reverse() as ZodErrorMap[];
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }

  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage,
  };
};
```

I've created PR #2950 that introduce a new parameter 'force' that could be returned from the errorMap in order to overwrite the schema message, and use the schema message as a translation key to find the translated message as needed.",,
1984607827,2946,Add support for jwt,"Add support to verify jwt strings. For example
```ts
const jwtSchema = zod.string().jwt()
jwtSchema.parse()
```",,
1981218374,2942,z.effect for preprocessing returns correct type but z.preprocess returns unknown for z.input,"Hi,

first, thanks for this awesome package!

I found out by accident that `z.preprocess()` would return `unknown` if infering with z.input but, if using `z.effect()` for preprocessing, z.input would return the right type. 2 questions:
* Why can't preprocess correctly infer the input type? I know that the arg is typed as `unknown` but what if we know that it will be a string? There is no way to pass a generic type to it.
* Why does z.effect work and why I don't find it in the documentation? I think is worth to add this method of preprocessing.

```typescript
const emptyStringToUndefined = (v) => (v === '' ? undefined : v);

const SchemaUnknown = z.object({
  name: z.preprocess(emptyStringToUndefined, z.string().optional()),
});

const SchemaCorrect = z.object({
  name: z.effect(z.string().optional(), {
    type: 'preprocess',
    transform: emptyStringToUndefined,
  }),
});

// name?: unknown;
type A = z.input<typeof SchemaUnknown>;

// name?: string;
type B = z.input<typeof SchemaCorrect>;
```",,
1980722388,2941,ZodEnum of ZodDiscriminatedUnion discriminator options?,"I have a ZodDiscriminatedUnion defined like this:

```
const SuperType = z.discriminatedUnion(""type"", [TypeA, TypeB, ..., TypeZZ])
```

Is there a simple solution to derive a ZodEnum that holds all values that the discriminator can take as per this definition?

The Typescript type is relatively easy to get:

```
type T = SuperType[""type""]
```

But since I need the enumeration anyway, I would rather have it as a ZodEnum and derive the Typescript type from that.

The following gives me an array of (typed) ZodLiterals ...

```
const e = SuperType._def.options.map((option) => option._def.shape().type)
```

... but `.map()` produces no `const` array, so that I can't pass it to `z.enum()` afterwards.

Is there an other way to get a ZodEnum from the union?",,
1980478732,2940,Custom error map does not override original message,"I'm setting a message for `z.number().max(100, ""too_old"")`

In the contextual error map, wanted to override this and return `very old`.

Have verified that the error map is being called, but the error is the result still comes up with the original message `too_old`

Tracing this down:

https://github.com/colinhacks/zod/blob/481c9ba1932203777f6fe9497bb2a8a1d33c620e/src/helpers/parseUtil.ts#L31

Should the above be changed to the following?

```ts
message: errorMessage || issueData.message
```


Test Case:

```ts
test(""zod custom error map"", () => {
  const schema = z.object({
    age: z.number().max(100, ""too_old""),
  });

  let errorMapMessage = """";
  const errorMap: z.ZodErrorMap = (issue, ctx) => {
    if (issue.message === ""too_old"") {
      errorMapMessage = ""very old"";
      return { message: errorMapMessage };
    }
    return { message: ctx.defaultError };
  };

  const result = schema.safeParse({ age: 101 }, { errorMap });
  expect(result.success).toBe(false);
  expect(errorMapMessage).toBe(""very old"");
  if (!result.success) {
    expect(result.error.issues[0].message).toBe(""very old""); // fails: actual is still ""too_old""
  }
});
```",,
1979426370,2938,z.infer returns z.object for objects with passthrough and preprocess or transform,"When an object has both the passthrough flag and undergoes a preprocess or transform: 
z.infer returns the zod object, instead of the typescript evaluation.

Below is a small snippet illustrating the bug. In the first two instances, the type should be (working as of 3.21.0):
[Working Demo](https://stackblitz.com/edit/typescript-syvzmi?file=index.ts)

`
{
    a: ({
        b: number;
    } & {
        [k: string]: unknown;
    })[];
}`

```
import {z} from 'zod';
const innerObject = z.object({
  b: z.number(),
}).passthrough();

// Broken
const preProcessObject = z.object({
 a: z.preprocess(x => [x], z.array(innerObject)),
});
const transformObject = z.object({
  a: innerObject.transform(x => [x]),
});

// These evaluate to: 
// {
//   a: z.objectOutputType<{
//       b: z.ZodNumber;
//   }, z.ZodTypeAny, ""passthrough"">[];
// }
type PreProcessObject = z.infer<typeof preProcessObject>;
type TransformObject = z.infer<typeof transformObject>;

// Working
const refinedObject = z.object({
  a: innerObject.refine(x => x.b > 5),
});

type RefinedObject = z.infer<typeof refinedObject>;
```",,
1979333995,2936,Nullability discrepancy z.infer and z.ZodSchema,"### Issue
If you infer a type from a schema that has a null filter on it, the schema won't match the inferred type. This is perhaps easiest shown rather than explained , so here is the minimal reproduction i could make.


```typescript
import { z } from ""zod"";

const NullableSchema = z
  .array(z.string().nullable())
  .transform((arr) => arr.filter((val): val is string => val !== null));

const func = (schema: z.ZodType<z.infer<typeof NullableSchema>>) => schema;
func(NullableSchema); // Typescript error null is not assignable to string
```

[![Edit determined-bartik-9g26qp](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/p/sandbox/determined-bartik-9g26qp?file=%2Fsrc%2Findex.ts&embed=1)

Just by removing the `nullable()` part it works as you would expect.

### Expected behavior
The Schema should match the type `z.ZodType<z.infer<typeof Schema>>`",,
1978295191,2934,What's the difference between AnyZodObject and SomeZodObject?,When to use each? I can't seem to find any docs on this.,,
1977751068,2933,Unused find function,"The find function in https://github.com/colinhacks/zod/blob/481c9ba1932203777f6fe9497bb2a8a1d33c620e/src/helpers/util.ts#L60 is not referenced in any place in the code base

Can I open a pull request to remove this chunk of code?",,
1977437148,2932,Add style to the whole page,"---
Title: CSS Issue - Content Page Stretching and Hamburger Menu Fix
---

**Issue Description:**

1. **Content Page Stretching:** The current CSS styles in the ZOD documentation do not seem to support the full-width stretching of the content page. This results in a restricted view, especially on larger screens. It's essential to have a responsive design that adapts to various screen sizes, allowing users to view content more comfortably.

2. **Hamburger Menu Behavior:** When the hamburger menu is opened, it appears that there might be issues with its functionality. It's crucial that the menu works seamlessly and doesn't cause any unexpected behavior or layout problems. Users should be able to navigate the documentation with ease.

**Request:**

I kindly request the ZOD documentation team to investigate and address these CSS issues. Specifically:

1. Implement CSS styles that allow the content page to stretch to the full width of the screen, ensuring a better reading experience on different devices and screen sizes.

2. Review and fix any issues related to the hamburger menu, ensuring it functions correctly and doesn't disrupt the layout or content.

Improving the CSS in the documentation will enhance the usability of the ZOD platform and make it more user-friendly for developers and users alike. Please keep me informed of any updates or solutions related to this issue.
",,
1977258326,2931,A schema for a list that includes at least one item of a certain type,"I imagine something like:

```ts
const schema = z.any().array().includes(z.string())
```

Seems like a very common use case (I need it right now for my project).
Is there a way to do such thing without refine?

",,
1975108505,2927,Donating Funds to Zod,"Hi Zod community and maintainers. I'm Lucas, a core contributor to the Radworks project.Â https://radworks.org/

We've been using https://github.com/colinhacks/zod as part ofÂ [Drips](http://drips.network/). It's in fact one of our most critical dependencies!

We really appreciate the work you all do and want to ensure you are all well-funded to keep doing it. For that reason, we have decided to donate some funds to your project throughÂ [Drips](https://www.drips.network/)(an initiative that is coming out of our organization for funding FOSS).

Who can I talk to about it?

@colinhacks @scotttrinh ",,
1974696249,2925,ZodUnion support for spread operator?,"Really: `[Symbol.iterator]()`

This would just be a convenient mechanism to save a few keystrokes for something like:
```
const U0 = z.union([z.literal(""foo""), z.literal(42)]);
const U1 = z.union([z.literal(""bar""), z.literal(true)]);


// What you have to do now:
const U = z.union([...U0._def.options, ...U1._def.options]);

// What would be nice:
const U = z.union([...U0, ...U1]);
```

Admittedly you can just do:
```
const U = U0.or(U1);
```

The iterator approach is nice when you're doing more dynamic/programmatic type creation, whereas the `.or()` is obviously nice for composing types ""statically"" (more akin to how you'd do it in pure Typescript).",,
1974143891,2924,`z.error#flatten` method does not respect schema transformation?,"I've created a schema and used a transform to modify its structure. When I use the `z.error#flatten` function on a failed `safeParse`, the structure of the errors I receive seems to be based on the input only without the schema transformation being applied.

[Codesandox](https://codesandbox.io/p/sandbox/ecstatic-tereshkova-px86wl?file=%2Fsrc%2Findex.ts&embed=1&layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522cloh4twux00073b6gv596oe7m%2522%252C%2522sizes%2522%253A%255B75.87052673904303%252C24.12947326095697%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522cloh4twuw00033b6g3hlyeaal%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522cloh4twuw00053b6gwml3sfps%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522cloh4twuw00063b6go4j1qa53%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B100%252C0%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522cloh4twuw00033b6g3hlyeaal%2522%253A%257B%2522id%2522%253A%2522cloh4twuw00033b6g3hlyeaal%2522%252C%2522activeTabId%2522%253A%2522cloh4u097005c3b6g08e9llvp%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cloh4twuw00023b6gb2k8flx3%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fyarn.lock%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.ts%2522%252C%2522id%2522%253A%2522cloh4u097005c3b6g08e9llvp%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fpackage.json%2522%252C%2522id%2522%253A%2522cloh58zxg01cg3b6g62faxhxq%2522%252C%2522mode%2522%253A%2522temporary%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%255D%257D%252C%2522cloh4twuw00063b6go4j1qa53%2522%253A%257B%2522tabs%2522%253A%255B%255D%252C%2522id%2522%253A%2522cloh4twuw00063b6go4j1qa53%2522%257D%252C%2522cloh4twuw00053b6gwml3sfps%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cloh4twuw00043b6gapr5njmb%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522start%2522%257D%255D%252C%2522id%2522%253A%2522cloh4twuw00053b6gwml3sfps%2522%252C%2522activeTabId%2522%253A%2522cloh4twuw00043b6gapr5njmb%2522%257D%257D%252C%2522showDevtools%2522%253Afalse%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)


```
import { z } from ""zod"";

const schemaWithTransform = z
  .object({
    email: z.string().email(""Invalid email address""),
    name: z.string(),
  })
  .transform((data) => ({
    details: {
      email: data.email,
      name: data.name,
    },
  }));

type SchemaErrorsType = z.inferFlattenedErrors<typeof schemaWithTransform>;

const payload = schemaWithTransform.safeParse({
  email: ""invalid@email"",
  name: ""name here"",
});

if (!payload.success) {
  const flattendErrors = payload.error.flatten();

  type ShouldBeSame = IfEquals<
    typeof flattendErrors,
    SchemaErrorsType,
    ""same"",
    ""different""
  >; // different
}

type IfEquals<T, U, Y = unknown, N = never> = (<G>() => G extends T
  ? 1
  : 2) extends <G>() => G extends U ? 1 : 2
  ? Y
  : N;

```

In this scenario, I expected that ï»¿`SchemaErrorsType` and the `type of ï»¿flattendErrors` should be the same and reflect the transformed schema. However, that's not what I observe - ï»¿flatten seems to be returning errors based on the input payload.
",,
1973755625,2923,Inconsistent inference between using static schema from local variable and dynamic schema from function parameter,"First of all, i'd like to apologize for a poorly formulated issue title, this is the best line I could come up with to describe the issue.
Second of all, this is _most certainly_ not a bug in zod itself - rather my lack of typescript skills, or me using the library not in the way it was intended to, but still I'm opening this issue as an opportunity for me to get help and get better and for zod authors and contributors to once again review API design decisions

Now to the issue

Imagine I want a function to wrap some schema (e.g. `{ foo: string, bar: number }`) in a discriminated union with metadata about operation outcome (e.g. `{ success: true, result: { foo: string, bar: number } } | { success: false, error: string }`. We create such function like so:
```ts
const wrapSchema = <T extends z.ZodTypeAny>(schema: T) => {
  return z.union([
    z.object({
      success: z.literal(true),
      result: schema,
    }),
    z.object({
      success: z.literal(false),
      error: z.string(),
    }),
  ]);
};
```

We would use this function like this:
```ts
const someSchema = z.object({ foo: z.string(), bar: z.number() });
const wrappedSchema = wrapSchema(someSchema);
const parsed = wrappedSchema.parse({ success: true, result: { foo: '', bar: 0 } });
if (parsed.success) {
  console.log(`Success with result ${parsed.result}`);
} else {
  console.log(`Failure with error ${parsed.error}`);
}
```
Every type in this example is inferred exactly as you would expect it (see the [playground link](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFAxhAHYDO8A7lAIZgDK1AFgKYg2cALxwAPABU4fAB4w+dYgxQA6AFokJATzB8AgnS0A+ABQNeAtgC44EgJQijiCnDhQ+MAK5Q6qz3WB6EwBtF1dVCAAjACs+ahgTBDDwuAZPamo+BgYbZBUAG2B5dnyTGChPPjsAGmTw9zT8mBtzfkFalLQauryo2PjEutc0jKyc1ULitlLMaYYqjpTpKBwoXJUmKGA6AHMTbs6DuABdO0o0Shp6JjhmIp5OGDYYYGpuNqFRSWk5BSVVDTEbS6AzGMwWQQ2eyOZyuWiMeCYCAQd6WEQRGJxBJIJEQdabbZ7GpwSJsNaqOieECRPhQfboM5heE3VgcXTEVGCdGsrgQtgmXGctiM1wwHR8OAAJSyniawIlojy20wtLEYt0EEwt3YYHZQqMlDh13gYDJ82I3J1er5KlNUHmiVS6Uy2Rs5Uq1TcMqaNhxyJsAHIA57SeSAAzoBmGuDALUmO3mjbOsYOJIpZkQfJ8AoQPYAA04yeyt3uXsa8AAJAgE3xiCoGrKYGg8yLI3x8vNYeEM1mc-mAGJsYD5bwSu4wHjLVZwKs1uu01bN1toCgXKjMlj3IV6BgABTJbBAHlp6O+snkimUeUB8tBplalihDmETjTcA32rZtaFlo4QvBHytuqErSuW8rokqdAqlAaripqn66t+fIGkyxpwHOv6IRyNo1o6IwuuM7p8J6DY+ogWD+nAQYhmSNgRhgXTRrGcDxmatZJqM2SpnUPbZvkuYmAWRbKOOk6kZW1ZsXW4lLtGGDtp2b5GowmZ8QJeaDsOo4lhOU7QDOkn2uxC7QLJYQrmuQA))

But suddenly everything breaks if I want `someSchema` to be dynamically defined by caller:
```ts
const withSchemaAsParameter = <T extends z.ZodTypeAny>(schema: T) => {
  const wrappedSchema = wrapSchema(schema);
  const parsed = wrappedSchema.parse({ success: true, result: { foo: '', bar: 0 } });
  if (parsed.success) {
    console.log(`Success with result ${parsed.result}`); // Property 'result' does not exist on type see playground link
  } else {
    console.log(`Failure with error ${parsed.error}`); // Property 'error' does not exist on type see playground link
  }
};
```

Is it possible to accomplish with zod?",,
1969756886,2919,nativeEnum invalid_type_error not returning error on wrong enum,"Zod returns `Invalid enum value` although `invalid_type_error` is set.

## Steps to reproduce

```ts
const schema = z.nativeEnum({MY_ENUM:""MY_ENUM""}, {
  invalid_type_error: ""this is an error"",
})

console.log(""result"", schema.parse(""AAA""));
// returns error ""Invalid enum value. Expected 'MY_ENUM', received 'AAA'""
```

## Expected behavior
When the type is wrong, Zod should return whatever I give in  `invalid_type_error`.
In the example, it should return `this is an error`

If `invalid_type_error` is meant to be used for something else, I would expect the following:
1. Add in the `nativeEnum` documentation section what is `invalid_type_error` for
2. Add with JS Docs what is `invalid_type_error` for
3. Add an `invalid_enum_error` to the `params` of `nativeEnum` where we can define a custom message. 
",,
1969681117,2918,add parseJson method,"I am repeating this pattern quite a bit:

```ts
return z
  .object({
    articleOutlineMarkdown: z.string(),
    ended: z.boolean(),
  })
  .parse(JSON.parse(articleOutlineUpdateJson));
```

I figured that since zod knows the schema, it could possibly parse it faster too?",,
1969223117,2917,Allow setting `typeName` in custom types,"I'm using a custom type for `Decimal.js` fields like so

```ts
const decimal = z.custom<Decimal>(Decimal.isDecimal)
```

This is nice and simple, which is great! 

However, when building a UI based on an arbitrary zod-typed input, I use `_def.typeName` to determine the expected output type for the sake of formatting, etc. Currently custom fields are labeled as `ZodEffects`, which isn't particularly helpful.

Something like this would be great

```ts
const decimal = z.custom<Decimal>(Decimal.isDecimal, { typeName: 'ZodDecimal' })
```

Alternatively, a custom metadata solution as described in https://github.com/colinhacks/zod/issues/273 would also enable me to solve the problem.",,
1967865418,2915,.catch() become unknown type when used with a generic function,"When I try
```ts
import zod from 'zod';

const userSchema = zod.object({
  name: zod.string(),
  address: zod.string().catch('')
});

const unparsedUser: any = {
  name: 'Alice',
  address: null
}

const parsedUser = userSchema.parse(unparsedUser)
```
The `address` of `parsedUser` will have the `string` type.
But if I create a generic function and then parse a data with it
```ts
function apiResponseSchema<T>(dataSchema: zod.ZodType<T>) {
  return zod.object({
    data: dataSchema
  })
}

const userApiResponseSchema = apiResponseSchema(userSchema)

const unparsedApiResponse: any = {
  data: unparsedUser
}

const user = userApiResponseSchema.parse(unparsedApiResponse).data
```
The `address` of the `user` will have the `unknown` type while it should be returning a `string` type also.

Here's the demo in [typescript playground](https://www.typescriptlang.org/play?noImplicitAny=false#code/JYWwDg9gTgLgBALwgEzgMyhEcDkTk4DcAUMQMYQB2AzvAK7UCmUAymQBaMgCGcAvIhQA6CACMAVozIwAFAG9icOJW4hGALkHIhtKMEoBzGQEoANIrjdkyKI2rVN+HTD2GTQstxgcZOHMeIAX2MSYjQ6SmlgKkswYAAlO0gaRjZOHgAeABUAPhlkL240rm5HYQAtFCyATzBGbJzjOAUlWxg6KEotEQkpWRalOAKYUqHC4p4LYKDSChp6SjBuKCZkAFUmKE1uSmr+ZosVNU0cAEEAG2AyRhxzJSsbOwdlOnPzmfIqWjgllcZ1zb7BjMCbcIS-JgyCIQ-4bZgBAD0CMGcAAegB+WZfeibU5xRLUZJMUH7bj4pJfVIcEpQzaggKfeZwaHLVZ4hIUlLbXb7AbDUYsv4A5gfObfYFQIG48mEymg8GsxhQxaK5DsglExjGIT84hIlEYoA).",,
1967068668,2914,Type declarations not found ,"Typescript compiler doesn't seem to find zod type declarations in nuxtjs 3 :point_down: 

```Cannot find module 'zod' or its corresponding type declarations.ts(2307)```
",,
1965766323,2911,Undefined values in record with optional values get stripped,"When using a Zod schema that should accept undefined values in a record, those entries get stripped anyway.

For example, this code

```
import z from ""zod"";

const schema = z.object({
  items: z.record(z.string().optional())
});

const data = {
  items: {
    a: ""qwerty"",
    b: undefined
  }
};

console.log(schema.parse(data));
```

outputs `{items:{a:""qwerty""}}`


According to Typescript, the inferred type is
```
{
    items: Record<string, string | undefined>;
}
```

So I expected` {items:{a:""qwerty"", b: undefined}}`",,
1964606303,2909,Extend within generic function doesn't infer type as expected,"I was using the suggested means of typing generic functions [as covered in the documentation](https://zod.dev/?id=writing-generic-function). My goal was to write a method that would `extend` any provided zod object with another hardcoded zod object.

Using

```ts
const extender = <T extends z.AnyZodObject>(p: T) => p.extend({ foo: z.boolean() });
```

Results in the incorrect type being inferred.

```ts
const schema = extender(z.object({ bar: z.number() }}));
z.infer<typeof schema> // === { [x: string]: any; [x: number]: any; [x: symbol]: any; foo?: boolean | undefined; }
```

Regardless of the object submitted as `p`.

The example below covers the cases I'd tested and a workaround I found that used `z.ZodRawShape` instead.

```ts
import { z } from ""zod"";

const schema = z.object({ bar: z.number() }).extend({ foo: z.boolean() });

const brokenExtender = <T extends z.AnyZodObject>(p: T) => p.extend({ foo: z.boolean() });
const schema2 = brokenExtender(z.object({ bar: z.number() }));

const workingExtender = <T extends z.ZodRawShape>(p: z.ZodObject<T>) => p.extend({ foo: z.boolean() }) ;
const schema3 = workingExtender(z.object({ bar: z.number() }));

/* As expected: type s1 = { bar: number; foo: boolean; } */
type s1 = z.infer<typeof schema>;
/* Not expected: type s2 = { [x: string]: any; [x: number]: any; [x: symbol]: any; foo?: boolean | undefined; } */
type s2 = z.infer<typeof schema2>;
/* As expected: type s3 = { bar: number; foo: boolean; } */
type s3 = z.infer<typeof schema3>;
```
[codesandbox](https://codesandbox.io/p/sandbox/agitated-https-s79s3p?file=%2Fsrc%2Findex.ts%3A7%2C35)

Note: This same behaviour occurs with `.merge()` as well.
```ts
const extender = <T extends z.AnyZodObject>(p: T) => p.merge(z.object({ foo: z.boolean() }));
const schema = extender(z.object({ bar: z.number() }}));
z.infer<typeof schema> // === { [x: string]: any; [x: number]: any; [x: symbol]: any; foo?: boolean | undefined; }
```
",,
1963803667,2907,Zod error message for union is misleading,"### Discussed in https://github.com/colinhacks/zod/discussions/2867

<div type='discussions-op-text'>

<sup>Originally posted by **bajewole** October 13, 2023</sup>
Issue: Zod error message for unions is misleading

```ts
const SuccessCode = z.number().min(1000).max(1999);
const ClientErrorCode = z.number().min(2000).max(2999);
const ServerErrorCode = z.number().min(3000).max(3999);

const StatusCode = z.union([
  SuccessCode,
  ClientErrorCode,
  ServerErrorCode,
]);
```

Zod error I got is 

```ts
const input = 4000;
    expect(() => StatusCode.parse(input)).toThrowErrorMatchingInlineSnapshot(`
    ""[
      {
        \\""code\\"": \\""too_big\\"",
        \\""maximum\\"": 1999,
        \\""type\\"": \\""number\\"",
        \\""inclusive\\"": true,
        \\""exact\\"": false,
        \\""message\\"": \\""Number must be less than or equal to 1999\\"",
        \\""path\\"": []
      }
    ]""`);
```

The valid error object should be this instead

```ts
const input = 4000;
    expect(() => StatusCode.parse(input)).toThrowErrorMatchingInlineSnapshot(`
    ""[
      {
        \\""code\\"": \\""too_big\\"",
        \\""maximum\\"": 3999,
        \\""type\\"": \\""number\\"",
        \\""inclusive\\"": true,
        \\""exact\\"": false,
        \\""message\\"": \\""Number must be less than or equal to 3999\\"",
        \\""path\\"": []
      }
    ]""`);
```

The validation works but the error is misleading. 

I tried creating a custom error by using `errorMap` but it still returned the above error

```ts
const StatusCode = z.union([
  SuccessCode,
  ClientErrorCode,
  ServerErrorCode,
],
  {
    errorMap: () => {
      return {
        message: ""StatusCode must be between 1000 and 3999"",
      };
    },
  });
```</div>",,
1963639124,2905,Zod error message for union is misleading,"### Discussed in https://github.com/colinhacks/zod/discussions/2867

<div type='discussions-op-text'>

<sup>Originally posted by **bajewole** October 13, 2023</sup>
Issue: Zod error message for unions is misleading

```ts
const SuccessCode = z.number().min(1000).max(1999);
const ClientErrorCode = z.number().min(2000).max(2999);
const ServerErrorCode = z.number().min(3000).max(3999);

const StatusCode = z.union([
  SuccessCode,
  ClientErrorCode,
  ServerErrorCode,
]);
```

Zod error I got is 

```ts
const input = 4000;
    expect(() => StatusCode.parse(input)).toThrowErrorMatchingInlineSnapshot(`
    ""[
      {
        \\""code\\"": \\""too_big\\"",
        \\""maximum\\"": 1999,
        \\""type\\"": \\""number\\"",
        \\""inclusive\\"": true,
        \\""exact\\"": false,
        \\""message\\"": \\""Number must be less than or equal to 1999\\"",
        \\""path\\"": []
      }
    ]""`);
```

The valid error object should be this instead

```ts
const input = 4000;
    expect(() => StatusCode.parse(input)).toThrowErrorMatchingInlineSnapshot(`
    ""[
      {
        \\""code\\"": \\""too_big\\"",
        \\""maximum\\"": 3999,
        \\""type\\"": \\""number\\"",
        \\""inclusive\\"": true,
        \\""exact\\"": false,
        \\""message\\"": \\""Number must be less than or equal to 3999\\"",
        \\""path\\"": []
      }
    ]""`);
```

The validation works but the error is misleading. 

I tried creating a custom error by using `errorMap` but it still returned the above error

```ts
const StatusCode = z.union([
  SuccessCode,
  ClientErrorCode,
  ServerErrorCode,
],
  {
    errorMap: () => {
      return {
        message: ""StatusCode must be between 1000 and 3999"",
      };
    },
  });
```</div>",,
1962935536,2904,Zod preprocess does not generate error,"I have been using zod as a validation library with react-hook-form. When I set up validation using preprocess in zod, I noticed that errors were not being detected as expected.

#### Similar issue

I have confirmed that this issue has been reported on the react-hook-form/resolver repository.

* https://github.com/react-hook-form/resolvers/issues/635

#### What I confirmed about this issue

Regarding this issue, I downgraded the zod version from 3.22.4 to 3.21.4 and confirmed that errors were detected as expected. I also tried several versions and found that the issue occurs starting from 3.22.0.

#### How to reproduce

Although this is a quote from the issue on the react-hook-form/resolver repository, here is a codesandbox that reproduces the phenomenon of errors not being detected (with zod version 3.22.4):

* https://codesandbox.io/s/react-hook-form-zod-preprocess-mn8sy4?file=/src/index.js

Additionally, here is a codesandbox with zod version 3.21.4, where errors are detected:

* https://codesandbox.io/s/react-hook-form-zod-preprocess-forked-cqm66q",,
1962933364,2903,How to keep a TypeScript interface in sync with a Zod schema?,"I have an existing project primarily written in TypeScript where we originally had no runtime validations for our data. As we're expanding our API and also have JavaScript users, I've decided to introduce Zod to validate our data at runtime.

**Example**
```ts
import { z } from 'zod';

interface MyData {
  name: string;
  age: number;
  isStudent?: boolean;
}

const MyDataSchema = z.object({
  name: z.string(),
  age: z.number(),
  isStudent: z.boolean().optional()
});
```

The challenge I'm facing is keeping the `MyData` interface and the `MyDataSchema` in sync. Every time I update the TypeScript interface, I have to manually update the Zod schema. This manual process is error-prone and can lead to inconsistencies.

I tried using `satisfies z.ZodType<MyTypescriptType>` (example below), but it doesn't handle optional types well.

```ts
const MyDataSchema = z.object({
  name: z.string(),
  age: z.number(),
  isStudent: z.boolean().optional()
}) satisfies z.ZodType<MyData>;
```

Is there an efficient way to enforce synchronization between a TypeScript interface and a Zod schema? Ideally, I'd like an approach where updating the interface would either automatically update the schema or at least throw an error if they're out of sync.",,
1961575825,2900,"Preprocessors now make schemas order-dependent, breaking form integration.","TLDR; Preprocessors in React Hook Forms resolvers no longer invalidate until all previous fields without preprocessors are valid.

We just updated from 3.21 to 3.22, and have found a breaking issue with the integration of preprocessors and react hook forms that did not exist in 3.21. 

We have a preprocesser called ZodNum that we use because the default z.coerce.number() translates empty strings into 0. With the update to 3.22, forms that use preprocessors inside their validation schemas, validate from top to bottom in the order of their field declaration in the schema. If you have a field with z.string().min(5) higher in the schema than any z.preprocess(), the preprocess does not invalidate until the string field is completely valid, leading to an issue where the form is invalid, but the resolver reports it as valid. 

In the code sandbox, the first two fields validate correctly, no matter the state of the first field. But if the second field is not valid, or has not been validated, the third and fourth field cannot validate at all. If the second field is valid, all fields can validate. If you change the order of the fields in the parser so that 'someId' is at the bottom, all fields validate as expected. 

Code Sandbox: https://codesandbox.io/p/sandbox/gracious-violet-wytl24?welcome=true",,
1960465868,2898,Zod Metadata,"I know this issue has been raised before but I want to bring it up again as I am encountering quite some problems trying to plug together an ecosystem around zod.

First point: I love zod!
And I really think that having one source of truth for models is a big plus in any TS code base. Without code generation steps and everything. I like that it is just plain code and Typesystem expressions.

So I want to use zod for building my data types and typescript interfaces. I want to infer UI models from it to generate forms, widgets and other components in a more declarative style (using zod-metadata).
I want to derive persistence schema for mongodb (using mongoose-zod)

Problem is that the way these libraries extend the Zod Types using d.ts files and somehow they clash. It is not possible to use them both. I am struggling hard and I am not getting these to work.  Trying to get multiple dts files work in mono-repo setup with multiple packages and all these different flavors of dependencies....man... Am I getting old? I remember when node.js kicked-ass compared to many other stacks...but I am loosing myself here....

The point is: I think it would be so much simpler for all sorts of third party code that builds on top of zod to have one very simple mechanism to add their own data to each type. In my opinion this would make the world a better place. I mean, it would allow extensions to add whatever processing metadata they need.


So, dear Colin. Can you please reconsider to add this method?",,
1955254078,2893,"Making all fields of an object ""nullable""","Currently, it is possible to make an object's properties optional by using `.Partial`. However, this does **NOT** make the object properties nullable, so there would be a repetitive task of adding `nullable()` to every field as seen below. Could we have an option to make all fields all nullable?

```
const MyObjectSchema = z
  .object({
    p1: z.string().nullable(),
    p2: z.number().nullable(),
    p3: z.boolean().nullable(),
    p4: z.date().nullable(),
    p5: z.symbol().nullable(),
  })
  .partial();
```",,
1955151749,2891,Add a `change` function to change the existing properties of a schema,"**Feature request:**

Similar to extend, but you are only allowed to change the existing properties of a schema, not extend it.

This is technically possible with `.extend`, but there is no typescript autocompletion for this.

```typescript
const schema = z.object({
    name: z.string(),
    age: z.number().optional(),
});

// You are only allowed to change properties that already exist in the schema you are changing.
const changedScema = schema.change({
    age: z.number(),    // remove optional
});

const changedSchema2 = schema.change({
    occupation: z.string().optional(),    // typescript error, because this property does not exist on `schema`
});
```",,
1954071501,2888,z.string().email() does not validate successfully where emails have single quotes in them,"`z.string().email()` fails validation when an email with a single quote (`'`) is used.

Example:
`o'leary@example.com`

This is allowed in RFFC 5332 as well.",,
1953791143,2887,How to create a generic zod parser factory that gives a picked schema with types?,"Hi all, 

I'm trying to create a generic zod parser factory that takes a schema and a list of fields that transforms that schema into a picked schema, but I am having an issue where the return type information is filtered out to any. 

Here's what I have so far:
```ts
    const parseFactory = (schema: z.AnyZodObject) =>  { 
        return <T extends keyof z.infer<typeof schema>>({item, fields}: {item: unknown, fields: T[]}): Pick<z.infer<typeof schema>, T> | undefined=> {
          try {
            const pickedSchema = schema.pick(Object.fromEntries(fields.map(field => [field, true])))
            return pickedSchema.parse(item)
          } catch (error) {
            // error handling
          }
        }
    }
```

However, in the above, the type of the return is : 
```ts
    {
        [x: string]: any;
        [x: number]: any;
    }
```

Any help would be appreciated!
",,
1953401804,2886,How to get def.checks in schema containing refine/superRefine?,"I have a schema like:
```typescript

const RegisterUsernameExtraSchema = z.object({
    username: z.string().min(1, { message: ""msg_required"" }),
    password: z.string().min(1, { message: ""msg_required"" }),
    email: z
        .string()
        .optional()
        .superRefine((val, ctx) => {
            const leg = Number(val?.length)
            if (!val || leg === 0) return true
            if (leg < WebConfig.Validation.email.min) {
                ctx.addIssue({
                    code: z.ZodIssueCode.too_small,
                    message: 'msg_error_register_field_email_require_minimum',
                    minimum: 4,
                    type: 'string',
                    inclusive: false
                })
            }
            if (leg > WebConfig.Validation.email.max) {
                ctx.addIssue({
                    code: z.ZodIssueCode.too_big,
                    message: 'msg_error_register_field_email_require_maximum',
                    maximum: 150,
                    type: 'string',
                    inclusive: false
                })
            }
            if (WebConfig.Validation.email.regex && !new RegExp(WebConfig.Validation.email.regex).test(val)) {
                ctx.addIssue({
                    code: z.ZodIssueCode.invalid_string,
                    message: 'email_invalid',
                    validation: 'email'
                })
            }
        })
})```

How to get `message information` and `minimum/maximum value` in superRefine of the email field? Please help me, thanks all guys!",,
1953128691,2885,Best way to create a zod validator for a list of literal strings,"I want to do something like this:

```
export const levels = ['level1', 'level2', 'level3', 'level4'] as const;

export const levelValidator = z.union(
  levels.map(l => z.literal(l))
);

export type Level = z.infer<typeof levelValidator>;
```

Goal is to create a list of literal strings and enforce that the property contains one of these strings.

I could certainly do:
```
z.union([
  z.literal('level1'),
  z.literal('level2'),
  z.literal('level3'),
  z.literal('level4'),
]);
```

But I want to have an array of these values that I can render as the options for a select input.

That map doesn't work because the type definition for `union` is so strict that it enforces that the array has at least 2 elements. This array does, but the compiler can't enforce that.

Any suggestions on the best way to proceed?

This issue is similar:
https://github.com/colinhacks/zod/issues/2691

But I can't imagine using ~100 lines of code for this.",,
1953039725,2884,"Feature: Allow using a function for validation ""message"" prop","It would be useful if the `message` prop for validation methods like `.min`, `.max` etc... could be `string | ((val) => string)` rather than just `string`. This would help in cases where you might be using a translation library and would like to defer the retrieval of the string until the moment it is needed. e.g..
```ts
const nameSchema1 = z.string().min(1, { message: 'Too Short' });
const nameSchema2 = z.string().min(1, { message: () => 'Too Short' });
```

This is a real-world example. As soon as the module/file is loaded, the string is materialized and this could be before your I18n library is available or the language is known.
```ts
export const nameSchema = z
  .string()
  .trim()
  .min(1, { message: I18n.t('common:validation.required') })
  .max(64, { message: I18n.t('common:validation.tooManyCharacters') });
```

I'm aware that this could be worked around by avoiding the `message` prop entirely and using `.refine()` at the end instead... OR by creating a custom `errorMap` function on the `string()`, but this greatly reduces the simplicity and legibility of the schema and makes the `message` option kind of pointless unless you have static hardcoded strings.",,
1951917272,2883,Cannot get error message from safeParse,"This should work:
```ts
//or process.env
const parsedEnv = envSchema.safeParse(Bun.env);
//@ts-ignore
if(parsedEnv.success === false) { console.error(parsedEnv.error.message); process.exit(1); }

```
but it doesn't.
Instead i have to do these shenanigans:
```ts
const parsedEnv = envSchema.safeParse(Bun.env);
if(parsedEnv.success === false) { console.error(JSON.parse(parsedEnv.error.message)[0].message); process.exit(1); }

```",,
1950699886,2880,runtime-only unions?,"Hi there - I am wondering if there's a way to define optional or union types for the sake of backwards-compatibility that is stricter at compile time. For example:

```ts
const Input = z.object({ status: z.string().optional({ runtimeOnly: true }) })

const a: z.infer<typeof Input> = {} // compile-time error, z.infer<typeof Input> has type { status: string }
const b = Input.parse({}) // no error, `status` is optional at runtime, so it's allowed to be missing

b.status.slice() // compile-time error, the output type is `{ status: string | undefined }`
```

Similarly with union types:

```ts
const Input = z.object({ status: z.enum(['open', 'closed']).or(z.string(), { runtimeOnly: true })

const a: z.infer<typeof Input> = {.status: 'invalid' } // compile-time error, z.infer<typeof Input> has type { status: 'open' | 'closed' }
const b = Input.parse({.status: 'invalid' }) // no error, `status` is optional at runtime, so it's allowed to be missing

b.status // has type `string`
```

The idea being that you could make changes to schemas that have deployed clients who may send the old value for some amount of time - but the typescript compiler will catch any out-of-date usage to make it easier to get those clients up to date.

If this doesn't exist (I couldn't find it) - would you be open to a PR adding it?",,
1950305509,2879,Make entire schema readonly,"Making a large schema deeply readonly is a LOT of `.readonly()`. It would be grand if there was a way to either set `.deepReadonly()` (like `deepPartial`), or `readonly` had an argument that would go deeeeeeeep.

Instead of

```ts
const Recipe = z.object({
  id: z.string().readonly(),
  name: z.string().readonly(),
  ingredients: z.array(z.string().readonly()).readonly(),
}).readonly();
```

we could do 

```ts
const Recipe = z.object({
  id: z.string(),
  name: z.string(),
  ingredients: z.array(z.string()),
}).deepReadonly(); 
```

or maybe

```ts
const ReadonlyRecipe = z.deepReadonly(Recipe)
```

or maybe

```ts
const Recipe = z.object({
  id: z.string(),
  name: z.string(),
  ingredients: z.array(z.string()),
}).readonly({ deep: true });
```

If this seems good, I can submit a PR. ",,
1948936524,2876,"odTypeAny, { ...; }, { ...; }>, { ...; }, { ...; }>' is not assignable to parameter of type 'ZodObject<any, UnknownKeysParam, ZodTypeAny, { [x: string]: any; }, { [x: string]: any; }>'.   Type 'ZodEffects<ZodObject<{ email: ZodString; password: ZodString; newPassword: ZodString; confirmPassword: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, { ...; }, { ...; }>' is missing the following properties from type 'ZodObject<any, UnknownKeysParam, ZodTypeAny, { [x: string]: any; }, { [x: string]: any; }>': _cached, _getCached, shape, strict, and 14 more.  64   @UsePipes(new ZodValidationPipe(resetPasswordSchema))","```
//filte reset-password.schema.ts
import { z } from 'zod';

export const resetPasswordSchema = z
  .object({
    email: z
      .string({
        required_error: 'Email is required',
        invalid_type_error: 'Email should be a valid email',
      })
      .email(),
    password: z
      .string({
        required_error: 'Password is required',
        invalid_type_error: 'Password should be a valid string',
      })
      .trim(),
    newPassword: z
      .string({
        required_error: 'New password is required',
        invalid_type_error: 'New password should be a valid string',
      })
      .trim(),
    confirmPassword: z
      .string({
        required_error: 'confirm password is required',
        invalid_type_error: 'confirm password should be a valid string',
      })
      .trim(),
  })
  .required()
  .superRefine((values, ctx) => {
    if (values.newPassword !== values.confirmPassword) {
      ctx.addIssue({
        message: 'Passwords do not match',
        code: 'custom',
      });
    }
    return values;
  });

export type ResetPasswordDto = z.infer<typeof resetPasswordSchema>;
```

```
import { PipeTransform, ArgumentMetadata } from '@nestjs/common';
import { ZodObject } from 'zod';

export class ZodValidationPipe implements PipeTransform {
  constructor(private schema: ZodObject<any>) {}
  transform(value: any, metadata: ArgumentMetadata) {
    this.schema.parse(value);
    return value;
  }
}
```

  @UsePipes(new ZodValidationPipe(resetPasswordSchema)) 
  
  how can I solve this",,
1948370690,2875,Inaccurate Error Reporting in Unions,"I believe there is a bug with the error reporting for unions of strict partial objects.  My expectation is that if there is N schemas in the union, a failed parsed should return N unionsErrors.  

```typescript
import * as z from 'zod';

const x = z.object({ x: z.number() });

try {
  const a = z.object({ a: x.optional() }).strict();
  const b = z.object({ b: x.optional() }).strict();
  const ab = z.union([a, b]);
  ab.parse({ b: { y: 1 } });
} catch (error) {
  if (error instanceof z.ZodError) {
    // Expected: 2 unionErrors:
    //   Error #1: - [b] Unrecognized key(s) in object: 'b'
    //   Error #2: - [b][x] Required
    //
    // Actual: 1 error:
    //   [b] Unrecognized key(s) in object: 'b'  <=== Unexpected
    console.log(JSON.stringify(error, null, 2));
  }
}
``` 

Output:
```
{
  ""issues"": [
    {
      ""code"": ""unrecognized_keys"",
      ""keys"": [
        ""b""
      ],
      ""path"": [],
      ""message"": ""Unrecognized key(s) in object: 'b'""
    }
  ],
  ""name"": ""ZodError""
}
``` 

Note that with non-optional properties, this behaves as expected:

```typescript
try {
  const a = z.object({ a: x }).strict();
  const b = z.object({ b: x }).strict();
  const ab = z.union([a, b]);
  ab.parse({ b: { y: 1 } });
} catch (error) {
  if (error instanceof z.ZodError) {
    // Expected & Actual: 2 unionErrors:
    //   Error #1: - [a] Required
    //             - [b] Unrecognized key(s) in object: 'b'
    //   Error #2: - [b][x] Required

    console.log(JSON.stringify(error, null, 2));
  }
}
``` 

Output:

```
{
  ""issues"": [
    {
      ""code"": ""invalid_union"",
      ""unionErrors"": [
        {
          ""issues"": [
            {
              ""code"": ""invalid_type"",
              ""expected"": ""object"",
              ""received"": ""undefined"",
              ""path"": [
                ""a""
              ],
              ""message"": ""Required""
            },
            {
              ""code"": ""unrecognized_keys"",
              ""keys"": [
                ""b""
              ],
              ""path"": [],
              ""message"": ""Unrecognized key(s) in object: 'b'""
            }
          ],
          ""name"": ""ZodError""
        },
        {
          ""issues"": [
            {
              ""code"": ""invalid_type"",
              ""expected"": ""number"",
              ""received"": ""undefined"",
              ""path"": [
                ""b"",
                ""x""
              ],
              ""message"": ""Required""
            }
          ],
          ""name"": ""ZodError""
        }
      ],
      ""path"": [],
      ""message"": ""Invalid input""
    }
  ],
  ""name"": ""ZodError""
}
``` 

Am I missing something?",,
1947193868,2873,Support coercion for arrays,"Currently there is no way to tell Zod ""if you get a single value of correct type, just put it into an array"". Existing `.coerce()` operation could be used for this.

Here is a reference implementation of this logic: https://github.com/lokalise/zod-extras/blob/main/src/utils/toArrayPreprocessor.ts
Test: https://github.com/lokalise/zod-extras/blob/main/src/utils/toArrayPreprocessor.test.ts",,
1944499571,2870,why zod doesn't make no empty string by default for required fields?,"I am using react hook form and zod as a validator resolver.

```ts
export const SignInValidator = z.object( {
    email: z.string().email( ""Invalid email address"" ),
    password: z.string(),
} )

const form = useForm( {
    resolver: zodResolver( SignInValidator ),
    defaultValues: {
        email: """",
        password: """",
    },
} )
```
  
SignInValidator is passes even if the password is an empty string. the default value is empty string, if I don't create an empty string at the default value, a Warning will occur: A component changed an uncontrolled input to a controlled one. This is likely caused by changing a value from undefined to a defined value, which should not happen. Decide between using controlled or uncontrolled input elements during the lifetime of the component.

why zod doesn't make noEmptystring by default for required fields?",,
1941959588,2865,Zod error message for union is misleading,"Issue: Zod error message for unions is misleading

```ts
const SuccessCode = z.number().min(1000).max(1999);
const ClientErrorCode = z.number().min(2000).max(2999);
const ServerErrorCode = z.number().min(3000).max(3999);

const StatusCode = z.union([
  SuccessCode,
  ClientErrorCode,
  ServerErrorCode,
]);
```

Zod error I got is 

```ts
const input = 4000;
    expect(() => StatusCode.parse(input)).toThrowErrorMatchingInlineSnapshot(`
    ""[
      {
        \\""code\\"": \\""too_big\\"",
        \\""maximum\\"": 1999,
        \\""type\\"": \\""number\\"",
        \\""inclusive\\"": true,
        \\""exact\\"": false,
        \\""message\\"": \\""Number must be less than or equal to 1999\\"",
        \\""path\\"": []
      }
    ]""`);
```

The valid error object should be this instead

```ts
const input = 4000;
    expect(() => StatusCode.parse(input)).toThrowErrorMatchingInlineSnapshot(`
    ""[
      {
        \\""code\\"": \\""too_big\\"",
        \\""maximum\\"": 3999,
        \\""type\\"": \\""number\\"",
        \\""inclusive\\"": true,
        \\""exact\\"": false,
        \\""message\\"": \\""Number must be less than or equal to 3999\\"",
        \\""path\\"": []
      }
    ]""`);
```

The validation works but the error is misleading. 

I tried creating a custom error by using `errorMap` but it still returned the above error

```ts
const StatusCode = z.union([
  SuccessCode,
  ClientErrorCode,
  ServerErrorCode,
],
  {
    errorMap: () => {
      return {
        message: ""StatusCode must be between 1000 and 3999"",
      };
    },
  });
```",,
1941571565,2864,Type inference when combining objects seems wrong,"Hi, sorry to bother you with this, I've been successfully using the lib until I ran into this issue I'm not sure if it's a misuse from my side or a bug/limitation in Zod.

I have these reusable types defined:

```typescript
import { z } from ""zod""

const SuccessResponse = <T>(schema: z.Schema<T>) => z.object({
  success: z.literal(true),
  data: schema
})
const ErrorResponse = z.object({
  success: z.literal(false),
  error: z.string()
})
const Response = <T>(schema: z.Schema<T>) => z.discriminatedUnion(
  ""success"",
  [
    SuccessResponse(schema),
    ErrorResponse
  ]
)

const Model = z.object({name: z.string()})

const response: unknown = {success: true, data: null}
```

And I'm able to use them just fine in this case:
```typescript
const model = Response(Model).parse(response)
if (model.success) {
  model.data.name
} else {
  model.error
}
```

But if I try to abstract the above code in a function then the type of the `parse` result does not allow me to type-guard on the `success` field:
```typescript
function responseData<T>(schema: z.Schema<T>, response: unknown): T {
  const model = Response(schema).parse(response)
  if (model.success) {
    return model.data // 'data' does not exist on type
  }
  throw new Error(model.message) // 'message' does not exist on type
}
```

I have a codesandbox created with this code: https://codesandbox.io/p/sandbox/silly-wing-m4gnt8",,
1940775880,2862,Proposal: z.not(parser) or equivalent,"## Purpose:

Returns the _inverse_ of the parser that is passed. For example:

```ts
// accepts anything _except_ a `string`.
z.not(z.string()) 

// accepts any string that _isn't_ an email
z.string().not(z.string().email());
```

Would this be useful? Is there a way of doing this in standard `zod` that I'm missing?

I know I can use `refine()`, but the ergonomics there are a bit awkward:

```ts
z.string().refine((val) => !z.string().email().safeParse(val).success);
```
",,
1938366642,2859,Defining function rest parameters,"This is essentially the same issue as the closed #1282. I have a function that is shaped like this:

```ts
export type  MyFunc = (...args: string[]) => object;
```

I tried a couple of the solutions offered in the original issues.

#### Attempt 1

This is my attempt to use the [original solution](https://github.com/colinhacks/zod/issues/1282#issuecomment-1237743124) offered by @colinhacks:

```ts
import { z } from 'zod';

const MyFuncSchema = z
  .function()
  .args(z.tuple([]).rest(z.string()))
  .returns(z.void());

export type MyFunc = z.infer<typeof MyFuncSchema>;

const myFunc: MyFunc = (...args) => {
  args.forEach((arg) => {
    console.log(arg);
  });
};

myFunc('a', 'b', 'c');
```

When I run I run `tsc`, I get this error:

```
my-func.ts:16:8 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'string[]'.

16 myFunc('a', 'b', 'c');
```

When I hover on the the `MyFunc` type (line 8) in the above,  VSCode kindly tells me that the type resolves to this:

```ts
type MyFunc = (args_0: string[], ...args_1: unknown[]) => void 
```

I think this means that Zod interprets `arg_0` as the tuple defined in the arguments, and the rest is whatever it is (which makes sense in from the syntax). 

#### Attempt 2

This is my attempt to use the [solution](https://github.com/colinhacks/zod/issues/1282#issuecomment-1374609774) offered by @maxArturo:

```ts
import { z } from 'zod';

const possibleInputs: [] | [z.ZodString, ...z.ZodString[]] = [
  z.string(), //
  z.string(),
];

const MyFuncSchema = z
  .function() //
  .args(...possibleInputs)
  .returns(z.void());

export type MyFunc = z.infer<typeof MyFuncSchema>;

const myFunc: MyFunc = (...args) => {
  args.forEach((arg) => {
    console.log(arg);
  });
};

myFunc('a', 'b', 'c');
```

For now, I'm going with this solution because, as @maxArturo says, this works! However, when I hover on `MyFunc`, I get this:

```ts
type MyFunc = (args_0: string, ...args_1: unknown[]) => void
```

This means I don't get the strong type checking on values in `args_1` that I want. ðŸ˜¢ 

#### What I want

What I'd love to have is the ability to define the function schema like this:

```ts
const MyFuncSchema = z
  .function()
  .args().rest(z.string())
  .returns(z.void());
```

This would result in a function type like this:

```ts
type MyFunc = (...args_0: string[]) => void 
```

#### Details

I'm using:

- tsc v5.2.2
- zod v3.22.4",,
1936679970,2856,Chinese docs are lagging and inaccurate,"Hi, I am a native Chinese speaker. I have noticed that the Chinese documentation lags behind the official documentation, and there are inaccuracies or deviations from native speaker language conventions in the Chinese version. If you're open to it, I'd be happy to submit a pull request to make improvements.",,
1936617590,2855,Persian (Farsi) locale support,"I've noticed that the locale folder in the repo currently only has an `en` file. I am aware of custom messages but when your entire app is in another language, you would have to define all the error messages manually and get your code cluttered.

I would like to add Persian locale to the project. Is there already an API for implementing new locales or would I have to propose a new one?

Some general guidance around this would be greatly appreciated.",,
1936295501,2854,What should deepPartial be replaced with?,"It looks like `deepPartial` was deprecated in [3.21.0](https://github.com/colinhacks/zod/releases/tag/v3.21.0). What should be used instead? 

Also just to note that the documentation at https://zod.dev/?id=deeppartial doesn't make any mention of `deepPartial` being deprecated. ",,
1935130016,2852,Using .catch causes input type to become unknown ,"When using a .catch block the typescript input type of the schema becomes unknown. 

**Without catch**

```typescript
const schema = z.number().min(1).max(255)
type SchemaType = z.input<typeof schema>
```
_SchemaType is number_

**With catch**

```typescript
const schema = z
  .number()
  .min(1)
  .max(255)
  .catch((err) => {
    return 1
  })

type SchemaType = z.input<typeof schema>
```
_SchemaType is unknown_

This seems to happen for all types string, number boolean etc",,
1935091502,2851,Please adhere to SemVer,"I started using `zod` in one of the packages in my team's monorepo, and everything was great. The `zod` version that Yarn installed was `v3.22.2`.

I then add `zod` to another package in my team's monorepo and it's still great. At this point, `v3.22.4` is released, and Yarn chooses to install that version. 

I then import a `zod` schema from the first package into the second package, try to use it to create a new schema, and the typescript server freaked out.

Here's an exerpt from my `tsserver.log` (manually prettified)

```json
Info 1066 [10:56:04.300] event:
{
	""seq"":0,
	""type"":""event"",
	""event"":""semanticDiag"",
	""body"":{
		""file"":""/<my team's monorepo>/packages/api/src/types/root.schema.ts"",
		""diagnostics"":[{
			""start"": { ""line"": 116, ""offset"": 28 },
			""end"": { ""line"": 122, ""offset"": 3 },
			""text"": ""Type instantiation is excessively deep and possibly infinite."",
			""code"": 2589,
			""category"": ""error""
		}, {
			""start"": { ""line"": 116, ""offset"": 14 },
			""end"": { ""line"": 116, ""offset"": 25 },
			""text"": ""The inferred type of 'Declaration' cannot be named without a reference to '@lll/shared/node_modules/zod'. This is likely not portable. A type annotation is necessary."",
			""code"": 2742,
			""category"": ""error""
		}]
	}
}
```

where `Declaration` is the schema I was constructing in `root.schema.ts`, using an import from `@lll/shared`.

It's worth noting, that error appeared only when adding a field to the object schema that used a schema from `@lll/shared`.

```ts
import { Schemas } from ""@lll/shared"";

//...

export const RootType = z.object({
//...
});

//...

export const Declaration = RootType.extend({
	// Inline schema properties. No dependency on @lll/shared
    //...

	allergens: Schemas.Primative.Allergens
});
```",,
1931175175,2846,Build in File and FileList Support,"# Add a support for File and FileList.

example

```ts
const size = 10000 // byte
z.flle().size(10000).allowType([""image/jpeg"",""image/png""])

z.fileList().min(1).max(10).size(10000).allowType([""image/jpeg"",""image/png""])
```",,
1929777188,2844,Cannot extend schema if target shape has .readonly(),"Zod version: 3.22.4
Typescript version: 5.2.2

Fails with `Property Â shapeÂ  does not exist on type` error on last string in example

```
import { z } from 'zod';

export const Entity = z.object({
  id: z.string(),
}).readonly();

export const IdNameEntity = z
  .object({
    name: z.string(),
  })
  .extend(Entity.shape);
```",,
1929387355,2843,Support for normalized strings?,"It would be nice if there was an easy integrated way to use [normalize](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize). Users sometimes input full-width characters which require different regexes to work.

It would be great to be able to do something like:

`const schema = z.object({
     fullWidthNumber: z.string().normalize(""NFKC"").regex(/\d{3}/)
});`

Where both `123` and `ï¼‘ï¼’ï¼“` would work.",,
1928644112,2842,nonempty is deprecated,"Hello, what reason to make it obsolete? How am I going to display this message now that the field is mandatory?
```
password: z.string()
    .nonempty('The Password field is required')
    .min(6, 'Password must be longer than 6 characters')
    .max(8, 'The password must not be a maximum of 8 characters'),
```",,
1925978146,2838,Loss of type (=any) when inferring branded schema type,"See TS Playground: `b1 = any` and `b2 = string`

[TS Playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbwF4F84DMoRHAREiAE1wCgSBjCAOwGd4AxCCOAXjiQDo6pgqBzABQBKDgCMoAQyqEBAckYRZQitTpwAQhKit2XGD37CyAemNwJARh3defOADJd6gEoBBAHIARADy4FuAD44AUooKABTchhlSlp4Sx0FDjAtGnCBXFxlElNzACZrfVtg0IiomNV4grZNKGTU9Mzs3NErNikAT2CAdyx+Cri4Vp0UqDSM3AAaOAVms1FquBt+Eugy6JVBhZGGiena7PQAVyoo4Go4UbTvAHlpzzhwgA8YcOkaXQAtIgAVDrBwp5wuhpgBJAICABuEgANkdwgAuOAnADWVAg3So0xo5AAFuEQBIkZwAMp4gkSW73MEBIRIm6IEhwZlwCIwI5QKhLcmE+pjdLQuHhZQoIA)

```ts
export declare class ZodBranded<T extends ZodTypeAny, B extends string | number | symbol> extends ZodType<T[""_output""] & BRAND<B>, ZodBrandedDef<T>, T[""_input""]> 
```

TS struggles inferring the BRAND intersection to fit into `z.Schema` (=`z.ZodType`): 
```ts
ZodType<T[""_output""] & BRAND<B>, ZodBrandedDef<T>, T[""_input""]>
```

The following works around the issue 100% for me with different types ([TS Playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbwF4F84DMoRHAREiAE1wCgSBjCAOwGd4AxCCOAXjiQDo6pgqBzABQBKDgCMoAQyqEBAckYRZQitTpwAQhKit2XGD37CVteJqgKdnAKZUAriAEBtWQEFZAGjiz1HrwGFZAF1lEgB6ULgJAEYdbl4+OAAyXXUAJRcAOQARAB5cBVwAPjgBSigoK3IYZUoTSJi2BQ4wLRorAVxcEPDIgCZY-XiSsoqqmtV4CX62M2bW9s7uiNEGyKoATxKAdwkaOC2sfgBuOCoILbgRyurjNRWdFqg2jtxPBSW4UWm4OP5h6FGN1qd2+j2enU8Zg+5B0uBcuDgAB88OoEcjcH4EaUAddxnUYWwwQtXhotO8yIRKgAbLRWDC2KhVYDUOBEnIAeU8WTgVgAHjAbIQ9pwAFpEAAq6zAViyVnQngAkp4AMo8-mC4UcZXkAAWVhAEg5XMVhUKAgAbhIqbYrAAuOAMgDWZy2VE8NF1+ok9uVQh9jlwAH0ILYYGBQ7hAkA)):
```ts
declare function parse<
  O, 
  D extends z.ZodTypeDef, 
  I, 
  S extends z.Schema<O, D, I>
>(value: unknown, schema: S): S[""_output""]
```",,
1925584643,2837,Tuple type produce uknown[] rest type when rest() not called (when strictNullChecks is set to false),"According to docs, basic tuple type should have produce:
```
const athleteSchema = z.tuple([
  z.string(), // name
  z.number(), // jersey number
  z.object({
    pointsScored: z.number(),
  }), // statistics
]);

type Athlete = z.infer<typeof athleteSchema>;
// type Athlete = [string, number, { pointsScored: number }]
```

But in reality, it produce
```
type Athlete = [string, number, {
    pointsScored?: number;
}, ...unknown[]]
```

Similar example
```
const pointSchema = z.tuple([z.number(), z.number()]);
type Point = z.infer<typeof pointSchema>;
```
expextion `[number, number]` but gents `[number, number, ...unknown[]]` which is really not useful. 

This happen when Typescript config has strictNullChecks: false",,
1925552922,2836,Regular Expression Denial of Service (ReDoS) [SNYK ISSUE] ,package is vulnerable to Regular Expression Denial of Service (ReDoS) due to using an inefficient pattern when validating emails.,,
1924112209,2835,Is there anyway to check if a string contains emojis?,"I'm currently using:

```javascript
z.string()
 .regex(/^((?!\p{Extended_Pictographic}).)*$/u, 'Emojis are not allowed');
```

Just wondered if there was another way of doing this?",,
1923689718,2833,Zod denial of service vulnerability,"# [Source Report](https://github.com/afifurrohman-id/employee-management/security/dependabot/2)
![image](https://github.com/colinhacks/zod/assets/118882411/6cd78a96-da0c-4078-b33e-f2ec9e27d006)
",,
1922413794,2832,Parse doesn't work when schema passed as generic type,"Hi I have a function like this 
```
export const parseMyObject = <T, Z extends z.ZodType<object>>(
  value: object,
  schema: Z
): T | string => {
  const result = schema.safeParse(value);
  console.log(result)
  if(result.success) {
    return obj;
  } else {
  return  result.error.message
}
```
Let's say I'm passing
```
type MyObject = {
  latitude: number;
  longitude: number
  timezone: string;
}
const mySchema = z.object({
  latitude: z.number(),
  longitude: z.number(),
  timezone: z.string(),
)}
parseMyObject<MyObject, typeof mySchema>({hi: ""mom""}, mySchema); 
  ```
For the signature I have tried `Z extends z.ZodType<T>` and `Z extends z.ZodTypeAny` as well.
When I pass a valid T for value, I get the object back.  But when I pass a wildly invalid value for T then console log is `{ success:true, data:{} }`
I have the same result when using schema.parse(value).  It does not throw, it returns `{ success:true, data:{} }`.
When I run parse and safeParse directly on the schema e.g. where the schema is defined and I have it in hand, it works as expected.

The above function is distilled from the real world function, so there maybe subtle errors, but the overall idea is correct.  e.g. I'm returning a type like what safeParse returns but I didn't want to type all that out. 

I feel like there's some subtle thing I'm doing wrong, but if not, then maybe there's a bug.
thanks
Raif",,
1921992369,2831,Intersection does not have a shape,"When using a union/intersection type, the resulting object does not have a shape.

```ts
export const GetPulseMeterCurrentUsageParams = z
    .object({
        duration: z.number().optional(),
    })
    .and(
        z
            .object({ iotDeviceID: z.string() })
            .or(z.object({ pulseMeterID: z.string() }))
    );

GetPulseMeterCurrentUsageParams.shape // undefined
```",,
1921802521,2830,Union doesn't return all options issues when used with string-specific validation,"```javascript
const { z } = require(""zod"")

const schema = z.union([z.string().startsWith(""1""), z.string().startsWith(""2"")])
const result = schema.safeParse(""3"")
!result.success && console.log(result.error.issues)
```

Returns:
```javascript
[
  {
    code: 'invalid_string',
    validation: { startsWith: '1' },
    message: 'Invalid input: must start with ""1""',
    path: []
  }
]
```

Expected:
```javascript
[
  {
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            code: 'invalid_string',
            validation: { startsWith: '1' },
            path: [],
            message: 'Invalid input: must start with ""1""'
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            code: 'invalid_string',
            validation: { startsWith: '2' },
            path: [],
            message: 'Invalid input: must start with ""2""'
          }
        ],
        ""name"": ""ZodError""
      }
    ],
    ""path"": [],
    ""message"": ""Invalid input""
  }
]
```

Looks like it works when removing these lines: https://github.com/colinhacks/zod/blob/ae0f7a2c15e7741ee1b23c03a3bfb9acebd86551/src/types.ts#L2836-L2839

But I'm not sure what is `dirty` ",,
1921701093,2829,Custom error message for required message under zod error map,"I want to implement my custom zod error map messages but wonder how do I make my custom required_message in the zod map? I couldn't find it in the switch/case for zodIssuecode.

Before that I had to do it manually for each input in the schema.

The zod map looks like this:

```ts
const customErrorMap: z.ZodErrorMap = (issue, ctx) => {
    switch (issue.code) {
        case z.ZodIssueCode.invalid_type:
            if (issue.expected === ""string"") {
                return { message: 'invalid_string' };
            } else if (issue.expected === ""number"") {
                return { message: 'invalid_number' };
            } else {
                return { message: 'invalid_type' };
            }
        case z.ZodIssueCode.custom:
            return { message: issue.message || 'custom_error' };
        case z.ZodIssueCode.invalid_union:
            return { message: 'invalid_union' };
        case z.ZodIssueCode.invalid_enum_value:
            return { message: 'invalid_enum_value' };
        case z.ZodIssueCode.unrecognized_keys:
            return { message: 'unrecognized_keys' };
        case z.ZodIssueCode.invalid_arguments:
            return { message: 'invalid_arguments' };
        case z.ZodIssueCode.invalid_return_type:
            return { message: 'invalid_return_type' };
        case z.ZodIssueCode.invalid_date:
            return { message: 'invalid_date' };
        case z.ZodIssueCode.invalid_string:
            return { message: 'invalid_string' };
        case z.ZodIssueCode.too_small:
            return { message: 'too_small' };
        case z.ZodIssueCode.too_big:
            return { message: 'too_big' };
        case z.ZodIssueCode.invalid_intersection_types:
            return { message: 'invalid_intersection_types' };
        case z.ZodIssueCode.not_multiple_of:
            return { message: 'not_multiple_of' };
        case z.ZodIssueCode.not_finite:
            return { message: 'not_finite' };
        default:
            return { message: ctx.defaultError };
    }
}

```",,
1921436919,2828,Security vulnerability in zod@3.22.2,"Hi maintainers,

I am reporting a security vulnerability in zod.
Vulnerability type: Regular Expression Denial of Service (ReDoS) [High Severity]
Additional information: [https://security.snyk.io/vuln/SNYK-JS-ZOD-5925617](https://security.snyk.io/vuln/SNYK-JS-ZOD-5925617)
![image](https://github.com/colinhacks/zod/assets/36725290/b9cb2aaf-39a1-4cc2-8674-73205ef06e41)

Best regards,
Arie
",,
1920761144,2826,Bug,z.coerce.boolean();  always returns true,,
1919007442,2821,`validDiscriminatorValues` disappeared,"Commit 2281caa1e1c9490800ce2aaf847da145381a2f36 (between versions 3.19.1 and 3.20.0) removed property `validDiscriminatorValues` from `ZodDiscriminatedUnion<...>`. 

The replacement seems to be `[...theUnion.optionsMap.keys()]`. Perhaps `validDiscriminatorValues` should be returned for backwards-compatibility and convenience.",,
1917887199,2820,PR's are going stale,"I really enjoy using ZOD, but it's pretty disconcerting to see almost 60 PR's open, and a bunch that have been closed because they have gone stale. A lot of these PR's are simple one liners that wouldn't take a long time for the maintainers to review. I see that even 5 days ago a maintainers got some work in, but there are a ton of PR's just sitting. I understand that it is a thankless job, so I do applaud you all for a great package, but confused as to why other's PR's aren't reviewed. ",,
1916803496,2817,Passing a variable that holds an array of schemas into `z.discriminatedUnion()` fails,"### Description

Passing a variable that holds an array of schemas to a `z.discriminatedUnion()` isn't possible on `zod@3.22.2`.

### ðŸ“ Run the issue

```ts
const ThingSchemas = [
  z.object({ type: z.literal('vehicle'), name: z.string() }),
  z.object({ type: z.literal('food'), name: z.string() })
];

const Thing = z.discriminatedUnion('type', ThingSchemas);
```

would prompt `Source provides no match for required element at position 0 in target` error.

### âœ… By-pass it

```ts
const ThingSchemas = [
  z.object({ type: z.literal('vehicle'), name: z.string() }),
  z.object({ type: z.literal('food'), name: z.string() })
];

const Thing = z.discriminatedUnion('type', [ThingSchemas[0], ...ThingSchemas.slice(1)]);
```

Manually structuring the first item of the array and spreading the rest for the win ðŸ¤Ÿ",,
1916500841,2816,`.nullish()` does not include the `null` type when using `z.infer()`,"```ts
const schema = z.object({
  prop: z.string().nullish(),
});

type Schema = z.infer<typeof schema>;
```

Expected type of `Schema` as a result:

```ts
type Schema = {
    prop?: string | null;
}
```

Actual type of `Schema`:

```ts
type Schema = {
    prop?: string;
}
```

Somehow the null is not included into the type. ",,
1916116998,2815,Inferred types somehow break with .catchall(),"Hey! Zod is fantastic. I've been heavily using it for a really ugly schema, which means I've been running into all sorts of edge cases with strange behavior. This one doesn't cause any compilation or runtime errors, but it can make for sometimes annoying development as I can't hover check certain variable types.

```ts
export type Stat = z.infer<typeof zStatSchema>;
export const zStatSchema = z
    .object({
        std: z.union([z.number(), z.null(), z.string()]).optional(),
        default: z.number().optional(),
        abilities: z.string().or(z.string().array()).optional(),
        notes: z.string().array().optional(),
        note: z.string().optional(),
    })
    .catchall(z.number());
const stat: Stat = {};
```
When I hover the type ""Stat"" I get a good type.
```ts
type Stat = {
    std?: string | number | null | undefined;
    default?: number | undefined;
    abilities?: string | string[] | undefined;
    notes?: string[] | undefined;
    note?: string | undefined;
} & {
    [k: string]: number;
}
```
 But when I hover the variable ""stat"" I get:
```ts
const stat: z.objectOutputType<{
    std: z.ZodOptional<z.ZodUnion<[z.ZodNumber, z.ZodNull, z.ZodString]>>;
    default: z.ZodOptional<z.ZodNumber>;
    abilities: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString, ""many"">]>>;
    notes: z.ZodOptional<...>;
    note: z.ZodOptional<...>;
}, z.ZodNumber, ""strip"">
```

Here's a minimal version that can be played with:

```ts
export const Foo = z
	.object({
		str: z.string().optional(),
	})
	.catchall(z.number().optional());
export type Foo = z.infer<typeof Foo>;
const stat: Foo = {}; // Valid, but the hover over types for stat are the zodified version. Hovering Foo gives the nice types.

const res: Foo = Foo.parse({ str: 'foo', bar: 3 }); // perfectly valid, no issues
const foo = res.str; // hover type checks as a string
const bar = res.bar; // hover type checks as a number
```


",,
1915128339,2813,"The ""and"" method behavior has changed","I was using zod@3.21.4 in my project. 
```
const sharedContactCreateOrImportSchema = z
  .object({
    phoneNumber: phoneNumberSchema.optional(),
    email: emailAddressSchema.optional(),
  })
  .and(accountsNumberOptionalSchema)
  .and(TaxNumberOptionalSchema)
  .superRefine((values, ctx) => {
    const { postalCode } = values;
    const  postalCodeError =
      validatePostalCode( postalCode);
    if (postalCodeError) {
      ctx.addIssue({
        code: 'custom',
        message: postalCodeError,
      });
    }
  });
```

If I had an object where all 5 properties where invalid, I'd get an array of 5 errors. But when I upgraded the zod package version to 3.22.2, this bahavior changed. Now if I have errors in `phoneNumber` or `email`, it never goes to the next parts, and I won't get errors for account number, tax number, or postal code.
",,
1913333138,2809,Foreign key constraint failed on the field: `foreign key`,"It doesn't tell which field.

```
Foreign key constraint failed on the field: `foreign key`
...
{
  code: 'P2003',
  clientVersion: '5.2.0',
  meta: { field_name: 'foreign key' }
}
",,
1912005246,2807,How to use Zod schema with existing TypeScript interface?,"### Discussed in https://github.com/colinhacks/zod/discussions/2796

<div type='discussions-op-text'>

<sup>Originally posted by **adamerose** September 24, 2023</sup>
I see Zod described as a ""TypeScript-first"" library but am struggling to figure out how to actually integrate it with my TypeScript definitions. Is there a way to pass a TypeScript interface to my Zod schema as a generic and have my linter tell me if they're not compatible? 

[This](https://github.com/jquense/yup#ensuring-a-schema-matches-an-existing-type) is how it looks in Yup:
```typescript
import { object, number, string, ObjectSchema } from 'yup';

interface Person {
  name: string;
  age?: number;
  sex: 'male' | 'female' | 'other' | null;
}

// will raise a compile-time type error if the schema does not produce a valid Person
const schema: ObjectSchema<Person> = object({
  name: string().defined(),
  age: number().optional(),
  sex: string<'male' | 'female' | 'other'>().nullable().defined(),
});

// âŒ errors:
// ""Type 'number | undefined' is not assignable to type 'string'.""
const badSchema: ObjectSchema<Person> = object({
  name: number(),
});
```

I found discussion [here](https://github.com/colinhacks/zod/issues/53) and [here](https://github.com/colinhacks/zod/issues/2086) but didn't see any solution I could understand, or relied on codegen and external libraries.

I think something like this might work? But it's very boilerplatey and I don't see anything like this in the docs:
```typescript
interface Person {
  name: string;
  age?: number;
  sex: ""male"" | ""female"" | ""other"" | null;
}

const zodSchema = z.object({
  name: z.string(),
  age: z.number().optional(),
  sex: z.enum([""male"", ""female"", ""other""]).nullable(),
});

type InferredPerson = z.infer<typeof zodSchema>;
function assertType<T>(_value: T) {}
assertType<Person>({} as InferredPerson);
```</div>",,
1910517192,2792,Invalid Environment Variables: DATABASE_URL 'Invalid url',"I set up my .env with a local mysql url. It errored because the password had #! in it, which needed to be URL encoded. I got it working. I then set up deployment, by leaving the .env alone, and modifying the schema.prisma file so that instead of using ""url = env(""DATABASE_URL"") it used the direct string to a railway MySQL server.  npx db push to MySQL remote server, got everything working on deployment through vercel by adding env variables to Vercel deployment.
Great
Now I switch back to local, tell prisma to look at local env var instead of railway, so that I can use local mySQL, and it refuses to parse the local env file as it had done just moments before...
![image](https://github.com/colinhacks/zod/assets/66894106/1fc47429-6482-4427-a46a-4f8267300d9a)

![image](https://github.com/colinhacks/zod/assets/66894106/c5b9a58e-7d7e-4c99-bab6-f46ffca15314)
![image](https://github.com/colinhacks/zod/assets/66894106/d6becfee-6ffb-4dfe-8032-c9a21694bced)
![image](https://github.com/colinhacks/zod/assets/66894106/7791498b-8af5-4c6c-a191-37c7a4a8e6e7)

",,
1910433916,2791,Uncatchable `invalid_union` error,"This code should catch and ignore the error, but it does not. There seems to be no way to catch the error.

```ts
try {
    const schema = z.union( [ z.literal( 1 ), z.literal( 2 ) ] )
    const result = schema.safeParse( 3 )
    !result.success && console.log( result.error.issues )
} catch {
    // do nothing
}
```

```
[
  {
    code: ""invalid_union"",
    unionErrors: [
      159 |     const json = JSON.stringify(obj, null, 2);
160 |     return json.replace(/""([^""]+)"":/g, ""$1:"");
161 | };
162 | class ZodError extends Error {
163 |     constructor(issues) {
164 |         super();
            ^
ZodError: [
  {
    ""received"": 3,
    ""code"": ""invalid_literal"",
    ""expected"": 1,
    ""path"": [],
    ""message"": ""Invalid literal value, expected 1""
  }
]
 errors: [
  {
    ""received"": 3,
    ""code"": ""invalid_literal"",
    ""expected"": 1,
    ""path"": [],
    ""message"": ""Invalid literal value, expected 1""
  }
]

      at new ZodError (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:164:8)
      at /home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:2589:75
      at map (:1:20)
      at _parse (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:2589:32)
      at _parseSync (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:624:23)
      at safeParse (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:654:23)
      at /home/jacob/software/bun-sandbox/src/zod.ts:21:19
, 159 |     const json = JSON.stringify(obj, null, 2);
160 |     return json.replace(/""([^""]+)"":/g, ""$1:"");
161 | };
162 | class ZodError extends Error {
163 |     constructor(issues) {
164 |         super();
            ^
ZodError: [
  {
    ""received"": 3,
    ""code"": ""invalid_literal"",
    ""expected"": 2,
    ""path"": [],
    ""message"": ""Invalid literal value, expected 2""
  }
]
 errors: [
  {
    ""received"": 3,
    ""code"": ""invalid_literal"",
    ""expected"": 2,
    ""path"": [],
    ""message"": ""Invalid literal value, expected 2""
  }
]

      at new ZodError (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:164:8)
      at /home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:2589:75
      at map (:1:20)
      at _parse (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:2589:32)
      at _parseSync (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:624:23)
      at safeParse (/home/jacob/software/bun-sandbox/node_modules/zod/lib/index.mjs:654:23)
      at /home/jacob/software/bun-sandbox/src/zod.ts:21:19

    ],
    path: [],
    message: ""Invalid input""
  }
]
```

```ts
// package.json
{
    ""dependencies"": {
        ""zod"": ""^3.22.2"",
    },
    ""devDependencies"": {
        ""bun-types"": ""latest""
    },
}
```",,
1910412579,2789,Function to create a union of literal dynamically,"Currently, it does not seem to be possible to create a function that does union of literal, like:

```ts
function unionOfLiterals<T extends string | number>(constants: readonly T[]): z.ZodUnion<[ZodTypeAny, ...ZodTypeAny[]]> {
  const literals = constants.map((constant) => z.literal(constant)) as [z.ZodLiteral<T>, ...z.ZodLiteral<T>[]];
  return z.union(literals);
}

const MY_CONSTANTS = ['a', 'b', 1] as const;
const unionType = createUnionType(MY_CONSTANTS);
```

This code gives the following typing error:

```
Argument of type '[ZodLiteral<T>, ...ZodLiteral<T>[]]' is not assignable to parameter of type 'readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
  Source provides no match for required element at position 1 in target.ts(2345)
```

And a call to this method returns a z.ZodUnion<[ZodTypeAny, ...ZodTypeAny[]]> object.

Providing the constants directly is straightfoward:
```ts
z.union([z.literal('a'), z.literal('b'), z.literal(1)])
```

If that was possible, it would enable several use cases for using solely zod for API input validation. Now I end up losing typing when doing that indirectly.

Amazing library, by the way.",,
1910398393,2788,How to use Zod schema with existing TypeScript interface?,"I see Zod described as a ""TypeScript-first"" library but am struggling to figure out how to actually integrate it with my TypeScript definitions. Is there a way to pass a TypeScript interface to my Zod schema as a generic and have my linter tell me if they're not compatible? 

[This](https://github.com/jquense/yup#ensuring-a-schema-matches-an-existing-type) is how it looks in Yup:
```typescript
import { object, number, string, ObjectSchema } from 'yup';

interface Person {
  name: string;
  age?: number;
  sex: 'male' | 'female' | 'other' | null;
}

// will raise a compile-time type error if the schema does not produce a valid Person
const schema: ObjectSchema<Person> = object({
  name: string().defined(),
  age: number().optional(),
  sex: string<'male' | 'female' | 'other'>().nullable().defined(),
});

// âŒ errors:
// ""Type 'number | undefined' is not assignable to type 'string'.""
const badSchema: ObjectSchema<Person> = object({
  name: number(),
});
```

I found discussion [here](https://github.com/colinhacks/zod/issues/53) and [here](https://github.com/colinhacks/zod/issues/2086) but didn't see any solution I could understand, or relied on codegen and external libraries.

I think something like this might work? But it's very boilerplatey and I don't see anything like this in the docs:
```typescript
interface Person {
  name: string;
  age?: number;
  sex: ""male"" | ""female"" | ""other"" | null;
}

const zodSchema = z.object({
  name: z.string(),
  age: z.number().optional(),
  sex: z.enum([""male"", ""female"", ""other""]).nullable(),
});

type InferredPerson = z.infer<typeof zodSchema>;
function assertType<T>(_value: T) {}
assertType<Person>({} as InferredPerson);
```",,
1910194189,2787,Zod email validation blocks the main thread in version 3.22.2,"Here is the version 3.21.4 of Zod:


https://github.com/colinhacks/zod/assets/56435044/0cb44a0c-90ac-486d-a435-a44590234c1b

And here is the version 3.22.2:


https://github.com/colinhacks/zod/assets/56435044/64ec1f54-3c08-4f7b-a159-96d4fc9a9510

here is the demo code:

```svelte
<script>
    import { z } from 'zod';

    let emailVal = '';

    let success;
    let counter = 0;

    $: {
        success = z.string().email().safeParse(emailVal).success;
        counter++;
    }
</script>

<input type=""text"" bind:value={emailVal} />
<p>success: {success} | {counter}</p>

```

and I also tried something like this:

```svelte
<script>
    import { z } from 'zod';
    import { onMount } from 'svelte';

    onMount(() => {
        console.log(z.string().email().safeParse('a'.repeat(50)).success);
    });
</script>
```

Both of them blocks the main thread and the second code doesn't even let me to see the page.

When I opened the performance tab in devtools I noticed it is doubling the time it takes the complete the task every time when I enter a new character to the input.

![chrome_yMIe5E2Et1](https://github.com/colinhacks/zod/assets/56435044/371295ce-0672-41b8-8f19-b41bf652bb0e)

| task | time     |
|------|----------|
| 1    | 10ms     |
| 2    | 19.33ms  |
| 3    | 38.42ms  |
| 4    | 75.17ms  |
| 5    | 151ms    |
| 6    | 299.96ms    |
| 7    | 598.56ms |
| 8    | 1.21s    |",,
1910042612,2786,`z.coerce.object()` should be a thing,"Instead of:

```ts
const mrfSimpleSchema = z.object({
  accept: z.string().array().catch([]),
  avatar_removal: z.string().array().catch([]),
  banner_removal: z.string().array().catch([]),
  federated_timeline_removal: z.string().array().catch([]),
  followers_only: z.string().array().catch([]),
  media_nsfw: z.string().array().catch([]),
  media_removal: z.string().array().catch([]),
  reject: z.string().array().catch([]),
  reject_deletes: z.string().array().catch([]),
  report_removal: z.string().array().catch([]),
}).catch({
  accept: [],
  avatar_removal: [],
  banner_removal: [],
  federated_timeline_removal: [],
  followers_only: [],
  media_nsfw: [],
  media_removal: [],
  reject: [],
  reject_deletes: [],
  report_removal: [],
});
```

We should be able to:

```ts
const mrfSimpleSchema = z.coerce.object({
  accept: z.string().array().catch([]),
  avatar_removal: z.string().array().catch([]),
  banner_removal: z.string().array().catch([]),
  federated_timeline_removal: z.string().array().catch([]),
  followers_only: z.string().array().catch([]),
  media_nsfw: z.string().array().catch([]),
  media_removal: z.string().array().catch([]),
  reject: z.string().array().catch([]),
  reject_deletes: z.string().array().catch([]),
  report_removal: z.string().array().catch([]),
});
```

`z.coerce.object` would be roughly equivalent to:

```ts
z.object({}).passthrough().catch({}).pipe(myObjSchema)
```

All keys of the shape need to be a `ZodCatch` or `ZodOptional`, otherwise it's a TypeError.",,
1908968112,2762,keep undefined values in .record(),"### Discussed in https://github.com/colinhacks/zod/discussions/2760

<div type='discussions-op-text'>

<sup>Originally posted by **DanielHoffmann** September 22, 2023</sup>
is there a way where I can type a record while keeping the keys that have `undefined` as a value?

For example, how could I set up this schema so this test passes?

```typescript
  import { z } from 'zod'
  test('allow undefined values', () => {
    const keySchema = z.string().startsWith('_')
    const valueSchema = z.union([z.number(), z.undefined()])
    const schema = z.record(keySchema, valueSchema)
    expect(
      Object.keys(
        schema.parse({
          _test: undefined,
        }),
      ),
    ).toEqual(['_test'])
  })
```

in this case the `Object.keys(schema.parse(...))` is returning empty array

Could this be a bug? For example, this tests passes:

```typescript
import { z } from 'zod'
test('allow undefined values', () => {
    const schema = z.object({
      a: z.union([z.number(), z.undefined()]),
    })
    expect(
      Object.keys(
        schema.parse({
          a: undefined,
        }),
      ),
    ).toEqual(['a'])
})
```

I would kind of expect `.record()` and `.object()` to behave the same in regards to the values</div>",,
1908589741,2759,Type error when using `transform()` together with an explicit type,"It seems that when you use `transform()` with an explicit type, the transformed type is not used, and you get a type error.

``` typescript
import { z } from ""zod"";

const BasePart = z.object({
    foo: z.number().transform(number => number.toString())
});

// The inferred type here is correct: `foo` is given type `string`
type WholeType = z.infer<typeof BasePart> & {
    bar: WholeType
}

// Type error: `foo` is seen as a number instead of a string (it is not using the transformed type)
const RecursivePart: z.ZodType<WholeType> = BasePart.extend({
    bar: z.lazy(() => RecursivePart)
})

// I found the error when following the example for a recursive type (shown above), but it can be shown more trivially:
type NonrecursiveType = z.infer<typeof BasePart> & {
    bar: number
}

// Same type error
const NonrecursivePart: z.ZodType<NonrecursiveType> = BasePart.extend({
    bar: z.number()
})

// But this is fine
const ImplicitType = BasePart.extend({
    bar: z.number()
})

/* 
Gives the correct type:
{
    foo: string;
    bar: number;
}
*/
type ImplicitType = z.infer<typeof ImplicitType>;

```",,
1908012297,2758,Support IP Range Validation,"This PR supports ip address, but sometimes we need to support network range. 
https://github.com/colinhacks/zod/pull/2066

So, we need like below validators for string.

```ts
z.string().ip_range({ version: ""v4""})
```

or

```ts
z.string().ipv4Range();
z.string().ipv6Range();
```

",,
1907623256,2756,Having an issue with a discriminatedUnion,"I haven't found this asked anywhere so I'm trying to figure out if this is possible.
Sorry if this has been asked/answered before but I'm having a hell of a time getting this to work.

```ts
export const ContactUsFormSchema = z.discriminatedUnion(formIds.whatIsYourRequestAbout, [
  z.object({
    whatCanWeHelpYouWith: z.nativeEnum(WhatCanWeHelpYouWith),
    whatIsYourRequestAbout: z.literal(Core.ICantAttendAnUpcomingCoresession),
    whichCoreSessionWillYouMiss: z.string(),
    reason: z.nativeEnum(AbsentReason),
  }),
  z.object({
    whatCanWeHelpYouWith: z.nativeEnum(WhatCanWeHelpYouWith),
    whatIsYourRequestAbout: z.nativeEnum(WhatIsYourRequestAbout),
    tellUsMoreAboutYourRequest: z.string(),
  }),
]);
```
If `whatIsYourRequestAbout` is a specific value I need a different object(first in the list).  
Otherwise I can accept any value from the WhatIsYourRequestAbout emum and apply the 2nd object.

Current error I'm getting when I select anything other than `Core.ICantAttendAnUpcomingCoresession` for `whatIsYourRequestAbout`:
```ts
{
    ""whatIsYourRequestAbout"": {
        ""message"": ""Invalid discriminator value. Expected 'I can't attend an upcoming core session' | 'Billing' | 'NominatingAColleague' | 'UpdatingMyProfile' | 'MyMembershipStatus' | 'CommunityGuidelines' | 'ChiefSwag' | 'ChiefsEmailCommunications' | 'Sponsorship' | 'GeneralMembership' | 'ZoomLinkForACoreMeeting' | 'CorePolicies' | 'ChangingCoreGroups' | 'ASuggestionToImproveCore' | 'GeneralCoreQuestion' | 'NeedToCancelARSVP' | 'ZoomLinkForAnEvent' | 'FeedbackForAnEvent' | 'SuggestionForAnEvent' | 'GeneralEventQuestion' | 'ModifyingAMeetingRoomReservation' | 'GeneralQuestionAboutTheClubhouse' | 'FeedbackAboutAClubhouse' | 'SuggestionForTheWebsite' | 'ReportAWebsiteBugOrIssue' | 'GeneralWebsiteQuestion' | 'SuggestionForTheMobileApp' | 'ReportAMobileAppBugOrIssue' | 'GeneralMobileAppQuestion' | 'BoardServices' | 'ChiefsEditionalServices' | 'ExecutiveCoaching' | 'ChiefsPartnerships' | 'AQuestionAboutMyCoreGroupOrGroups' | 'MemberAttendance' | 'ZoomSupport' | 'ReportAGuidePortalBugOrIssue' | 'ContentOrAGroupExercise'"",
        ""type"": ""invalid_union_discriminator"",
        ""ref"": {}
    }
}
```

I'm using `zod` with `react-hook-form`'s `zodResolver`.

Any hints or insight would be greatly appreciated.  
Would I need to break out the 2nd `z.object` in to an object for each of the possible options?",,
1904409757,2750,Not interresting issue,"EDIT : This was a bug on my code, so no need to worry about this",,
1902719623,2749,Required object with optional fields,"Hi

I noticed something unexpected when trying to validate objects and fields. In the particular case, I had an object with few random fields, one field was itself an object that was required, but had all of its internal fields defined as optional. I would have expected this to work, but zod parse throws an error.

Example:
```
const example = z.object({ 
    field1: z.string().optional(), 
    field2: z.object({ first: z.string().optional(), second: z.string().optional()}).required(), 
    field3: z.number().optional()
})
```
Then trying to validate it, when both fields of field2 are there it works, when one is missing it fails:
```
> example.safeParse({ field1: 'something', field2: { first: 'bar', second: 'bar'}, field3: 123})
{
  success: true,
  data: {
    field1: 'something',
    field2: { first: 'bar', second: 'bar' },
    field3: 123
  }
}
> example.safeParse({ field1: 'something', field2: { first: 'bar'}, field3: 123})
{ success: false, error: [Getter] }
```
My expectation would be that either fields of `first` or `second` being present should satisfy the field2 schema and the latter validation should succeed, but it does not and instead, both fields need to be present. 

Is there something that I'm doing wrong, or is this expected?

Thanks!",,
1899805812,2746,ZodRecord.create ZodType checking issue,"Hi, I have a use case in which I use Zod internally in my JS library, but I also want users to be able to use Zod to define plugins for the library (defined externally to my NPM package).

I have run into an issue where ZodRecord.create() results in unexpected behavior due to this `if` statement:

https://github.com/colinhacks/zod/blob/28c19273658b164c53c149785fa7a8187c428ad4/src/types.ts#L3409

The `instanceof ZodType` check fails due to having two independent ""copies"" of Zod: the one internal to my JS library, and one in userland. The user then ends up with `z.record(z.string(), first)` but they expected `z.record(first, second)`.

Observable notebook with minimal reproducer: https://observablehq.com/d/25a9954667141376

Perhaps there is a better way to check for the second parameter being a Zod schema that would work across multiple independent copies of Zod imports.
",,
1899563531,2745,Is it possible to get previous errors in superRefine,"When using superRefine on a zod object, is it possible to know which fields validation failed in the object?

Here is an example where I want to ensure that some fields are as expected before doing additional checks : 

```typescript
export const EMAIL_SCHEMA = DEFAULT_SCHEMA.merge(
	z.object({
		type: z.literal(FormElementTypes.EMAIL),
		default_value: z.string().email().optional(),
		domain: z
			.string()
			.regex(/^([a-z]+\.){1,3}[a-z]{2,3}$/)
			.optional(),
	})
).superRefine(({ default_value, domain }, ctx) => {
        // here we are not sure if default_value and domains match expected format
        // doing format checked once more here would be overkill
	if (default_value && domain && !default_value.endsWith(domain)) {
		ctx.addIssue({
			code: z.ZodIssueCode.invalid_string,
			message: 'Invalid',
			path: ['default_value'],
			validation: 'email',
		});
	}
});
```
it is possible to do so?? if so, how to achieve it? else, does a workaround exist?",,
1899473992,2744,JsDoc `@deprecated` is not included in the build files,"In previous commits ([1](https://github.com/colinhacks/zod/pull/440), [2](https://github.com/colinhacks/zod/commit/347332c30b801c608ea29c89f61f0247a953bb83)) `ZodString.nonempty` was marked as `@deprecated` but when I use it, the IDE doesn't cross out it. 
I doubled-checked the code, it's done perfectly

https://github.com/colinhacks/zod/blob/28c19273658b164c53c149785fa7a8187c428ad4/src/types.ts#L979-L984

However, upon inspecting the file in my `node_modules`, I could not locate the `@deprecated` annotation. [Please refer to line 200 in `zod/lib/types.d.ts` for verification](https://www.npmjs.com/package/zod?activeTab=code)

It seems like an issue with the build options.",,
1899146167,2743,Zod Preprocess returning unknown type,"This preprocess method:

```ts
IBAN: z.preprocess(
    (v: string): String => v.replace(/[ \_]/g, """"),
    z.string().toUpperCase().min(15).max(34)
  ),
```

returns unknown type instead of string.

Zod version: 3.22.2",,
1899144961,2742,Cannot read properties of undefined (reading 'coerce'),"My error is suspiciously similar to https://github.com/colinhacks/zod/issues/1193, but there are no circular dependencies. Also, this error only occurs inside vitest, and I'm seeing it as a result of converting my project from jest to vitest.

My code as as follows:

```ts
import React from 'react';
import { FormattedNumber } from 'react-intl';
import { z } from 'zod';

/** The input is a number and is not NaN. */
export const realNumberSchema = z.coerce.number().refine(n => !isNaN(n));

// ...more functions
```

I'm not sure if this is a problem in zod, vitest, or just my configuration.",,
1898790194,2740,Generate zod schema code from schema already defined,"Hello there!!

My use case is pretty specific. I wont to use `drizzle-orm` and `drizzle-zod` to generate insert schemas. I would like to use the schema in the server side and the client side.

The problem is that if I import the zod schema definition from the client side I get all the database dependencies.

```typescript
import { pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core'
import { createInsertSchema } from 'drizzle-zod'

const usersTable = pgTable('users', {
    id: uuid('id').primaryKey().defaultRandom(),
    createdAt: timestamp('created_at').notNull().defaultNow(),
    email: text('email').notNull().unique(),
})

const insertUserSchema = createInsertSchema(usersTable, {
    id: (schema) => schema.id.uuid()
})

const insertUserCommandSchema = insertUserSchema.pick({ email: true })
```

If I try to import the `insertUserCommandSchema` to perform client-side validations I am getting all the server side stuff. That make sense.


Is it possible to generate the `zod` schema definition code from `insertUserCommandSchema`? Is there any tool that can achieve this?

Thanks in advance!!
",,
1898256257,2739,Extend zod.object() with zod.record(),"Hey,

I know that the request most likely sounds awkward, but my goal is to enforce specific keys on an object and allow further unknown keys with a limited set of value types. My typescript type representing my goal looks like this:

```ts
declare type PasteEnvironment = {
    operatingSystem: {
        name: string
        version: string
        architecture: string
    },
    javaVirtualMachine?: {
        name: string
        vendor: string
        version: string
    }
} & { [key: string]: CustomMetadataValueType }

declare type CustomMetadataValueType = string | number | boolean | string[] | number[]
```

My attempt was the following:
```ts
export const CreatePasteSchema = zod.object({
    application: zod.object({
        name: zod.string(),
        version: zod.string()
    }).required(),
    environment: zod.object({
        operatingSystem: zod.object({
            name: zod.string(),
            version: zod.string(),
            architecture: zod.string()
        }).required(),
        javaVirtualMachine: zod.object({
            name: zod.string(),
            vendor: zod.string(),
            version: zod.string()
        }).optional(),
    }).extend(
        zod.record(
            zod.string(),
            zod.union([zod.number(), zod.string()])
        )
    ).required()
})
```

Sadly Sadly zod.extends want's a RawZodShape which requires defined keys - therefor that does not work and creates an typescript error:
<img width=""826"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/27054324/34083a3c-5a54-4ab7-9984-27309c826b61"">

Is there any possibility to achieve my goal somehow?",,
1898152421,2738,z.enum with default give type incompatibility,"I'm trying to create a mutually recursive type, but on one of both types, I have an enum with a default value that gives me a type compatibility error. Check the following code:

```javascript
export const pricePlainSchema = z.object({
  productId: z.string().uuid(),
  id: z.string().uuid(),
  status: z.enum(['active', 'archived']).default('active'),
  name: z.string(),
  price: number,
  duration: z.number().optional(),
  created: z.string().datetime(),
  updated: z.string().datetime(),
});

export const productPlainSchema = z.object({
  id: z.string().uuid(),
  productId: z.string().uuid(),
  status: z.enum(['draft', 'published', 'archived']).default('draft'),
  name: z.string(),
  created: z.string().datetime(),
  updated: z.string().datetime(),
});

export type Price = z.infer<typeof pricePlainSchema> &{
  product?: Product;
}

export type Product = z.infer<typeof productPlainSchema> & {
  price?: Price;
};

let priceSchema : z.ZodType<Price>;
export const productSchema: z.ZodType<Product> = productPlainSchema.extend({
  price: z.lazy(()=>priceSchema.optional())
});

priceSchema = pricePlainSchema.extend({
  product: productSchema.optional()
})
```
I'm having the next errors in the productSchema definition

> Les types de la propriÃ©tÃ© 'status' sont incompatibles.
          Impossible d'assigner le type '""draft"" | ""published"" | ""archived"" | undefined' au type '""draft"" | ""published"" | ""archived""'.
            Impossible d'assigner le type 'undefined' au type '""draft"" | ""published"" | ""archived""'.

Similar for the price schema:

> Les types de la propriÃ©tÃ© 'status' sont incompatibles.
          Impossible d'assigner le type '""archived"" | ""active"" | undefined' au type '""archived"" | ""active""'.
            Impossible d'assigner le type 'undefined' au type '""archived"" | ""active""'

If I remove the default construct, i have no error, so the problem is that when an attribute has a default construct the type generated should mark it as optional, and not mandatory as it is doing now.

Even more, If I create the types manually as follows, it works like a charm too (you can see that the attributes with default are defined as optional), but it is not the idea to build the types manually
```javascript
export type Price = {
  productId: string;
  id: string;
  status? : 'active' | 'archived';
  name: string;
  duration?: number;
  created: string;
  updated: string;
  product?: Product;
}

export type Product = {
  id: string;
  productId: string;
  status?: 'draft' | 'published' | 'archived';
  name: string;
  created: string;
  updated: string;
  paymentOffer?: PaymentOffer;
};
``` ",,
1895535313,2735,[Question] How to describe a RegExp object?,"So I'm building a config schema for my tool, and I'd like it to have a regex option for pattern matching.

This is the type I'm trying to get from Zod schema:

```typescript
interface Config {
  ...

  exclude: (string | RegExp)[]

  ...
}
```

I'm using Zod for like two days now, so my experience with it is near zero. My google searches did not return any meaningful results for my usecase, so help would be appreciated",,
1894859759,2734,"Properties with Symbol keys are stripped from objects, even with passthrough()","TL;DR Properties with symbol keys are stripped from objects regardless of the object shape.  

`ZodRawShape` is defined as `[k: string]: ZodTypeAny` but according to Typescript rules, this [does not mean that a passed object should only have string keys](https://github.com/microsoft/TypeScript/issues/53265).  I think this is why Zod allows the object shape but then doesn't handle the presence of Symbol keys.

Therefore there should probably, at least, be a runtime exception to indicate that they are not handled.

```ts
const bar = Symbol('bar')

const Schema = z.object({
  foo: z.string(),
  [bar]: z.string()
})

const input: z.infer<typeof Schema> = {
  foo: 'foo',
  [bar]: 'bar',
}

const output = Schema.parse(input)
```

Results in:

```js
{
  foo: 'foo'
}
```

It seems that symbol keys are ignored in the object specification, as `z.string().default('bar')` also does not result in there being a property for `Symbol(bar)` with value `bar` in the output.

This also happens if the symbol property is included or omitted, and the schema has `.passthrough()` added.
",,
1894771510,2733,Question: is it possible to create a schema for a recursive structure that also use generic parameter?,"Is it possible to create a zod schema for the following type?
```ts
export interface GroupItem<T> {
  key: unknown;
  items: GroupItem<T>[] | T[] | null;
  count?: number;
  summary?: unknown[];
}
```

I cannot wrap my head around how to define the ""items"" property with zod.",,
1893922060,2732,Unable to create an object with readonly property,"Possibly related to #728, but without the need for recursive application to the object properties. 

```
z.object({
  id: z.string().readonly(),
  description: z.string(),
})
```

As of Zod 3.22.2, syntactically this is acceptable, but based on the description of `readonly()` it probably should not apply to primitive types).  The resulting type drops the `readonly` and gives `{ id: string, description: string }`.

I also tried an intersection of objects:

```
z.intersection(
  z.object({ id: z.string() }).readonly(),
  z.object({ description: z.string() })
)
```

But this oddly gives `{ id: any, description: string }`, thus losing both the type and the `readonly` protection.

In my application, I have entities where the ID should not be changed (storage requires the old entity to be deleted and one with a new identity created).  Zod is preventing me from creating a schema that enforces this.

The only way I can figure out how to set the `id` to be readonly is to cast the return type from `parse`, e.g:

```
schema.parse(input) as (z.infer<typeof schema> & { readonly deviceId: string })
```

or to create a type from the schema with a similar union:

```
type X = z.infer<typeof schema> & { readonly deviceId: string }
```

which seems like a total fudge.


",,
1893799898,2730,Handling the Race Problem,"No, not that one.

I have a frustrating issue that I always come back to and attempt to solve differently. But with Zod being my primary validator, I want to see if there are better ways to handle it.

Most forms will require multiple calls to a DB for validations of some sort. E.g., updating an email (checking to see if it's available, been used before, etc.). But I also want to keep uniformity throughout my error handling - which currently leads me to most commonly mock the `ZodIssue` and return a similar error for the front end. But that seems redundant - but unavoidable without a way to kill the Zod validator mid-process and just return whatever errors have currently been found.

Does Zod process all the fields in parallel or does it execute them one after another? The refinements seem to run in order - as the fatal flag can break a `superRefine`. 

Ideally, I'd love to be able to run those additional validation steps (even though it's validating the entry against DB queries, not just syntax) within the validator - because it would allow a seamless transition for the front end, and make the leg-work on the backend much more concise.

I know it can be done a few different ways, but right now, if I'm updating an email in a profile for example I have to:

1. Validate the email string
2. Check if the email is the same
3*. If not, Verify the email is not being used by other users
4*. If not, , Service the new pending change

Steps 2 and 3 and 4 can be handled in a `superRefine`, but if one fails, it's not going to stop the rest of the validation process. Which leaves every other field to be validated with possible refinements as well (possible additional unnecessary DB queries). If we can flag an abort option on fail - it would save any future refinements from running - leaving the DB untouched. And it's because the _validation_ is of the email field. So for the front-end response, it's nothing but a field error.

As it is, it's not ideal to use the superRefine with any DB data, because there's no way to control it's use throughout the process. So I would run steps 2 and 3 and 4 _after_ the validation, and mock the errors to the 'email' path so the front end gets an accurate error response. I agree Zod should flag any and everything by default, but a simple abort flag could save massive amounts of time and power, and allow form error handling to stay uniform instead of requiring a mock to handle the issues. 
",,
1893497561,2729,How to workaround type export when schema is defined inside the component (blocked scope)?,"Imagine this case:

Is there any smooth way to workaround this? I believe this is a common case, how can I export the type for other modules to use?

```tsx
const MyComponent = (): JSX.Element => {
  type SchemaType = z.output<typeof schema> // âš ï¸I can only define it here because the schema is block-scoped

  const { data: existingEmails } = useQuery(...) // fetch data dynamically

  // Schema can only be defined here due to usage of scoped variable existingEmails in the schema
  const schema = z.object({
    email: z.string().email()
      .refine(val => !existingEmails.includes(val))
  })

  return <div>...</div>
}

export type { SchemaType } // âš ï¸This won't work due to SchemaType is block-scoped
```",,
1891599266,2728,Exclude deno build from source control,"It's great to have the scripts to build for `deno`, though I feel that build should be excluded from the source control here.
- The `deno` build here bloat the repo
- The existing [zod-deno](https://github.com/colinhacks/zod-deno) repo does the job well

Therefore I submitted PR #2727  to address it.

Open to hear why it was included though.",,
1890832077,2726,[Question/Help Needed] Can you infer a generic ZodObject from a generic ZodRawShape in an interface?,"ðŸ‘‹  Hello! 

I have an interface that looks like this (I'm on TypeScript v4.9.5):

```ts
import { z } from 'zod';

export interface Endpoint<T extends z.ZodRawShape> {
  args?: (schemaTypes: typeof z) => T;
  fx: {
    (
      ctx: Context<
        ReturnType<typeof z.object<ReturnType<Required<Endpoint<T>>['args']>>>
      >,
      next?: any
    ): any;
  };
}
```

Here's an example of its usage:
```ts
return {
  args({ string }) {
    return {
      email: string().email(),
      password: string().min(8),
    };
  },
  fx(ctx, next) {
    const { email, password } = ctx.requestContext.args;
    // ...
  },
};
```

^ It represents an endpoint that is encapsulated in an object and is handled by the `fx` key. The arguments *for* that endpoint come from the `args` key.

Now here's what `Context` looks like:

```ts
interface Context<T extends z.ZodTypeAny = any> {
  requestContext: {
    args: z.infer<T>;
  };
}
```

`ctx.requestContext.args` is being inferred as:
```ts
RequestContext<ZodObject<any, ""strip"", ZodTypeAny, { [x: string]: any; }, { [x: string]: any; }>>.args: {
  [x: string]: any;
}
```

So when I hover over the `email` or `password` keys, their type is `any`. Is there a way to dynamically infer their type?


Thank you for your help ðŸ˜ƒ ",,
1890450642,2725,Provide string-specific validation for iso8601 periods (durations) ,"Similar to the string-specific validation for [datetime](https://zod.dev/?id=iso-datetimes), maybe consider adding one for [iso8601 periods](https://en.wikipedia.org/wiki/ISO_8601#Durations), possibly called `.duration()` or `.period()`

Some references that might be relevant for a discussion:
* https://tc39.es/proposal-temporal/docs/duration.html
* https://momentjs.com/docs/#/durations/as-iso-string/",,
1889789458,2724,wrap internal errors from `preprocess` and `refine`,"As [explained here](https://github.com/colinhacks/zod/issues/2401) zod intentionally does not catch errors from within `preprocess` and `refine`.

> This is behaving as intended currently. An error in a refinement is considered an application-level bug, not a validation error. The thinking is that catching this error in Zod would make it harder to debug actual real-life bugs, and you can always use try/catch. But if Zod catches these errors, there's no way to opt-out of this and allow errors to bubble up.

However, consider this schema:
```typescript
z.object({ a: z.array(z.object({ b: z.preprocess(data => { throw new Error('asdf') }, z.date()) }))}).parse({a: [{}]})
```
The error will be:
```
Uncaught Error: asdf
    at Object.transform (REPL12:1:66)
    at ZodEffects._parse (/node_modules/zod/lib/types.js:2137:38)
    at ZodObject._parse (/node_modules/zod/lib/types.js:1070:37)
    at ZodObject._parseSync (/node_modules/zod/lib/types.js:109:29)
```

This makes it difficult to know where the error came from.
Consider an object schema with many properties (that may also be nested) - if I get this error I don't know which property caused it.

In contrast, the regular zod parsing errors are amazing:
```typescript
z.object({ a: z.array(z.object({ b: z.date()})) }).parse({a: [{}]})
```
Error:
```json
[
  {
    ""code"": ""invalid_type"",
    ""expected"": ""date"",
    ""received"": ""undefined"",
    ""path"": [
      ""a"",
      0,
      ""b""
    ],
    ""message"": ""Required""
  }
]
```
It tells me exactly the path to the problem in my object.

### Proposed solution
I propose that zod will catch my internal error and wrap it in a zod error (and re-throw it) that will at least tell me where the error occurred in the object.

For example something like:
```typescript
z.object({ a: z.array(z.object({ b: z.preprocess(data => { throw new Error('asdf') }, z.date()) }))}).parse({a: [{}]})
```
Expected error:
```json
[
  {
    ""code"": ""preprocess_error"",
    ""path"": [
      ""a"",
      0,
      ""b""
    ],
    ""message"": ""Uncaught Error: asdf"",
    ""originalError"": <the original error object>
  }
]
```",,
1887360746,2721,Is there another good way to avoid checking for hidden elements at submitting?,"When using useForm,I'd like to use a specific check rule based on the page element being shown and hidden, but I can't move forward with this error,or is there another good way to avoid checking for hidden elements at submitting,How to make `shouldUnregister` take effect in zod?

<img width=""627"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/105040671/d480330b-7320-4db5-9bf9-1219e94a2da2"">
Error:There should be 3 parameters, but getting 1,types.d.ts(13, 74): no independent variable for ""context"" provided.
<img width=""611"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/105040671/8941bc0c-5df2-4596-8a7d-ce6ef923a96a"">
",,
1886094777,2718,Update to Custom Schemas example in Documentation,"Hi, 

I'm interested in updating the Custom Schemas example in the documentation.  The function type takes in an unknown, so the example casts the value to a string in order to operate on it with a RegExp

```typescript
const px = z.custom<`${number}px`>((val) => {
  return /^\d+px$/.test(val as string);
});
```

I want to propose using Type Narrowing. It's helped me catch errors from validating a non-expected type, and I believe it would help others as well as a good practice with interacting with the unknown type.

```typescript
const px = z.custom<`${number}px`>((val) => {
  return typeof val === ""string"" ? /^\d+px$/.test(val) : false;
});
```

Please let me know if this is a welcome change.  I can make a fork of the repo and create a PR!",,
1884416613,2715,Zod schema.parse method return Partial object (every field is nullable) in nestjs app,"Suppose a user schema as follows
```js
import { z } from ""zod"";

const UserSchema = z.object({
  name: z.string(),
});

type User = z.infer<typeof UserSchema>;
```

Here type **User** is equivalent to

```js
type User = {
    name?: string;
}
```

instead of 
```js
type User = {
    name: string;
}
```

What is wrong with zod here, I want name field to be non nullable but it is not here? It works pretty much fine on both simple **nodejs app** and **deno**, but it does not work in **nestjs** app.

## Steps to reproduce

1. Create a new nest app
```terminal
nest nest testzod
```

2. create a schema file with user schema
```js 
import { z } from ""zod"";

const UserSchema = z.object({
  name: z.string(),
});

type User = z.infer<typeof UserSchema>;
```

3. Check it

 ",,
1881934894,2710,Add a zod.dev/playground,"There should be a playground for testing out zod schema right in the documentation without having to run code to check if the schema is working as intended.

This would make it much more straightforward to validate the schema or test different behaviors of the schema.

Just like the Joi sandbox: https://joi.dev/tester/",,
1881627557,2709,isDirty error,"When i click on input then isDirty is still 'false', but if i don't type nothing, and click away or on the other input, then isDirty is 'true'.

I think is not issue with blank char '\n' is leave in input, but this shouldn't work that way.

On first click, everythink works well:
![Screenshot 2023-09-05 at 11 51 54](https://github.com/colinhacks/zod/assets/64608510/6eecdf30-8826-4e3d-a512-7d9f7df3a5d4)

But on second focus(When i click away, and here one more time):
![Screenshot 2023-09-05 at 11 52 15](https://github.com/colinhacks/zod/assets/64608510/689c3a1a-c494-4f87-919c-ca2ca3980024)

",,
1879103283,2706,Regex not working as expected,"I'm trying to add a validator to ensure keys of records are written in camel case. The regex works as expected when used directly, but within the schema parser, it doesn't behave the same.

I wrote a test to illustrate.

```ts
import { z } from 'zod'

const REG = /^[a-z]([A-Za-z0-9]+)$/

const schema = z.record(
  z.string(),
  z.string().regex(REG, 'Key must be camelCase'))

describe('Zod Regex', () => {

  // Valid camelCase strings

  it('should idenfify valid camelCase strings directly', () => {
    expect(REG.test('camelCase')).toBe(true)
    expect(REG.test('camel')).toBe(true)
    expect(REG.test('camelCaseId')).toBe(true)
    expect(REG.test('camelCaseID')).toBe(true)
  })

  it('should parse zod record with valid camelCase keys', () => {
    expect(() => schema.parse({ camelCase: 'value' })).not.toThrow()
    expect(() => schema.parse({ camel: 'value' })).not.toThrow()
    expect(() => schema.parse({ camelCaseId: 'value' })).not.toThrow()
    expect(() => schema.parse({ camelCaseID: 'value' })).not.toThrow()
  })

  // Invalid camelCase strings

  it('should idenfify invalid camelCase strings directly', () => {
    expect(REG.test('CamelCase')).toBe(false)
    expect(REG.test('camel_Case')).toBe(false)
    expect(REG.test('camelCase_')).toBe(false)
    expect(REG.test('CAMEL_CASE')).toBe(false)
    expect(REG.test('_camelCase')).toBe(false)
  })

  it('should throw error when parsing zod record with invalid camelCase keys', () => {
    expect(() => schema.parse({ CamelCase: 'value' })).toThrow()
    expect(() => schema.parse({ camel_case: 'value' })).toThrow()
    expect(() => schema.parse({ camelCase_: 'value' })).toThrow()
    expect(() => schema.parse({ CAMEL_CASE: 'value' })).toThrow()
    expect(() => schema.parse({ _camelCase: 'value' })).toThrow()
  })
})
```

The test fails during the first expect of the last test:
```
expect(() => schema.parse({ CamelCase: 'value' })).toThrow()
```

Am I using it the wrong way? I know with the `record` type, values go first, opposite of how TS generics work. I've tried it both ways just to be sure.

Using the latest version of Zod `3.22.2`, and Node `16.14.2`, but the same results under different node versions 18 and 20.
",,
1877964397,2702,Distinguish between z.record key and value errors.,"Is there a way to distinguish between z.record key and value errors?
They both result in the same issue.path.
However, I need to find a way to know if the error was the key or the value of the record value.

Example: 
```js
const schema = z.record(z.string(), z.string()).parse()

// Both errors will not show a difference between the two.
schema.parse({ 1: ""abc"" })
schema.parse({ ""abs"": 1 })
```
",,
1877297853,2699,"zod instance use with Generics ,defalut method prompt error","```ts
let a1 = z.object({});
let b1 = z
  .object({ b: (a1 as typeof a1).deepPartial().optional() })
  .default({});
let b2 = z.object({ b: a1.optional() }).default({});

function run<T extends typeof a1>(input: T) {
// default params error
  let b3 = z.object({ b: input.optional() }).default({});
}

```
When `T extends typeof xxx` ,the input value `default` method params prompt error
![image](https://github.com/colinhacks/zod/assets/9607121/aa0d178c-8a1e-4863-8609-7452fc6831bd)
![image](https://github.com/colinhacks/zod/assets/9607121/be9fe6eb-8f0a-4c8d-bc86-7f207ad50993)
",,
1876421029,2698,Skypack error on 3.19+,"Perhaps related to https://github.com/colinhacks/zod/issues/965 although it's a different error message.

Importing zod@3.18 and earlier works fine: https://codepen.io/luisfarzati/pen/RwERpMg

Importing zod@3.19 and newer fails, the console shows:

```
""[Package Error] 'zod@v3.19.0' could not be built. 
[1/5] Verifying package is validâ€¦
[2/5] Installing dependencies from npmâ€¦
[3/5] Building package using esinstallâ€¦
Running esinstall...
Cannot find module 'zod/locales/en.d.ts'""
```

https://codepen.io/luisfarzati/pen/rNoLyrB
",,
1875953739,2697,Zod 3.22.2 TS 5.2.2: TS2589: Type instantiation is excessively deep and possibly infinite,"```ts
const EventSchema = z.union([
  z.object({
    action: z.enum(['create', 'drop', 'update', 'hydrate']),
  }),
  z.object({
    action: z.literal('rollback'),
    tag: z.string().optional().default('initialState'),
  }),
]);
```

Error: ` src/handler.ts(64,3): error TS2589: Type instantiation is excessively deep and possibly infinite` 

Related  (both closed): #495 and #577 

Tried rimraf node modules and reinstalling. That type seems so simple that I don't see what I can do to simplify it. 

Is there a playground that I can pull Zod into to reproduce it? ",,
1875628009,2696,Extract the inferred type is not working as expected,"In documentation says that we can infer the type from a schema like this:

![image](https://github.com/colinhacks/zod/assets/32942055/f4152ac1-d07d-45a4-834d-04ff9b412ae7)

But when I try this with the example above, I was expecting attributes required by default and optional only for those I set as optional...
```
import { z } from 'zod';

export const createDiscountCouponSchema = z.object({
  accountId: z.number().optional(),
  coupon: z.string(),
  additionalDiscount: z.number(),
  expirationDate: z.date(),
  status: z.string(),
  campaign: z.string().optional(),
});

export type CreateDiscountCouponDto = z.infer<
  typeof createDiscountCouponSchema
>;
```

however, I'm receiving all attributes as optionals, 

![image](https://github.com/colinhacks/zod/assets/32942055/0a3ee60e-26f6-46e2-93bd-f265872bdb0f)

is that right?

I'm using zod ```3.22.2``` and typescript ```5.0.3```",,
1873867184,2694,Parse query string as object before validation,"I am building a custom filtering system where I make use of the query parameters so like this:
http://example.api/stufftoget?filter={""name"":""nameofstuff"",""prices"":[2,3,4,5]}

But i cant seem to find a way to create a zod schema to transform this in an object. 
Tried preprocess, transform (I now know that the transform happens after).

I read about coerce which was promising but didnt have a object type only string,bool,number.

I could put it as string and then json parse later but that defeats the whole point of using zod.

So am i missing something?  or is this not (yet) possible.

I read through the issues as well as the documentation and stack overflow posts

",,
1872210362,2693,Will do. ..,,,
1870070988,2691,How to make ZodUnion from a enum?,"Imagine we have an API where some types are list of options. It can be done via enums, arrays or objects. Here's a enum example:

```ts
enum color {
  red = ""red"",
  green = ""green"",
};
```

Imagine also, that we have to validate user input. Using Zod we can create a schema:

```ts
const colorSchema = z.union([z.literal(""red""), z.literal(""green"")])
```

and then use it for validation:

```ts
const color = colorSchema.parse(userInput)
      //^? color: ""red"" | ""green""
```

The problem with this approach is that we're breaking the DRY principle: we have to repeat every value from every enum from the API, which brings even bigger problem with keeping it up to date. If a new color gets added to the enum, how will our schema know about it? There is no way. So the only solid way to do it, is to convert **enums to z.unions**.

However, I couldn't figure out how to do this.
`z.union()` accepts an array of literals, but I cannot find a solution how to create `ZodUnion` from a enum. 

Here are a couple of sandboxes, that differ only in the way how options are defined:
- [using enum](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFA9NXAIIAKAkgFxwDuApnABYCGANx4BnXDybNOvYAGNecKFxgBXKADsRcGLy4guWgEYBPOLIgAbaHGDERVLupV5zVqIgpxFXYnAC8BEqkADSecADmSo7+BJFcjvihaJQwxmA8AMKW0My+AQDWXMYQmNppXCVm2VBUqelwACq6+gBKXACOKgbwAQhhrjnE7FluuZTJVMRcshb8Slgq6rIwwBDqEcpNelz0YMAAFErt7FutHV0iMACU7PzqxpQ0dADKGQASAKIAsvTshirwbhwdTxHzaCBwQT8Cy2fgwHgqERcdzAdRgAFwfbYXBmGFYaxcAAe-HAFi4Nyo5k08AGUDanW6z3ken4MWQADoIIYAFbTGD7PpeWm5dgcxardT7ADaHJh8Kg0P2+CC+CuwRQ7LlyMV+DiCSuAF01XBaHAAFQWihoK6PU0AVWe9AA4h92GSYAByLQcKDAeFwMT6KpTKiYRbLCUbGCnLj7YVDAMwX3qcJXDxCtaXbwMrMBWn0i4wJnNfjssBzJECqqjXzWyheBsN2gAPQA-GFwptmjs9odzt0bVaKEA)
-  [using object](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFA9NXAIIAKAkgFxwDuApnABYCGANx4BnXDybNOvYAGNecKFxgBXKADsRcGLy4guWgEYBPOLIgAbaHGDERVc5vjmrUOAF5EFOIq7F2+EqkADTecADmSlzqAZFc0fihGPxajiIwlDDGYDwAwpbQzMQecAAUWTkQmGYFUACUANoA1lzGVdrZXO0u0AC6lBQVPAAquvoASlwAjioG8J4IYT1QRez5rkWUaAPEXLIW-EpYKuqyMMAQ6hHKo3pc9GDApUpT7LcT07Ppdez86sYDWhwADKuQAEgBRACy9HYhhU8G4cHU8T82ggcEE-Astn4MB4KhEXDcwHUYARZWwuDMOKw1i4AA9+OALFwfg5Lukaq5JjM5sD5Hp+CVkAA6CCGABWexgpUWPmWqxQopOF3UpQaYpx+Kg2NKgT8+DqwWV2uJevwcQSdV6xrgQIAVE6KGg6oC6ABVYH0ADiEPYrJgAHItBwoMB8XAxPoarsqJgTmc1dcYO8uKVFf4ozBw+pwnUvArOfAXl95tzoLyywKxvxRWBDkS5RWVsVXZQfJ3O7QAHoAfjC4RuY3uj2enzmbpdFCAA)

Check out the `***`-marked lines.




",,
1869457393,2689,`string().array().or(record(any()))` as key in `object()` has wrong type,"Works fine:
```ts
const test = string().array().or(record(string()));
type Test = z.infer<typeof test> // string[] | Record<string, string>
```

Don't work:
```ts
const test = object({ values: string().array().or(record(string())) });
type Test = z.infer<typeof test>; // { values: (string[] | Record<string, string>) & (string[] | Record<string, string> | undefined); }
```",,
1869319480,2688,Is there any way to pick/omit array of object,"const schema = z.array(z.object({ name: z.string(), address: z.string() }));

const newSchema = schme.pick({ address: true })

i want to pick just `address`, is possible?",,
1869062588,2687,Preprocessing hides errors in zod 3.22.x,"Consider this piece of code:

```typescript
import { z } from ""zod"";

const zodStringWithPreprocess =
  // Notice that in this simplified example, the preprocessing does nothing
  z.preprocess((val) => val, z.string()) as z.ZodEffects<
    z.ZodString,
    string,
    string
  >;

const validatorWithoutPreprocess = z.object({
  name: z.string(),
  town: z.string(),
});

const validatorWithPreprocess = z.object({
  name: zodStringWithPreprocess,
  town: zodStringWithPreprocess,
});

const dataToValidate = {};

const parsedWithoutPreprocess =
  validatorWithoutPreprocess.safeParse(dataToValidate);
console.log(""Without preprocess"");
console.log(JSON.stringify(parsedWithoutPreprocess, null, 2));

const parsedWithPreprocess = validatorWithPreprocess.safeParse(dataToValidate);
console.log(""With preprocess"");
console.log(JSON.stringify(parsedWithPreprocess, null, 2));
```

# Expected behavior


In Zod 3.21.4, the result is the same regardless of preprocessing:

```
Without preprocess
{
  ""success"": false,
  ""error"": {
    ""issues"": [
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""name""
        ],
        ""message"": ""Required""
      },
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""town""
        ],
        ""message"": ""Required""
      }
    ],
    ""name"": ""ZodError""
  }
}
With preprocess
{
  ""success"": false,
  ""error"": {
    ""issues"": [
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""name""
        ],
        ""message"": ""Required""
      },
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""town""
        ],
        ""message"": ""Required""
      }
    ],
    ""name"": ""ZodError""
  }
}
```

# Actual behavior

In Zod 3.22.x (x <= 2), the version with preprocessing stops at the first error:

```text
Without preprocess
{
  ""success"": false,
  ""error"": {
    ""issues"": [
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""name""
        ],
        ""message"": ""Required""
      },
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""town""
        ],
        ""message"": ""Required""
      }
    ],
    ""name"": ""ZodError""
  }
}
With preprocess
{
  ""success"": false,
  ""error"": {
    ""issues"": [
      {
        ""code"": ""invalid_type"",
        ""expected"": ""string"",
        ""received"": ""undefined"",
        ""path"": [
          ""name""
        ],
        ""message"": ""Required""
      }
    ],
    ""name"": ""ZodError""
  }
}
```

Notice that the `""expected"": ""string"",` for the `town` property is missing.

It seems to be a regression for Zod.",,
1868451385,2686,Allow number in enums,"It would be helpful to allow numbered enums such as in this example

```typescript
const userMap = {
  1: { name: ""John"" },
  2: { name: ""Bob"" },
};

const ids = Object.keys(prices).map(Number) as [keyof typeof prices];
const idSchema = z.enum(ids);
```

While `""${number}""` could be used to index the userMap, if this were a network request, it would annoyingly also cause the request to format the numbers into strings. Respectively, I think there are valid use-cases where a numbered enum can be helpful.",,
1867979627,2685,"Appetite for `xor` method (like `joi`) to require one of a set of object keys, but never together","Unless I'm mistaken, a simple helper method for the functionality of `xor` (exclusive or) does not exist for `zod`. 

The definition of `xor` would be:

`Provide one of these N keys, but never together`

Instead, all I can find is the recommended use of a chained `.refine()`:

```javascript
z.object(...)
  .refine(args =>
    !(args.val1 !== undefined && args.val2 !== undefined),
  { message: 'val1 and val2 cannot be provided together' },
  )
  .refine(args =>
    args.val1 === undefined && args.val2 === undefined,
  { message: 'one of val1 or val2 must be provided' },
  );
```

Is there opposition about introducing such a helper method?

I find it very cumbersome to write the refine logic and it's also a bore to read.",,
1864514334,2684,Add a `text` validation for multiline?,"**The problem:** 

As per [html spec](#ref), the new lines of a text area are normalized to \n in browser and \r\n when the form is sent. So a simple count in characters will yield inconsistent length between browser and server. 

This inconsistency is inevitable (it's cross browser as part of the html spec) and only concerns new lines so the validation of textarea elements. 

So one cannot validate a textarea with a `maxlength` in browser and the `max` validation in the schema (if there are new lines). This also impacts libraries trying to use a zod schema as single source of truth https://github.com/ciscoheat/sveltekit-superforms/issues/253

**Workaround**

- Use a `refine` instead of a `max` like

```js
const schema = z.object({
	name: z.string().default('Bob'),
	email: z.string().email().optional(),
	// bio: z.string().max(5) // this won't work with new lines
	bio: z.string().refine(
	    (str) =>  str.length - (str.match(/\r\n/g) ?? []).length <= 5,
	     { message: 'Bio too long' }
	) // One has to take into account the \r characters added by the new line normalization, as per html specs
});
```

- Alternatively use a `transform`:

```js
const normalize = (text: string) => text.replaceAll('\r\n', '\n');

const schema = z.object({
	name: z.string().default('Bob'),
	email: z.string().email().optional(),
	bio: z.string().transform(normalize).pipe(z.string().max(5)) 
});
```

But both solutions add some boilerplate for every `maxlength` on a textarea.

**Suggested solution:**

Maybe a `text` validation could be useful. It would be like `string` but would implement `max` to prevent the browser/server inconsistency? Or a `multiline` option to adapt the `string` validation behavior?

**<span id=""ref"">Refs</span>**

> For historical reasons, the element's value is normalized in three different ways for three different purposes. The raw value is the value as it was originally set. It is not normalized. The API value is the value used in the value IDL attribute, textLength IDL attribute, and by the maxlength and minlength content attributes. It is normalized so that line breaks use U+000A LINE FEED (LF) characters. Finally, there is the value, as used in form submission and other processing models in this specification. It is normalized as for the API value, and in addition, if necessary given the element's wrap attribute, additional line breaks are inserted to wrap the text at the given width.

https://html.spec.whatwg.org/multipage/form-elements.html#the-textarea-element

> As with all MIME transmissions, ""CR LF"" (i.e., `%0D%0A') is used to separate lines of data.

https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4
",,
1863027292,2682,Limit valid schema types to things that come from strings,"I think this relates to #2421 and #2519 but I'm filing it separately because I'm not using `z.input` in any way.

I am looking to write a generic function for parsing data, which I know comes in the general form of:

```ts
{
  [K: string]: string | string[] | undefined
}
```

Some of those strings are of course other things, that I want to parse and transform. And so I'm trying to set up a generic function to validate that shape and do type coercion into a more useful shape. Where I want to limit the list of valid values to parsing functions that accept a string as input.

```ts
type ObjectSchema = Record<string, ObjectValue>
// Value must be optional or defaulted, let's flag our future parse error as a type error
type ObjectValue = z.ZodOptional<Inner1> | z.ZodDefault<Inner1>
// Value can either be a primitive or an array of primitives
type Inner1 = Inner2 | z.ZodArray<Inner2>
// Anything we can coerce from a string is fine
type Inner2 = z.ZodType<any, z.ZodTypeDef, string>

const objectSchema: ObjectSchema = {
  // arg0: z.string(), // Type Error, as expected
  arg1: z.string().optional(),
  arg2: z.string().default(""""),
  arg3: z.coerce.number().default(0), // Type Error, is z.ZodNumber, knows nothing of its input type
  arg4: z.string().transform(val => parseInt(val, 10)).optional(), // Works, but not as pretty as the new syntax
  arg5: z.string().array().default([]),
}

type OutputType<T extends ObjectSchema> = z.infer<z.ZodObject<T>>

typeof OutputType<typeof objectSchema> = {
    arg1: string | undefined;
    arg2: string;
    arg3: number; // if it could be included
    arg4: number | undefined;
    arg5: string[];
}
```

I couldn't see anything obvious I could latch onto here to make this work using the new coerce options.",,
1861566286,2678,Default not applied for transform with default,"I've created a transform to perform string coercion without the default zod string coercion that turns null and undefined values into ""null"" and ""undefined"":
```
export const CoerceString = z
  .any()
  .transform((val) => val?.toString())
  .pipe(z.string());
```
When I define an object using this with a default value the default isn't applied, instead the mock has `undefined` as the value:
```
const MyType = z.object({
  a: CoerceString.default(""""),
});
```
In the VSCode debugger I see the value of ""a"" in MyType as ZodDefault, but the mock generator isn't picking up on that.",,
1861378270,2677,zod.preprocess v3.22.2 issues are ignored in case of another error in the model,"Another issue we found in v3.22.2 is that the schema inside `preprocess` either isn't executed or doesn't add issues to the context in case the model being parsed contains an error in another field (`nonNullableObject` below):
```ts
import * as zod from 'zod';

const wrapToArray = <T extends zod.ZodTypeAny>(elementSchema: T) =>
  zod.preprocess((val) => [val], zod.array(elementSchema));

const singleItemSchema = zod.object({
  quantity: zod.number(),
});

const itemsStepSchema = zod.object({
  nonNullableObject: zod.object({}),
  items: wrapToArray(singleItemSchema), // swapping this line with the one below results in correct behaviour (2 issues instead of 1)
  // items: singleItemSchema,       
});

const res = itemsStepSchema.safeParse({
  nonNullableObject: null,
  items: {},
});

//@ts-ignore
console.log(res.error.issues.length);  // 3.21 shows 2 errors, 3.22 - only 1
console.log(res);
```
An error in `nonNullableObject` hides the `preprocess` errors. Also, if I remove the `preprocess` call completely the behaviour becomes correct. This doesn't look right as preprocess stops errors from being populated.
[3.21.4](https://codesandbox.io/s/jolly-yalow-3k6lyg?file=/src/index.ts):
<img width=""404"" alt=""Screenshot 2023-08-21 at 19 06 17"" src=""https://github.com/colinhacks/zod/assets/32125472/fa6c0a7e-ec18-43b9-9b9d-f95e15b44b7a"">

[3.22.2](https://stackblitz.com/edit/typescript-aejujt?file=index.ts):
<img width=""274"" alt=""Screenshot 2023-08-21 at 19 05 12"" src=""https://github.com/colinhacks/zod/assets/32125472/3a241228-08f1-4ee7-9fcf-7d26c368bad9"">",,
1860201512,2674,z.nativeClass(MyClass),"# Problem
Zod solves typing very well, but due to our stack, we have trouble integrating Zod with our existing class-based deserializer code (due to using NestJS default scaffolding).  We need a way to break out of the class-based typing into Zod, implementing the ""strangler pattern"".

# Solution
Implement a schema `z.nativeClass(MyClass)` with similar pattern to `z.nativeEnum(MyEnum)` that reflects out the structure of `MyClass` and ensures that parsed values have compatible shape to `MyClass`.

Note that unlike `z.instanceOf(MyClass)`, `z.nativeClass(MyClass)` does not validate the inheritance change; this is because TypeScript already does not provide this guarantee and therefore it is not typically helpful to assume a class-typed value has a correct inheritance chain. Further, I would expect the schema to be composed with other Object schema methods which would definitely not have a preserved inheritance chain.",,
1859355405,2671,The result of zod.preprocess v3.22.2 is ignored and falls back to the original value inside a further refine,"This code is on [sandbox](https://stackblitz.com/edit/typescript-olfm9s?file=index.ts). We noticed this behaviour in v3.22.2.
```ts
const schema = zod
  .object({
    inactiveObject: zod
      .object({
        isInactive: zod.boolean(),
      })
      .refine(
        ({ isInactive }) => isInactive === false, // <-- This refine fails leading to the preprocess below to be ignored
        { message: 'object is inactive' }
      ),
    arr: zod.preprocess((val) => [val], zod.array(zod.object({}))), // <-- The result of this code is ignored, `arr` remains `val` in the refine below
  })
  .refine(({ arr }) => arr.some((elem) => elem !== null)); // arr.some is not a function

schema.safeParse({
  inactiveObject: {
    isInactive: true,
  },
  arr: {},
});
```
I debugged the code and it turns out the bug occurs [here](https://github.com/colinhacks/zod/blob/792b3ef0d41c144cd10641c6966b98dae1222d82/src/types.ts#L4276):
```ts
if (effect.type === ""preprocess"") {
  const processed = effect.transform(ctx.data, checkCtx);
  if (ctx.common.issues.length) {
      return {
          status: ""dirty"",
          value: ctx.data
      };
  }
...
```
-- the result of `transform` is ignored. This condition was absent in v.3.21.4 which worked fine for the usecase above.",,
1857689461,2669,"Zod Docs, Can we redesign the whole docs.",Considering UI/UX it's not that much good to read and travel through it. ,,
1855322771,2665,Signature of superRefine() changed from zod@3.21 to zod@3.22,"With `zod@3.21` the following code was valid:

```
import { z } from ""zod"";

const schema = z.object({
  name: z.string(),
  value: z.string(),
});

const schemaRefine = schema.superRefine((val, _ctx) => {
  return val.value !== 'INVALID';
});
```

After upgrading to `zod@3.22` we are seeing the following typescript error:

```
Type 'boolean' is not assignable to type 'void | Promise<void>'.
```
",,
1854772228,2664,`z.preprocess` ignores `.optional()` modifier,"zod version: 3.17.3

code:
```typescript
const schema = z.preprocess(data => data === '' ? undefined : data, z.number()).optional();

schema.parse(undefined) // works, returns undefined
schema.parse('') // throws
```

However, this works:
```typescript
const schema = z.preprocess(data => data === '' ? undefined : data, z.number().optional());
schema.parse(undefined) // works, returns undefined
schema.parse('') // works, returns undefined
```

I would expect the first schema to behave the same as the second schema.",,
1853756839,2663,"TypeError: Not assignable to parameter of type ZodType<any, any, any>","I've created this `schema` to use in `React Hook Form`, but I'm getting an error that I'm not sure how to fix.

```
import { z } from 'zod';

export const schema = z.object({
  email_domains: z.string().min(1, { message: 'At least one domain is required' }),
  add_to_groups: z.string(),
  expires_at: z.string(),
  language: z.string(),
  name: z.string().min(1),
});

export type FormValuesType = z.infer<typeof schema>;
```

```
import { zodResolver } from '@hookform/resolvers/zod';
import { FormProvider, useForm } from 'react-hook-form';

import { defaultExpiresAt, defaultName } from '@/lib/invite-links';

import {
  FormValuesType,
  schema,
} from '@/components/InviteLinkCreatePage/schema';

export default function Form() {
  const methods = useForm<FormValuesType>({
    resolver: zodResolver(schema),
    values: {
      email_domains: '',
      add_to_groups: '',
      expires_at: defaultExpiresAt(),
      language: '',
      name: defaultName(),
    },
  });

  const handleSubmit = (data: FormValuesType) => {
    console.log({ data });
  };

  return (
    <FormProvider {...methods}>
      ...
    </FormProvider>
  );
}
```

The error coming back is: 

```
Argument of type 'ZodObject<{ email_domains: ZodString; add_to_groups: ZodString; expires_at: ZodString; language: ZodString; name: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to parameter of type 'ZodType<any, any, any>'.
  The types of 'refine(...)._def.typeName' are incompatible between these types.
    Type 'import(""/Users/ernstoarllano/Sites/dispel/packages/cweb/node_modules/zod/lib/types"").ZodFirstPartyTypeKind.ZodEffects' is not assignable to type 'Zod.ZodFirstPartyTypeKind.ZodEffects'.
      Property 'ZodReadonly' is missing in type 'Zod.ZodFirstPartyTypeKind'.
```",,
1853557985,2662,`.describe` does not work on existing object,"The following code works to set the description...
```ts
const obj = z.object({ someString: z.string() })
    .describe(""SET DESCRIPTION TO THIS"");
```
This code does not set the description...
```ts
const obj = z.object({ someString: z.string() });
obj.describe(""SET DESCRIPTION TO THIS"");
```",,
1853451948,2661,Custom message through functional variable,"The required_error / invalid_type_error / message variable now are accepting string where the message will be fixed whenever the variable is initialized.

Having a functional variable here will be helpful following how class-validator works where message can be populated on the fly instead of fixed on initialization.",,
1851590446,2658,Stricter Array Types,"Hey crew!

We rely on [noUncheckedIndexedAccess](https://www.typescriptlang.org/tsconfig#noUncheckedIndexedAccess) on our repos so we rely on nonempty array types.

<img width=""706"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/18017094/334317a6-aab8-4c42-bf07-73a90b1c458b"">

This makes enforcing array type lengths very important.

This proposes enhancements to `min` and `length` checks to create even more accurate types which can work well with `noUncheckedIndexedAccess`.

```ts
z.string().min(3);
// [string, string, string, ...string[]];

z.string().length(3);
// [string, string, string];
```

We could type the following
```ts

type MaxArray<
  T,
  Max extends number,
  Min extends number = 0,
  R extends T[] = Tuple<T, Max>
> = R[""length""] extends Min
  ? Min extends 0
    ? []
    : never
  : R extends [infer U, ...infer V]
  ? U extends undefined
    ? never
    : V extends T[]
    ? R | MaxArray<T, Max, Min, V>
    : never
  : never;

z.string().max(3);
// [] | [string] | [string, string] | [string, string, string];
```

But that would require a little bit of rework to pipe min and max cardinality around and probably isn't all that helpful in general.
 ",,
1850593470,2655,.passthrough() pass through excess nested properties as well,"Appears `.passthrough()` only operates on root properties.

```
import { z } from 'zod';

const schema = z.object({
  first: z.string(),
  details: z.object({
    hair: z.string(),
  }),
});

const myObj = {
  first: 'me',
  last: 'mine',
  details: {
    hair: 'red',
    eyes: 'blue',
  },
};

const res = schema.passthrough().safeParse(myObj);
console.log(res);
```

Actual results
```
{
  success: true,
  data: { first: 'me', details: { hair: 'red' }, last: 'mine' }
}
```

Expected results
```
{
  success: true,
  data: { first: 'me', details: { hair: 'red', eyes: 'blue' }, last: 'mine' }
}
```

Additional functionality which would be very handy, as it relates to nested properties:
1. `.pick()` allow picking and choosing for nested props",,
1850571649,2654,Schema in object being inferred differently (and weirdly),"See the following TS snippet:

```ts
import { z } from ""zod"";

const EventNameSchema = z.string().or(z.array(z.string()));

type EventName = z.infer<typeof EventNameSchema>;
// EventName is string | string[]

const EventSchema = z.object({
  name: z.string().or(z.array(z.string())) // this is the same as the EventNameSchema
});

type EventWithName = z.infer<typeof EventSchema>;
type EventName2 = EventWithName[""name""];
// EventName2 is (string | string[]) & (string | string[] | undefined)
```

And the TS playground: [link](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFAxhAHYDO8AogG4CmdMAcgIYjsAytQAW7ELzgBeFADomUYHQDmACgCUs6KuSzeUKLwCeO+TEUqN69ZQowjYdnDace-JzN1LM7KAB57RwhMZw4uPgFhMQkAPkoAenjQ1winYAY4BSVlOAAfTPNsgG0AXSpaRhYwmCjxSU8tACMAK3ZqGFUECjg4OncALjksy01tXX1DE11htWt1CjQbKkCnFy4AdWAYEVTpOW9fAId2YOSuWtjKFbO3AQAmPbWYTe3Uovw+gXwShKSn1Ie6TgqhmeQKFmUpXUcAAZMDQfkZqUwQBXOjEdiYJTsYjqIA)

I'm not sure if this is intended or a bug or maybe just a user error. Using zod `3.21.4` and TS `4.8.4`",,
1849966118,2653,"Function ""setErrorMap"" Not Overriding Default Mapping","## Issue Title: `setErrorMap` Function Not Overriding Default Mapping

### Description
**Affected Library:** ZOD

**Current Behavior:**
The `setErrorMap` function in the ZOD library, which is intended to allow users to set their own error mappings for different languages, is not functioning as expected. According to the documentation, this function should override the default error mapping with the custom mapping provided by the user.

**Expected Behavior:**
When using the `setErrorMap` function, it is expected that the custom error mapping provided by the user should completely replace the default error mapping. However, in its current state, the library appears to be retaining elements of the default mapping, resulting in unexpected behavior when trying to change the language of error messages.

**Steps to Reproduce:**
1. Initialize the ZOD library.
2. Use the `setErrorMap` function to set a custom error mapping for a specific language.
3. Trigger a validation error in that language.

**Current Outcome:**
Despite setting a custom error mapping using `setErrorMap`, the error messages still contain elements from the default mapping. This makes it difficult to fully customize the error messages for different languages.

**Expected Outcome:**
Upon using `setErrorMap`, the custom error mapping should take precedence over the default mapping, resulting in error messages that are fully customized according to the user's specifications.

### Additional Information
- Version of ZOD Library: ""^3.21.4""
- Browser/Environment: node v16.13.0
- Code Example:
  ```javascript
      const { z } = require(""zod"");
      z.setErrorMap((issue, _ctx) => {
        let message = ""Test"";
        // all errors should be ""Test""
        return { message }
      });
      
I temporarily solved this in my project by changing the order of the errorsMaps in the ""addIssueToContext"" function in ""./helpers/parseUtil.ts"". It can be seen in the function of the same file ""makeIssue"" because it does not work as expected, a reverse is being used, I don't know if it is intentional or because it is due.

      

",,
1848791460,2651,zod.function as property of zod.object loses `this`,"Quoting myself from discord:

```
const MyObj = z.object({ foo: z.function() });
class MyObjImpl implements z.infer<typeof MyObj> { private bar: string; constructor(){this.bar = 'baz';} foo() { console.log(this.bar); } };
const inst = MyObj.parse(new MyObjImpl()); //ok
inst.foo(); // kablooey :( ""this is undefined""
```

The problem is that the parsed object's parsed method is an arrow function, and thus has a ""this"" of the ZodFunction (see: https://github.com/colinhacks/zod/blob/1ecd6241ef97b33ce229b49f1346ffeee5d0ba74/src/types.ts#L3755). A similar problem applies to async functions.

I can think of two possible solutions here. First is to make the parsed result a normal function instead of an arrow function, then apply its `this` to the underlying `fn`. The second is to use proxies on either the parsed function, the parsed object, or both to get a similar behavior.

I'll have a not-yet-mergeable PR for the former strategy up for this shortly. Would love help getting it over the line.",,
1847401199,2649,Schema properties become optional if passed to generic function,"When passing a schema with a normally matching generic type as a function parameter, object properties seem to become optional. So the following code fails with type error `Type 'undefined' is not assignable to type 'string'.`:
```typescript
// not working
function test1<T extends ZodType<string>>(schema: T) {
  return z.object({ value: schema }) satisfies ZodType<{ value: string }>
                                  // ^ Type 'undefined' is not assignable to type 'string'.
}
```

When passing the schema with a specific type, it is working, but as stated in the documentation, some type information will be lost:
```typescript
// working
function test2(schema: ZodType<string>) {
  return z.object({ value: schema }) satisfies ZodType<{ value: string }>
}
```

I'm not sure whether this is a TypeScript quirk, a bug in Zod or something I'm doing wrong. Any help would be appreciated.

[Reproduction on StackBlitz](https://stackblitz.com/edit/typescript-d7ho4u?file=index.ts&view=editor)
Maybe related: #2198",,
1846677484,2647,Feature request: Attach input value to ZodError,It would be useful it the parsed value was attached to the thrown ZodError so that an error handler could display what was the incorrect value.  I volunteer to write a PR.,,
1846613986,2646,Can't extend Zod object contain refine function ,"![image](https://github.com/colinhacks/zod/assets/52112750/98bdd928-527c-47cd-9b6a-9bc7615566e8)
![image](https://github.com/colinhacks/zod/assets/52112750/43558e32-f9d8-46f6-af89-d6fd76f276c6)
https://codesandbox.io/s/bold-rgb-979c5f?file=/src/App.tsx",,
1845544004,2644,"[Feature Request] - Property mapping for smoother object chain construction - mapProps(), and mapPropsPicked()","For input validation, Zod sometimes feels like it's copy/paste error prone and feels ""reversed.""  Often, you validate inputs that are going to be sent to another model type that will be written to an API or database.  The types of the properties of the inputs and the destination type usually have the same data type, or only a few properties on the input need to be coerced, refined, or transformed before simply being copied to another type.   I would also like the some of the errors on the model type to be surfaced immediately before any other logic takes place.  

Also, autocomplete is greatly hindered as making sure the property names and property types stay in sync is difficult.

I based a lib I wrote almost entirely off Zod, and added this functionality and it's been a big help.  You can see the documentation which mirrors Zod's docs, here:  

https://github.com/kutruff/nimbit#mapprops

I'd love for this functionality to also be in Zod.  

```ts
const Address = z.object({
  street: z.string(),
  zipcode: z.string().length(5) // validate zip is 5 chars.
});

const Person = z.object({
  name: z.string(),
  age: z.number().min(0), //An existing validation on the model
  address: Address,
  title: z.string()
});

const PersonInput = z.object({
  //z.string() is copy pasted here rather than just using the model.
  name: z.string().default(''),
  //Oops. The age validation on the model isn't caught early...
  age: z.string().pipe(z.coerce.number()),
  //Need to validate sub props and coerce Address...
  //Can't reuse the Address type and we didn't get the validation. Using merge() won't guarantee prop names match.
  address: z.object({ 
    street: z.string().refine(x => x.includes('St.')),
    //expect zipcode to be a number for input but we just forgot the Address validation.
    zipcode: z.number().pipe(z.coerce.string()) 
  })
});
```

Now imagine if we had `mapProps()` that allowed us on a property by property basis to work with the first type:  

```ts
const PersonInput = Person.mapProps({
  // p is the Person.name.  It's strongly typed.
  name: p => p.default(''),
  // now we get the age validator )
  age: p => z.coerce.number().pipe(p),
  // Now we can use map props on nested objects too!
  address: p => p.mapProps({ 
    street: sub => sub.refine(x => x.includes('St.')),
    // adding pipe to reuse the length validation on Address.zipcode
    zipcode: sub => z.number().pipe(z.coerce.string()).pipe(sub) 
  })
});
```

`mapPropsPicked()` would do the same but restrict the properties would only allow the properties that were specified in the mapping.
",,
1845111708,2643,"cant make an array of ""open"" objects","in typescipt we can make the following

```ts
type OpenObject  = {
    id: string
} & {
    [key: PropertyKey]: unknown
}
type OpenObjectList = OpenObject[] // or Array<OpenObject>
```
Trying to define that using zod and z.infer seem to fail...
Wondering if this is a bug or a known limitation or if i'm missing someting
```ts
import {z} from ""zod""

const openObject = z.object({
  id: z.string()
}).catchall(z.unknown())

type OpenObject = z.infer<typeof openObject>
// correct type output
// type OpenObject = {
//     id: string;
// } & {
//     [k: string]: unknown;
// }
const openObjectList = z.array(simpleOpenObject)

type OpenObjectList = z.infer<typeof openObjectList> 
// type output is not as expected 
// type OpenObjectList = z.objectOutputType<{
//    id: z.ZodString;
// }, z.ZodUnknown, ""strip"">[]

// expected one of 
// type OpenObjectList = Array<OpenObject>
// type OpenObjectList = OpenObject[]
// type OpenObjectList = { 
//        [key: PropertyKey]: unkown
//         id: string
// }[]
```
",,
1844999326,2642,Feature request: add .example to ZodType,"# Motivation
Zod schemas can be leveraged to automatically generate API information (ie, [nestjs-zod](https://github.com/risen228/nestjs-zod)). This is very convenient because it allows defining the validation schema and the API documentation in a single place. As Zod does not have the concept of an `.example` value, these toolings rely on `.default` values to present _sample values_. Unfortunately, though, this breaks the semantics of `.default`, on `.parse`.

# Goal
Create the new method `.example()` on `ZodType`.

### Suggestion
- x.example(anyValue) // setter
- x.example() // getter",,
1844016241,2641,Provide zod schemas for the object shapes that Zod itself can return,"Iâ€™d love if Zod included validators for the objects Zod itself produces. For example, imagine I design an API that returns `ZodIssue`s from `z.safeParse`:
```ts
const parsed = mySchema.safeParse(unknownData);
if (!parsed.success) return new Response(JSON.stringify({ error: true, issues: parsed.error.issues }));
...
```

Now, when I write client code to consume this API, Iâ€™d like to use Zod to validate the shape of the data I receive from the request:
```ts
const mySchema = z.discriminatedUnion('success', [
  z.object({ success: z.literal(true) }),
  z.object({
    success: z.literal(false),
    issues: /* ?? */
  }),
]);
const r = await fetch(...);
const data = mySchema.parse(await r.json());
```

In this example, in order to write the validator â€œmySchemaâ€ it would be useful if Zod exported a Zod schema for `ZodIssue`, which I could drop in for `/* ?? */`.

Of course, a simple schema for `ZodIssue` would be relatively easy to write, but in reality the `ZodIssue` type is a complex union, so a â€œtrivialâ€ schema would lose some of the details captured by the `ZodIssue` type.

I can imagine exporting schemas for other built-in Zod types would be similarly useful.",,
1843521546,2639,String format request: xid,"In line with `UUID`, `ULID`, `CUID`, and `CUID2`, I think it would be great to add an additional format as well: `xid`.

It seems like it's fairly simple and well supported, and I'm looking to use it in a project that I use `zod` for, so support would be great.

Here's the source repo: https://github.com/rs/xid
Here's a typescript implementation: https://github.com/yiwen-ai/xid-ts

I can start on a PR if that would be appreciated!",,
1840791993,2637,Using a union for the discriminator with discriminatedUnions fails,"Using a union for the discriminator value with discriminatedUnions yields this runtime error: 

```
Error: A discriminator value for key `status` could not be extracted from all schema options
```

Sample code:
```ts
const myUnion = z.discriminatedUnion(""status"", [
  z.object({ status: z.union([z.literal(""success""), z.literal(""ok"")]) , data: z.string() }),
  z.object({ status: z.literal(""failed""), error: z.instanceof(Error) }),
]);

myUnion.parse({ status: ""success"", data: ""yippie ki yay"" });
```

The valid type for this would be something like:

```ts
type myUnion = {
  status: ""success"" | ""ok"";
  data: string;
} | {
  status: ""failed"";
  error: Error;
}
```

The workaround is to duplicate the the entry for each value in the inner union.",,
1838278906,2635,Nullable Enums fail validation,"It seems to me that the enum validation happens first and therefore `undefined` and `null` fail this test, eventhough `.nullish()` is appended to the definition.

I sadly do not have the time to investigate this and it seems adding `undefined` to the enum itself is not possible. I'll try my luck with a union.

Thank you for all the work on this library and sorry for the sparse information.",,
1836932788,2632,z.string().mail() doesn't allow hyphens and dots in domain part,"The validation with `z.string().email()` doesn't allow hyphens in the domain part if the domain part contains dots.
The following example throws an error:

```javascript
z.string().email().parse({ email: ""antony.kamp@student.uni-potsdam.de"" })
```

I found the following regex that allows dots and hyphens in the domain part of an email address:

```
  /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
```
resource: https://html.spec.whatwg.org/multipage/input.html#email-state-(type=email)
But it's not RFC compliant ",,
1836615732,2630,z.enum() cannot accept parameter from a json file,"# What's the Issue

I have a json file that stores a list of slugs
```
/* dataSlugs.jsona */

{
  ""slugs"": [""one"", ""two"", ""three""]
}
```

Then I import this json and pass it as parameter to`z.enum`
```
import dataSlugs from './dataSlugs.json'

type DataSlugJson = {
  slugs: string[]
}

const slugs = (dataSlugs as DataSlugJson).slugs

export const mySchema = z.enum(slugs) /* this throws a type error */

```

I get the error:
<img width=""896"" alt=""Screenshot 2023-08-04 at 7 52 38 PM"" src=""https://github.com/colinhacks/zod/assets/30344224/77b3898c-ad98-4e68-966e-e4286b22be3f"">


I found in the docs about `z.enum`  can use `as const`

```
/* THIS WORKS */
const slugs = [""one"", ""two"" ""three""] as const
export const mySchema = z.enum(slugs)

```

```
/* BUT THIS DOESN't */
const slugs = (dataSlugs as DataSlugJson).slugs as const
 /* ERROR A 'const' assertions can only be applied to references to enum members, or string, number, boolean, array, or object literals.ts(1355) */
 
export const mySchema = z.enum(slugs)

```

How can I get a data from a json file, and pass it as parameter to `z.enum()` ?

## ZOD Version
`""zod"": ""^3.21.4""`",,
1835753897,2629,z.strictObject missing from documentation,"Hi,

I just went to check the docs for more information on this function and I find that is missing.

Is this intentional?",,
1835485699,2628,large schemas make it hard to read the type,"first of all thanks for making this amazing project. it is one of my favorite libraries.

i have some really big zod objects in my project. You can see here what it looks like when i hover over a parsed object (`finalEntities`):
![image](https://github.com/colinhacks/zod/assets/32936978/54718237-dc98-4748-916f-3e96364b7c9a)

it shows the entire type definition and not the name. But if i do this with a regular ts type instead of zod, it would just show `Promise<SpaceType>` and allow me to easily navigate to that type.

sometimes i may have many large similar schemas in a union at which point it becomes almost impossible to read.

I'm trying to stay 100% inferred. so my app just uses the result of `const finalEntities = SpaceInstanceArray.parse(entities);`.
would be cool if i could hover over `finalEntities` and see the name of the schema and be able to go to the schema easily.

I tried using z.infer to get the type and then cast it as that type , like this:
```
type SpaceType = z.infer<typeof SpaceInstanceArray>;
 const finalEntities = SpaceInstanceArray.parse(
        entities
  ) as unknown as SpaceType;
```
but i still just see the entire type definition when i hover over finalEntities. Is there anyway to get around this or improve DX on this?
",,
1834874616,2627,Object type inference breaks when passing generic parameters,"[Reproduction](https://codesandbox.io/s/typescript-playground-export-forked-shpc4g?file=/index.ts)

Summary:

We interface with a library that converts Rust structs into JSON. A rust enum will be converted like such:

```rs
enum PrimaryColor {
  Red,
  Yellow,
  Blue,
}
```
```json
{ ""__kind"": ""Red"" }
```

To simplify parsing these enums, we created a factory function to generate the schemas.

```ts
const rustEnum = <T extends string, U extends Readonly<[U, ...U]>>(values: U) =>
  z.object({ __kind: z.enum(values) }).transform(({ __kind }) => __kind);
```

However, type inference of `z.object` seems to break when passing in generic parameters that are used for an enum within that shape. Here ""breaking"" means that `undefined` is added to the union of enum values.

There are some simple workarounds such as simply copy-pasting the code or adding a non-null assertion.

",,
1831713805,2625,Feature Request: Docs site should be searchable with Cmd+K hotkey,"This seems to be the hot thing to do nowadays, but I find myself instinctively hitting `cmd+k` and realizing that zod.dev doesn't support it. The content of the documentation is fantastic, and this would be a nice way to make it more searchable!",,
1830840530,2624,Zod compiles d.ts files with errors,"My team recently noticed an issue that came up in the .d.ts files after zod compiled 1 of our schemas.

Original zod schema:
```ts
export const UserEventMetadataSchema = EventMetadataSchema.extend({
  userId: z.string().or(z.null()),
  journeyId: z.string(),
  locale: z.string(),
  os: z.string().optional(),
  device: z.string().optional(),
  browser: z.string().optional(),
})
```
The output in our d.ts file:
```ts
export declare const UserEventMetadataSchema: z.ZodObject<z.extendShape<{
    appVersion: z.ZodString;
    environment: z.ZodEnum<[""production"", ""staging"", ""development""]>;
    clientVersion: z.ZodString;
   ....
},
```
The problem is that in the d.ts file Typescript cannot find the exported module extendShape:
![image](https://github.com/colinhacks/zod/assets/17296943/17d12ef9-486a-474e-81c3-009dea22f943)

Package versions:
```json
""dependencies"": {
    ""zod"": ""^3.21.4"",
    ""typescript"": ""^4.9.4""
  },
```

Does anyone know why the d.ts files are generated with typescript errors?",,
1830446542,2623,`z.record` with a key of a union or enum schema results in a partial record,"If a union or enum schema is passed to `z.record` as a key type, the resulting schema has all properties as optional for both the parsing logic and the inferred TypeScript type.

I propose that we make the behavior of `z.record` similar to that of TypeScript's. If you pass an union or enum type to Record in TypeScript, the resulting type has all properties required.

I understand changing the existing behavior of `z.schema` would be a breaking change. For now, how about introducing a new zod type `z.strictRecord` where all properties are required?

I apologize if this has been considered before. Please let me know if there are specific reasons the behavior of`z.schema` differs from TypeScript's ðŸ™‡ 

I also found related issues and listed them below for reference.

- https://github.com/colinhacks/zod/issues/2320
- https://github.com/colinhacks/zod/issues/2448
- https://github.com/colinhacks/zod/issues/55

The following example code illustrates the current behavior of `z.record`.

```ts
import { z } from 'zod';

const exampleEnumSchema = z.enum(['foo', 'bar']);
const exampleRecordSchema = z.record(exampleEnumSchema, z.string());

type ExampleRecord = z.infer<typeof exampleRecordSchema>;
// {
//     foo?: string | undefined;
//     bar?: string | undefined;
// }

exampleRecordSchema.parse({foo: 'foo'}); // doesn't error
```

The following example code illustrates the behavior of TypeScript Record.

```ts
enum ExampleEnum {
    Foo = 'foo',
    Bar = 'bar',
}

type ExampleRecord = Record<ExampleEnum, string>;
// {
//     foo: string;
//     bar: string;
// }

const exampleRecord: ExampleRecord = {
    [ExampleEnum.Foo]: 'foo',
}
// Property '[ExampleEnum.Bar]' is missing in type '{ foo: string; }' but required in type 'ExampleRecord'.
```

If the schema created by `z.record()` is used for a property on another object schema, the property's type is inferred as a `Partial` type.

```ts
const tempSchema = z.object({baz: exampleRecordSchema});

type Temp = z.infer<typeof tempSchema>;
// {
//     baz: Partial<Record<""foo"" | ""bar"", string>>;
// }
```",,
1830307114,2622,[Feature request] Marking a field as deprecated,"Use case
--- 

I am creating an API using Zod and TRPC, and I can't guarantee that all of the clients will upgrade immediately upon deploy (e.g. long opened tabs). 

I would like to deprecate fields out of the TRCP input or output schema without forcing an immediate client refresh; and I didn't spot an approach to doing this in the docs.

If I have missed any easier approach, please let me know :) 

Proposal
---

A `deprecated` method which removes the key from the input, or output, types based on the setting (naming just a first-thought, not a suggestion).

- `input`: 
   - optional in validation
   - is **not** in the input type
   - is in the output type
- `output`: 
   - same as before in validation (optional or required)
   - is in the input type
   - is **not** in the output type

Why not just temporarily use `optional`
---

- For `input` types, it will not prevent consumers from continuing to attempt to supply this data. A two step deprecation allows all consumer code to be updated (and type checked) before updating the server code.
- For `output` types, it ensures that no consumers are still expecting this field before the server stops sending it entirely

In both situations, deprecating for a situation-appropriate amount of time helps to avoid API mismatch.

Examples
---

```ts
export const appRouter = t.router({
  hello: publicProcedure
    .input(
      z.object({
        // consumers of this API route will not see `name` in the input types
        // but it is still available here to be responded to for old consumers
        name: z.string().deprecated('input'),
      }),
    )
    .query((opts) => {
      const name = opts.input.name;
      if (name) { /* do the old version */ }
      else { /* do the new version */ } 
      return {
        greeting: ""Hello"",
      };
    }),
});
```

```ts
export const appRouter = t.router({
  // this method is being deprecated, so new consumers will see `{}` as the output type
  // it will still work for older consumers, allowing time for all clients to update to the latest build
  // this specific situation may be better managed at a TRPC level as well
  hello: publicProcedure
    .input(
      z.object({
        name: z.string().deprecated('input'),
      }),
    )
    .output(
      z.object({
        greeting: z.string().deprecated('output'),
      }),
    )
    .query((opts) => {
      const name = opts.input.name;
      return {
        greeting: ""Hello"",
      };
    }),
});
```",,
1827835924,2617,Cannot import Zod schema from monorepo package when deploying Firebase Cloud Function,"I am using Zod for runtime validation in my Firebase Cloud Functions.

I also have a monorepo setup. All my TypeScript models and Zod schema are exported from a single internal package.

There are no IDE errors. But when I import Zod schema from that internal monorepo package into my Firebase Cloud Function I get this error during deploy or emulate:

> Failed to load function definition from source: FirebaseError: Functions codebase could not be analyzed successfully. It may have a syntax or runtime error

This only happens when importing and deploying Zod schema. Importing and deploying plain TypeScript interfaces does not have the same problem.

Also if I move the Zod Schema into the Firebase Function itself everything works fine. So there is a problem specifically with importing Zod Schema from the internal monorepo package.

Any ideas what's going on here?

This is the internal package:

**`my-app/packages/types/src/index.ts`**
```
import { z } from ""zod"";

export const SerpGridOnCallSchema = z.object({
  companyId: z.string(),
  companyLocationId: z.string(),
  companyLocationCid: z.string(),
  keyword: z.string(),
  centerCoordinates: z.object({
    lat: z.number(),
    lng: z.number(),
  }),
  gridSizePerSide: z.number(),
  gridNumPointsPerSide: z.number(),
  mapZoomLevel: z.number(),
});

export type SerpGridOnCall = z.infer<typeof SerpGridOnCallSchema>;
```

**`my-app/packages/types/package.json`**
```JSON
{
  ""name"": ""@seoturbo/types"",
  ""version"": ""1.0.0"",
  ""license"": ""UNLICENSED"",
  ""description"": ""Typescript types"",
  ""main"": ""src/index.ts"",
  ""types"": ""src/index.ts"",
  ""scripts"": {
    ""lint"": ""eslint --ext .js,.ts ."",
    ""build"": ""tsc""
  },
  ""dependencies"": {
    ""@turf/helpers"": ""^6.5.0"",
    ""firebase"": ""^9.17.2"",
    ""firebase-admin"": ""^11.10.1"",
    ""quasar"": ""^2.12.1"",
    ""zod"": ""^3.21.4""
  },
  ""devDependencies"": {
    ""@seoturbo/eslint-config-custom"": ""*"",
    ""@seoturbo/tsconfig"": ""*"",
    ""eslint"": ""^8.9.0"",
    ""typescript"": ""^5.1.6""
  }
}
```

This is the Firebase Functions file where the internal monorepo package is imported and used:

**`my-app/apps/functions/src/api/http/on-call/test.ts`**
```
import { CallableRequest, onCall } from ""firebase-functions/v2/https"";
import { SerpGridOnCall, SerpGridOnCallSchema } from ""@seoturbo/types"";

export const test = onCall(async (req: CallableRequest<SerpGridOnCall>) => {
    SerpGridOnCallSchema.parse(req.data);
  }
);
```",,
1827238716,2614,string().trim() is not working. ,"As title, the whitespaces aren't trimmed after going through the zod layer. ",,
1826444169,2613,Make zod faster,"I found repo with [validators benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/). Zod in it not so good as I expected.

I wrote simple test for my model and custom validation function, which fully corresponds to the Zod scheme.

When running, I saw a 15x (1500%) execution speed difference.

![image](https://github.com/colinhacks/zod/assets/4066631/8912ac24-83d1-416f-8b7a-d1bd1f5c1e18)

My performance test code:
```js
const z = require('zod')

const DATA = {
    id: 1,
    yo: 1,
    email: 'me@email.name',
    username: 'admin',
    score: 0,
    roles: ['owner'],
    userProfiles: [
        { profileId: 1, profileName: 'Yo!1' },
        { profileId: 2, profileName: 'Yo!2' },
    ],
}
const TRY_COUNT = 100000

function validateZod(data, tryCount) {
    const userSchema = z.object({
        id: z.number(),
        email: z.string(),
        username: z.string(),
        score: z.number(),
        roles: z.array(
            z.enum(['admin', 'manager', 'owner', 'customer'])
        ),
        userProfiles: z.array(
            z.object({ profileId: z.number(), profileName: z.string() })
        ),
    })

    for(let i = 0; i < tryCount; i += 1) {
        userSchema.parse(data)
    }
}

function validateCustom(data, tryCount) {
    function parse(data) {
        if (!data || typeof data !== 'object') {
            throw new Error('data is not object')
        }

        const out = {}

        if (typeof data.id !== 'number') {
            throw new Error('id is not number')
        }
        out.id = data.id

        if (typeof data.email !== 'string') {
            throw new Error('email is not string')
        }
        out.email = data.email

        if (typeof data.username !== 'string') {
            throw new Error('username is not string')
        }
        out.username = data.username

        if (typeof data.score !== 'number') {
            throw new Error('score is not number')
        }
        out.score = data.score

        if (!Array.isArray(data.roles)) {
            throw new Error('roles is not array')
        }
        out.roles = data.roles.map((data, i) => {
            if (!data || typeof data !== 'string') {
                throw new Error(`roles[${i}] is not string`)
            }

            if (!['admin', 'manager', 'owner', 'customer'].includes(data)) {
                throw new Error(`roles[${i}] is not string`)
            }

            return data
        })

        if (!Array.isArray(data.userProfiles)) {
            throw new Error('userProfiles is not array')
        }
        out.userProfiles = data.userProfiles.map((data, i) => {
            if (!data || typeof data !== 'object') {
                throw new Error(`userProfiles[${i}] is not object`)
            }

            const out = {}

            if (typeof data.profileId !== 'number') {
                throw new Error(`userProfiles[${i}].profileId is not number`)
            }
            out.profileId = data.profileId

            if (typeof data.profileName !== 'string') {
                throw new Error(`userProfiles[${i}].profileName is not string`)
            }
            out.profileName = data.profileName

            return out
        })

        return out
    }

    for(let i = 0; i < tryCount; i += 1) {
        parse(data)
    }
}

// Zod test

let startTs = Date.now()
let ticksStart = process.hrtime.bigint()

validateZod(DATA, TRY_COUNT)

let ticksEnd = process.hrtime.bigint()
let endTs = Date.now()

console.log(`ZOD: Time sec ${(endTs - startTs) / 1000}, ticks: ${Math.round(Number(ticksEnd - ticksStart) / 1000)}`)

// Custom validation test

startTs = Date.now()
ticksStart = process.hrtime.bigint()

validateCustom(DATA, TRY_COUNT)

ticksEnd = process.hrtime.bigint()
endTs = Date.now()

console.log(`CUSTOM: Time sec ${(endTs - startTs) / 1000}, ticks: ${Math.round(Number(ticksEnd - ticksStart) / 1000)}`)
```

I know the overhead is unavoidable, but maybe you can optimize the code by precompiling the Zod-schema and make 15x gap smaller.
My suggestion is to compile the Zod-schema with a `new Function()` (at least for simple cases) and use it when calling validation.

```js
function compileSchema(zodSchemaDefinition) {
    let code = ''

    if (zodSchemaDefinition.nullable) {
        code += `if (value === null) return null;\n`
    }

    if (zodSchemaDefinition.optional) {
        code += `if (value === undefined) return undefined;\n`
    }

    if (zodSchemaDefinition.type !== 'string') {
        // MVP compiler: only for strings at the moment
        return null
    }

    code += `if (typeof value !== 'string') throw new Error('value is not a string');\n`

    if (zodSchemaDefinition.min) {
        code += `if (value.length < ${zodSchemaDefinition.min}) throw new Error('Minimum value length is ${zodSchemaDefinition.min}');\n`
    }

    code += 'return value;'

    return new Function('value', code)
}

// Schema must get from Zod schema metadata
const validator = compileSchema({
    nullable: true,
    type: 'string',
    min: 2,
})

console.log('Generated validator function:')
console.log(validator.toString())
console.log()
console.log('Value ""qwe"" validation: ', JSON.stringify(validator('qwe')))
console.log()
console.log('Next validation of number 1 must throw error')
console.log(validator(1))
```

![image](https://github.com/colinhacks/zod/assets/4066631/02d3ebdd-bca9-4fe6-967d-b92b5d3bda9a)
",,
1825286288,2612,"How to... ? Possible empty array, map'ing through it","Hi

Given I have this schema:
```ts
const keywordSchema = z.object({
  text: z.string(),
  url: z.string().url()
});

const post = z.object({
  // Keywords is always here, it is an array, can be empty, can have keywords in it
  // Using approach from example: https://zod.dev/?id=arrays
  keywords: keywordSchema.optional().array()
  // ... stuff
});
```

When I want to iterate over keywords:
```ts
const keywordTexts = post.keywords.map(({ text }) => text);
```

I get a TS warning about `text` being possibly `undefined`.

### Questions:

1. is this correct behavior? Given that `.map` can iterate over empty arrays, this is not a runtime problem but it is a TS one.
1. How can I achieve this scenario, in which I get all of the text values of keywords from the array of keyword objects, given that the array can be empty or full?",,
1823894878,2611,how use zod pass the File object,"This is my trpc+zod code.
```
  test: t.procedure
    .input(
      z.object({
    input_image: z.any(),
      }),
    )
    .mutation(async (req) => {
      const img = req.input.input_image
      console.log(input_image) //{}
      return true
    }),
```
I ended up with an empty object

",,
1823188844,2609,Email Regex Vulnerable to ReDoS attack,"# Email Regex Vulnerable to ReDoS attack

## The problem

When trying to develop authentication in my new application, I decided to use Zod for (part of) my validation checking.

I always check for vulnerabilities, and I know that ReDoS (Regular Expression Denial of Service) is a primarily common vulnerability. I knew Zod must use regex to validate `z.string().email()`. So, I checked the source code. I found (on my local machine, `./node_modules/zod/lib/types.js` had a vulnerable regex.

On line 324 it has the following code:

```javascript
const emailRegex = /^(([^<>()[\]\\.,;:\s@\""]+(\.[^<>()[\]\\.,;:\s@\""]+)*)|(\"".+\""))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
```
I copied the regular expression and checked if it was vulnerable to a ReDoS attack. I went to the most recommended ReDoS checker, [recheck](https://makenowjust-labs.github.io/). This is what I found:

<img width=""455"" alt=""zod-redos-proof-1"" src=""https://github.com/colinhacks/zod/assets/95201376/06b59863-78ac-402d-a11f-d20a2cf71b67"">

## The other regexes

I have not checked any other regexes, but there are multiple others, but I will paste the code for anyone who would like to check. This starts in the same file previously mentioned but on line 320.

```javascript
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const emailRegex = /^(([^<>()[\]\\.,;:\s@\""]+(\.[^<>()[\]\\.,;:\s@\""]+)*)|(\"".+\""))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
const emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
    if (args.precision) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
    }
    else if (args.precision === 0) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
    }
    else {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
    }
};
```

--------------------------------

**Please let me know of any way that I can help**",,
1823083620,2608,Error reported inside union are wrong,"Using the following code:

```ts
import { ZodError, z } from ""zod"";

async function superRefineFunction(val: any, ctx: any) {
    if (val !== 'Z') { 
        ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: ""This value is not in db"",
        });    
    }
}

const schema = z.union([
    z.string().regex(/^P=\d{4}$/),
    z.string().regex(/^A=\d{4}$/).pipe(z.string().superRefine(superRefineFunction)),
]);

async function run(data: unknown) {
    try {
        const result = await schema.parseAsync(data);
        console.log(`${result}: ok`);
    } catch (e) {
        console.log(`${data}: ${(e as ZodError).issues.map((i)=>i.message).join(',')}`)
    }
}

run('A=2222').then(() => {});
```

The error reported is not the one reported in the superRefineFunction. But, if I invert the order of the elements in the array of the argument passed to z.union, then I receive the right error.

```ts
const schema = z.union([
    z.string().regex(/^A=\d{4}$/).pipe(z.string().superRefine(superRefineFunction)),
    z.string().regex(/^P=\d{4}$/),
]);
```

Conclusion: Using union, It seems only the first error encountered is reported. Would it be better to report all the errors encountered?",,
1822932544,2607,`omit` & `pick` allowing keys not present in the object,"It seems that `z.omit` and `z.pick` allow any keys to be omitted/picked, as long as **one** of the omitted/picked keys **is** in the object.

```ts
import { z } from ""zod""

export const SomeZodObject = z.object({
  a: z.string(),
  b: z.string(),
})

export const ErroneousOmit = SomeZodObject.omit({
  c: true, // <-- Errors because `c` is not in `SomeZodObject`, and it is the only key being omitted
})

export const AllowedOmit = SomeZodObject.omit({
  a: true,
  c: true, // <-- Does *not* error because `a` *is*` part of `SomeZodObject`, so any key is now allowed
})
```

The same behavior as above happens with `pick`.

Note that TypeScript's `Omit` type **does** allow omitting keys not present in the object:

```ts
type SomeZodObjectInput = z.input<typeof SomeZodObject>

// No errors
export type TSOmitted1 = Omit<SomeZodObjectInput, ""c"">
export type TSOmitted2 = Omit<SomeZodObjectInput, ""a"" | ""c"">
```

But TypeScript's `Pick` type does **not**:

```ts

type SomeZodObjectInput = z.input<typeof SomeZodObject>

// Both of these error
export type TSPicked1 = Pick<SomeZodObjectInput, ""c"">
export type TSPicked2 = Pick<SomeZodObjectInput, ""a"" | ""c"">
```

Is this intended behavior? And if so, is there a way to get TS to error for **any** key that doesn't exist in the object?

TSPlayground: https://tsplay.dev/wO1pdm
",,
1821515236,2606,Parsing Union of objects removes property from object,"```TypeScript
import { z } from ""zod"";

const UpdateBookingSchema = z.union([
  z.object({
    propertyType: z.string()
  }),
  z.object({
    region: z.string()
  }),
  z.object({
    propertyType: z.string(),
    region: z.string()
  })
]);

const updateBooking = UpdateBookingSchema.parse({
  propertyType: ""unit"",
  region: ""vic_bayside""
});

console.log({ updateBooking });
```

Output:
```
{ propertyType: ""unit"" }
```

Expected:
```
{
  propertyType: ""unit"",
  region: ""vic_bayside""
}
```

https://codesandbox.io/s/hungry-mcclintock-9dzmnp

If I move the last `z.object` to the first item in the union it works as expected",,
1816081801,2602,Is it possible to make z.union partial,"Currently i have this code:
```
// typeA and B will always have type field, but might include other fields
const typeA = z.object({ type: z.literal('a') });
const typeB = z.object({ type: z.literal('b') });

const scheme = z.union([typeA, typeB]).array();

// I need it to validate only required keys, and ignore others
// I want it to accept this one:
scheme.safeParse([{ type: 'a' }, { type: 'b' }]).success // true, (works right now)
scheme.safeParse([{ type: 'a' }, { type: 'c' }]).success // true, it might strip ""c"" if needed (not works)
scheme.safeParse([{ type: 'c' }]).success // true, doesn't contain a or b (not works)

```
Right now i am validating backend response and i have only specific types, that i will use, not all existing.

So i need it to parse keys, that i can use and validate them, ignoring others.
Or maybe i don't union here...",,
1816041844,2600,[feat] `z.number().latitude()` and `z.number().longitude()`,"Latitude and longitude are used in a variety of applications, it feels like this simple validation is missing, currently is possible to validate chaining min and max but it would be better if this validation was abstracted away.

```ts
const latitude = z.number().min(-90).max(90)
const longitude = z.number().min(-180).max(180)

// Proposed
const latitude = z.number().latitude()
const longitude = z.number().longitude()
```",,
1815416008,2599,Zod can not have an optional url,"z.string().optional() is not a problem 
but z.string().url().optional() doesnt work
and z.url() doesnt exist 
i can just do it with z.string().regex() ",,
1814621799,2598,Zod infers undefined field as optional,"### Given:
`zod 3.21.4`

```typescript
({ }) satisfies { x: undefined };   // 1
({ }) satisfies z.infer<typeof x>;  // 2
const x = z.object({ x: z.undefined() });
```

### Expected:
- `1` should not typecheck because field is not optional
- `2` should not typecheck as well because `x` models the same type

### Actual:
- `1` typechecks (and it is correct)
- `2` does not typecheck (`zod` for unknown reason makes field optional)

It is not the problem with `strict: true` in tsconfig.",,
1813976408,2597,Include original class in schema for `z.instanceof()`,It'd be great if the original class (e.g. `Uint8Array` for `z.instanceof(Uint8Array)`) could be included in the schema to allow for more flexibility.,,
1813066074,2596,Bloating with esbuild bundled output,"Hi Colin!

Awesome project, I came across this issue as referred by the following:

_Originally posted by @gustavopch in https://github.com/colinhacks/zod/issues/294#issuecomment-1638064507_
            
The thread confirms your intention of having tree-shakable esm code, and it is marked as resolved and closed. However, esbuild currently bundles all of Zod into your output if you import a simple zod schema.

Steps to replicate: 
- Creating a simple ts project that uses esbuild with bundled output enabled.
- Create a simple zod schema:

`
import {z} from ""zod""
const testSchema = z.string().min(10)
`
- Validate some random string using the test schema
- Build the project with esbuild using bundled output (also bundling external node_modules, so would be zod module in our case. This is currently how edge functions such as wrangler cli for cloudflare workers bundle ts, and the bundled code is several thousand lines of unused js from Zod in an edge environment supposed to be small and lightweight)

Another similar comment in thread:
_Originally posted by @ekwoka in https://github.com/colinhacks/zod/issues/294#issuecomment-1438548315_

Is treeshaking working as expected? Looking forward to hearing from you,
Cheers!",,
1812128821,2593,Nested discriminated unions.," Is there any option to write discriminated union for two values ?

```
    const validation1 = z.object({
        field1: z.literal(""VALIDATE""),
        field2: z.literal(""YES""), //if YES validate field3
        field3: z.string().array().nonempty({
            message: ""You must set at least one correct answer""
        })
    })

    const validation2 = z.object({
        field1: z.literal(""VALIDATE""),
        field2: z.literal(""NO""), //if NO validte field4
        field4: z.string()
    })
	
	
    const validation3 = z.object({
        field1: z.literal(""NO_VALIDATE""),
        field2: z.literal(""NO""),
       	//no_validations
    })
    
     const validation4 = z.object({
        field1: z.literal(""NO_VALIDATE""),
        field2: z.literal(""YES""),
        //no_validations
    })

 const validatorSchema = z.discriminatedUnion(""field1"", [validation1, validation2, validation3, validation4])````",,
1812123842,2592,z.date() does not work with vi.setSystemTime(),"When mocking the system, time with vitest (which uses: `https://github.com/sinonjs/fake-timers` internally) the date parser stops working.

CodeSandbox: https://codesandbox.io/p/sandbox/zen-bartik-gg4nn9

```ts
it(""runs"", () => {
  const dateSchema = z.coerce.date();

  // This Works
  console.log(dateSchema.parse(""2023-07-19""));

  vi.setSystemTime(1689775661);

  // This doesn't work
  console.log(dateSchema.parse(""2023-07-19""));
});
```

The second parse throws an Error, even through it worked before with the same value:
```
ZodError: [
  {
    ""code"": ""invalid_type"",
    ""expected"": ""date"",
    ""received"": ""object"",
    ""path"": [],
    ""message"": ""Expected date, received object""
  }
]
```

",,
1810907979,2590,Feature request: allow for single element unions,"In Typescript I can do something like:

```typescript
type Animal =
    | { type : 'bird', name: 'Graculus' }
```

-- with the assumption that there could be future union values in future, and to hint to future maintainers that some function is set up to be extended to support multiple values.

Would be nice if zod could match that and allow a single element union.",,
1810197546,2588,Zod Preprocess returning unknown type,"Same as https://github.com/colinhacks/zod/issues/1458, 

The type returned from [z.preprocess](https://zod.dev/?id=preprocess) is giving out type ""unknown"" instead of expected behavior of inferring from schema passed as second argument and throw the error on runtime if the processed value is different from schema.

```ts
const processedObject = z.preprocess(
    (v) => (typeof v === ""string"" ? JSON.parse(v as string) : v),
    z.array(jsonSchema),
) // typeof processedObject returning unknown
```

using zod v3.21.4",,
1809717388,2587,Importing zod schemas exported from a different package forces ZodError to lose its type,"Hi, I was trying to reuse zod schemas by importing them from another package, but when I do so, parse function does not return ZodError instance anymore. I am currently compiling my source code with esbuild into an esm module, so I tried to compile it into commonjs instead but it still failed with the same behavior. Exported schemas are compiled with tsc and it's in commonjs.

Below is the compiled typescript code with esbuild.

<img width=""665"" alt=""Screen Shot 2023-07-18 at 4 02 42 AM"" src=""https://github.com/colinhacks/zod/assets/35556519/4da5b239-06fc-4f3b-935f-0211b628c8ff"">

From the above code, if I remove ""import_base_payload"" then it works as expected.
But If I run the validation function with imported schema, then I get this as an error object caught in the catch block:

<img width=""1213"" alt=""Screen Shot 2023-07-18 at 4 13 15 AM"" src=""https://github.com/colinhacks/zod/assets/35556519/1479f822-47c4-4fec-a927-6ad3a1b2323d"">

Usually, errors that are caught in the catch block are instances of ZodError but this one isn't. Very weirdly, error.constructor.name happens to be ""ZodError"" but the err is not the zod instance for some reason. 

Exported schemas are the discriminated union of two zodObjects and both objects did not involve any transformation. Below is exported schema's directory structure and schemas are exported from payload.ts file.

<img width=""177"" alt=""Screen Shot 2023-07-18 at 4 23 56 AM"" src=""https://github.com/colinhacks/zod/assets/35556519/bac7bc55-4d8f-4eff-971c-cf045ba9f123"">

Any help would be appreciated. Thanks in advance!",,
1809412104,2586,parse and safeParse differ in their result,"I have been caught out by this twice now, once using zod directly and once with drizzle-zod.
I have the expectation that zodObject.safeParse().success will always be false in scenarios where zodObject.parse will throw and
zodObject.safeParse().success will always be true in scenarios where zodObject.parse will not throw.

However, this is not the case.
Drizzle-Zod example:
```
import { int, mysqlTable } from 'drizzle-orm/mysql-core';
import { createSelectSchema } from 'drizzle-zod';
import { expect } from 'chai';

describe('table.update.test.ts', () => {
  const tableSchema = mysqlTable('test_table', {
    wordDelimiterTest: int('word_delimiter_test').notNull(),
  });
  const parser = createSelectSchema(tableSchema).partial();
  it('should fail validation if the key is the wrong case', () => {
    expect(parser.parse.bind(parser, { word_delimiter_test: 1 })).to.throw; //pass, throws error
    expect(parser.safeParse({ word_delimiter_test: 1 }).success).to.be.false; //fail, success is true
  });
});
```

parse does throw an error but safeParse returns success as true.. this makes safeParse unusable as it is the one that is incorrect.
I would try to find out what causes this disparity but I don't have the time to hunt for the actual methods in the codebase.

UPDATE: I retested the first occurrence I found of this behaviour and due to the parser (zod schema) being changed it is no longer reproducible.",,
1807662085,2585,Decide correct schema from union by specific key,"Hey,

I don't really know how to name it, but I am running into an issue trying to validate design tokens from a json file:

**Setup**
1. I have schemas for each token type, for example:

```js
export const fontWeightToken = baseToken
  .merge(
    z.object({
      $type: z.literal('fontWeight'),
      $value: z.union([fontWeightValue, referenceValue]),
    }),
  )
  .strict()
  ```
2. All specific types have the `$type` property, but it is not required for all tokens, a token can also only have the `$value` property. To validate this case I have the following `genericToken` schema:

```js
const genericTokenValue = baseToken
  .pick({$description: true})
  .merge(
    z.object({
      $value: z.union([z.string(), z.number(), referenceValue]),
    }),
  )
  .strict()
```

The problem that I run into is that if the `$type` matches with a schema, but the `$value` is wrong, it does not error, but falls through to the `genericToken` and returns an error about an invalid property `$type`.

For example if I have a fontWeight token with an invalid number:
```js
        ""light"": {
          ""$type"": ""fontWeight"",
          ""$value"": 350 // should be 300, it matches against some literals
        }
```
I want to get an error like `Invalid $value for ""light""`. However instead it goes on and says:
```js
Validation error: Unrecognized key(s) in object: '$type' at ""base.text.weight.light""
```
Because it tests this object against the `genericToken`. Is there a way that I can tell `zod` that if an item has one of the specified `$types` (so a valid type) it should match against the specific schema?

If not, is there a way to use `preprocess` or something else to go through the entire object and add `$type: ""noType""` or something like this to the items that have no `$type` object?",,
1806155120,2583,Compilation error after updating from 3.20.6 to 3.21.0,"After updating Zod from 3.20.6 to 3.21.0 I receive this error when compiling.

```
TS2345: Argument of type 'ZodObject<{ data: ZodObject<{ type: ZodLiteral<IotStateUpdateType.LOCK_STATE>; result: ZodNativeEnum<typeof IotLockEventResult>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>; ... 9 more ...; version: ZodOptional<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to parameter of type 'ZodTypeAny'.
  Types of property '_parse' are incompatible.
    Type '(input: ParseInput) => ParseReturnType<{ expires?: Date | undefined; version?: number | undefined; sent?: Date | undefined; id: string; idType: IotIdType; data: { ...; }; ... 4 more ...; source: IotHardware; }>' is not assignable to type '(input: ParseInput) => ParseReturnType<any>'.
      Types of parameters 'input' and 'input' are incompatible.
        Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/helpers/parseUtil"").ParseInput' is not assignable to type 'Zod.ParseInput'.
          The types of 'parent.common.issues' are incompatible between these types.
            Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodIssue[]' is not assignable to type 'Zod.ZodIssue[]'.
              Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodIssue' is not assignable to type 'Zod.ZodIssue'.
                Type 'ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodIssue'.
                  Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'Zod.ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }'.
                    Type 'ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodInvalidUnionIssue'.
                      Types of property 'unionErrors' are incompatible.
                        Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodError<any>[]' is not assignable to type 'Zod.ZodError<any>[]'.
                          Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodError<any>' is not assignable to type 'Zod.ZodError<any>'.
                            Types of property 'issues' are incompatible.
                              Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodIssue[]' is not assignable to type 'Zod.ZodIssue[]'.
                                Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodIssue' is not assignable to type 'Zod.ZodIssue'.
                                  Type 'ZodInvalidArgumentsIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodIssue'.
                                    Type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodInvalidArgumentsIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'Zod.ZodInvalidArgumentsIssue & { fatal?: boolean | undefined; message: string; }'.
                                      Type 'ZodInvalidArgumentsIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodInvalidArgumentsIssue'.
                                        The types of 'argumentsError.addIssue' are incompatible between these types.
                                          Type '(sub: import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodIssue) => void' is not assignable to type '(sub: Zod.ZodIssue) => void'.
                                            Types of parameters 'sub' and 'sub' are incompatible.
                                              Type 'Zod.ZodIssue' is not assignable to type 'import(""/Users/paulthornton/Documents/GitHub/iot-bridge/node_modules/zod/lib/ZodError"").ZodIssue'.
                                                Type 'ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodIssue'.
    386 |       if (lockEventResult) {
    387 |         this.pubsubService.publishState(
  > 388 |           AxaSchema.StateMessage,
        |           ^^^^^^^^^^^^^^^^^^^^^^
    389 |           AxaDto.newStateMessage(
    390 |             payload.imei,
    391 |             {
```

I can provide more details if the cause isn't immediately obvious.
",,
1805042689,2580,Email Validation Hangs at 100% CPU usage,"Hello,

I came across an issue with the email validation for a specific input string (a long and complex email address).
When attempting to validate/parse the string, the process immediately goes to 100% CPU usage, and never actually finishes parsing. I have waited for ~15 minutes max.
 
Here's some code to reproduce, which also shows 2 other RegExes for which the problem doesn't occur:

```typescript
import {z} from ""zod""

const email = ""noreply1@1-90y790o645vz81zq6287dhb9x1x28ab4q521nuv7b1og4y9c3q.5r-h8uter0.sc016.case.sandbox.salesforce.com""

const otherRegex1 = /[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/gi
const otherRegex2 = /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/gi

console.log(otherRegex1.test(email)) // true
console.log(otherRegex2.test(email)) // true

const parsed = z.string().email().parse(email) // hangs at 100% CPU

console.log(parsed) // never reached
``` 

![Screenshot 2023-07-14 at 10 58 23â€¯AM](https://github.com/colinhacks/zod/assets/13756082/63d01f8a-4f6c-44c7-93c9-63a7083541b8)


Using Zod `v3.21.4`
on a 2023 M2 Macbook Pro",,
1803318259,2576,Huge output `.d.ts` files when using `.catchall` with `.passthrough`,"After upgrading from `zod@3.21.0` to `zod@3.21.4`, output `.d.ts` files for schemas combining `.catchall` with `.passthrough` grew exponentially - on our project for one particular schema it exploded **from 350 lines to 70k lines**

This is a problem because it causes worse compile performance & GC failures when using tools like webpack.

You can check out a sample case to reproduce the error here (the repo also contains the comparison of output declaration sizes for different errors): https://github.com/vmajsuk/zod-d-ts-regression",,
1800532500,2573,Intersection between `z.object` and `z.record` incorrectly merges validators,"When intersecting a `z.object` and a `z.record`, zod applies validators for the keys and values of the record to the rest of the object. 

```typescript
const ConfigSchema = z
  .object({
    name: z.object({
      first: z.string(),
    }),
  })
  .and(
    z.record(
      z.enum(['a', 'b']),
      z.object({
        sub: z.string(),
      })
    )
  );

const validInput: z.infer<typeof ConfigSchema> = { // typescript type is correct and doesn't complain here ðŸ‘
  name: {
    first: '',
  },
  a: {
    sub: '',
  },
};

ConfigSchema.parse(validInput);
// ^ this throws 2 errors because:
// 1. 'name' doesn't match ['a', 'b']
// 2. 'name.sub' is required (even though this will never exist)
```
<img width=""185"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/34844898/90ce3c93-ec39-4357-a782-a0f0928f3e2e"">

**[Reproduction URL: stackblitz.com](https://stackblitz.com/edit/typescript-dauayd?file=index.ts,package.json)**

**Expected behavior:** validators for record keys and values should only apply to the record.

The same problem occurs with intersections of records that have native enum keys and template literal keys (eg. `[key: dynamic/${string}]`). ",,
1798036752,2569,Creating discriminated unions from functions,"```typescript
export const Parent = (id: string, ...ids: string[]) => {
  const toObj = (i: string) =>
    z.object({
      type: z.literal(`${i}_id`),
      [`${i}_id`]: z.string()
    });
  return z.discriminatedUnion(""type"", [toObj(id), ...ids.map(toObj)]);
};

const P = Parent(""system"", ""user"");
type P = z.infer<typeof P>;
//   ^? { [x: string]: string; type?: `${string}_id` | undefined }

const P2 = z.discriminatedUnion(""type"", [
  z.object({
    type: z.literal(""system_id""),
    system_id: z.string()
  }),
  z.object({
    type: z.literal(""user_id""),
    user_id: z.string()
  })
]);
type P2 = z.infer<typeof P2>;
//   ^? { type: ""system_id""; system_id: string; } | { type: ""user_id""; user_id: string; }
```

I am expecting the types, P and P2, to be identical

Maybe @conorbrandon will know :D",,
1797755484,2567,Extending discriminated union types,"In Typescript I can do something like this:

```typescript
type Nestable =
  | {
      has_children: false;
    }
  | {
      has_children: true;
      children: [string, ...string[]];
    };
```

and compose that with other types:

```typescript
type Prototype = {
  object: ""block"";
  id: string;
  created_at: Date;
  updated_at: Date;
};

export type Block = Prototype & Nestable;
```

such that I will get compile errors if I declare a block object like so:

```typescript
const b: Block = {
  object: ""block"",
  id: ""xxx"",
  ...
  has_children: false,
  children: [""yyy""] // <-- error: ""children"" does not exist on type
};
```

With zod, I can't achieve this in a similarly composable way. I can use discriminated unions to achieve the same type checking, but then I lose the ability to compose that type with other types.

```typescript
const Nestable = z.discriminatedUnion(""has_children"", [
  z.object({
    has_children: z.literal(false)
  }),
  z.object({
    has_children: z.literal(true),
    children: z.string().array()
  }),
]);

const Prototype = Nestable.extend({  // <-- error: property 'extend' does not exist on type ...
  // similar zodified schema declaration
});
```

I can do it slightly differently and make each type _in the discriminated union_ extend Prototype, but that is annoying. And still leaves me with an un-extendable ""final type"" (which is of type z.ZodDiscriminatedUnion<...>

I'm not requesting anything specific, unless there are features in flight that might make this easier to do, but rather looking for suggestions on how to implement such types with zod.",,
1797705065,2566,Better type inference for arrays,"```typescript
// This is what I want:
type A = [string, ...string[]];

const A = z.array(z.string()).min(1);
// But this is what I get
type  Z = z.infer<typeof A>; // string[]
```",,
1797157826,2565,Wrong infered type when using passthrough with an array?,"Is there a reason why it doesn't just infer to: `Array<{ foo: string; } & { [k: string]: unknown; }>`

```ts
import { z } from 'zod'

type Passthrough = z.infer<typeof passthrough>
//  { foo: string; } & { [k: string]: unknown; }
const passthrough = z.object({ foo: z.string() }).passthrough()

type PassthroughWithArray = z.infer<typeof passthroughWithArray>
// z.objectOutputType<{ foo: z.ZodString; }, z.ZodTypeAny, ""passthrough"">[]
const passthroughWithArray = z.object({ foo: z.string() }).passthrough().array()

type PassthroughWithArray2 = z.infer<typeof passthroughWithArray2>
// z.objectOutputType<{ foo: z.ZodString; }, z.ZodTypeAny, ""passthrough"">[]
const passthroughWithArray2 = z.array(z.object({ foo: z.string() }).passthrough())
```

repro:
https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgFBkwCeYApnAAoCGAzizABY4CuA5h3AC8KAHTAAdplpQAPNToRMcMK3ZcIfDgD4yAel1xDRwwD0A-GQDGEce2WrOPfkNEQARgCtalmAAokmBAQAFyi7FASvL4AlOjRIipsjhr8MRTy9MxJ6poA6sCcAIJQUExULshiktJyNLSK9tlOHPlFJWU6+sbG5lY2dolqza0cxaXlwpXuXj7+WEGhleGRMXEJDjmp8UztVGmUdYwbwwWjuwBMFVVSshkNg8l5p2Nl550G3aYW1rbwD5stZ4XK47ca+Kaebx+AILMIwCLiKKxNDxf7NGLRIA",,
1796657921,2564,Incorrect ZodCatch Output type,"The `Output` type of `ZodCatch` is currently set to `unknown`. Consider the following:

```ts
import { z } from 'zod';

type ParentSchema = z.infer<typeof parentSchema>; // type ParentSchema = { property: string }

const parentSchema = z.object({
  property: z.string(),
});

type ChildSchema = z.infer<typeof childSchema>; // type ChildSchema = { property: string }

const childSchema = parentSchema.extend({
  property: z.string().catch(''),
});

declare let p1: ParentSchema;
declare let p2: ParentSchema;
declare let c1: ChildSchema;
declare let c2: ChildSchema;

p1 = c1; // Works
c2 = p2; // Works

declare function testSchema(schema: z.Schema<ParentSchema>): void

testSchema(childSchema); // Doesn't work
```

When trying to call `testSchema(childSchema)` the following Error is thrown:

```
Argument of type 'ZodObject<{ property: ZodCatch<ZodString>; }, ""strip"", ZodTypeAny, { property: string; }, { property?: unknown; }>' is not assignable to parameter of type 'ZodType<{ property: string; }, ZodTypeDef, { property: string; }>'.
  The types of '_input.property' are incompatible between these types.
    Type 'unknown' is not assignable to type 'string'.ts(2345)
```

It appears that the `Output` type of `ZodCatch` should be `any`.

Related https://github.com/colinhacks/zod/issues/1816",,
1795797654,2563,Problems with typing of `error.format()` of discriminated union ,"<img width=""700"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/26056783/96ffdf84-161c-4a61-827f-10b0cc22082c"">

Here we define a discriminated union, and try to get the typing of `error.format()`. However, the typing seems broken and we cannot get to the error of each case. Also, `f.tag` is typed as `{}`, which is too general.

<img width=""531"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/26056783/c8cc1eba-6249-42e2-9aa3-82034f022269"">


Reproduction on codesandbox:

https://codesandbox.io/s/problems-with-typing-of-error-format-of-discriminated-union-l2c68d?file=/index.ts",,
1793453168,2561,z.string().nullish() throws an error on undefined value,"I upgraded `zod` to `3.21.4` and the validation `zod.string().nullish().optional()` started to fail with the error:
```typescript
{
    code: ""invalid_type"",
    expected: ""string"",
    message: ""Required"",
    path: [""myField""],
    received: ""undefined""
}
```

It can be circumvented by transforming the value:
```
.transform(value => {
     return value ? value : null;
})
```",,
1793106443,2560,z.or() typescript is wrong,"Hey,

With this code:

```ts
const airportSchema = z
  .object({
    id: z.number().int().positive(),
  })
  .or(airportsStoreSchema.body);

const body = z.object({
  company: z.string().min(2).max(255),
  state: z.nativeEnum(States),
  lta: z.string().min(2).max(255),
  flightNumber: z.string().min(2).max(255),
  departureTime: z.coerce.date(),
  arrivalTime: z.coerce.date(),
  handOverTime: z.coerce.date().optional(),
  expeditor: z.string().min(2).max(255),
  weightLimit: z.number().min(0),
  volumeLimit: z.number().min(0),
  quantityLimit: z.number().min(0),
  departureAirport: airportSchema,
  arrivalAirport: airportSchema,
});
```


I should be able to call `flight.departureAirport.id` and `flight.departureAirport.name` which is inside airportsStoreSchema.body but typescript tells me that .id doesn't exist.
",,
1792210943,2558,"`z.union` parse method is not doing schema validation first, instead is throwing union error.","I think the point of z.union would be to keep the parser's behavior - that is, to throw the error - but not to ignore the validation of the schema first.

Example:
```ts
import { z } from 'zod';

const baseSchema = z.object({
  amount: z
    .number({ required_error: 'Amount must be provided' })
    .positive({ message: 'Amount should be a positive number' })
    .finite(),
});

const schema = baseSchema.or(z.array(baseSchema)); // could be z.union too, same result.

// those two work normally
console.log(
  schema.parse({
    amount: 20,
  })
);

console.log(
  schema.parse([
    {
      amount: 20,
    },
    {
      amount: 20,
    },
  ])
);

try {
  console.log(
    schema.parse({
      amount: 0,
    })
  );
} catch (err) {
  console.log(err.issues); // OK: Amount should be a positive number
}

try {
  console.log(
    schema.parse({
      amount: undefined,
    })
  );
} catch (err) {
  console.log(err.issues); // Wrong?: Invalid input
}
```
cc: @ramos-ph",,
1792130487,2557,package types seem to be incorrect in node16 and nodenext,"First of all thanks for the amazing library!

According to [attw](https://arethetypeswrong.github.io/?p=zod%403.21.4) `zod` has incorrect types for both moduleResolution `node16` and `nodenext`.

This is because you are exporting only one set of types (CJS in this case) when you should be exporting types for both ESM **and** CJS.

This is further explained in this [tweet](https://twitter.com/atcb/status/1634653474041503744).",,
1791256791,2555,missclick,ddd,,
1790883651,2554,[feat] Cloning an object schema while stripping some props,"I did not find any api for this, so i built it. it's not very clean but serves the purpose well. Please instruct if there's better way to do this:

```ts
import { z, ZodObject } from ""zod"";

type Cloned<T, K extends string | number | symbol> =
  T extends ZodObject<infer Shape, infer UnknownKeys, infer Catchall, infer Output, infer Input>
    ? ZodObject<Omit<Shape, K>, UnknownKeys, Catchall, Omit<Output, K>, Omit<Input, K>>
    : never

export function cloneSchema<
  T extends ZodObject<any>,
  K extends (keyof T['shape']),
>(schema: T, without: K[] = []) {
  const shape = Object.fromEntries(
    Object.keys(schema.shape)
      // @ts-ignore
      .filter(key => !without.includes(key))
      .map(key => [key, schema.shape[key]])
  )

  return z.object(shape) as Cloned<T, K>
}
```

usage:

```ts
const userSchema = z.object({
  userId: z.string(),
  email: z.string(),
})

const onlyEmail = cloneSchema(userSchema, ['userId'])
```",,
1790794684,2553,[feat] `z.string().regex(regex).transform_regex_groups()`,"Related 

https://github.com/colinhacks/zod/issues/2552

```ts
const schema = z
  .union({
    ax: z.string().regex(aregx).transform_regex_groups().brand<{ ay: AOpaque }>(),
    bx: z.string().regex(bregx).transform_regex_groups().brand<{ by: BOpaque }>()
  })
  .transform_union_scenario()

type expected = { scenario: 'ax'; value: { ay: AOpaque } } | { scenario: 'bx'; value: { by: BOpaque } }
const parsed: expected = schema.parse(val)
```",,
1790779792,2552,[feat] `z.union(union).transform_union_scenario()`,"```js
const schema = z.union({
  a: z.string().regex(regex_a),
  b: z.string().regex(regex_b)
}).transform_union_scenario()

const parsed = schema.parse(val) // {scenario: 'a', value: '...'} |  {scenario: 'b', value: '...'}
```
",,
1790772466,2551,Passing array to .endsWith,"I want to validate emails from certain domains , example `yahoo.com, gmail.com, outlook.com`. Using `.endsWith` works perfectly for 1 domain but what if I want to validate it for all 3 domains? I can't pass an array of valid domains to `.endsWith`. 

Does `.endsWith` support array or just string?",,
1790729810,2550,Intersections can result in duplicate errors,"An intersection like this
```typescript
const schema = z
  .object({ packageCount:  z.coerce.number().optional() })
  .and(z.object({ packageCount:  z.coerce.number().optional() }))
schema.parse({ packageCount: 'asd' })
```
will result in 2 invalid_type errors instead of just one.

Obviously this is a contrived example, but I'm doing something like this in real code so that I can apply a `refine()` to one part of the union (see https://github.com/colinhacks/zod/issues/2524#issuecomment-1622897861)",,
1790186648,2548,Feature Proposal: Functionalities for adding label and example(s),"# Feature Proposal: Functionalities for adding label and example(s)
## Introduction

This proposal aims to introduce new functionalities to Zod, drawing inspiration from the capabilities of Joi. The proposed enhancements will allow users to assign labels as well as ability to set or add input examples. The primary objective of these enhancements is to augment Zod's capabilities, enabling the extraction of vital data necessary for tasks such as constructing OpenAPI specifications.

## Detailed Description
### 1. Setting name [^1][^3]
The proposed feature will allow users to set names for their schemas. This will provide more context about the data and make it easier for developers to understand the purpose of each schema.

In style of [.describe](https://zod.dev/?id=describe#describe) I propose the following:

#### `.name`
Use property `name` via the constructor to add a `name` property to the resulting schema.

```ys
const namedString = z
  .string({ name: ""NamedString"" });
documentedString.name; // NamedString
```

This can be useful for documenting a field, for example in a JSON Schema using a library like [zod-to-json-schema](https://github.com/StefanTerdell/zod-to-json-schema)).

This property is available in the error map when generating error messages.

### 2. Setting and Adding Example(s) [^2][^4]
In addition to setting descriptions and labels, the proposed feature will also allow users to set or add examples of input. This will provide a practical illustration of how the schema should be used, making it easier for developers to understand and implement.

In style of [.describe](https://zod.dev/?id=describe#describe) I propose the following:

#### `.exemplify`
Use `.exemplify()` to add add an `examples` property to the resulting schema.

```ts
const exampleString = z
  .string()
  .exemplify(""Some example"");
documentedString.examples; // ['Some example']
```

```ts
const exampleString = z
  .string()
  .exemplify(""Some example"", ""Another one"");
documentedString.examples; // ['Some example', 'Another...
```

This can be useful for documenting a field, for example in a JSON Schema using a library like [zod-to-json-schema](https://github.com/StefanTerdell/zod-to-json-schema)).

## Benefits
The foremost benefit of this proposal is the enhanced ability to extract data from Zod. This is crucial for tasks such as building OpenAPI specifications. By providing more context about the data (through descriptions and labels) and practical examples of use, developers will find it easier to understand and use the schemas. This, in turn, will lead to more efficient development processes and higher-quality output.

## Conclusion
The proposed enhancements to Zod, inspired by Joi, will significantly improve the platform's functionality and usability. By allowing users to set labels and examples of input, we can make Zod more intuitive and effective for developers. This will ultimately lead to better data extraction capabilities, which is crucial for tasks such as building OpenAPI specifications.

## Earlier proposals

- #1439
- #1767 
- #1443
- #1902
- #2387

## Pull Requests made

- #2549  

----

Points of discussion

1. Do we need a property for `notes`?[^5]
2. Do we need a property for `tags`?[^6]
3. Do we need a property for `unit`?[^7]

[^1]: For `name` we need other words, as the function cannot be the same as the property being set.
[^2]: I am open for using another term.
[^3]: Inspired by https://joi.dev/api/?v=17.9.1#anylabelname
[^4]: Inspired by https://joi.dev/api/?v=17.9.1#anyexampleexample-options
[^5]: Inspired by https://joi.dev/api/?v=17.9.1#anynotenotes
[^6]: Inspired by https://joi.dev/api/?v=17.9.1#anytagtags
[^7]: Inspired by https://joi.dev/api/?v=17.9.1#anyunitname",,
1787809031,2547,Transformer should have a different style with schema,"Day 1 on zod.

At my first glance, I thought `z.string().trim()` is schema for trim-ed string.

```js
// validations
z.string().max(5);
z.string().min(5);
z.string().length(5);
z.string().email();
z.string().url();
z.string().emoji();
z.string().uuid();
z.string().cuid();
z.string().cuid2();
z.string().ulid();
z.string().regex(regex);
z.string().includes(string);
z.string().startsWith(string);
z.string().endsWith(string);
z.string().datetime(); // defaults to UTC, see below for options
z.string().ip(); // defaults to IPv4 and IPv6, see below for options

// transformations
z.string().trim(); // trim whitespace
z.string().toLowerCase(); // toLowerCase
z.string().toUpperCase(); // toUpperCase
```

Or Suggest 1

```js
import { z } from ""zod/schema-only-no-transform"";


// @ts-expect-error: Property 'trim' does not exist on z.string()
z.string().trim()

```

Or Suggest 2

-  `z.XXX()` are schema,  `z.string().trim()` is schema to match trim-ed string

-  `Z.transform.XXX` are transformer,  `z.string().transform.trim` is schema to match string, and do string-trim transform





",,
1786361446,2546,"Use of ParseReturnType<T> instead of SyncParseReturnType<T> as param for isAborted, isDirty and isValid, isAsync util functions","I'm new to the codebase, was going through the parseUtil helper functions, found that a bunch of type predicate functions were accepting the broader `ParseReturnType` type and consequently needing to use `as any` before checking the status when it seems the `SyncParseReturnType` type would be narrower and avoids using `as any`:

```export type INVALID = { status: ""aborted"" };
export const INVALID: INVALID = Object.freeze({
  status: ""aborted"",
});

export type DIRTY<T> = { status: ""dirty""; value: T };
export const DIRTY = <T>(value: T): DIRTY<T> => ({ status: ""dirty"", value });

export type OK<T> = { status: ""valid""; value: T };
export const OK = <T>(value: T): OK<T> => ({ status: ""valid"", value });

export type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;
export type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
export type ParseReturnType<T> =
  | SyncParseReturnType<T>
  | AsyncParseReturnType<T>;

export const isAborted = (x: ParseReturnType<any>): x is INVALID =>
  (x as any).status === ""aborted"";
export const isDirty = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> =>
  (x as any).status === ""dirty"";
export const isValid = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> =>
  (x as any).status === ""valid"";```

Is there any reason why it was done this way?",,
1786198087,2545,Alias `z.infer` to `z.Infer`?,"Given that Infer is a type, are you open to aliasing it to a pascal-cased alternative? Similar for `z.input` and `z.output`?",,
1785585036,2543,Put typeName into `ZodTypeDef` interface,"As we see here: https://github.com/colinhacks/zod/blob/master/src/types.ts#L56 `ZodTypeDef` only has `errorMap` and `description` but if check interfaces that extends `ZodTypeDef` we see that all of them have `typeName: ZodFirstPartyTypeKind` so why canâ€™t we put typeName as property of `ZodTypeDef` ?

i also experience a problem when trying to programmatically explore zod schema at runtime like this:
```
declare const someSchema: ZodSchema;
console.log(someSchema._def.typeName; // getting ts error here
```
While we always know that `typeName` will be present in every zod typeâ€¦",,
1782592702,2540,Error when validating an existing email with hyphen (-) symbols when having a subdomain,"Hi,

I'm getting a strange error when parsing an email that contains a hyphen (-) when having a subdomain:

Example of a valid email:
```bash
me@.main-domain.com # works
me@subdomain.maindomain.com # works
me@subdomain.main-domain.com # error
```

Error:
```
Invalid data: ZodError: [
  {
    ""validation"": ""email"",
    ""code"": ""invalid_string"",
    ""message"": ""Invalid email"",
    ""path"": [
      ""email""
    ]
  }
]
```

This started happening when upgrading from `3.20.x` to `3.21.x`

The only I could think about was to use a Regex instead:
```
z.string().regex(/^[a-zA-Z0-9_!#$%&â€™*+/=?`{|}~^.-]+@[a-zA-Z0-9.-]+$/)
```

Any ideas or workaround on it? ",,
1781759398,2537,schema.shape[key].parse(value) not infering correctly when typeof key is a key of the schema.,"This is what happens:
![image](https://github.com/colinhacks/zod/assets/38871879/fc044357-c6b7-43f2-9439-48eb961f23eb)

A workaround (besides using the generic to manually set type) is using pick and then getting the value using the key:
![image](https://github.com/colinhacks/zod/assets/38871879/46f8370b-ab62-42be-b18d-3bae314fb67b)

But either way it's not expected behaviour.

Code example:
```ts
import { prisma } from ""@/prisma"";
import { z } from ""zod"";

const globalSettingsSchema = z.object({
  fee: z.number(),
  hello: z.string().optional(),
});
export type globalSchemaType = z.infer<typeof globalSettingsSchema>;

export async function getSetting<K extends keyof globalSchemaType>(key: K) {
  const setting = await prisma.globalSettings.findUniqueOrThrow({
    where: {
      key,
    },
  });
  const parsedValue = JSON.parse(setting.value);
  // const result = globalSettingsSchema.pick({ [key]: true }).parse(parsedValue);
  // return result[key];
  const result = globalSettingsSchema.shape[key].parse(parsedValue);
  return result //as globalSchemaType[K];
}
```",,
1781434417,2535,Feature: Filter out error parsed variables,"**User story**
Say I'm calling an API, which returns a bunch of data from a backend that hasn't always been properly maintained. The data is returned in an array of objects. I want a function to filter out the objects that aren't compliant with the schema and returns only the data that can be parsed.

**Example**
In this case, I created an example function `parseFilter`
```javascript
// Array returned from backend:
const data = [
    {
        name: ""Foo"",
        email: ""foo@bar.com""  
    },
    {
        name: ""Foo"",
        phone: ""12345678"",
        email: ""foo@bar.com""  
    },
]

// Define schema
const userSchema = z.object({
    name: z.string(),
    phone: z.number(),
    email: z.string().email()
});

// Parse schema but filter out objects that doesn't parse:
userSchema.parseFilter(data)
// returns
// [
//     {
//         name: ""Foo"",
//         phone: ""12345678"",
//         email: ""foo@bar.com""  
//     },
// ]
```

**Details**
I'm unsure what the return type should be, if the array contains 0 parsed items. Should it then return an empty array, null/undefined or throw an error?",,
1779125805,2534,Nested union of tuples is not recognised as an iterable,"Something appears to have broken in `3.21.2`. The following reproduction shows the problem: https://codesandbox.io/s/hopeful-golick-q5lx85?file=/src/index.tsx

```ts
import { z } from ""zod"";

const TupleUnion = z.union([
  z.tuple([z.string()]),
  z.tuple([z.string(), z.string()])
]);

const Schema = z.object({
  breaks: TupleUnion,
  works: z.tuple([z.string(), z.string()])
});

type Schema = z.infer<typeof Schema>;
type TupleUnion = z.infer<typeof TupleUnion>;

function parse(s: Schema, bt: TupleUnion) {
  const [a, b] = s.breaks;
  const [c, d] = s.works;
  const [e, f] = bt;
}
```

Somehow TypeScript doesn't know that the returned tuple is iterable. I'd expect the array destructuring to work as expected here. Note how the case with `TupleUnion` by itself works, but when nested inside `z.object` it breaks.

This is the error reported by TypeScript:

```
Type '[string] | [string, string]' must have a '[Symbol.iterator]()' method that returns an iterator. ts(2488)
```

It appears to be dependant on that specific `tsconfig.json`, I'm not sure exactly what is causing the problem here.

These are the versions:
TypeScript: `5.1.3`
Zod: `3.21.2` (verified to break in both `3.21.3` and `3.21.4`)

These are the compiler options set in `tsconfig.json`:

```json
""compilerOptions"": {
  ""lib"": [
    ""dom"",
    ""dom.iterable"",
    ""esnext""
  ],
  ""strict"": true,
  ""alwaysStrict"": true,
  ""strictBindCallApply"": true,
  ""strictFunctionTypes"": true,
  ""strictNullChecks"": true,
  ""allowJs"": false,
  ""skipLibCheck"": true,
  ""noImplicitAny"": true,
  ""noImplicitThis"": true,
  ""forceConsistentCasingInFileNames"": true,
  ""esModuleInterop"": true,
  ""module"": ""esnext"",
  ""moduleResolution"": ""node"",
  ""resolveJsonModule"": true,
  ""isolatedModules"": true,
  ""downlevelIteration"": true,
  ""noUncheckedIndexedAccess"": true,
  ""incremental"": true,
  ""target"": ""es2019"",
  ""jsx"": ""preserve"",
  ""noEmit"": true,
  ""exactOptionalPropertyTypes"": false,
  ""strictPropertyInitialization"": false
}
```",,
1776752498,2531,[features] add frendlyname in zodType.,"Hi,

I have started to `overZod` my projects. So I have lots of Zod types.

I'm now implementing some custom formatting code to report my zod rejection, but to make them easier to read, I'm adding an extract of the parsed data and a unique name of my zod type.

For the parsed data, I use a custom method to update the error message and include part of the incoming data, but I do not see any non-over-boilerplate way to add a friendly name to my types.

It would be nice to add something like that:

```ts
export const LoginPostModel = z.object({
  email: z.string().email(),
  password: z.string().max(50),
}).friendly(""Login Post control input"");
```

And maybe add a reference to the parsed data in the ZodError.

Feel free to add your point of view.",,
1774810990,2530,Why haven't we dropped a new release?,"It's been a long time since the last `zod` release (almost 4 months), and there are a lot of useful changes since the last version.

Are we waiting until we complete something specific?",,
1774236504,2529, The performance drops rapidly during error checking,"I write a simple validate schema
```ts
const stringSchema = z.object({
  data: z.string(),
});

suite
  .add(""valid"", () => {
    stringSchema.safeParse({ data: """" });
  })
  .add(""invalid"", () => {
    stringSchema.safeParse({ data: 123 });
  })
  .on(""cycle"", (e: Benchmark.Event) => {
    console.log(`${SUITE_NAME}: ${e.target}`);
  })
  .on(""complete"", function () {
    const fastest = this.filter(""fastest"").map(""name"");
    const slowest = this.filter(""slowest"").map(""name"");
    const ratio = this.filter(""fastest"").map((result: any) => {
      return result.hz / this.filter(""slowest"").map(""hz"")[0];
    })[0];

    console.log(`Fastest is ${fastest}`);
    console.log(`Slowest is ${slowest}`);
    console.log(`Ratio is ${ratio.toFixed(2)}x`);
  })
  .run();
```

<img width=""768"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/32590310/1d83bddc-431d-46cf-9818-5c0da5934c48"">


Is there any way to solve it with error checking? it's too slow

",,
1772048500,2528,Is there any way to specify a minimum record count in z.record?,"If I could specify a minimum number of records then I wouldn't get `possibly undefined` errors when using these records.

```ts
export enum NetworkNames {
    development = 'development',
    staging = 'staging',
    production = 'production',
}

const NetworkNamesSchema = z.nativeEnum( NetworkNames )

export const NetworkConfigSchema = z.record(
    NetworkNamesSchema,
    z.object( {
        endpoint: z.string().url(),
    } ).required()
).min( 1 ) // <--------------------------- something like this
```

Even when I specify a `.default` on the end of the `.record`, TS doesn't realise that there will be a value in the NetworkConfigSchema.",,
1769449743,2526,z.string().datetime() accepts invalid timestamp values,"`z.string().datetime()` values where both month and day values are out of range are incorrectly parsed successfully.

https://codesandbox.io/s/practical-hill-t8s9qj?file=/src/index.ts

```ts
import { z } from ""zod"";

const invalid = ""2023-13-13T17:45:07.289Z""; // 13th month and 13th day should be prohibited
const valid = ""2023-12-13T17:45:07.289Z""; // 12th month, 13th day should be allowed

console.log(z.string().datetime().safeParse(invalid).success); // true, should be false
console.log(new Date(invalid)); // Invalid Date, as it should be
console.log(z.coerce.date().safeParse(invalid).success); // false, as it should be. Using using this in addition to string().datetime() can serve as a workaround

console.log(z.string().datetime().safeParse(valid).success); // true, as it should be
console.log(new Date(valid)); // Wed Dec 13 2023 17:45:07 GMT+0000 (Greenwich Mean Time), as it should be
```
",,
1767515075,2525,How to discard paricular field in `.refine()` or somewhere else without changing the schema?,"Re-use the example in #2524:
https://stackblitz.com/edit/vitejs-vite-c6cz55?file=src%2FApp.tsx

In the example above, I first entered something in `passport`, then switched to `driver_license`, but when I submit the form, the value of `passport` is there as well.

I know this is expected since I defined it in the schema, just want to know whether there's a way to get around?

The discarding totally satisfies the schema, since both `passport` and `driver_license` is `optional`, hence discarding them won't break the type.

I'm aware that I can use `z.discriminatedUnion()` for this particular case, but it's not really my preferred solution, as in the real-world case, the complexity of the form is ridiculous, where usage of `Discriminated Union` will only make the schema even harder to organize in my opinion.

And I want the interface to looks like a simple single one instead of complex `intersection` with `discriminated union`

```ts
// This is what I need
interface User {
  name: string;
  age: number;
  id_type: 'passport' | 'driver_license'
  driver_license?: string;
  passport?: string;
}
// Instead of
type User = {
  name: string;
  age: number;
} & ({
  id_type: 'passport';
  passport: string;
} | {
  id_type: 'driver_license'
  driver_license: string;
})
// Or
type User = {
  id_type: 'passport';
  name: string;
  age: number;
  passport: string;
} | {
  id_type: 'driver_license';
  name: string;
  age: number;
  driver_license: string;
}
```  

![image](https://github.com/colinhacks/zod/assets/45784210/beda643b-2ad9-48da-919f-d36e2f9353bf)

In `yup`, I can still do `transform` after `when` condition (e.g. transform to `undefined`), can I do something similar like conditionally discard a field in `.refine()` or `.superRefine()` in `zod`? I currently can't find a way to do so.

---

Or, as another solution, is it possible to make a new feature that removes all `falsy` value or any specified value during parse? e.g. Automatically remove empty string `''`",,
1766737992,2524,"[Feature request] An option to always execute `refine`s even if parse failed, or workaround","This is a simple form, with `zod` and `react-hook-form`, using `@hookform/resolvers` for integration.
Reproduction link: https://stackblitz.com/edit/vitejs-vite-c6cz55?file=src%2FApp.tsx

This is an issue we've been talking about for a while... as in #479, #1394 and many other places... But I can't really find an ultimate solution for this.

So as part of my example, the validation schema is like this:
```ts
const schema = z
  .object({
    name: z.string().min(1),
    age: z.string()
      .transform((val) => (val ? +val : val))
      .pipe(z.number().min(18)),
    id_type: z.enum(['passport', 'driver_license']),
    passport: z.string().optional(),
    driver_license: z.string().optional(),
  })
  .refine(
    ({ id_type, passport }) => (id_type === 'passport' ? !!passport : true),
    { path: ['passport'], message: 'passport is required' }
  )
  .refine(
    ({ id_type, driver_license }) => id_type === 'driver_license' ? !!driver_license : true,
    { path: ['driver_license'], message: 'driver_license is required' }
  );
```

So in my reproduction, what I'm expecting is, once you click ""Submit` button, all error messages should appear, including the ""passport"" one (by default if you don't select driver license).

But due to `name` and `age` are not entered at all (i.e. value is `''` as the default value defined), hence it will halt and `.refine()` won't be executed at all.

I'm aware there's a concept called `stopping` or `non-stopping` issue (e.g. `invalid_type` compared to `too_small`), hence if I enter something like just a `1` in the age input box, the `refine`s will be triggered. I also know it's due to type-safety purposes and I respect that...

But in the real-world use case, most likely it's not going to work like that. Apparently, I want to show all the error messages even if nothing is filled. This can be easily achieved by API like `yup.when()` but as @colinhacks clearly says it won't be part of `zod`, hence it's really a huge headache here.

---

One way to workaround is by `z.intersection()`, and define the `id_type` / `passport` and `driver_license`, as well as those `.refine()`s into another schema, but that's not really what I want. Although it works in particular cases, but it does break my expected typing system, e.g.
```ts
// When I can have something like this
type MyType = {
  foo: string;
  bar: string;
}
// Why do I have to do this?
type A = { foo: string };
type B = { bar: string };
type MyType = A & B;
```
And even worse, it's now a `ZodIntersection` instead of a `ZodObject` where I can't do something like `.pick()` / `.omit()` after that which is not good for extensibility.

---
Something to note:
- I can't use `z.merge()` there since `ZodObject` cannot be merged with `ZodEffect` (the return type of `.refine()`)
- Since `react-hook-form`'s resolver only accepts one single schema, so I'm not sure how the `.partial()` solution works, or maybe it's not working for this case at all
- `z.discriminatedUnion()` is NOT what I need:
  - It will break the object shape, the same as `z.intersection()`
  - A real-world form may contain lots of conditions, so using this on every conditions is awkward

---

I think this is the end of my explanation as everyone working on this kind of real-world form validation will run into this issue. Is there any chance we can have this feature (at least as an OPTION) implemented in `zod` or are there any better workarounds other than the awkward `z.intersection()`?

It's kinda a show-stopper for my migration from `yup` to `zod`... so I badly want a workaround without breaking the type (i.e. the final schema should still be a single object to align with my API)",,
1766601326,2523,Incompatibility with TypeScript 5.1.3 - discriminatedUnion,"### Description
I recently updated TypeScript from version 4.9.5 to 5.1.3 and I noticed that my code that uses `zod` is no longer working as expected. It seems that types are not being correctly extracted when using TypeScript 5.1.3.

### Code to reproduce the issue

Here is the code in which I define a `zod` type:

```typescript
import * as z from 'zod';

export const ZApiGatewayClientSchema = z.enum(['One', 'Two']);

const ZGetExampleBySelectorInputSchemaOne = z.object({
  gateway: z.literal(ZApiGatewayClientSchema.Enum.One),
  env: ZApiEnvironmentSchema,
  language: z.string().length(2).optional(),
  brand: z.string().optional(),
  bookingSystem: ZBookingSystemSchemaLegacy.optional(), // optional
});

const ZGetExampleBySelectorInputSchemaTwo = z.object({
  gateway: z.literal(ZApiGatewayClientSchema.Enum.Two),
  env: ZApiEnvironmentSchema,
  language: z.string().length(2).optional(),
  brand: z.string().optional(),
  bookingSystem: ZBookingSystemSchemaLegacy, // required
});

export const ZGetExampleBySelectorInputSchema = z.discriminatedUnion('gateway', [
  ZGetExampleBySelectorInputSchemaOne,
  ZGetExampleBySelectorInputSchemaTwo,
]);

export type TGetExampleBySelectorInputSchema = z.infer<
  typeof ZGetExampleBySelectorInputSchema
>;
```

And here is the code in which I attempt to extract the discriminated union using Extract:

```typescript
async getExampleBySelector(
  input: Extract<TGetExampleBySelectorInputSchema, { gateway: 'One' }>,
): Promise<ApiExampleResponseOne> {
  return await this.requestHotels(input);
}
```

This code worked correctly with TypeScript 4.9.5, but after updating to TypeScript 5.1.3, the types are not extracted correctly.

### Expected behavior
The types should be correctly extracted even after updating TypeScript to version 5.1.3.

### Actual behavior
The types are not correctly extracted after updating to TypeScript 5.1.3.

### Environment:
- TypeScript Version: 5.1.3
- Zod Version: 3.21.4
- Node Version: 18.15.0",,
1766287480,2521,Feature: merge issues of nested `SafeParseReturnType`s,"Thank you for reviewing this. I believe Zod is rather focussed on comprehensive error outputs, so hopefully this idea stands in good stead.

### Use case
Say I have a function which extracts data from the HTML of a webpage. This function uses zod to parse the data extracted from attributes/text nodes/JSON-LD/<script> etc.

This function is composed of utilities which are each responsible for more focussed extraction. These may utilise zod's `z.pipeline` and `z.transform` (i.e. the input is rather different to the output).

Not all of these utilities validate their result using `zod` and instead rely on validation from the parent which uses `.parse`.

### The Problem
As far as I'm aware, there is currently no established way of _chaining_ the results of parses together when you have parses _nested_ inside one another. Said another way, it's currently impractical to combine one parse result with something that parses that result.

### Current Solutions
1. Return a `parse` from utilities, allow the error to bubble up to a try-catch, losing any other issues that may have occured in the parent.
2. Perform a `safeParse` in utilities, and return `SafeParseReturnTypes.data` and some type which does not match the parent schema, losing original issue context and potentially allowing a false-positive if the parent schema is changed to permit this value which was intended to make the parent fail.
3. Perform a `safeParse` in utilities, and return `SafeParseReturnTypes.data` and `SafeParseReturnTypes.error`, potentially maintaining context (depending how the error is serialised), but with an undesired `invalid_type` issue trying to parse `ZodError` instance.
4. _(probably possible) some custom parsing logic_

### The Ideal
I would like to have a way to collect all the issues together, both from the nested utilities' parsings and the parent's parsing.

### Proposal
My initial idea is to treat `ZodError`s differently when being parsed, and merge the issues from that error in with the resultant `ZodError` from the parent parse. If an input being parsed contains a `ZodError` it will always fail parsing.

### Basic Code Example
Here's a stripped down example of what I'm talking about here:
```ts
const myUtility = (myHtml: string) => {
  // mySchema is some schema that helps with the extraction/parsing logic of the function
  // it could utilise `.transform` or `.pipeline` for example
  // and it's something which wants to be abstracted away
  const parseResult = mySchema.safeParse(myHtml);
  return parseResult.success ? parseResult.data : parseResult.error
}

const parseMyHtml = (myHtml: string) => {
  const myUtilityResult = myUtility(myHtml)
  // and other utilities

  return myFinalSchema.parse({
    foo: myUtilityResult,
    // ... and more
  });
}

declare const myHtml: string; // fetch a document

// expected to throw on fail, the error is captured and submitted to (e.g.) sentry for later debugging
const extractedData = parseMyHtml(myHtml);
```

For my proposal, the issues that arise from `myUtility` would be merged with any other issues from `parseMyHtml`.",,
1765805709,2520,"`z.coerce.string()` casts `undefined` to ""undefined"" string","Here are the rules:

```ts
{
  title: z.coerce.string(),
}
```
As you can see, the field ""title"" is required. But in case you don't pass it at all, `coerce` fills it with ""undefined"" and the validation passes. And later this ""undefined"" gets passed into the rest of the app's logic. ",,
1765667681,2519,`z.input<â€¦>` of coercibles should be `any`,"In this code â€¦

```ts
import { z } from 'zod'

const b = z.coerce.boolean()

type B = z.input<typeof b>
```

â€¦ `B` evaluates to â€¦

```ts
type B = boolean;
```

I expected `B` to evaluate to â€¦

```ts
type B = any;
```

If this is intended behaviour, I'd be happy if you could share your reasoning. Thank you. :pray: 

This is related to #2421.

zod version: v3.21.4",,
1765526293,2518,Using/building in packages,"I moved my zod types into a separate package.

However, when trying to use them, all the fields are now optional. Which is not how I defined them. For example,

### Definition
```ts
export const coordinates = z.object({
  latitude: z.number(),
  longitude: z.number(),
  elevation: z.number().optional(),
});
export type Coordinates = z.infer<typeof coordinates>;
```


### Output in `index.d.ts`
```ts
export declare const coordinates: z.ZodObject<{
    latitude: z.ZodNumber;
    longitude: z.ZodNumber;
    elevation: z.ZodOptional<z.ZodNumber>;
}, ""strip"", z.ZodTypeAny, {
    latitude?: number;
    longitude?: number;
    elevation?: number;
}, {
    latitude?: number;
    longitude?: number;
    elevation?: number;
}>;
export type Coordinates = z.infer<typeof coordinates>;
```

**Do you know what I should do when putting zod types in a separate package?** 

Thanks for zod!",,
1764535373,2516,"How do you pronounce ""zod""? ","I've encountered a slight issue regarding the pronunciation of ""zod"". While this may seem a minor point, I believe understanding the correct pronunciation will contribute to accurate communication when discussing the software in my community, which largely consists of non-native English speakers.

There's currently no phonetic guide or pronunciation key available in the software's documentation. Therefore, I kindly request some guidance on the matter. How should ""Zod"" be pronounced? If possible, could you provide this information in the International Phonetic Alphabet (IPA) or some other universally recognized format?",,
1764400882,2515,Supplying a name for refinements,"In order for a JSON-based de/serializer of Zod to serialize custom schemas/refinements, would you consider allowing passing in a refinement object which included the name of the refinement (or otherwise pass in a name) so that the custom name could be used by serialization and in turn by deserialization steps?",,
1764266746,2514,Invalid zod types in monaco editor,Not relative anymore...,,
1763029778,2513,Optional email string schema fails on parsing empty string,"Well... I think it's working as expected that an empty string fails on `z.string().email().optional()` since the design principal of `zod`, where `optional`  means `undefined` in TS rather than allowing an empty string at run time.

In `yup`, if you do something like `yup.string().email()` (It's optional by default, which is the run-time optional), it will success in parsing an empty string, but whatever... I'm sticking to `zod`

```ts
yup.string().email() // success with EMPTY STRING
```

One possible workaround I can think of and is working:
Note the `optional()` here is just to allow `undefined`, or in a form, more specifically just to add `undefined` to the type since I need to assign a default value to controlled input.
```ts
const emailSchema = z.string().max(0).or(z.string().email());
```
I mean.. although this works. but it's looking sooo weird... honestly. Is there any better alternative way to do so? Thanks.

https://stackblitz.com/edit/stackblitz-starters-zfd4c9?file=index.js


",,
1762759368,2511,How to tighten the type of a schema,"In `yup`, I can do something like this to tighten the type of a string schema simply:
```ts
type Foo = 'foo' | 'bar'

const a = yup.string<Foo>().required()
type A = yup.InferType<typeof a>
//   ^? Foo
```

But in `zod`, seems currently the only way I can achieve it is by `z.custom`? Is there any better alternative or more straight forward way to do so?
```ts
const b = z.custom<Foo>(str => typeof str === 'string' && ['foo', 'bar'].includes(str))
type B = z.infer<typeof b>
//   ^? Foo
```
And it's even worse if I want to make it optional... where I have to write more in the `check` function and invoke `optional()` just for the type, where it actually does nothing. Overall the whole thing seems weird.
```ts
const c = z.custom<Foo>(str => str === void 0 || typeof str === 'string' && ['foo', 'bar'].includes(str))
  .optional()
type C = z.infer<typeof c>
//   ^? Foo | undefined
```

There's actually another way, but way more chaos... (Look at that I need to write another `optional()` just for type inference which actually does nothing!)... This is a little bit disgusting to deal with. Compare to `yup`'s `yup.string<Foo>()`ðŸ˜¥. But I believe there should be an easier way right?

```ts
const d = z.string().optional()
  .refine(val => val ? ['foo', 'bar'].includes(val) : true)
  // Here I have to write "".optional()"" again otherwise it won't be in the final inferred type
  .pipe(z.custom<Foo>().optional());
type D = z.infer<typeof d>
//   ^? Foo | undefined
```

Also, the type of `check` function of `z.custom` is a little bit weird to me, like it's reasonable to make received `val` to be `unknown`, but why it's returning `any` instead of `boolean`? 

And also what's the usage of `.refinement()`? I can't find anything related in the documentation

---

https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAKjgQwM5wJ4FcxwGZQQhwDk2YJAUKJLHAN5wBecAvvocSUxACZWVKMDGACmcAGIQIcALyk80knAA+pAEbIoAygGMIAO1TxkczDgB0xqMAMBzADxSIAPgAUASgtRRARyzAPryeQiLiAIJm5BYAkgZ4olAAKmEOwmIQeCgulAD0uXCFAHoA-IJ6hsZw6mZMFrpYxkRO0u7Wci5w6aKZcO2yA6TWtnbKAGRjcADaJIoQJAA0GlokALoWtroANli8oqhu1h4eoWJwAEK1G-GJaWG96jn5hXClgvpG8LpXDU0gLa5DjAoB0+sC5IMAG4QYC8OAABlUam6vX6gxIw3s40mMzmi2W2nWmx2ewORxOhQsEDAMGAhmQWxC3TgAGErrYElA7hksrongVimV3pV4HD5HVMXZPFSaXSDAyQpSfHhbKI3JCGaCNVs4CVprMlEsSJpCddtrt9uqGR44AAuLpQLCiClwZ4ACUS4hicAAFshIeIYDIAO42GDiABEMtp9MZHgjKDsyFscAgMB9iWDwFQ4mA8GDhhI8HUuYMXQz+Fsmo5iSCXTClEpYGAYjcdV+Qf+zncXmpMflcY8AG5TuIACLsm5clFZXj8l5vIA",,
1762166459,2510,"[Source code digging] What's the purpose of `T extends [any, ...any[]]` rather than `any[]`?","I'm currently looking into this part, but found out this part is a little bit weird.

What's the purpose of `T extends [any, ...any[]]` rather than `T extends any[]` straight away? In other words, when will it match `[any, ...any[]]`? To me, the difference is non-empty arrays (or TUPLE?) and empty-able arrays, but I don't see a reason to separate them.

I've did some experimental here, where seems like any kind of `Array` will fall into `any[]`, and only `Tuple` will fall into `[any, ...any[]]`. I'm really confused about the purpose of doing this since usually we won't pass a tuple? Is this the intended design?
https://www.typescriptlang.org/play?#code/C4TwDgpgBAggPAFQHxQLxQVCAPYEB2AJgM5QDaAhviADRQB0jVIZAuqwLABQUUA-FACM3XgC4MWXARJRmbEb35QATArFQAzN24BjAPb5iwWQCcTacoLrK6Gzl32Hj+CEYiEYZi2Svkbm9l0DIywAWzBQTxNxfABXUIAjCBM2b3tuUEgoACELeAA5A3zYgBsSigSSiDhMiD0AM1MTJCRuAHo2xQA9Pm0uWqgAYTy4QvxisoqqmvA6xpc3DzMW9s7eHr6BgBERsYnyyurahrCIkCiVrg7u3q4+xxDgWLAq8TI4xOS6IxMAS3wAOasby+ADkylB6X6sygAFFdkVSgdpsdGk8XhBLtd1nwgA

I also found out that for `any[]`, we are not using `?` modifier, I'm aware it's because of TS limitation but I think `[K in keyof T]: T[K]` is pretty much the same as `[k: number]: T[number]` when `T extends any[]` matches, isn't it? hence why can't we use the same syntax as other two branches did to add the `?` modifier? Or is there any special intention here?

Or I can be wrong about above, hence can someone tell me what's happening there?
https://github.com/colinhacks/zod/blob/5e23b4fae4715c7391f9ceb4369421a034851b4c/src/ZodError.ts#L175-L185

---

This is trivial compared to the above one, but here's another place I'm confused about here in `util.ts`, I don't know why we have to force the array to be non-empty here (or is it matching non-empty TUPLE only?). If it's empty then simply return an empty object `{}` which is fine from my perspective.

https://github.com/colinhacks/zod/blob/5e23b4fae4715c7391f9ceb4369421a034851b4c/src/helpers/util.ts#L20-L28

---

Thanks a lot for anyone having a look at this. Appreciated.â¤",,
1759803541,2509,Factory function for create object schema with keys passed by args,"So, i have this example: 
```
function createSchema(keys: ZodRawShape){
 
    return z.object(keys);
}

const userSchema = createSchema({

    id: z.number(),
    name: z.string()
});

type UserSchemaType = z.infer<typeof userSchema>;

const u1: UserSchemaType = {
    //Nothing inferred 
}
```

The type inference not works.. any though on this? Thx for help!",,
1759369714,2508,Can I name my project ZodBus?,"Hey, thank you for Zod; it's great and we all love it.

I'm building an event bus that uses Zod to define the schema, infer everything, and validate the data.
Is it ok with you if I call it `ZodBus`?

It's on https://github.com/3rd/zodbus, and I just published it to NPM as `zodbus`, so that the name won't get sniped by trolls.

https://github.com/3rd/zodbus/assets/59587503/08d2c13c-cccd-407f-b14c-957d7dd5115d",,
1759147721,2507,Upgrading from 3.2.1 to 3.3.0 introduces breaking changes,"I believe that changing the `content` field to being optional is a breaking change. I'm using TypeScript so it's only breaking my build, but this is going to cause a ton of projects to start failing at runtime if the API is indeed leaving it out now.

// Version 3.2.1

```TypeScript

export interface ChatCompletionResponseMessage {
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    'role': ChatCompletionResponseMessageRoleEnum;
    /**
     * The contents of the message
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    'content': string;
}

```

// Version 3.3.0


```TypeScript

export interface ChatCompletionResponseMessage {
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    'role': ChatCompletionResponseMessageRoleEnum;
    /**
     * The contents of the message.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    'content'?: string;
    /**
     *
     * @type {ChatCompletionRequestMessageFunctionCall}
     * @memberof ChatCompletionResponseMessage
     */
    'function_call'?: ChatCompletionRequestMessageFunctionCall;
}
```",,
1755620642,2504,Support min/max on record,"This is very similar to the `min` and `max` of other types like `z.string`, `z.number` and `z.array`.

_On `z.record` this would validate number of entries of the record (including those explicitly undefined if the value schema permits)._

This wouldn't affect the input/output type at all, but it would be a nice feature as a schema validation tool.

Por ejemplo ðŸ”
```ts
const MySchema = z.record(
  z.string(),
  z.number().optional()
).min(1).max(2)

MySchema.parse({}) // âŒ
MySchema.parse({ foo: 1 }) // âœ…
MySchema.parse({ foo: 1, bar: 2 }) // âœ…
MySchema.parse({ foo: 1, bar: undefined }) // âœ…
MySchema.parse({ foo: 1, bar: 2, baz: 3 }) // âŒ
MySchema.parse({ foo: 1, bar: 2, baz: undefined }) // âŒ
```

I've never made contributions here before, but I would very much like to give it a go if this feature is deemed desirable.",,
1755262891,2502,object.refine doesnt always detect unmatching fields,"Im using the following for password and confirm_password to check that the fields match: - 

```ts
const passwordCompoundField = z
  .object({
    password: PASSWORD,
    confirm_password: z.string().min(1, 'Required'),
  })
  .refine((data) => data.password === data.confirm_password, {
    message: ""The passwords didn't match. Please try again"",
    path: ['confirm_password'],
  });
```

This works fine in the usual scenario password is entered, confirmed password is entered (which doesnt match) and the error message will show under the confirm password field. However with the following scenario the error message doesnt show: - 

password: Example111
confirm_password~: Example11

Error message will show below confirm_password field

If i then amend the password field to the below: -

password: Example11
confirm_password~: Example11

The error message still remains.

To get the error to disappear i have to delete the last '1' from confirm_password then retype",,
1751353808,2499,[Feature Request] Pass in both original value and proprocessed value (by `coerce`) to `ErrorMapCtx` when defining error map,"Consider the following scenario:

I'm using `React Native`, where the component is `<TextInput>`, which means it can only input `string`, and pass `string` to `zod`
Imagine I have a `price` field in the form, so I have something like
```ts
const schema = z.object({
  // `coerce` is a must-have here, since `<TextInput>` always gives a `Numeric string`. Otherwise the parse will fail
  price: z.coerce.number().min(1),max(10000)
})
```

Hence it leads to some problem in the error map

- What I want:
  - Display `Price is required` when there's nothing in the input box. i.e. the result is `''`
  - Display `Price must be greater than or equal to 1` if user inputs `0`
- The actual behaviour:
  - No matter whether user inputs nothing or a `0`, it will be converted to `0` by `coerce`, but I just can't remove it since it's needed for the parse
  - I have no way to determine which is the original value before the `coerce preprocessing`

My error map:
```ts
setErrorMap((issue, ctx) => {
  const fieldName = capitalize(issue.path.at(-1) ?? 'This field')

  let message = ctx.defaultError

  // this is what I wanted when it's an empty string before the preprocessing by `coerce`
  ctx.data === '' && (message = `${fieldName} is required`)


  switch (issue.code) {
    case ZodIssueCode.too_small:
      switch (issue.type) {
        case 'number':
          // It always goes to here for `z.coerce.number()`, no matter whether it's empty string or a `0`
          message = `${fieldName} must be greater than or equal to ${issue.minimum}`
          break
      }
      break

    case ZodIssueCode.too_big:
      switch (issue.type) {
        case 'number':
          message = `${fieldName} must be less than or equal to ${issue.maximum}`
          break
      }
      break
  }


  return { message }
})
```
",,
1750280047,2497,Dynamic object validation,"Hi,
at first I want to mention that I already spent some time looking for similar problem, but didn't find anything close to it. 
### Context
I'm working on some NestJS app with already installed Zod for requests validation. Currently I'm trying to create validation for custom configuration file.
For the sake of simplicity, here is the example configuration object, even though it's going to be loaded from .yml file.
```ts
const config = {
  languages: ['en', 'de'],
  resources: [
    {
      names: {
        en: 'Apple',
        de: 'Apfel',
      },
    },
    {
      names: {
        en: 'Cherry',
        de: 'Kirsche',
      },
    },
  ],
};
```
The main goal of validation is to require setting every name translation, according to entered languages. For example if I choose English only, then config should look like this:
```ts
const config = {
  languages: ['en'],
  resources: [
    {
      names: {
        en: 'Apple',
      },
    },
    {
      names: {
        en: 'Cherry',
      },
    },
  ],
};
```
If I choose more languages it should look like this:
```ts
const config = {
  languages: ['en', 'de', 'pl'],
  resources: [
    {
      names: {
        en: 'Apple',
        de: 'Apfel',
        pl: 'JabÅ‚ko',
      },
    },
    {
      names: {
        en: 'Cherry',
        de: 'Kirsche',
        pl: 'WiÅ›nia',
      },
    },
  ],
};
```
Of course, every missing or excess translation should result in validation error. So next two examples are considered invalid.
```ts
const config = {
  languages: ['en'], // missing 'de'
  resources: [
    {
      names: {
        en: 'Apple',
        de: 'Apfel',
      },
    },
    {
      names: {
        en: 'Cherry',
        de: 'Kirsche',
      },
    },
  ],
};
```
```ts
const config = {
  languages: ['en', 'de', 'pl'],
  resources: [
    {
      names: {
        en: 'Apple',
        de: 'Apfel',
        // missing pl:
      },
    },
    {
      names: {
        en: 'Cherry',
        de: 'Kirsche',
        pl: 'WiÅ›nia',
      },
    },
  ],
};
```
As for now I came up with two step solution. At first it checks an array of languages and then uses it to construct a resources schema validation.
```ts
const supportedLanguages = ['en', 'pl', 'de'] as const;
const languagesSchema = z.array(z.enum(supportedLanguages)).nonempty();
const languages = languagesSchema.parse(config.languages);
console.log(languages);

const resourcesSchema = z.array(
  z.object({
    names: z.object(
      languages.reduce(
        (acc, lang) => ({ ...acc, [lang]: z.string() }),
        {} as Partial<Record<(typeof languages)[number], z.ZodString>>,
      ),
    ),
  }),
);
const resources = resourcesSchema.parse(config.resources);
console.log(resources);
```
### Problem
It works well, but the only problem is that resource names are of type `unknown` rather than `string`.
![image](https://github.com/colinhacks/zod/assets/33811303/22812f70-5e71-4554-a89f-7f3647f0ad25)

Any help will be appreciated, even if it doesn't resolve `unknown` type issue, but maybe changes config structure or schema construction.
",,
1747839362,2495,`Error Handling` documentation seems outdated,"https://zod.dev/ERROR_HANDLING
This seems outdated, where some of types I found in `dts` file is missing there.

E.g. 
![Snipaste_2023-06-08_22-51-35](https://github.com/colinhacks/zod/assets/45784210/41d6f2f4-a52c-4f9c-ab7e-9e40d1258131)
vs
![Snipaste_2023-06-08_22-51-59](https://github.com/colinhacks/zod/assets/45784210/a3b7c060-3a38-44bf-b296-e0e59dcdf28d)
---
![Snipaste_2023-06-08_22-52-58](https://github.com/colinhacks/zod/assets/45784210/7cc87dbc-75ee-480f-bbdc-9cc29784f5c9)
vs
![Snipaste_2023-06-08_22-52-37](https://github.com/colinhacks/zod/assets/45784210/a6e73800-ebbb-4820-81ec-521831fdfa0c)
",,
1746094290,2493,Cannot find module 'zod' or its corresponding type declarations.,"I have a strange issue that when I run my tests locally, they pass, but in a Github Action, the runner cannot find the `zod` NPM package after running `npm ci`. The runner does not have this problem with other NPM packages. Any ideas?",,
1745649548,2492,Custom error messages can't be modified with ErrorMap,"According to the [documentation](https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md#customizing-errors-with-zoderrormap) it should be possible to override all error messages, but it only works with custom errors only if the original message is undefined. Messages defined in refinements seem to be hardcoded and values returned by ErrorMap are ignored.

[codesandbox example](https://codesandbox.io/s/laughing-voice-10u0wk?file=/src/index.ts)",,
1745068165,2491,`.optional().default()` doesn't make property optional in typeScript type inference,"Hello,

I've encountered an issue when trying to use .optional().default() on a Zod schema. Even when a property is marked as .optional(), the inferred TypeScript type requires the property to be present.

Here's a simple example to illustrate the problem:

```typescript
import { z } from 'zod';

const schema = z.object({
  name: z.string(),
  rootDir: z.string().optional().default(""default/path""),
});

type SchemaType = z.infer<typeof schema>;

function processConfig(config: SchemaType) {
  // Function implementation...
}

const config = {
  name: ""myApp"",
};

processConfig(config); // TypeScript error: 'rootDir' is missing in type '{ name: string; }' 
```

In this example, TypeScript expects both 'name' and 'rootDir' to be present in the 'config' object, even though 'rootDir' is marked as optional with a default value in the Zod schema.

My expectation would be that, since 'rootDir' is marked as .optional(), it should not be required in the inferred TypeScript type. I would expect this code to compile without errors, and for Zod to apply the default value of 'rootDir' at runtime when it's not provided.

Is this the intended behavior or am I misunderstanding the usage of .optional().default()?

Thanks for your help!",,
1744369214,2490,Error during the parsing with a readonly schema.,"Hi,

I've been very disappointed by the fact that we can't parse an object with a readonly z.object schema: indeed, it is not secure to not freeze a public complex schema, used by several functionnalities of a software. A developer may do a mistake by modifying the internal data of the schema somewhere, which impacts directly the rest of the software functionnalities. This is not safe coding. :/

The error message during the execution of the Schema.parse method is :
`TypeError: Cannot assign to read only property '_cached' of object '#<O>'

      at O._getCached (../node_modules/@mylib.js:1:44278)
      at O._parse (../node_modules/@mylib.js:1:44518)
      at O._parseSync (../node_modules/@mylib.js:1:22947)
      at O.safeParse (../node_modules/@mylib.js:1:23438)
      at O.parse (../node_modules/@mylib.js:1:23121)`

I suppose the zod library stores a cache inside the z.object schema, which causes the problem. The library should store nothing inside the schema after its creation. If a cache must be used, why not store its contents somewhere inside an internal Map in the zod library inner files, associating a schema to the value(s) to cache associated to it? Plus the advantage you can manage a global cache, with a limited size and/or with a time-limited storage.

zod version: 3.21.4

Regards.",,
1744206459,2489,How to strictify ZodType,"Using z.ZodType<Obj>, typescript tells me that I'm missing the name key from the objSchema, correctly.

```ts
type Obj = {
  id: string
  name: string
}

const objSchema: z.ZodType<Obj> = z.object({
  id: z.string()
}).strict() 
```

But, this example:

```ts
type Obj = {
  id: string
  name: string
}

const objSchema: z.ZodType<Obj> = z.object({
  id: z.string(),
  name: z.string(),
  extraParam: z.string() // unwanted extra param
}).strict()
```

Doesn't warn me that I have an extra key in my schema definition. How can I achieve the same level of strictness from the generic type of the strict() method?",,
1741714786,2486,Incorrect type when preprocessed is used?,"Hi there! I don't know if this is a bug, but I was wondering why `preprocess` creates a very different type then without it. Here is my [example](https://codesandbox.io/s/lucid-brahmagupta-hsdljj?file=/src/App.tsx).

I was wondering why `role` accepts e.g. `'ADMIN'`, but why `status` doesn't accept `['ACTIVE']` and is `unknown` instead.

<img width=""539"" alt=""image"" src=""https://github.com/colinhacks/zod/assets/1152805/6a1431c5-7e60-45dd-8db4-7eae77549fbd"">
",,
1740570076,2484,Feature Request: Common context for schema transformations,"## TL;DR

I would like to have a locals object for transformers so it's easier to deal with deeply nested objects. For example:

```ts
const mediaSchema = z
	.object({
		path: z.string(),
	})
	.transform((media, locals) => ({ ...media, path: locals.url + media.path }))

const locals = {
	url: 'https://example.com/',
}
mainSchema.parse(obj, locals)
```

## Problem

I have a media schema which comes with just the path, as such:

```ts
const mediaSchema = z.object({
	path: z.string(),
})
```

```json
{
	""path"": ""/media/some-image.jpg""
}
```

I'd like to dynamically transform the path into a full URL, so each parse could have a different domain, eg: `https://example.com/media/some-image.jpg` and `https://different-example.com/media/some-image.jpg`,

But, currently it is served in multiple places in a larger schema. For example:

```ts
const mainSchema = z.object({
	deeply: z.object({
		nested: z.object({
			media: mediaSchema,
		}),
	}),
	more: z.object({
		nested: z
			.object({
				media: mediaSchema.array(),
			})
			.array(),
	}),
})
```

There are some cumbersome ways to solve this, which all step around using Zod, instead of using Zod out the box. But the best way I think this could be done is to use some sort of common context passed down to transformation functions.",,
1740377307,2482,Comparison with typebox?,"The README has a great breakdown of how Zod compares with many similar libraries: https://github.com/colinhacks/zod#comparison. [@sinclair/typebox](https://github.com/sinclairzx81/typebox) could be added to the comparison; it seems to be comparable with similar syntax, and is widely used.",,
1740376443,2481,How do I reuse a scheme as a nested field of another type,"trying to achieve this:

```ts
type A {
   field1: string;
   field2: number;
}

type B {
  arrayOfA: A[];
}
```

I'm not clear on the syntax to achieve that:

```ts
// equivalent to type A
const AZod = z.object({
field1: z.string(),
field2: z.number()
});


// equivalent to type B
const BZod = z.object(z.array(z.infer<typeof AZod>) // is this correct?
```


also, wondering if it is possible to skip this entirely and just infer directly from the types I already have?

Want to do this:

```ts
type A {
   field1: string;
   field2: number;
}

// type A schema zod validator directly from the type
const AZod = z.Zod<A> // create the A zod type without typing everything?

type B { ... } 
const BZod = z.Zod<B> // ?
```
",,
1740347778,2480,Make brand available as a runtime value,"I'm inspecting Zod values at runtime. I've run into a situation where I would like to use branded types but I've found that the brand isn't available at runtime. The `brand` function takes the brand as an optional runtime parameter. I'd like this value to be stored in the type definition. This is the code that I would like to be able to write:

```ts
const schema = z.number().brand('foo');

if (schema._def.typeName === 'ZodBranded') {
  if (schema._def.brand === 'foo') {
    // ...
  }
}
```

I'd also like this `brand` propertyâ€™s type to be the brand type (`'foo'` in the above example) if a runtime value was provided or `undefined` if a value wasnâ€™t provided.

As a workaround, I might be able to get away with using the description for my use case but I need the `description` as a description. The brand and the description serve different purposes.

Related: #1833",,
1740072131,2478,".trim() , .toUpperCase , .toLowerCase , .transform() ...basicaly transformations doesnÂ´t work","![image](https://github.com/colinhacks/zod/assets/114420790/69c11e1f-12af-4ef3-bd35-ca5f2d7f78d1)
I have this param on my z.object({
firstName
})

Transform methods are not working. Something happend?",,
1738885932,2477,"BUG: zod zccepts invalid url: `z.string().url().safeParse(""a:"")`","Current behaviour:
```ts
// zod 3.21.4
console.log(z.string().url().safeParse(""a:"")); // {success: true}
```
I expect validation to fail there",,
1736772120,2475,"Add a way to ""drop"" a property when it doesn't match the schema","<details>
<summary> Discussed in https://github.com/colinhacks/zod/discussions/2469 </summary>

<div type='discussions-op-text'>

<sup>Originally posted by **JaneJeon** May 31, 2023</sup>
Hi, I have an object that's coming from outside that I need to put into in some _guaranteed form_, but NOT throw.

Basically, I want to make sure that the object's property matches the validation OR it's not included in the first place.

For a simple example, let's consider an object with a string field `foo`:

```ts
z.object({ foo: z.string().url() }).partial()
```

However, this doesn't work because if `foo` is not a URL, it will throw instead of just dropping the property.

Here's how it would ideally go:

```ts
schema.parse({ foo: 'bar'}) // -> {}
schema.parse({}) // -> {}
schema.parse({ foo: 'https://example.com' }) // -> { foo: 'https://example.com' }
```

Even transformers don't work, because I don't want the `foo` field with an undefined value to be in the object. I just want the key to not even be present in the first place.

So far the only thing that _seems_ like it could work is if I were to create a union of objects (_not_ the `foo` field) in which the `foo` field is present and meets validation, or isn't present at all:

```ts
z.union([ z.object({}).strip(), z.object({ foo: z.string().url() } ])
```

However, I have 5 other properties like `foo`, and that means I'd need a union of 2^5 = 32 schemas, which is just untenable, especially as the number of properties may go up in the future.

Is there any good way to do this other than a MASSIVE union of schemas, i.e. to do this at the field level so that `foo` either is accepted or is dropped (without throwing)?

Thanks.</div>
</details>

Basically, I would like to request for a way to ""unset"" the key when the value doesn't match the schema. With current methods, there's no way to do this in-schema other than an exponentially increasing combination of schemas.

Thank you.",,
1736617892,2474,ZodObject that are `.refine` or `.superRefine` returns a ZodEffects type,"Zod version `3.21.4`

# Problem

Using `.refine()` or `.superRefine()` on `ZodObject` (`z.object()`) prevents the use of `.shape` or `.merge()` method as the returned type is a `ZodEffects` and not a `ZodObject`.

# Example

```ts
const schema1 = z.object({ foo: z.string() }) // = type ZodObject
const schema2 = z.object({
  bar: z.string(),
  attributeRelatedToBar: z.string(),
}).superRefine(handleSchema2Errors) // = type ZodEffects

/**
 * Impossible because `.merge` expect `schema2` to be type of `ZodObject` instead of `ZodEffects`:
 * TS2352: Conversion of type 'ZodEffects [â€¦] to type 'ZodObject ' may be a mistake because
 * neither type sufficiently overlaps with the other.
 * If this was intentional, convert the expression to 'unknown' first.
 */
const finalSchema = schema1.merge(schema2)

/**
 * Same error with `.shape` that expect a `ZodObject` instead of `ZodEffects`:
 * TS2339: Property 'shape' does not exist on type 'ZodEffects'.
 */
schema2.shape.bar
schema2.shape.attributeRelatedToBar
```

# Expected behavior

Using `.superRefine()` or `.refine()` on `z.object()` should return a `ZodObject` type
â€“ or â€“
`.merge()` & `.shape` should be functional on `ZodEffects` applied to a `ZodObject`.",,
1736520215,2473,[idea - needs work][discussion] `z.satisfies` companion to `z.infer`,"TLDR;

Allows for overriding the output of `z.infer` while still being constrained to it's requirements.

```ts
type satisfies<T extends z.infer<Zod>, Zod extends z.ZodType> = T extends z.infer<Zod> ? T : never;
```

## Why

Due to a combination of the way Zod is built and the limitations of TS's type system, types produced by `z.infer` can be difficult to read. While intellisense does a lot of the legwork for us, there are some cases where it's worth the extra work of manually writing a type just to clean up TS's inference. This becomes increasingly true for larger unions and non-trivial object structures.

## How

```ts
type satisfies<T extends z.infer<Zod>, Zod extends z.ZodType> = T extends z.infer<Zod> ? T : never;
```

The generic `Zod` here must be a valid input to `z.infer`, and the generic `T` must satisfy that inferred constraint. This leads to some interesting behavior beyond simply working as a `satisifes` clause for the user-defined type. Some of these are desirable, others less so, and ultimately this does *not* enforce everything that the schema enforces.
Therefore, the purpose of this is less ""it guides you as you write your own inferred type, blocking anything which is not permitted"" and more of a ""you know what you're doing and recognise this is **satisifies**, not **implements**"".

An implements type could be created with a little bit more work, though I doubt that it would be used much. The kind of user who would need a strict constraint when manually defining the type of their schema is the kind of user who more than likely wouldn't want to go down that route to begin with.

## Key Benefit

The major benefit of this I see is that Zod schemas can be made infinitely generic. For example, some `z.any()` can instead be made generic, allowing library authors or (more likely) users to create their own type safety for situations where the internal workings don't care what data is at a certain place, but consumers want to ensure they adhere to some structure or other when manipulating it.

```ts
const mySchema = z.object({
  foo: z.string(),
  bar: z.string(),
  baz: z.record(z.string(), z.any())
});
type MySchemaTyped<T extends Record<string, any> = Record<string, any>> = z.satisfies<{
  foo: string;
  bar: string;
  baz: T;
}, typeof mySchema>

// consumer
const myData = mySchema.parse({
  foo: ""foo"",
  bar: ""bar"",
  baz: {
    thisIsNot: ""assignable to `Thing`"",
//  ^^^^^^^^^ ts(2322)
  },
} satisfies MySchemaTyped<Thing>) as MySchemaTyped<Thing>;
```

This could be more user-friendly and less verbose with a modified `parse` signature. It would no longer allow any input, however it would use TS to validate that the input matches the additional constraint. This would not effect the runtime at all; this is a self-imposed restriction rather than a validation restriction.

```ts
// additional parse signature example
    parse(data: unknown, params?: Partial<ParseParams>): Output;
    parse<EnforceInput extends Output = Output>(data: EnforceInput, params?: Partial<ParseParams>): T;

const myData = mySchema.parse<MySchemaTyped<Thing>>({
  foo: ""foo"",
  bar: ""bar"",
  baz: {
    thisIsNot: ""assignable to `Thing`"",
//  ^^^^^^^^^ ts(2322)
  },
});
```",,
1735574158,2472,How can I validate a JSONB type?,How can I validate a JSONB (JSON BLOB) type? is it possible to achieve JSONB using https://github.com/colinhacks/zod#json-type itself?,,
1734753959,2470,There's no ergonomic way to rename object properties or do `.partial()` etc on object transformation pipelines,"Consider the case where you want to build an API response with camelCase properties in JS, and then send it over the wire with snake_case properties: 

```ts
const Post =
  z.object({
    id: z.string(),
    body: z.string(),
    userId: z.string(),
  })
  .transform(
    ({ userId, ...rest }) => ({ ...rest, user_id: userId })
  )
  .pipe(z.object({
    id: z.string(),
    body: z.string(),
    user_id: z.string(),
  }))
```

You might want to do `.partial()` if you have another API that allows the user to pick a selection of fields from a `Post`:

```ts
const PostSelection = Post.partial() // plz?
```

One could create the following helper function for this.  But this all feels very cumbersome.  Maybe in an alternate universe, Zod has a more ergonomic way to do all of this?

```ts
function pipelinePartial(schema) {
  if (schema instanceof z.ZodObject) {
    return schema.partial()
  }
  if (schema instanceof z.ZodPipeline) {
    return z.pipeline(pipelinePartial(schema._def.in), pipelinePartial(schema._def.out))
  }
  if (schema instanceof z.ZodEffects) {
    return z.effects(pipelinePartial(schema._def.schema), schema._def.effect)
  }
  throw new Error(`unsupported schema type: ${schema.constructor.name}`)
}
```",,
1733240222,2468,UUID Parsing fixed but not released on NPM,"Hi there, we are using the latest published version from NPM `3.21.4`. We were having some trouble parsing the zero-ish UUIDs hard coded in our test cases. For example `00000000-0000-0000-0000-000000000001` or `00000000-0000-0000-0000-000000000002`. 

[This recent commit](https://github.com/colinhacks/zod/commit/37e9c550460e4edd144da90d903e878c119c5cc1) seems to have rectified this problem. 

Is there any way to cut an NPM release such that we can absorb this change without having to maintain our own fork?

Thanks!",,
1732028178,2466,z.string() validates empty strings,"This is created after viewing the conversation on this issue: #63

Currently, the result of `z.string()` validation of an empty string `""""` leads to a pass instead of a fail, even though the field itself is required. This is not documented anywhere except github issues and apparently an old changelog, but it is not very intuitive in some cases and leads to potential issues especially when trying to validate forms.

Potential solutions:
1. Update `z.string()` to not pass validation for `""""` unless `.optional()` is provided (breaking change)
2. Update the zod strings documentation section with a note specifically about this functionality, providing the alternative proposed solution. specifically:
```
z.string().trim().min(1, { message: ""Required"" })
// or
const notEmpty = z.string().trim().min(1, { message: ""Required"" });
z.string().pipe(notEmpty);
```
Credit for the above solutions go to the folks in issue #63

I expect to get resistance to option 1 so hopefully option 2 is a reasonable middle ground ðŸ™‚",,
1729660848,2465,Add `.eq` or `.coerce.literal`,"I am working with a Zod schema where the data comes from an unusual API. The API primarily uses XML, but sometimes JSON, and has a property named `ResponseCode` sprinkled all over the place. This is an integer value that indicates success or failure by the API.

If the data comes from XML, all `ResponseCode` values will inherently be strings, until they're coerced into something else. If the data comes from JSON, `ResponseCode` will be a JSON number, as in `143`, unless it's zero, because then, ***sometimes but not always*** it will be the string `""0""`.

My Zod schema uses `z.coerce.number().int().min(0)` which works, I would also like to have a schema for matching the LiTeRaL zero, meaning any value which is represented by `0` after being coerced into a number.

- `0` => `0`
- `""0""` => `0`
- `false` => `0`

I could still use `z.coerce.number().int().min(0).max(0)`, but wouldn't it just be nicer if we could do something like this:

```ts
z.coerce.literal(0)
```

or maybe:

```ts
z.coerce.number().eq(0)
```

Or maybe this is already possible?",,
1728962962,2464,Using undefined() incorrectly marks keys as optional,"From [this Stackoverflow question](https://stackoverflow.com/questions/71477015/specify-a-zod-schema-with-a-non-optional-but-possibly-undefined-field) (I'm hitting the same thing):

This code:
```typescript
const schema = z.object({
  x: z.string().or(z.undefined()),
});
type Schema = z.infer<typeof schema>;
```

Produces a schema with an optional key:
```typescript
type Schema = {
    x?: string | undefined;
}
```

Same with:
```typescript
z.undefined().or(z.string())
```
Same with any variation of union (which seems to be how `.or()` resolves under the hood anyway)
```typescript
x: z.union([z.string(), z.number(), z.undefined()])
```
",,
1728499913,2463,object.extend broken referential transparency,"Hi,

This is a weird one, but I'm seeing the following issue. Here's the minimal code to repro:

```typescript
const mapType = <
    SchemaType extends z.ZodTypeAny,
    FinalSchemaType extends z.ZodType<z.output<SchemaType>>
>(
    schema : SchemaType
) : FinalSchemaType => {
    return schema as unknown as FinalSchemaType;
};

const foo = z.object({}).extend({
    foo: mapType(z.string())
});

const extension = {
    foo: mapType(z.string())
};

const foo2 = z.object({}).extend(extension);

type Foo = z.output<typeof foo>['foo'];
type Foo2 = z.output<typeof foo2>['foo'];

// @ts-expect-error
export const shouldNotAllowNumber : Foo = 1;

// @ts-expect-error
export const shouldNotAllowNumber2 : Foo2 = 1;
```

For some reason `Foo` resolves to `any`, while `Foo2` correctly resolves to `string`.

This is weird, right? In both cases the exact same object is used to extend the object. ",,
1727701796,2462,Type that allows any type of schema?,"I want a function to receive any zod schema as an argument. If I use `z.ZodSchema` as a the type of the argument it works mostly fine, but if I use `.transform` or `.pipe` in the schema I'm passing as an argument it breaks.

This is my function:
```javascript
import axios from 'axios';
import { z } from 'zod';

async function apiFetcher<O>(zodSchema: z.ZodSchema<O>, options) {
  const response = await axios.request<O>(options);
  return zodSchema.safeParse(response.data);
}
```

And here's what doesn't work:
```javascript
const DataSchema = z.object({
  expiration_date: z.string().datetime().pipe(z.coerce.date()),
});

const data = apiFetcher(DataSchema, {/* options */});
```",,
1727626476,2461,z.coerce.number() defaults empty strings to 0,"When working with react-hook-form and using controlled inputs, we need to default values to empty strings or else there will be errors of going from uncontrolled to controlled.

So using z.number() does not work because every input returns a string even if the input type is set number, it still returns a string in the event.

Switching to `z.coerce.number()` works fine with the inputs not complaining about types, but when the validation runs, empty strings are getting converted to a `0`. The state of the form shows an empty string. This causes a weird behavior where if the field is required, validation passes because the schema sees a 0 which gives a false positive.",,
1727581829,2460,z.infer does not show unions,I have a schema  where I need to hide/show different fields based on another fields value. I was able to accomplish the validation using `union` but now those fields in the union do not appear whenever i try to `z.infer<typeof schema` to have the type autocomplete and TS linter errors saying those fields do not exist (when they actually do exist),,
1722975597,2456,isOptional/isNullable aren't compatible with async transforms,"```
z.string().optional().transform(async x => x).isOptional()
Uncaught:
Error: Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.
    at ZodEffects._parse (/Users/andy/stl-api/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/types.js:2842:27)
    at ZodEffects._parseSync (/Users/andy/stl-api/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/types.js:127:29)
    at ZodEffects.safeParse (/Users/andy/stl-api/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/types.js:157:29)
    at ZodEffects.isOptional (/Users/andy/stl-api/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/types.js:311:21)
```

I can understand that `isOptional` is kind of an expedient.  But we're trying to use some 3rd-party OpenAPI schema generation libs that rely on `isOptional`, crashing on our schemas that have async transforms.

For the OpenAPI schema generation use case at least, ""static analysis"" would work well enough for most cases:

```
// ZodType
isOptional() {
  // subclasses should override
  return false;
}
```
```
// ZodOptional, ZodUndefined, ZodVoid
isOptional() {
  return true
}
```
```
// ZodUnion
isOptional() {
  return this.options.some(o => o.isOptional());
}
```
```
// ZodLazy
isOptional() {
  return this.schema.isOptional();
}
```
etc...",,
1718558749,2454,Universal unwrap for types and term,"I often find myself building interfaces that want to take a zod type, and then need to perform some branching logic based on the zod type that was given, either at the type level, term level, or both.

I've done this enough times now, facing pain each time, that I thought I'd make an issue. The out come of this issue might be:

1. Better Docs
2. Better Utility types

Take this example:

<img width=""401"" alt=""CleanShot 2023-05-21 at 12 08 10@2x"" src=""https://github.com/colinhacks/zod/assets/284476/36fb6ab9-44fa-43b1-b743-a16f6fe37b42"">

`.unwrap` is nice, but it is not universally available. Nor is it clear which subset of zod types support it. My solution to this varies. I don't remember every incarnation but often it's something about constraining the input type from being any zod type to being something narrow. Often I start extremely narrow and then open up based on consumer needs. That approach however doesn't work for library design where the callsite/consumer and the interface are far apart.

Perhaps some additional type categories groups would be helpful such as `z.SomePrimitiveType` which would allow `boolean` `string` etc. but also crucially the various additional things such as `pipe` `optional`, union, etc.

Also, the ability to universally unwrap any zod type to its primitive type, or multiple (if it's a union etc.) would be useful as well.

Note, I have seen this doc: https://github.com/colinhacks/zod#writing-generic-functions.


",,
1718011155,2451,Does `.shape` not work on recursive types in zod?,"I am unable to use `.shape` when I use `z.ZodType<Type>`:

```ts
/* eslint-disable sort-exports/sort-exports */
import { z } from 'zod'

export const LOAD_FIND_TEST = [
  'bond',
  'base_link_mark',
  'head_link_mark',
  'base_mark',
  'head_mark',
  'base_text',
  'miss_bond',
  'have_bond',
  'have_text',
] as const

export type Load = {
  find?: LoadFind
  read?: LoadRead
  save?: LoadSave
  task?: string
}

export type LoadFind = LoadFindLink | Array<LoadFindLink>

export type LoadFindBind = {
  form: 'bind'
  list: Array<LoadFindLink>
}

export type LoadFindLike = {
  base: LoadFindLikeLinkBond
  form: 'like'
  head: LoadFindLikeBond | LoadFindLikeLinkBond
  test: LoadFindTest
}

export type LoadFindLikeBond = string | boolean | null | number

export type LoadFindLikeLinkBond = {
  link: string
}

export type LoadFindLink = LoadFindLike | LoadFindRoll | LoadFindBind

export type LoadFindRoll = {
  form: 'roll'
  list: Array<LoadFindLink>
}

export type LoadFindTest = (typeof LOAD_FIND_TEST)[number]

export type LoadRead = {
  [key: string]: true | LoadReadLink
}

export type LoadReadLink = {
  find?: LoadFind
  read: LoadRead
}

export type LoadSave = {
  [key: string]: Array<LoadSaveBase> | LoadSaveBase
}

export type LoadSaveBase = {
  find?: LoadFind
  read?: LoadRead
  save?: LoadSave
  task?: string
}

export type LoadSort = {
  name: string
  tilt: '+' | '-'
}

export const Load: z.ZodType<Load> = z.object({
  find: z.optional(z.lazy(() => LoadFind)),
  read: z.optional(z.lazy(() => LoadRead)),
  save: z.optional(z.lazy(() => LoadSave)),
  task: z.optional(z.string()),
})

export const LoadFind: z.ZodType<LoadFind> = z.union([
  z.lazy(() => LoadFindLink),
  z.array(z.lazy(() => LoadFindLink)),
])

export const LoadRead: z.ZodType<LoadRead> = z.record(
  z.union([z.lazy(() => LoadReadLink), z.literal(true)]),
)

export const LoadSave: z.ZodType<LoadSave> = z.record(
  z.lazy(() => LoadSaveBase),
  z.array(z.lazy(() => LoadSaveBase)),
)

export const LoadFindBind: z.ZodType<LoadFindBind> = z.object({
  form: z.literal('bind'),
  list: z.array(z.lazy(() => LoadFindLink)),
})

export const LoadFindRoll: z.ZodType<LoadFindRoll> = z.object({
  form: z.literal('roll'),
  list: z.lazy(() => z.array(LoadFindLink)),
})

export const LoadFindTest = z.enum([
  'bond',
  'base_link_mark',
  'head_link_mark',
  'base_mark',
  'head_mark',
  'base_text',
  'miss_bond',
  'have_bond',
  'have_text',
])

export const LoadFindLike: z.ZodType<LoadFindLike> = z.object({
  base: z.lazy(() => LoadFindLikeLinkBond),
  form: z.literal('like'),
  head: z.union([
    z.lazy(() => LoadFindLikeLinkBond),
    z.lazy(() => LoadFindLikeBond),
  ]),
  test: LoadFindTest,
})

export const LoadFindLink: z.ZodType<LoadFindLink> = z.union([
  z.lazy(() => LoadFindLike),
  z.lazy(() => LoadFindRoll),
  z.lazy(() => LoadFindBind),
])

export const LoadFindLikeBond: z.ZodType<LoadFindLikeBond> = z.union([
  z.string(),
  z.boolean(),
  z.null(),
  z.number(),
])

export const LoadFindLikeLinkBond: z.ZodType<LoadFindLikeLinkBond> =
  z.object({
    link: z.string(),
  })

export const LoadReadLink: z.ZodType<LoadReadLink> = z.object({
  find: z.optional(LoadFind),
  read: LoadRead,
})

export const LoadSaveBase: z.ZodType<LoadSaveBase> = z.object({
  find: z.optional(LoadFind),
  read: z.optional(LoadRead),
  save: z.optional(LoadSave),
  task: z.optional(z.string()),
})

export const LoadSort: z.ZodType<LoadSort> = z.object({
  name: z.string(),
  tilt: z.enum(['+', '-']),
})

console.log(LoadFindLike.shape)
```

> Property 'shape' does not exist on type 'ZodType<LoadFindLike, ZodTypeDef, LoadFindLike>'.ts(2339)

How do I get `.shape` to work when I have to use `z.ZodType` for the recursive types?

This is the only way I have figured it out so far:

```ts
export const LoadSort: z.ZodType<LoadSort> = z.object({
  name: z.string(),
  tilt: z.enum(['+', '-']),
})

// console.log((LoadFindLike._def as z.ZodObjectDef).shape())

assertZod(LoadSort)

console.log(LoadSort.shape)

export function assertZod<S extends z.ZodObject<z.ZodRawShape>>(
  x: unknown,
): asserts x is S {
  if (!(x instanceof z.ZodObject)) {
    throw new Error()
  }
}
```

Update: [Cross post](https://stackoverflow.com/questions/76293170/property-shape-does-not-exist-on-type-in-zod).",,
1717868486,2448,"When z.infer a Record with Template Literal Type as a key, it becomes a Partial Record.","This issue is very similar to #2069 but instead of Branded key, the same issue is with Template Literal Type key.

When z.infer a Record with Template Literal Type as a key, it becomes a Partial Record.


With defining a Record type normally:

```ts
import { z } from ""zod""

const zodKey = z.custom<`${number}`>()

type ZodKey = z.infer<typeof zodKey>
type ZodRecord = Record<ZodKey, number>
// type ZodRecord = {
//     [x: `${number}`]: number;
// }
```

With defining a Record type with `z.infer`:
```ts
import { z } from ""zod""

const zodKey = z.custom<`${number}`>()
const zodRecord = z.record(zodKey, z.number())

type ZodRecord = z.infer<typeof zodRecord>
// type ZodRecord = {
//     [x: `${number}`]: number | undefined;
// }
```
It has `undefined`.

---
The extra Partial<...> is more explicit in this case:

```ts
import { z } from ""zod""

const zodKey = z.custom<`${number}`>()
const zodRecord = z.record(zodKey, z.object({ a: z.number(), b: z.number() }))
const zodWrapper = z.object({ zodRecord })

type ZodWrapper = z.infer<typeof zodWrapper>
// type ZodWrapper = {
//     zodRecord: Partial<Record<`${number}`, {
//         a: number;
//         b: number;
//     }>>;
// }
```",,
1716413394,2445,Keep async validations in regular `parse`,"I'm building a form validation library that accepts a zod schema. I'd like to run `.parse()` as I do currently but retain async validations in the result

So if a consumer provided us with a schema like 

```js
const schema = z.object({
  age: z.number().min(18),
  username: z.string().refine(userNameExists, { message: ""Username taken"" })
})
```
I could call `.parse()` and get an immediate result with  `{ success: true, loading?: Promise<Result> }`

Right now I can emulate the behaviour with something like this

```js
try {
  let r = schema.parse(value, {async: false})
  updateValidation(r)
} catch (e) {
  if (isAsyncValidationError(e)) {
    setLoading(true)
    schema.safeParseAsync(value).then((r) => {
      setLoading(false)
      updateValidation(r)
    })
  }
}
```
But obviously this isn't ideal as I'm having to re-parse the whole object twice. What I'd prefer is something like this

```js
let result = schema.safeParse(value)

if (result.loading) {
  setLoading(true)
  result.loading.then(r => updateValidation(r))
  setLoading(false)
} else {
  updateValidation(r)
}
```",,
1716183447,2444,Even explicitly declaring circular z.ZodObject types seems impossible,"I need to declare some circular object schemas, but I'm wishing I'd be able to `.partial()` on them without casting...so I tried declaring more refined explicit types, but even that doesn't work...

```ts
import z from ""zod"";

type ExtendedZodObject<
  Base extends z.SomeZodObject,
  Aug extends z.ZodRawShape
> = z.ZodObject<z.objectUtil.extendShape<Base[""shape""], Aug>>;

const baseUser = z.object({
  id: z.string(),
  name: z.string().optional(),
});

type UserType = ExtendedZodObject<
  typeof baseUser,
  {
    posts: z.ZodArray<z.ZodLazy<PostType>>;
  }
>;
const User: UserType = baseUser.extend({
  posts: z.array(z.lazy(() => Post)),
});

const PartialUser = User.partial();  // <-- this is why I don't want just const User: z.ZodType<...> 

const basePost = z.object({
  id: z.string(),
  body: z.string(),
  userId: z.string(),
});

type PostType = ExtendedZodObject<
  typeof basePost,
  {
    user: z.ZodLazy<UserType>;
  }
>;
const Post: PostType = basePost.extend({
  user: z.lazy(() => User),
});
```

### Errors
```
Type of property 'posts' circularly references itself in mapped type 'baseObjectOutputType<{ id: ZodString; name: ZodOptional<ZodString>; posts: ZodArray<ZodLazy<PostType>, ""many"">; }>'.ts(2615)
Type of property 'posts' circularly references itself in mapped type '{ id: ""id""; name: never; posts: never; }'.ts(2615)
Type of property 'user' circularly references itself in mapped type 'baseObjectOutputType<{ id: ZodString; body: ZodString; userId: ZodString; user: ZodLazy<UserType>; }>'.ts(2615)
Type of property 'user' circularly references itself in mapped type '{ [k in keyof baseObjectOutputType<{ id: ZodString; body: ZodString; userId: ZodString; user: ZodLazy<UserType>; }>]: undefined extends baseObjectOutputType<...>[k] ? never : k; }'.ts(2615)
```

I'm not a TS expert, but it makes me wonder if some less complicated type mapping would be possible than what `baseObjectOutputType` is doing, that would be compatible with TS...",,
1715748462,2442,Check only for the type of value for a key not the structure,"I have an object like such:

```
{
   a: {...},
  b: {...},
  c: [...]
}
```

I only want to verify if a has an object, b has an object and c has an array, and they are not nullable",,
1714426329,2440,superRefine breaks compatibility with discriminatedUnion,"# Problem

Here's an easy demo, using zod@3.21.4

```ts
import * as z from ""zod"";

const schemaA = z.object({
  version: z.literal(""a""),
}); // observation, no use of superRefine

z.discriminatedUnion(""version"", [schemaA]); // works

const schemaB = z
  .object({
    version: z.literal(""b""),
  })
  .superRefine(() => {}); // observation, use of superRefine

z.discriminatedUnion(""version"", [schemaB]); // doesn't work

/*
Type 'ZodEffects<ZodObject<{ version: ZodLiteral<""b"">; }, ""strip"", ZodTypeAny, { version: ""b""; }, { version: ""b""; }>, { version: ""b""; }, { version: ""b""; }>' is missing the following properties from type 'ZodObject<{ version: ZodTypeAny; } & ZodRawShape, UnknownKeysParam, ZodTypeAny, { [x: string]: any; version?: any; }, { [x: string]: any; version?: any; }>': _cached, _getCached, shape, strict, and 14 more.ts(2740)
*/
```

The type-error is correct, and it breaks at runtime as well.

In otherwords, ZodEffect<ZodObject> isn't supported... but it should be! A schema that has assertions on top of it is still a compatible schema.

# Expectation

`z.discriminatedUnion` to still work on `.superRefine`d schemas.",,
1712576631,2437,Option to allow bitwise operations on enums,"I'd like to be able to use bitwise operations on enums and have them validated using zod. 
```ts
enum Flags {
  None = 0,
  Good = 1 << 0,
  Bad = 1 << 1,
  Solid = 1 << 2
}

const Thing = z.object({
  flags: z.nativeEnum(Flags),
  name: z.string()
});

type Thing = z.infer<typeof Thing>;

const thing: Thing = {
  flags: Flags.Good | Flags.Solid,
  name: ""Test""
};

Thing.parse(thing);
```
Currently, I'm given an `invalid_enum_value` error, as the value of `Flags.Good | Flags.Solid`, `5`, is not one of `[ 0, 1, 2, 4  ]`. Is there any way I can allow bitwise operations on enums and have them validated? Or should I just required a number and hope the user does the right thing. ",,
1712195853,2435,Creating default for a property in a recursive schema causes error,"Here is a minimal example:

```ts
export const mySchemaBase = zod.object({
  someOptionalThing: zod.boolean().default(true),
});

export type SchemaWithChildren = zod.infer<typeof mySchemaBase> & {
  children: SchemaWithChildren[];
};

export const finalSchema: zod.ZodType<SchemaWithChildren> = mySchemaBase.extend({
  children: zod.lazy(() => finalSchema.array()),
});

// Note that the type is correct, and when we parse, the parsing is fine
type MyType = zod.infer<typeof finalSchema>;
    // ^?
```

Error happens at `export const finalSchema`

When I check the type on the final line, it seems to be correct.  When I parse items, it seems to parse correctly giving the default value.  It appears to be an error with `finalSchema` because we are ""helping"" the type for the recursive schema using `zod.ZodType`.

Playground link: https://www.typescriptlang.org/play?ssl=17&ssc=10&pln=1&pc=1#code/JYWwDg9gTgLgBAKjgQwM5wF4QCZwGZQQhwDkW2JA3AFDUCmAHpLHAMYQB2q8IAngMqsAFnRDIAQmjpwAvJhwA6CACMAVnVYwAFAG9qcOKiJ0A8mBjBOyADYAVIcA4BzAFzzsC5RAjW6yDloAlArYdHjIAK7W2jBQEXSBADTUAL6BNPRM0PAwvGDSgiJiAOrAMEIAwg7W2FB0HLLuCo54dFAAPLn5EHhwfIWiElIAfHAAZHB6BsLANXUcbgMlZZXVtfUA2gC6NCkZjMzw7FzweI42S8hu5AoAWji2eXTtl6XlVbPrHKNy-cKDklQdAUjBg9Wwun0bDW82uimsyAwvC0QVkozOHAu-zECmQUCgyGRgSSqXStAA9OS4AA5CBguDlZA5EQMp5wYDodj4jQwRIoDi4ADuIgagukYDxQL55XFkscTnZ6AxdGoXWkAFleI98o0bi02p0nj18OdrJdhjQDAZKXAAHoAfiAA",,
1710766692,2433,Invalid emoji regular expression,"Here is the full error message: 

```Invalid regular expression: /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/: Invalid property name```

based on sentry, it says the error is happening on this line:

```const emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;```

Looking thru the zod source code quickly it seems like [this line](https://github.com/colinhacks/zod/blob/a8be4500851923aa865e009fe9c2855e80482047/src/types.ts#L556) is the origin.

For context, this is happening on a NextJS (13.1.6) site with zod v3.21.4. 

Based on sentry it seems like it's happening on Android phones exclusively on the following browsers: 
- UC Browser 13.4.2: 24%
- Chrome Mobile 68.0.3440: 16%
- Chrome Mobile 66.0.3359: 16%
- Chrome Mobile WebView 62.0.3202: 12%
- Other: 30%",,
1708525028,2427,Global installation to be able to use zod with Code Runner,"Is it also possible to globally install zod to be used with for example Code Runner?

Something like:
`yarn add zod -g`
**settings.json**
```
  ""code-runner.executorMap"": {

    ""python"": ""python"",    
    ""javascript"": ""node"",
    //""javascript"": ""node -r esm $fullFileName""
    ""typescript"": ""node"",
    //""typescript"": ""node -r esm $fullFileName""
  },
```

### **Tried:**
**zod.ts** (how to access the globally installed module?) ==> ðŸ˜•
```
// import { z } from 'zod'; // => SyntaxError: Cannot use import statement outside a module
// const z = require('zod') // => SyntaxError: Unexpected token 'export'
const scheme = z.number(); // => error TS2304: Cannot find name 'z'

export const toString = (num: unknown) => {
  return String(scheme.parse(num));
};
console.log(toString(1))
console.log(toString(""1""))
```
**zod.mts** (with errors, seems to behaves the same as `ts`) ==> ðŸ˜•
```
// import { z } from 'zod'; // => SyntaxError: Cannot use import statement outside a module
// const z = require('zod') // => SyntaxError: Unexpected token 'export'
const scheme = z.number();

export const toString = (num: unknown) => {
  return String(scheme.parse(num));
};
console.log(toString(1))
console.log(toString(""1""))
```
**zod.mjs** (without errors, but without typescript and by importing `zod`) ==> ðŸ˜¢
```
import { z } from 'zod';
// const z = require('zod')
const scheme = z.number();

export const toString = (num) => {
  return String(scheme.parse(num));
};
console.log(toString(1)) // => 1
console.log(toString(""1"")) // => ZodError: ""Expected number, received string""
```

",,
1707263444,2425,Circular,,,
1706807450,2424,No way to merge multiple schemas. request function to merge deep multiple schemas like javascript object spread,"v3.20.6

We got no way to merge the **3 or more schemas** into 1 schema.

GiftVehicle.ts file
```
export const VehicleSchema = merge CarSchema, TruckSchema and SuperCarSchema 

Goal:
VehicleSchema = z.object({
  authToken: z.string(),
  colour:  z.string(),
  options: z
    .object({
      giftMessage: z.string().optional(),
      isConvertible: z.boolean().optional(),
      hasHugeWheels: z.boolean().optional(),
    })
    .optional(),
})
```

If we use `merge`, for more than 2 e.g. `CarSchema.merge(TruckSchema).merge(SuperCarSchema)`

it doesn't copy the deeper `options` correctly. after test, the `TruckSchema.options.hasHugeWheels` disappears.

`union` or `discriminatedUnion`  is not making it due to the way it works. its not merging of object properties.

any suggestions? please help thank you...

.
.
.
.
.


GiftCar.ts file
```
export const CarSchema = z.object({
  authToken: z.string(),
  colour:  z.string(),
  options: z
    .object({
      giftMessage: z.string().optional(),
      isConvertible: z.boolean().optional(),
    })
    .optional(),
})

call giftCar API
```

GiftTruck.ts file
```
export const TruckSchema = z.object({
  authToken: z.string(),
  colour:  z.string(),
  options: z
    .object({
      giftMessage: z.string().optional(),
      hasHugeWheels: z.boolean().optional(),
    })
    .optional(),
})

call giftTruck API
```

GiftSuperCar.ts file
```
export const SuperCarSchema = z.object({
  authToken: z.string(),
  colour:  z.string(),
  options: z
    .object({
      giftMessage: z.string().optional(),
      isConvertible: z.boolean().optional(),
    })
    .optional(),
})

call giftSuperCar API
```",,
1705765651,2421,"z.input: ""enum"" should infer to ""string"" and ""coerce"" to the coercible types","Given this [TS example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbwF4F84DMoRHAREiAE1wCgSBjCAOwGd4AxCCAIwEMo4BeOJAOhYBWAU3IwAFAhJxpGJgC4evOlGBUA5mICUvGFFa100EGIBuXAHxwTvADZD1MABaaANFJlsoCvvYCuxgG1cT1wXPEMIXABdV3dpCM9vJV1VDW1mPSpCMVwE9lxNEhRCkhgATzAhOEYWdgBJLkVVMF8YAB5yyoh0aqZPc1KKqprPAHlGvlV0ISgOoe7e2qgBknRfKlFgajhyKCFWGCER9jFm1oVjqDrNRDid6jpZJcbL3jB2GiFTqhaYQpk4AB6QFwXhg3hFMjAuBCAAerHAdjgMAgMNovj2cAA7o57HAyhBfDtHPo1MM+uwwk4DvjCRwbBBWIQZvdmXBgDQ4KwbDRUb4wIQDkJCCRobjMXsQMBYQBaDmOOAMpkzMLMVpwGigYA2djsqhwCBOFmUKiHWEwGgkVg0MobDDrTbbJXMqBiPYARwUACUhO7fEI6DdJACTY9DFAcNxWFjWMB4B7eOGQAARA6sLR3UPwPIcbi7faHS4SO4AiIKADKKXUYiTvDJ4gA5BEG5pYgCAYk4JWVNXa-WxA3PC22+34hSvF2qxo+0JGznh3dikUgA)

> The inferred input type (z.input) of z.enum should be string, not the literal.

Found another, similar case, updated adding this [coerce example](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbwF4F84DMoRHAREiAE1wCgSBjCAOwGd4AxCCAIwEMo4BeOJAOhYBWAU3IwAFAhJxpGJgC4evOlGBUA5mICUvGFFa100EGIBuXAHxwTvADZD1MABaaANFJmGW7BX2WqN2sx6VIRiuJ5sULiu7tKRnj68lEJQ5EK8VACuIMwpWrzsegCeWiQommQwRWBCcIxeUACSXIqqYJkwADxVNRDodUyR5iQ9tfWRAPItfKroKd3VQn0DDcMk6JlUosDUcORQQqwwQuPsYm0dCqdNmoixe9R0sg0t17xg7DRC51TtMBUyOAAeiBcF44PuBxgmSgVGekTKZBBcCEAA9WOA7HAYBAUbQYbUAO6OexwIoQTJ7Rz6NRjQbsFzY6nwckwuA2CCsQgpB7cuDAGhwVg2Gi4zJgQhHISEEjIkkHOAHEDAVEAWgFjnZnO5UEZzA6cBooGANnY-LhECcPMoVGOqJgNBIrBoRS2GE2212HK5eQOAEcFAAlIR+zJCOi3SSAm1PQxQHDcViE1jAeD+3hxkAAESOrFK0ce8AiZu4+0Ox2uEnugIScAAyrp-GJM7xaeIAOSeduaGKAmv0qAKBsqdTNoytoQd4tQbu9vtxdi1lttgCCNhsYXiTGivBArDAYmH-gBMnKZSAA)

> The inferred input type (z.input) of coerce should be a union of types coercible.

If the examples aren't enough to understand why it makes more sense, I can clarify more in detail.",,
1705421694,2419,Removing extra validation to create looser version of schema to validate types only?,"I have a schema for my form, which validates that the data has certain values inputted, emails are actually valid emails and so on, the regular form validation stuff. However, I also need to save the intermediate, non-valid data to `localStorage` to allow closing the form and continuing later. Currently an extremely simplified version pseudo-implementation of the solution looks like the following:

```tsx
const formSchema = z.object({ email: z.string().email(), /* ... */ });

function Form() {
  useOnFormChange(state => localStorage.setItem(""form"", JSON.stringify(state))

  function getFormDefaultState() {
    const jsonStr = localStorage.getItem(""form"")
    return JSON.parse(jsonStr) as any // No validation step
  }
// ...
}
```

Attempting to validate the `JSON.parse(jsonStr)` result would not work as I allow saving for example malformatted or empty email strings to the email field. They only need to be valid at submission. I would love a feature such as

```tsx
const bareFormSchema = formSchema.recursivelyRemoveExtraValidations()
// Equal to z.object({ email: z.string(), /* ... */ })

function getFormDefaultState() {
    const jsonStr = localStorage.getItem(""form"")
    const object = JSON.parse(jsonStr)
    return bareFormSchema.parse(object)
}
```

I was unable to create a custom function that would implement this logic. It should maintain the type and structure, but none of the validations such as `.min()`, `.max()`, `.refine()` , `.email()` or other non-type-specific information.",,
1705407158,2418,Removing extra validation to create looser version of schema to validate types only,,,
1705150450,2417,Any reason why `transform` doesn't have access to other props of the object?,Any reason why `transform` and `refine` do not have optional access to all other props of the object? Could have been another property in context object.,,
1699607474,2414,Proper way to use zod enum without using native enum.,"I have a sample enum as an object:

```ts
export const timeFilter = {
    ANY: """" as const,
    DAY: ""r86400"" as const,
    WEEK: ""r604800"" as const,
    MONTH: ""r2592000"" as const,
}
```
and I want to build the type: `z.enum(["""", ""r86400"", ""r604800"", ""r2592000""])`

If I use the syntax `z.enum(Object.values(timeFilter))` that will failed `Object.values` will return the type `string[]`

I also tried to used a const array with a const type:
```ts
export const validTimeFilter = Object.values(timeFilter) as typeof timeFilter[keyof typeof timeFilter][];
```
by now the error is:
```
Argument of type '("""" | ""r86400"" | ""r604800"" | ""r2592000"")[]' is not assignable to parameter of type '[string, ...string[]]'.
```

I do not want to use enum for various reasons.

And I'm sure that a typical case should be present in the Zod documentation.

---

The syntax: 
```ts
export enum TimeFilter {
    ANY = """",
    DAY = ""r86400"",
    WEEK = ""r604800"",
    MONTH = ""r2592000"",
}
z.nativeEnum(TimeFilter)
```
works but that is a native enum.",,
1699253006,2413,Runtypes-like `.guard()`,"I miss this feature from runtypes and i would like to implement it (making issue first, as CONTRIBUTING.md said)

## My use case
I am recently got tasked with integrating multiple 3rd-party APIs, and i have chosen following pattern for it

```typescript
class ExampleApiUnkownError extends Error { ... }
class ExampleApiError extends Error { ... }

const BaseResponse = z.object({
  response: z.custom((value) => value !== undefined)
})

type BaseResponse = z.static<typeof BaseResponse>; 

const ErrorResponse = z.object({
  error: z.object({ ... })
})

class ExampleApiClient {
  async request({...}): Either<ExampleApiError | ExampleApiUnknownError, BaseResponse> {
    try {
      const response = await fetch(...);
      const json = await response.json();
      
      // And here i would like to 
      // 1. Check if json matches BaseResponse -> return early
      // 2. Check if json matches ErrorResponse -> make ExampleApiError from it and return early
      // 3. return left(new ExampleApiUnkownError(""..."", { cause: { response, json } })); if nothing matched
      
      // In my opinion, both .parse and .safeParse are too cumbersome, cause
      // .parse requires error handling
      // .safeParse requires additional variable to work correctly
      
      // I prefer doing something like this
      
      if (BaseResponse.guard(json)) {
        return right(json.response);
      }
      
      if(ErrorResponse.guard(json)) {
        return left(ExampleApiError.fromJSON(json));
      }
      
      return left(new ExampleApiUnkownError(""..."", { response, json }));
      
    } catch(error) {
      return left(new ExampleApiUnkownError(""..."", { cause: error }));
    }    
  }
}

```",,
1698857296,2411,Incorrect type for `default` value of a piped schema,"This is a zod schema that validates an environment variable that may be set as:
```bash
ENABLE_FEATURE=""1""
ENABLE_FEATURE=1
ENABLE_FEATURE=""0""
ENABLE_FEATURE=0
ENABLE_FEATURE= 
ENABLE_FEATURE=
# ...etc
```

```typescript
import { z } from 'zod';

export const zodEnvBooleanSchema = () =>
	z.coerce.number().pipe(z.coerce.boolean());

const isEnabledSchema = zodEnvBooleanSchema().default(false)
// No overload matches this call.
//   Overload 1 of 2, '(def: number): ZodDefault<ZodPipeline<ZodNumber, ZodBoolean>>', gave the following error.
//     Argument of type 'boolean' is not assignable to parameter of type 'number'.
//   Overload 2 of 2, '(def: () => number): ZodDefault<ZodPipeline<ZodNumber, ZodBoolean>>', gave the following error.
//     Argument of type 'boolean' is not assignable to parameter of type '() => number'. [2769]

const isEnabled = isEnabledSchema.parse(process.env.ENABLE_FEATURE);
```

Since the final product of the schema (`isEnabled`) is type `boolean`, I expected the value passed to `.default()` to also have type `boolean`. But it expects a `number` instead.

Is the type lost when using the `pipe` function? Or am I just misusing it?  Or perhaps there is a better way to do this?",,
1697409437,2408,How to check if the email field is required first,"Hello guys, 
I'm trying to validate the email field, I want to check if the field is required or not first, then I want to trigger the email validation

```ts
    -------- Validator.ts --------
    export const FormDataValidator = z.object({
      email: z.string({required_error: ""Required field""}).email(invalidEmail),
    })

    -------- index.ts ----------
    const result = FormDataValidator.shape.email.safeParse(
        emailReference.value
    );
```

but the problem is that always i get ""Invalid Email"" from the ""email function()"" .
Is there any way to fix this?",,
1697079223,2406,Setting default value breaks extend,"``` typescript
const baseCategorySchema = z.object({
  name: z.string(),
  num: z.number().default(0),
});

type Category = z.infer<typeof baseCategorySchema> & {
  subcategories: Category[];
};

const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
  subcategories: z.lazy(() => categorySchema.array()),
});
```

![image](https://user-images.githubusercontent.com/20667774/236390281-98bf213f-31c8-4ddb-b1d7-b6f29cbab90f.png)
",,
1696911060,2405,Validate (not coerce) for trim/upper/lower case,"I understand the principle of 'parse not validate' but is there also a way to validate?

I'd like, on the front end mobile app, to have this schema generously handle mostly-compliant input, but on the backend only accept clean data:
```
const tag = Zod.string().trim().toLowerCase()
const parsed = tag.parse(' kittyCAT ') // => 'kittycat'
const validated = tag.validate(' kittyCAT ') // => ZodError
```

While the first (a secret transform within the parse chain) is nice to have, for our use the second is essential. I can accomplish the coercion with a transform, but not the validation

Looking through the api, it seems that -- apart from `coerce` -- `trim` and `toLower/UpperCase` are the only checks that behave as transforms. The multipleOf check does not round to the nearest multiple, min and max do not pad or truncate their input.

Is there already a way to validate? If not, would you accept a PR to enable the behavior I'm after?

The option I like would add the `.strict()` method to `string()` checks. When the strict flag is false, trim/lower/upper follow their current behavior. With strict set to true, they validate against `/^[^\p{Lu}]*$/u` (no uppercase characters) // `/^[^\p{Ll}]*$/u` (no lowercase characters) or `(! /^[\p{Z}]/.test(val)) && (! /[\p{Z}]$)/.test(val))` (no starting or ending space separators). 

Another option would be to add a field to the return value of safeParse that discloses whether any coercion happened, and internally a flag on issue noting whether it is a problem or a coercion:

```
const tag = Zod.string().trim().toLowerCase()
const parsed = tag.safeParse(' kittyCAT ') // => { success: true, data: 'kittycat', coerced: true }
const parsed = tag.safeParse(' kittycat ')   // => { success: true, data: 'kittycat', coerced: false }
```

A final (easiest(?)) but clutter-y option would be to allow `isTrimmed` and `isLower/UpperCase` checks that do no implicit coercion
",,
1696130067,2403,use .pick/.omit on ZodType,"Hello, i'm trying to use .pick or .omit on schema which is recursive.

```typescript
type ItemAttribute = keyof Item;

type BaseItem = z.infer<typeof baseItemSchema>;

type Item = BaseItem & {
  parent_item: Item;
  subitems: Item[];
};

const baseItemSchema = z.object({
  id: z.number(),
  name: z.string(),
});

const itemSchema: z.ZodType<Item> = baseItemSchema.extend({
  parent_item: z.lazy(() => itemSchema),
  subitems: z.lazy(() => itemSchema.array()),
});

itemSchema.pick()
```

```typescript
Property 'pick' does not exist on type 'ZodLazy<ZodType<Item, ZodTypeDef, Item>>'.ts(2339)
```

I search to convert a Zodtype to a ZodObject, I don't find any informations about it.
I find that I can cast itemSchema but I lost the type when I parse some data
I don't know what try.

```typescript
const itemSchema: z.ZodObject<any, any, any, Item> = baseItemSchema.extend({
  parent_item: z.lazy(() => itemSchema),
  subitems: z.lazy(() => itemSchema.array()),
});
```

Anyone has an idea ? 

Thank you",,
1694954532,2401,safeParse throws if refine throws,"# Problem

`schema.safeParse(input)` should yield `.error` if it fails, but refinement that throws breaks the ""safe"" part of the contract. `.refine` isn't supposed to throw, but ...errors happen :)

# Discussion

```js
const schema = z.string().refine(() => { throw new Error(""kaboom"") });
schema.safeParse(""weeeeeee""); // throws
// Uncaught Error: kaboom
```

I expected a `{ error: ZodError, success:false }`.

Could/should this be the norm? I did search existing issues for keywords, but didn't see discussion on this topic.",,
1693923296,2398,Validate unix timestamp (milliseconds),"I didn't found any specific rule to validate unix timestamp, my object is structured like this:
```
{
   ""start_date"": 1683114592000,
   ""end_date"": 1683114627000
}
```

Attributes start_date and end_date are unix timestamp in milliseconds. I need also to express in my validation rule:
1. end_date must be greater than start_date
2. start_date must be greater than system time
",,
1693695087,2397,Add `unwrap` on `ZodCatch`,"It would be nice to be able to access the schema wrapped by `ZodCatch`, similar to `ZodOptional` and `ZodNullable`.
Is there a reason this is not possible?",,
1693480581,2396,Email validation broken,"Hi,

zod is rejecting valid email addresses of the form a@b.c.com (note the two dots after the @).

",,
1693423957,2395,`z.string().url()` claims invalid URL when `URL` is not in the global scope,"Hello and thanks to everyone working on Zod, it's an amazing library!

## Scenario
I have code running on a bare-bones v8 engine and there is not access to many of the standard Javascript APIs by default, including `URL` which is common in most environments.

## Issue
Zod works well in this bare-bones environment for most things, but I recently got quite hung up on why all URLs were invalid. After digging I realized Zod validates strings as valid URLs through use of the `URL` web standards API.

The error I was receiving when URL was not on global scope was:
```json
{
  ""issues"": [
    {
      ""validation"": ""url"",
      ""code"": ""invalid_string"",
      ""message"": ""Invalid url"",
      ""path"": [
        ""components"",
        0,
        ""url""
      ]
    }
  ],
  ""name"": ""ZodError""
}
```

However, when I use `URL` in the environment outside of Zod I get the following:
```
Uncaught ReferenceError: URL is not defined
```

## Next steps
1) I think it's fine that Zod marks the URL as invalid, but I think __there needs to be some way to be informed that the API Zod is using for validation is not actually available in this environment__ and all strings will be invalid URLs even when they are valid.

2) This creates a followup question which is: __What other standard APIs does Zod depend on that may be absent or behave different based on execution environment?__

Cheers and thanks for reading this far!
Jack
",,
1691151240,2392,pick and pipe with with subset of property names to create object chains.,"I would really like to be able to take an existing zobject, and work with the object as a whole with pipes rather than working with individual properties via transforms.  In particular, I'd like to pick a subset of properties, and then pipe those properties to another zObject that declares my validations.  Intellisense and typescript should enforce that the name of the picked properties exist at compile time.

I've tried many many different ways to do this and it keeps falling down because of undefined property errors.  

I would like to be able to express this in a single function without having to call separate functions or break this out on a property by property basis.

See here and what I'm trying to do:

https://codesandbox.io/s/dazzling-gwen-mu0fti?file=/src/index.ts

```typescript
const Post = z.object({
  id: z.string(),
  title: z.string(),
});

function pickAndMap<
  TSrc extends z.AnyZodObject,
  TSrcShape extends TSrc['shape'],
  TDestShape extends { [k in keyof TSrcShape]?: z.ZodTypeAny }
>(source: TSrc, dest: TDestShape) {  
  return z.object(dest);
}

//notice the type intentionally changes and I discard all prior validation
const OverrideProperties = pickAndMap(Post, {
  id: z.number(),
  title: z.number().max(100),
})


function pickAndPipe<
  TSrc extends z.AnyZodObject,
  TSrcShape extends TSrc['shape'],
  TDestShape extends { [k in keyof TSrcShape]?: z.ZodTypeAny }
>(source: TSrc, dest: TDestShape) {
  const mask = dest as unknown as { [k in keyof TSrcShape]?: true };
  const picked = source.pick(mask).pipe(z.object(dest));
  return picked;
}

//Here I want any property that I define to be automatically piped from post.
const PipedProperties = pickAndPipe(Post, {
  id: z.string(),
  title: z.string().min(100),
})
```",,
1690039008,2390,"String validations, chaining and transform","I would expect this to work but it does not. 

z.string().url().optional()

If you type something in and then delete it you are still left with an empty string which then fails the url() validation. And now you are stuck.

So why not transform it?

z.string().url().optional().transform(e => e === """" ? undefined : e)

but transform() has to come after url() due to chaining so this doesn't work. So then you have to come up with something ugly to solve a simple problem:

const isUrl = new RegExp(/^(http|https):\/\/[^ ""]+$/);

z.string().optional().transform((e, ctx) => {
            if (e && !isUrl.test(e)) {
                ctx.addIssue({
                    code: z.ZodIssueCode.custom,
                    message: ""Invalid url"",
                })
            }
            return e === """" ? undefined : e;
})

so now you're asking why use zod if it's this unintuitive for something so basic?

",,
1689596746,2387,[Feature Request] Enrich error details,"In `yup` you can attach some metadata in schema, like [`label`](https://www.npmjs.com/package/yup#schemalabellabel-string-schema), [`meta`](https://www.npmjs.com/package/yup#schemametametadata-object-schema). these metadata is helpful to generate a friendly error message.

```js
const schema = object({
  userId: string().label('Manager').meta({ isSelect: true }).required(),
});

setLocale({
  mixed: {
    required: (params) => {
      // indicate that is a select
      if (params.spec.meta.isSelect) {
        return `Select a ${params.label}`;
      }
      
      // show 'Input Handler'
      return `Input ${params.label}`;
    },
  }
})
```",,
1688896290,2385,Datetime validation without offset should allow omission of Z zone designator,"ISO-8601 allows datetime strings to not have any timezone offset or _Z_ zone designator. In these instances, it is assumed to be in local time. (Reference: https://en.wikipedia.org/wiki/ISO_8601#Local_time_(unqualified))

However, the datetime validator currently marks these as invalid.

```ts
const schema = z.string().datetime() // offset: false is default behavior
console.log( schema.safeParse( '2022-01-01T00:00:00' ).success ) // false
```",,
1688548402,2384,ZodIssue docs provides wrong link for discriminated union,"Very tiny thing the link provided [here](https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md#zodissue) for 
the discriminated union doesn't exist

the correct link is:
https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions",,
1687592270,2379,refine doesn't revalidate form onChange on array/object,"[This sandbox](https://codesandbox.io/s/zealous-tristan-5cw1mz?file=/src/App.js) demonstrates the problem.

I have this schema:
```
  const schema = z.object({
    portals: z.array(
      z
        .object({
          firstName: z.string()
        })
        .refine((data) => data.firstName !== """", {
          message: ""First name is required""
        })
    ),
    lastName: z.string().refine((data) => data !== """", {
      message: ""Last name is required""
    })
  });
```
- firstName is a string inside an object inside an array;
-  firstName only gets revalidated on onSubmit.
- lastName is just a string;
- lastName gets revalidated on onSubmit and onChange.

In my real scenario, I have an array which I'd like to revalidate onChange, but I'm unable to.

I've heard I could user React Hook Form's `trigger()` method but I'm looking for a solution which doesn't causes re-render at root level.

Does anyone have a solution for this?

Thanks!

@Edit:
For anyone reading, a terrible workaround is to use React Hook Form's `setError` on the input `onChange` event and set the error manually. The problem with this is that it causes re-render at root level and is likely to cause performance issues when the error is set if you have a large array.",,
1686887496,2376,Not able to assign computed array as Zod enum,"I'm trying to create a Zod object in Astro which takes in `tags` as one of the properties. `tags` can be an array of 0 or more categories.

```ts
const blog = defineCollection({
  schema: () => z.object({
    title: z.string(),
    tags: z
      .array(z.enum(['CSS', 'Reference Docs', 'General', 'Astro']))
      .optional(),
  }),
});
```
The above code works fine (ie when I pass a statically typed array into `Z.enum()`. However, now I'm trying to the tags in an external JSON file and import it and pass a computed array into `Z.enum()`.

```json
[
    {
        ""label"": ""css"",
        ""displayText"": ""CSS"",
        ""coverImage"": ""@assets/unsplash-image.jpg"",
        ""description"": ""Cascading Style Sheets is a language used to describe the visual presentation of web pages.""
    },
    {
        ""label"": ""reference-docs"",
        ""displayText"": ""Reference Docs"",
        ""coverImage"": ""@assets/unsplash-image.jpg"",
        ""description"": ""Reference docs are documents that provide information, instructions, or guidance on how to use a particular product, tool, or technology.""
    },
    {
        ""label"": ""astro"",
        ""displayText"": ""Astro"",
        ""coverImage"": ""@assets/unsplash-image.jpg"",
        ""description"": ""Astro is a static site builder that allows developers to use familiar technologies like JavaScript, CSS, and HTML to build modern websites.""
    },
    {
        ""label"": ""general"",
        ""displayText"": ""General"",
        ""coverImage"": ""@assets/unsplash-image.jpg"",
        ""description"": ""Does not belong to any other categories.""
    }
]
```

```ts
// Import the above JSON data
import tagsJson from '@assets/tags.json'

// Created a computed array
const tagsArray = tagsJson.map(tag=>tag.displayText) as string[]
// Above line equals => ['CSS', 'Reference Docs', 'General', 'Astro']
```

When I pass this `tagsArray` into `Z.enum()`, I get the following error.

```txt
No overload matches this call.
  Overload 1 of 2, '(values: readonly [string, ...string[]], params?: { errorMap?: ZodErrorMap; invalid_type_error?: string; required_error?: string; description?: string; }): ZodEnum<[string, ...string[]]>', gave the following error.
    Argument of type 'string[]' is not assignable to parameter of type 'readonly [string, ...string[]]'.
      Source provides no match for required element at position 0 in target.
Overload 2 of 2, '(values: [string, ...string[]], params?: { errorMap?: ZodErrorMap; invalid_type_error?: string; required_error?: string; description?: string; }): ZodEnum<[string, ...string[]]>', gave the following error.
    Argument of type 'string[]' is not assignable to parameter of type '[string, ...string[]]'.
      Source provides no match for required element at position 0 in target.ts(2769)
```

",,
1686385047,2375,Multiple `ZodString` validations of the same type,"Currently, string validations such as `.max()`, `.min()`, `.startsWith()`, etc. seem to be able to register duplicate same type validations for the same schema.
Since these are contradictory definitions, shouldn't they raise an error on function call or be completely overwritten?
(My apologies if this is a specification intended for some use case I am not aware of.)
```js
const stringSchema
    = z.string()
        .min(1)
        .min(2)
        .startsWith('a')
        .startsWith('b')
    ;
console.dir(stringSchema._def.checks);
// [
//   { kind: 'min', value: 1 },
//   { kind: 'min', value: 2 },
//   { kind: 'startsWith', value: 'a' },
//   { kind: 'startsWith', value: 'b' }
// ]
```

For example, what about the idea of changing `schema._def.checks` to be managed by key-value object instead of an array, as shown below?
```js
// schema._def.checks
{
  min: 2,          // or { value: 2 }
  startsWith: 'b', // or { value: 'b' }
}
```",,
1686156888,2373,Feature request or how to add extra info to shape props?,"Use case: I want to fully derive HTML forms from zod schemas and since some `input` attributes like `hidden` can't be derived, I'd need some ded. info-prop. I could use `.describe()` but it takes string only and it would get messy quickly.",,
1684885782,2370,Struggling with discriminated union,"I want to have discriminated union of sections for CMS.

So for example:
```ts
const SectionA = {
  type: z.literal(""A""),
  enabled: z.boolean(),
}
const SectionB = {
  type: z.literal(""B""),
  enabled: z.boolean(),
}
```
I can easily do discriminatedUnion with this:
```ts
const Sections = z.discriminatedUnion(""type"", [SectionA, SectionB])
```

The problem begins when I want to disable validation when enabled=false

I've tried something like this:
```ts
type AllSectionUnion =
  | typeof SectionA
  | typeof SectionB
  
const allowDisabled = <S extends AllSectionUnion>(schema: S) => {
  return z.discriminatedUnion('type', [
    schema,
    z
      .object({ enabled: z.literal(false), type: schema.shape.type })
      .passthrough(),
  ]);
};


const Sections = z.discriminatedUnion(""type"", [SectionA, allowDisabled(SectionB)])
```

But I get some weird errors. I guess typescript doesn't understand that allowDisabled will be single instantiation of the union.


Any idea how to solve this problem. I would love if simply there was support to disable validation easily conditionally or express my model somewhat.

It works if I use union instead of discriminatedUnions but then I am getting much worse validation errors.",,
1681970457,2366,Zod don't work well with inferFormattedError and error formatting after version 3.21,"We are having some issues after upgrade zod to version `3.21.4`. The problem is that the type returned from `inferFormattedError` is no more matching with `error.format` from a parser. The code bellow simulates this issue:

```typescript
import { ZodType, ZodIssueCode, ZodTypeDef, z } from ""zod"";

type ErrorType = { message: string; code: ZodIssueCode };
type ParserType<T> = ZodType<T, ZodTypeDef, unknown>;
type PayloadParseError<T> = z.inferFormattedError<ParserType<T>, ErrorType>;

const formatError = async <T>(data: T, parser: ParserType<T>) => {
  const parsed = await parser.safeParseAsync(data);

  if (!parsed.success) {
    // In 3.21.4 version, the PayloadParseError<T> type is breaking the code
    const errorDetails: PayloadParseError<T> = parsed.error.format((issue) => ({
      message: issue.message,
      code: issue.code,
    }));
  }
};
```

The code above works in version **`3.20.6`**, but after **`3.21.X`** the `format` output type is no more being recognized along with the output of `inferFormattedError` function.

Could you guys help us with this issue?",,
1680051722,2362,Support for Structured Cloning object discernment,"Hi,

I'm looking to adopt, adapt or create a schema language which can be used with IndexedDB (I'm therefore also interested in a JSON serialization of Zod, but that is a separate issue) and directly reference JavaScript object types (not JavaScript needing to be converted into JSON and then validated with the likes of JSON Schema).

The Structured Cloning paradigm which is used by IndexedDB supports a few types for which it seems Zod does not have current out-of-the-box support, and it raised the question for me whether you might be inclined to ever add them.

- Cyclical object/array references
- `Infinity`, `-Infinity`, `-0`
- Types which can be detected through a ""class string"" (however imperfect this mechanism can be), i.e., the value returned by `Object.prototype.toString.call(obj)`, e.g., helping distinguish `String`/`Number`/`Boolean` built-ins (e.g., `new String('xyz')`), `Error`, `Blob`, `CryptoKey`, etc. (allowing for discernment of built-ins from user objects with a similar type signature)

The first may be difficult, but I expect the others might become formally supported or whether you'd just expect users to use `custom` or such?",,
1678582161,2357,.datetime() validation,"Hello, the current implementation for z.string().datetime() passes validation with incorrect values.

```javascript
const valid_date = z.string().datetime().parse('1234-12-12T12:12:12.123Z'); // valid.
const date_with_max_year = z.string().datetime().parse('9999-12-12T12:12:12.123Z'); // valid.

// Invalid time.
const date_with_invalid_seconds = z.string().datetime().parse('1234-12-12T12:12:99.123Z'); // valid, should throw error -> seconds can't be > 60
const date_with_invalid_minutes = z.string().datetime().parse('1234-12-12T12:99:12.123Z'); // valid, should throw error -> minutes can't be >= 60
const date_with_invalid_hours = z.string().datetime().parse('1234-12-12T99:12:12.123Z'); // valid. should throw error -> hours can't be > 24

// Invalid date.
const date_with_invalid_day = z.string().datetime().parse('1234-12-99T12:12:12.123Z'); // valid, should throw error -> day can't be > 31
const date_with_invalid_month = z.string().datetime().parse('1234-99-12T12:12:12.123Z'); // valid, should throw error -> month can't be > 12

console.log(new Date(valid_date)); // 1234-12-12T12:12:12.123Z
console.log(new Date(date_with_max_year)); // 1234-12-12T12:12:12.123Z

console.log(new Date(date_with_invalid_day)); // Invalid date.
console.log(new Date(date_with_invalid_month)); // Invalid date.

console.log(new Date(date_with_invalid_seconds)); // Invalid date.
console.log(new Date(date_with_invalid_minutes)); // Invalid date.
console.log(new Date(date_with_invalid_hours)); // Invalid date.
```

The same issue might be in ZodString.date() & ZodString.time() implementation (https://github.com/colinhacks/zod/pull/1766)",,
1677437945,2355,`function()` incorrect typing for objects in `.args()`,"I'm defining a function as follows:

```typescript
const func = z
  .function()
  .args(
    z.string(),
    z.object({
      temperature: z.number(),
    })
  )
  .returns(z.string())
  .implement((text, options) => {
    return ""Hello, World!"";
  });
```

However, the `options` variable has a TypeScript type of `{ temperature?: number }`.

![image](https://user-images.githubusercontent.com/30580900/233488773-713521d7-ef2c-40cf-823b-6f1ee29f66e1.png)

I believe this should just be `{ temperature: number }`, right?

Related Discussion: https://github.com/colinhacks/zod/discussions/1771
",,
1677038476,2354,Types from type inference should be shown more simplified,"When defining a type with `z.infer` the type does not get recognized as the named, simplified type, but as the more detailed and complex one.
```typescript
const MySchema = z.object({
  foo: z.string(),
});
type MyType = z.infer<typeof MySchema>;

const x: MyType = {
  foo: ""bar"",
};
```
In this code example hovering `x` doesn't show `const x: MyType` but:
```typescript
const x: {
    foo: string;
}
```
Especially for big and complex types showing `MyType` would drastically improve readability.",,
1676824367,2353,The .url validation accepts `javascript:` schemas which could lead to cross-site scripting vulnerabilities,"The `.url` string validation currently validates for `javascript:` URLs which allows for cross-site scripting vulnerabilities if these URLs are re-displayed in a web app. ([codesandbox](https://codesandbox.io/s/zod-xss-example-l5ckgi)).

The validation also doesn't accept any options to override this behavior. Most people (including myself until recently) probably don't realize that this vulnerability exists, so it would be good to do the following (not mutually exclusive):

1. At least document it so that people are aware
2. Accept options to the `.url` validation to allow people to change the behavior
3. And probably best case change the default behavior of the validation to reject `javascript:` URLs.",,
1676697877,2352,always required in initial load in vue 3 composition api,"I have variable called `const isEnabled = ref(false)`  

my validation code like this
`street: zod
        .string()
        .refine((isEnabled) => isEnabled.value, {
          message: t(""common.validation.required""),
      })`

this works fine on switching but the issue here is the initial load (of component) as you see I set it to `false` the `isEnabled` variable but I getting `required` on initial load.

Thanks in advance",,
1676374217,2351,`flatten()` broken/useless when doing `new z.ZodError()` with a JSON stringified/parsed ZodError coming from the server,"A ZodError goes from server to client, hence is stringified and parsed on its way, and on the client the flatten() method is ofc gone, so I do `new z.ZodError(sentError)` which works BUT using `.flatten()` on latter yields:

```
TypeError: this.issues is not iterable
    at ZodError.flatten ...
```

Do I miss anything?",,
1675649208,2348,Validate an array of object and set error message to one of the array index,"Consider the schema
```
z.array(
    z.object({
        exitPath: z.object({
            exitLocation:  z.string().nonempty('Should be mandatory'),,
        }),
        priority: z.string().nonempty('Should be mandatory'),,
    })
)
```
  I want to make sure that a combination of exitLocation and priority is not duplicated. I can achieve that by 

              
```
refine(
    values => {
        const mappedRoutes = _.map(values, route => {
            return {
                exitLocation: _.get(
                    route,
                    'sdwanExitPath.exitLocation'
                ),
                priority: route.priority,
            };
        });

        const index = findIndexOfFirstDuplicateObject(
            mappedRoutes
        );
        return index !== -1 ? false : true;
    }, {
        message: 'Found duplicate Exit Location',
        path: ['sdwanExitPath', 'exitLocation'],
    }
)
```
How do I set the message to exitLocation {{index}} which is the duplicate value. 'path' does not support array indexes",,
1675457120,2347,Allow introspection of `issues` in `z.RefinementCtx` to allow early escape from expensive `superRefine`ments,"Hello! In the case of an expensive `superRefine` which follows other non-fatal parsing errors:
```
z.string()
  .min(4, { message: ""Min length 4"" })
  .max(20, { message: ""Max length 4"" })
  .superRefine(async (val, ctx) => expensive1000msServerTrip(val, ctx))
```

It would be valuable to be able to break out before the expensive part of the refinement is called. This becomes particularly apparent when validation is being done on a form, where validation of the above string would _always_ call the expensive server trip, taking > 1000ms, despite the instant non-fatal errors from the clamping validators. 

Breaking out could be done by moving the `min` and `max` validations into the `superRefine` itself, but that comes at the cost of some of the magic and composability of zod.

Suggestion: Add an introspective field: **`issues`** to `z.RefinementCtx`, that way non-fatal errors could prevent subsequent expensive calls:
```
  z.string
    .min(4, { message: ""Min length 4"" })
    .max(20, { message: ""Max length 4"" })
    .superRefine(async (val, ctx) => {
      if (ctx.issues.length > 0) return z.Never
      
      // Alternate with some pickiness
      // if (ctx.issues.some((issue) => issue.type === 'too_small')) return z.Never
      
      expensive1000msServerTrip(val, ctx)
    })
```

Let me know what you think!

Also: I'm sure you're in no need of more _validation_ (heh) but zod has been a pleasure to work with, and its become so deeply rooted in my workflow that I almost can't imagine not having it, so thanks!
",,
1675255089,2345,Add `ZodType#isType` as syntactic sugar for type predicate.,"## Problem
I primarily use Zod as a way to strongly type my API integrations. A scenario I find myself in quite often is one where the server performs logic that results in a response that is a union or has nested keys that are a union.

```ts
const User =  z.object({
    first_name: z.string(),
    last_name: z.string()
})

const Staff = User.extend({
    group: z.string(),
    isAdmin: z.boolean()
})

// this type of scenario
const Response = z.object({
    id: z.string(),
    user: z.union([ User, Staff ])
})
```

When accessing these responses inside my application, I have to perform some sort of type narrowing. My initial solution was a generic predicate whose arguments were the type I want to assert and the data I'm asserting against.

```ts
function isType<T extends ZodTypeAny>(schema: T, datum: unknown): datum is z.infer<T> {
    return schema.safeParse(datum).success
}

response.user.group // can't be accessed here

if( isType(Staff, response.user) ){
    response.user.group // no errors
}
```

The more often I found myself using it, the more I wished that Zod had a native way of doing this, specifically:

```ts
if( Staff.isType(response.user) ){
    response.user.group // no errors
}
```",,
1674979307,2344,Consolidate correct type definitions for dynamically created z.object(),"Hello, i have more of a question than issue. my question is how can i consolidate types for dynamically generated zod object.

if i have:
```
z.object({field: z.string()})
```

compiler understands types.

But if i write:
```
class Example {

  @valdiate(z.string())
  public field: string
}
```

For each class `z.object({})` is created and @validate prop just accumulates all fields and its validation rules into one object (`object.setKey(fieldName, rules)`)

later on i fetch this object, but its types are messed up. Its just any.

Is there are way to consolidate them into correct types? To acknowledge fields and and its types. I could convert them to string and than back to zod types in separate file i thought, but i have code in transform fallbacks as well.

I am new to ts and it seems that if it is written into a file and ts compiler can understand everything correctly, but if i stack them together other way, than compiler can't understand what types there are. Where are macros when they are needed :D",,
1674278196,2342,Error.message returns unexpected value,"Hello,

I found a bug in the types of ZodError.message. It should return a string, but returns an Error-Object. Either the Type or the return-value is wrong.

```
import { z } from 'zod'

const myString = z.string()

const results = myString.safeParse(5)

if (!results.success) {
  const message = results.error.message
  // type said message is a string, but got an Array with an Error-Object
  console.log('message:', message)
}

```

BTW: Thank you for this wonderful library!",,
1673784907,2340,Schema bound error map doesn't seem to work?,"```js
const errorMap = (error, ctx) => {
  switch (error.code) {
    case z.ZodIssueCode.invalid_type: {
      if (error.received === ""null"") {
        return { message: ""Required"" };
      }
      break;
    }
  }
  return { message: ctx.defaultError };
};

const a = z.object({ a: z.string() }, { invalid_type_error: ""blah"" });
// No custom message
console.debug(a.safeParse({ a: null }).error.format());
// Custom message
console.debug(a.safeParse({ a: null }, { errorMap }).error.format());

const b = z.ZodObject.create(a.shape, { errorMap });
// No custom message
console.debug(b.safeParse({ a: null }).error.format());
// Custom message
console.debug(b.safeParse({ a: null }, { errorMap }).error.format());

const c = z.object({ a: z.string() }, { errorMap });
// No custom message
console.debug(c.safeParse({ a: null }).error.format());
// Custom message
console.debug(c.safeParse({ a: null }, { errorMap }).error.format());
```

Should contextual error maps behave differently than schema bound error maps?",,
1673622879,2339,IPv6 valdiation is incomplete,"The current IPv6 validator has some issues with completeness. I've noted the following issues.
- Doesn't match upper-case/capitol hex digits.
  - `::F` for example.
- Doesn't match some valid IPv6 addresses
  - Zero form `::` which would become `0:0:0:0:0:0:0:0`. Note that Zod's IPv4 would match `0.0.0.0`, so why not IPv6's similar.
  - ""7::1"" form like `f:f:f:f:f:f::f` which would become `f:f:f:f:f:f:0:f`.
  - ""7-1::"" form like `f:f:f:f:f:f:f::` which would become `f:f:f:f:f:f:f:0`.
    - Also fails for these `f::`, `f:f::`, `f:f:f::`, `f:f:f:f::`, `f:f:f:f:f::`, and `f:f:f:f:f:f::`.
- Doesn't match the valid IPv4 translation form of ""6:v4"" form like `F:F:F:F:F:F:192.168.0.1`, which is valid.
- Matches some inalid compact IPv4 translation. Since the IPv4 octets replace that last two IPv6
  octet pairs; at most 6 pair, or less in compact form, may be present.
  - ""::6:v4"" form like `::F:F:F:F:F:F:192.168.0.1`, which is invalid. It is a compact form with 6 pairs.
  - ""1::5:v4"" such as `F::F:F:F:F:F:192.168.0.1`, which is invalid. It is a compact form with 6 pairs.
  - ""2::4:v4"" such as `F:F::F:F:F:F:192.168.0.1`, which is invalid. It is a compact form with 6 pairs.
  - ""3::3:v4"" such as `F:F:F::F:F:F:192.168.0.1`, which is invalid. It is a compact form with 6 pairs.
  - ""4::2:v4"" such as `F:F:F:F::F:F:192.168.0.1`, which is invalid. It is a compact form with 6 pairs.
  - ""5::1:v4"" such as `F:F:F:F:F::F:192.168.0.1`, which is invalid. It is a compact form with 6 pairs.
",,
1673110839,2336,Make zod globally available in the docs,"Hi there, thanks for the awesome lib!

I suggest that you make `z` globally available in your documentation, so we can try it out in the console.

The [dayjs lib](https://day.js.org/) does it and is very helpful; to test go to the website, open the console and type dayjs.",,
1672231845,2334,ZodUnion inside ZodObject question,"![image](https://user-images.githubusercontent.com/15936231/232653959-6864b330-9c37-4dda-9ad4-77deee460fbc.png)
![image](https://user-images.githubusercontent.com/15936231/232654378-b0623f04-7e79-40ba-a70d-696fff4cacd4.png)


```ts
import {z} from ""zod"";

const adapter = z.object({
    union: z.union([
        z.object({
            name: z.string(),
            ip: z.string(),
        }),
        z.object({
            name: z.string(),
            subnet: z.string(),
        })
    ]),
});
```

why we got 
```ts
type Adapter = {
    union: ({
        name: string;
        ip: string;
    } | {
        name: string;
        subnet: string;
    }) & ({
        name: string;
        ip: string;
    } | {
        name: string;
        subnet: string;
    } | undefined);
}
```

instead of 

```ts
type Adapter = {
    union: {
        name: string;
        ip: string;
    } | {
        name: string;
        subnet: string;
    };
}
```",,
1669624244,2328,RefinementCtx can/should allow more general use cases,"While parsing some data with a huge and convoluted Zod schema, packed with recursion and indirections, I'm looking for a way to ""tag"" some paths when their value fulfills some criteria.

I figured that `superRefine` and `ctx.addIssue` would be perfect for this â€“ just use a custom message which I can pick up later in a custom error map. I already get the path without any extra effort.

However, there is no way to use `ctx.addIssue` and _continue parsing_ after? The status either gets set to dirty or or aborted.

Is there anything like this that I'm missing?",,
1668951350,2327,Benchmark with competitors,"It would be great to have benchmarks with competitors like io-ts, runtypes, etc

See as example https://github.com/gcanti/io-ts/issues/133",,
1668907071,2326,[Feature Request] Tuple type inspection,"<img width=""384"" alt=""image"" src=""https://user-images.githubusercontent.com/457552/232147082-f1ff1f33-0690-4749-9834-4b3de2b10178.png"">

As you can see, we can define a Tuple type with a name. TypeScript will infer them, so we can better understand this tuple type. 
I tried z.Tuple with the field description but seems doesn't work.

 Is there a way to achieve this in zod?

Thank you very much.",,
1668167405,2325,`z.union` type inside `z.object` returns `(UnionType) & (UnionType | undefined)` when `z.array()` is one of the options,"When an array is one of the options in `z.union` inside `z.object`, the inferred type becomes `(UnionType) & (UnionType | undefined)` instead of just `UnionType`.

```ts
const UnionType = z.object({
  test: z.union([z.string(), z.number()])
});
type UnionType = z.infer<typeof UnionType> // { test: string | number }

const UnionTypeBug = z.object({
  test: z.union([z.string(), z.number().array()])
});
type UnionTypeBug = z.infer<typeof UnionTyptBug> // { test: (string | number[]) & (string | number[] | undefined) }, should be { test: string | number[] }",,
1666914630,2324,Support for date-only string field,"Are there plans for implementing in the near future?

I read up on https://github.com/colinhacks/zod/issues/126 and was delighted to hear about the `z.string().datetime()` update, however as @colinhacks mentioned at the end of his [final reply](https://github.com/colinhacks/zod/issues/126#issuecomment-1347806185) in the thread, this does not cover date-only scenarios. Also, something to keep in mind is that while the string regex approach is trivial, it does not account for invalid dates in the right format (ex. 2020-15-01).

I am currently implementing via a custom transform function:
```ts
import { z } from ""zod"";
import moment from ""moment"";

export const date = () =>
  z.string().transform((date, ctx) => {
    if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
      ctx.addIssue({
        code: ""invalid_date"",
        message: mustBeDateOnlyFormatMsg,
      });
      return z.NEVER;
    } else if (!moment(date).isValid()) {
      ctx.addIssue({
        code: ""invalid_date"",
        message: invalidDate,
      });
      return z.NEVER;
    }

    return new Date(date);
  });
```

However I feel that this should be natively supported as it is a common use case:
```ts
import { z } from ""zod"";

/**
* Valid date only string field.
* Has the same effect as the transform function mentioned previously. 
* Would be nice also to parameterize the format i.e DD/MM/YYYY, MM/DD/YYYY etc.
*/
z.string().date()

/**
* Valid time only string field. 
* Would have to solve the same issue mentioned but w/ invalid times. 
* i.e 12:79 should not be accepted.
*/
z.string().time()
```",,
1665102192,2320,`z.record` makes all his attributes optional,"Look at this:

![imagen](https://user-images.githubusercontent.com/58707456/231560761-aefdaf18-25e0-4e19-b30b-87a72c005cb0.png)


It should warn me about `foo` being missing, but isn't  because `z.record` produces this: `Partial<Record<""foo"" | ""bar"", number>>`

Is that intentional because of some reason i don't understand? I read all the docs and I couldn't find anything.

Thank you :heart:",,
1661888163,2318,Add z.select (similar to z.enum but accepting anything as options),"### Problem

Imagine I have a schema that validates a value to be one of the predefined integers. Like when a user chooses the length of the secret key to be either 512, 1024 or 2048 bits (just random example). Naturally, I would imagine there was a Zod schema for that... like `z.enum([512, 1024, 2048])`? Unfortunately, that doesn't work, as `z.enum` only accepts string values.

Another scenario is where the list of options is coming from the variable and is only known in runtime:

```ts
const options = await getOptions(); // string[] or number[] or even any[]
const schema = z.enum(options); // doesn't work
```

### Current workaround

One can use `z.union([z.literal(512), z.literal(1024), z.literal(2048)]` but it's cumbersome, it's arguably slow (as it validates each sub-schema independently) and it doesn't work with option values other than strings and numbers.

### Considered solutions

At first, I was thinking that `z.enum` could be extended to allow any list of anything as valid options (#2317). That is not a viable approach as `z.enum(...).enum` will break then (thanks @igalklebanov for pointing to that).

Another suggested approach was to extend `z.union` to accept literals. I don't like that for two reasons:
* `z.union` is advertised as an aggregating schema builder. Mixing unrelated concepts (nested schemas vs. literals) should be avoided.
* If `z.union` were to accept arbitrary options but treat zod schemas separately, then zod schemas themselves would not be valid options to choose from. (Not that it's a huge tragedy but that is a limitation that could be avoided).

### Suggested approach

I propose to add `z.select` which will be basically `z.enum` without `schema.enum` but accepting anything as the list of options (not even necessarily primitives):

```ts
const Select = z.select([1, 5, ""test"", true]) // or: z.select(options) where options extends any[]
type Select = z.infer<typeof Select> // 1 | 5 | ""test"" | true
Select.options // [1, 5, ""test"", true]
const option = Select.parse(...) // one of options
```

In fact, `z.enum` will probably be a subclass of `z.select` in that case (they will share `schema.options` and probably the actual validation implementation).

The resulting type could be derived from the options with [`ElementOf<...>`](https://github.com/ts-essentials/ts-essentials/tree/afccd3550cc1c03b87d1df4bd590b1e1caa0c930/lib/element-of) recipe.
",,
1661371752,2317,z.enum to allow non-string options,"I recently opened the issue #2312 where I elaborated that the typings of `z.enum` were too restrictive as they didn't allow arbitrary list of strings.

This is the extension of the above problem which goes not only about typings but also about implementation. _(I am opening a separate issue as I realise this is all breaking changes and maintainers tend to disregard them... so I give these separate issues more chance to survive :)_

### Problem

Imagine I have a schema that validates a value to be one of the predefined integers. Like when a user chooses the length of the secret key to be either 512, 1024 or 2048 bits (just random example). Naturally, I would imagine there was a Zod schema for that... like `z.enum([512, 1024, 2048])`? Unfortunately, that doesn't work, as `z.enum` only accepts string values.

### Current workaround

One can use `z.union([z.literal(512), z.literal(1024), z.literal(2048)]` but that's cumbersome (and also arguably slow as it validates each sub-schema independently).

### Suggested approach

What if `z.enum` simply allowed any list of anything as valid options?

Like, what if `z.enum([1, 5, ""testing"", true])` simply worked and validated the value to be one of the options (with `options.includes(value)` as the implementation)? The resulting type could be derived from the options with [`ValueOf<Options>`](https://github.com/ts-essentials/ts-essentials/tree/afccd3550cc1c03b87d1df4bd590b1e1caa0c930/lib/value-of) recipe.",,
1660793451,2315,Using `.transform()` stops `z.discriminatedUnion` from working,"Hi there,

May I please have some help I am stuck with an issue which seems to be caused by `SomeZodType.transform(fn=>...)` when `fn` returns a type which is incompatible with the original `SomeZodType`. Whenever I use `.transform()` the types will no longer work in `z.discriminatedUnion`.
Is this intended behavior, or am I missing something?
Please excuse the really long example code below;


```typescript
// === USER CODE ===

class Position extends Component {
    position = new Vector2(0, 0);
    // ...
    static readonly schema = z.object({
        type: z.literal(""Position""),
        position:Vector2.schema
    }).strict().transform(data=>new Position(data.position));
}

class Velocity extends Component {
    velocity = new Vector2(0, 0);
    // ...
    static readonly schema = z.object({
        type: z.literal(""Position""),
        position:Vector2.schema
    }).strict().transform(data=>new Position(data.position));
}

// === LIBRARY CODE ===
export class Vector2{
    //...
    static readonly schema = z.object({
        type: z.literal(""Vector2""),
        x: z.number().default(0),
        y: z.number().default(0),
    }).strict().transform(data=> new Vector2(data.x, data.y));
}

class Entity {
    readonly uid: string;
    label:string;
    private components: Map<string, Component<any>>;
    //...
    static readonly schema = z.object({
        type: z.literal(""Entity""),
        uid: z.string().nonempty(),
        label:z.string().nonempty().optional(),
        components: ????????????????????????????
    }).strict().transform(data=>new Entity(data.uid, new Map(data.components.map(???)), data.label ?? data.uid));
}
```

At this point I am stuck because

1. `Entity` is part of a library; user code is supposed to implement arbitrary Component types and give each implementation its own `static schema=...`, therefore I can't give `Entity.components` static schema inside the Entity class
3. I want to do
   - user creates list `components = [Velocity.schema, Position.schema]`
   - user calls `Entity.register_components(components)`
   - Entity.schema is updated with `z.discriminatedUnion(""type"", components)`
   - User uses the parser as below
   
```typescript 
Entity.schema.parse({
    type:""Entity"",
    uid:""xxxx123"",
    label:""the thing"",
    components:[
        {
            type:""Position"",
            position:{type:""Vector2"", x:10, y:10}
        },
        {
            type:""Velocity"",
            velocity:{type:""Vector2""}
        }
    ]
})
```

Whenever I try to make a function that passes a list of component schemas into `z.discriminatedUnion` I get a massive error which is hard to understand;

```text
Type 'ZodEffects<ZodObject<{ type: ZodLiteral<""Velocity"">; velocity: ZodDefault<ZodOptional<ZodEffects<ZodObject<{ type: ZodLiteral<""Vector2"">; x: ZodDefault<ZodNumber>; y: ZodDefault<ZodNumber>; }, ""strict"", ZodTypeAny, { ...; }, { ...; }>, Vector2, { ...; }>>>; }, ""strict"", ZodTypeAny, { ...; }, { ...; }>, Velocity, { ....' is missing the following properties from type 'ZodObject<{ type: ZodTypeAny; } & ZodRawShape, UnknownKeysParam, ZodTypeAny, { [x: string]: any; type?: any; }, { [x: string]: any; type?: any; }>': _cached, _getCached, shape, strict, and 14 more.ts(2740)
(property) Velocity.schema: z.ZodEffects<z.ZodObject<{
    type: z.ZodLiteral<""Velocity"">;
    velocity: z.ZodDefault<z.ZodOptional<z.ZodEffects<z.ZodObject<{
        type: z.ZodLiteral<""Vector2"">;
        x: z.ZodDefault<z.ZodNumber>;
        y: z.ZodDefault<z.ZodNumber>;
    }, ""strict"", z.ZodTypeAny, {
        ...;
    }, {
        ...;
    }>, Vector2, {
        ...;
    }>>>;
}, ""strict"", z.ZodTypeAny, {
    ...;
}, {
    ...;
}>, Velocity, {
    ...;
}>
```

I tried my best to find any existing issues or questions... this one looks related? #2146 . There was a suggestion in that thread to try zod@canary, but that doesn't seem to have helped.",,
1660621320,2313,refine is not working when we have array,"I have a schema like this:
```
const schema = () =>
  z
    .object({
      reg: z.string({}).optional(),
      vin: z.string({}).optional(),
      vehicle_num: z.string({}).optional(),
      data: z.array(
        z.object({
          description: z.string({
            required_error: translate(
              'new_request.description_or_number_is_required'
            ),
          }),
        })
      ),
    })
    .refine(({ reg }) => reg, {
      path: ['reg'],
      message: 'error',
    });
```
here refine is not working but when I comment the data it's working:
```
const schema = () =>
  z
    .object({
      reg: z.string({}).optional(),
      vin: z.string({}).optional(),
      vehicle_num: z.string({}).optional(),
      // data: z.array(
      //   z.object({
      //     description: z.string({
      //       required_error: translate(
      //         'new_request.description_or_number_is_required'
      //       ),
      //     }),
      //   })
      // ),
    })
    .refine(({ reg }) => reg, {
      path: ['reg'],
      message: 'error',
    });
```",,
1659815434,2312,z.enum typings are too restrictive,"This is related to #2280 but from a different perspective.

Consider a schema with a enum field which is dynamically generated with the database options (a fairly reasonable scenario in my thinking). The current typings simply don't allow this:

```ts
const options = await EnumOptionModel.query().where(...).then(map('option')) // returns string[]
const schema = z.enum(options) // Error: Argument of type 'string[]' is not assignable to parameter of type 'readonly [string, ...string[]]'
```

Granted, the list of options coming from the database could be empty. However, the author might be okay with the schema never validating in that case. Like what if they are developing a form constructor? The form will indeed never validate with no options, but under the circumstances that will be the desired behaviour. Why should Zod disallow that code?

This is happening due to:

https://github.com/colinhacks/zod/blob/51e14beeab2f469fcbf18e3df44653e1643f5487/src/types.ts#L3918

I think this is over-designed (see above why) and the whole type should be removed in favour of simple `string[]`. I realize that doing so will result in a breaking change, so I'd suggest `EnumValues` first to be set to `string[]` and marked as deprecated, then perhaps removed several releases later.",,
1659620031,2311,Very slow autocompletion performance on VSCode.,"Hi there,

I was wondering if anyone else is having similar issues where the TypeScript autocompletion in VSCode is very slow and makes my CPU usage spike? I made [an issue](https://github.com/microsoft/TypeScript/issues/45824#issuecomment-1500959079) before in the official TypeScript repository and just commented on it.

I am not quite sure why this is happening but it is quite frustrating, thanks a lot.

Hope someone is able to help me out, thanks!",,
1659341860,2310,ZodObject.extends() metadata,"It would be very useful to have some information stored against the ZodObject about the object which was extended from.

Context: I'm trying to create a plugin which will be enhanced by knowing when an object extended another.

eg. 

```ts
const a = z.object({
  prop1: z.string()
});

const b = a.extend({
  prop2: z.string()
});

console.log(b._def.extends)
// returns reference to a
```",,
1659151163,2308,`transform` does not run after previous `refine` returned false,"Hello,

Given this minimal example:
```typescript
const nameToGreeting = z
  .string()
  .transform(val => val.toUpperCase())
  .refine(val => val.length > 15, 'must be longer than 15')
  .transform(val => `Hello ${val}`)
  .refine(val => {
    console.log(val); // val is 'JOHN DOE' here
    return val.indexOf('!') === -1;
  });

console.log(nameToGreeting.safeParse('John Doe'));
```

The second transform is skipped. The refine that follows it receives the once-transformed uppercase string, without the added `""Hello ""`.

I did not find any explanation of this in the docs. The only issue that is related to this is https://github.com/colinhacks/zod/issues/506.

I believe this is a bug. If this behavior is intended, I believe it should be explained in the docs.

The expected behavior would be to
- run the transform regardless of whether the previous refine failed or not

OR
- after returning false in a refine, not run any following refines
",,
1658608725,2306,Monorepo:  The types of '_def.errorMap' are incompatible between these types.,"I have a monorepo with multiple apps which use multiple packages. Some of these packages require the app to pass Zod schemas to the package. However, I keep getting an error when trying to type the parameters to a function. They have the same Zod version and even weirder is that they direct to the same package location. My package function looks like this:

```typescript
const useForm = (schema: z.ZodObject<any>) => {
	const errorStore: ValidationErrors = writable({});
}
```

The call in my boiler:

```typescript
const test = z.object({
	id: z.string().cuid().optional(),
	name: z.string()
})
.strict();
const { validate } = useForm(test);
```

And then I get this error:

```
Argument of type 'ZodType<GroupCreateInput, ZodTypeDef, GroupCreateInput>' is not assignable to parameter of type 'ZodType<any, ZodTypeDef, any>'.
  The types of '_def.errorMap' are incompatible between these types.
    Type 'Zod.ZodErrorMap | undefined' is not assignable to type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodErrorMap | undefined'.
      Type 'Zod.ZodErrorMap' is not assignable to type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodErrorMap'.
        Types of parameters 'issue' and 'issue' are incompatible.
          Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodIssueOptionalMessage' is not assignable to type 'Zod.ZodIssueOptionalMessage'.
            Type 'ZodInvalidUnionIssue' is not assignable to type 'ZodIssueOptionalMessage'.
              Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodInvalidUnionIssue' is not assignable to type 'Zod.ZodInvalidUnionIssue'.
                Types of property 'unionErrors' are incompatible.
                  Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodError<any>[]' is not assignable to type 'Zod.ZodError<any>[]'.
                    Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodError<any>' is not assignable to type 'Zod.ZodError<any>'.
                      Types of property 'issues' are incompatible.
                        Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodIssue[]' is not assignable to type 'Zod.ZodIssue[]'.
                          Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodIssue' is not assignable to type 'Zod.ZodIssue'.
                            Type 'ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodIssue'.
                              Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'Zod.ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }'.
                                Type 'ZodInvalidUnionIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodInvalidUnionIssue'.
                                  Types of property 'unionErrors' are incompatible.
                                    Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodError<any>[]' is not assignable to type 'Zod.ZodError<any>[]'.
                                      Type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodError<any>' is not assignable to type 'Zod.ZodError<any>'.
                                        Types of property 'addIssue' are incompatible.
                                          Type '(sub: import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodIssue) => void' is not assignable to type '(sub: Zod.ZodIssue) => void'.
                                            Types of parameters 'sub' and 'sub' are incompatible.
                                              Type 'Zod.ZodIssue' is not assignable to type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodIssue'.
                                                Type 'ZodInvalidLiteralIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'ZodIssue'.
                                                  Type 'Zod.ZodInvalidLiteralIssue & { fatal?: boolean | undefined; message: string; }' is not assignable to type 'import(""/Users/jessie/projects/jcbdevelopment/jcb/node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/ZodError"").ZodInvalidLiteralIssue & { fatal?: boolean | undefined; message: string; }'.
                                                    Property 'received' is missing in type 'ZodInvalidLiteralIssue & { fatal?: boolean | undefined; message: string; }' but required in type 'ZodInvalidLiteralIssue'.
```",,
1657857988,2304,Type error with z.object({}).passthrough(),"Hello,

We depend on Zod and have run into an issue which prevents us upgrading from version 3.18.0 -> 3.21.4. We are on Typescript 4.7.4 but I reproduced with Typescript 4.9.5 as well.

We make use of `z.object({}).passthrough()` to generically represent a type containing an object of unknown type. The intent is to be able to parse that field with a more specific schema elsewhere in the code. Most commonly, this aligns with a JSONB column in a Postgres table that can represent many things. 

When upgrading to a newer zod version, we run into type errors preventing compilation. The error states:

```
(property) value: {} & {
    [k: string]: unknown;
}
Type 'SpecificConfig' is not assignable to type '{} & { [k: string]: unknown; }'.
  Type 'SpecificConfig' is not assignable to type '{ [k: string]: unknown; }'.
    Index signature for type 'string' is missing in type 'SpecificConfig'.ts(2322)
Untitled-12(7, 5): The expected type comes from property 'value' which is declared here on type '{ user_id: string; created: Date; key: string; value: {} & { [k: string]: unknown; }; }'
```


Here is an example that reproduces the error--line 40 (`config: configVal,`) contains the type error.

```typescript
import {z} from 'zod'

/**
 * SQL table
 * 
 * config
 * ---------------
 *  CREATE TABLE config (
 *    user_id VARCHAR(255) NOT NULL,
 *    created TIMESTAMP NOT NULL,
 *    key VARCHAR(255) NOT NULL,
 *    value JSONB NOT NULL,
 *    PRIMARY KEY (user_id, key)
 *  );
 */

const configSchema = z.object({
    user_id: z.string(),
    created: z.date(),
    key: z.string(),
    value: z.object({}).passthrough(),
})

type Config = z.infer<typeof configSchema>

interface SpecificConfig {
    foo: string
}

function makeSpecificConfig(): Config {

    const configVal: SpecificConfig = {
        foo: 'bar'
    }

    return {
        user_id: '123',
        created: new Date(),
        key: 'foo',
        value: configVal,
    }
}
```

What can we do to address this? What is the right use of zod to support this use case?

Thank you!",,
1657843607,2303,Create query sintax for feathers api,"I need to do something like this 

$limit: import(""@sinclair/typebox"").TNumber;
$skip: import(""@sinclair/typebox"").TNumber;
$sort: TObject<T[""properties""] extends infer T_2 ? { [K_1 in keyof T_2]: TOptional<TInteger>; } : never>;
$select: import(""@sinclair/typebox"").TUnsafe<(keyof T[""properties""])[]>;

I have problem with $select and $sort operations

const defaultQueries: <T extends z.SomeZodObject | z.ZodIntersection<z.SomeZodObject, T>, K extends string[]>(
  type: T,
  keys: K
) => z.ZodIntersection<
  T,
  z.ZodOptional<
    z.ZodObject<{
      $limit: z.ZodNumber
      $skip: z.ZodNumber
    }>
  >
\> = undefined


Thanks.",,
1657015961,2302,zod@3.21.4 fails on firefox 68 : invalid identity escape in regular expression,"Hi everyone, 

thanks for this awesome project.

Unfortunately I have to report a bug (minor? maybe?). But I'm working on a project that requires a large compatibility spectrum, up to ffx68.

Unfortunatelly ffx68 raises the following error: 
Maybe it's linked to : https://github.com/colinhacks/zod/blob/a263814fc430db8d47430cd2884d2cea6b11c671/src/types.ts#L556 ?

Downgrading to zod@3.20.2 fixed it.

Best
",,
1656132431,2300,`.toLowerCase/UpperCase()` should infer to `Lowercase/Uppercase<string>`,"The [Lowercase](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#lowercasestringtype) and [Uppercase](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#uppercasestringtype) types are relatively new to TS and already have [analogs in Zod](https://github.com/colinhacks/zod#strings).

When I do this:
```ts
const MySchema = z.string().toLowerCase();
type MyType = z.infer<typeof MySchema>;
```
I should get this:
```ts
type MyType = Lowercase<string>
```
In zod v3.21.4, I get this:
```ts
type MyType = string
```",,
1655525851,2297,.preprocess or .default do not work when called on a subfield of an optional object,"I am not sure if this is a bug or a feature but this is what happens:

### Test Case
```ts
  it('boolean field in nested object should return false if undefined', () => {
    const exampleSchema = z.object({
      foo: z
        .object({
          bar: z.preprocess((v) => {
              if (v === undefined || v === null) return false
              return v
           }, z.boolean())
        })
        .optional()
    })

    const result = exampleSchema.parse({})

    expect(result).toEqual({ foo: { bar: false } }) // Result equals to `{}` instead.
  })
```

Using default does not work as well:


```ts
  it('boolean field in nested object should return false if undefined', () => {
    const exampleSchema = z.object({
      foo: z
        .object({
          bar: z.boolean().default(false)
        })
        .optional()
    })

    const result = exampleSchema.parse({})

    expect(result).toEqual({ foo: { bar: false } }) // Result equals to `{}` instead.
  })
```
",,
1654679203,2295,Schema inference - similar to `yup.mixed<Type>()`,"I can't find this anywhere in the documentation or issues on github. 

```ts
import { PaletteOptions } from ""@mui/material/styles"";

type Account = {
  uuid: string;
  name: string;
  palette?: Pick<PaletteOptions, ""primary"" | ""secondary"">;
}

// yup
const Schema = y.object({
  uuid: y.string().required(),
  name: y.string().required(),
  palette: y.mixed<Pick<PaletteOptions, ""primary"" | ""secondary"">>() //     <----
});

// zod
const Schema = z.object({
  uuid: z.string(),
  name: z.string(),
  palette: // ???     <----
});
```

I know that using `z.infer` I can get `type` from `schema` but can I get `schema` from `type` like in `yup`?",,
1654299809,2293,"z.object().passthrough(), z.number().transform(), and z.intersection() causing ""invalid_intersection_types""","Hello, 

Given the following schemas:

```typescript
export const paginated = z.object({
  paging: z
    .object({
      next: z.string(),
    })
    .passthrough(),
}).passthrough();

export const myObject = z.object({
  created: z.number().transform((value) => new Date(value)),
}).passthrough();

export const fullSchema = z.intersection(
  z.object({
      objects: z.array(myObject),
    }).passthrough(),
  paginated,
);
```
which I use to parse the following:
```typescript
const zodResult = fullSchema.safeParse({
  objects: [
    {
      created: 1638767655,
    },
  ],
  paging: { next: '123' },
});
```

I get the following error: 
```typescript
{
  code: 'invalid_intersection_types',
  path: [],
  message: 'Intersection results could not be merged'
}
```

After some testing, I've found that removing the `.passthrough()` calls or removing the `.transform()` stops the issue, but unfortunately in this instance I need to use both of them. Is this known or expected behavior? Is there some workaround?",,
1654158947,2292,Can we have minLength and maxLength getters for array() as well?,I see these getters are defined for string but could we get them on array. I see they are defined on _def but feels like i shouldn'y expect to use a private member.,,
1653520274,2290,Deeply nested schema results in a huge bundle size,"I have a very complex schema, and when I try to build it, it produces a really big bundle size (1.2MB):

```text
zod-explode â¯ pnpm build
> tsup src/index.ts --format esm,cjs --dts --clean

CLI Building entry: src/index.ts
CLI Using tsconfig: tsconfig.json
CLI tsup v6.7.0
CLI Target: es2022
CLI Cleaning output folder
ESM Build start
CJS Build start
ESM dist/index.mjs 2.93 KB
ESM âš¡ï¸ Build success in 43ms
CJS dist/index.js 4.90 KB
CJS âš¡ï¸ Build success in 44ms
DTS Build start
DTS âš¡ï¸ Build success in 942ms
DTS dist/index.d.ts 1.20 MB
```

I created an example repo for that: https://github.com/fehergeri13/zod-explode/blob/bc35120c51f43eed226102fad2341339958506e9/dist/index.d.ts

When I replace the `.object` with a custom implementation, I can reduce the bundle size to a much more sustainable size, but I'm not sure what I risk

```ts
function object<T extends ZodRawShape>(shape: T) {
  return z.object(shape) as ZodType<baseObjectOutputType<T>, ZodTypeDef, any>;
}
```

```text
DTS dist/index.d.ts 78.40 KB
```

https://github.com/fehergeri13/zod-explode/blob/master/dist/index.d.ts

Is there a way, to reduce the output size by default without this ""hack""?",,
1651689335,2286,Runtime introspection of `z.instanceof()`?,"In React Zorm I'd like to [automatically add](https://github.com/esamattis/react-zorm/discussions/48) `type=""file""` to the input when user defines a field with

```ts
const FormSchema = z.object({
    image: z.instanceof(File)
});
```

But unfortunately there does not seem to be way to check what was the class passed to `z.instanceof()`?

Something like this would be great

```ts
expect(FormSchema.shape.image.cls).toBe(File);
```

",,
1650657925,2285,New feature: z.date().utc(),"Because of the differences when the date field goes from backend(probably UTC) to client(local timezone) it's easy to get a date(YYYY-mm-dd) 1 day behind/forward and have to deal with it manually, specially when using form inputs with type=date.

Therefore I propose that this transform:

```ts
z.date().transform((val) => convertDateToUTC(val));

function convertDateToUTC(date: Date) {
	return new Date(
		date.getUTCFullYear(),
		date.getUTCMonth(),
		date.getUTCDate(),
		date.getUTCHours(),
		date.getUTCMinutes(),
		date.getUTCSeconds()
	);
}
```

Becomes this core function:
```ts
z.date().utc()
```",,
1650427217,2284,Equality between properties of the schema,"In the case of comparing two passwords for instance (`password` & `passwordConfirmation`), it would be great to have a way of comparing the two inside the schema.

```javascript
const registrationSchema = z.object({
  password: z.string(),
  passwordConfirmation: z.equals(schema => schema.password.value)
});
```

The schema is deliberately simplified for demonstration purposes.

Here above, the `equals` could be an operator that helps check if the value is equal (`===`) to the wanted property of the schema.

This could also be great to enable this operator with a `refine` when needed.

```javascript
z.string().refine((value, schema) => {
  return schema.password.value === value;
})
```

This would not mean breaking the API if this is another parameter that the `refine` method accepts.

Or, it could be a completely new method.

```javascript
z.string().compare((value, schema) => {
  return schema.password.value === value
})
```

> This would also be useful for unlocking cool things for dates for instance `z.date().after(schema => schema.beginDate.value)`

Either way, the point is that it would be awesome to be able to reflectively inspect values from our own schema for that particular case and others to come.

*Note: the code excerpts above are only pseudo-code blocks, the API might be changed completely, I didn't read the full source-code to adapt these examples.*",,
1649052124,2281,Modify schema with a closure,"### Problem

From what I see, that is not possible to construct a zod schema conditionally without `let`, temporary local variables, self-executing function and such.

Let's say I have a schema for a user and their address:

```ts
const user_schema = z.object({
  name: z.string(),
  address: z.object({
    city: z.string(),
  }),
})
```

Now let's imagine I create this schema in a context, and based on the context I may want city to be nullable:

```ts
function create_user_schema(ctx: { city_nullable: boolean }) {
  let city_schema = z.string()
  if (ctx.city_nullable) {
    city_schema = city_schema.nullable()
  }

  return z.object({
    name: z.string(),
    address: z.object({
      city: city_schema,
    }),
  })
}
```

Not only this is ugly and lengthy: with duck typing as above, this leads to type error: `Type 'ZodNullable<ZodString>' is missing the following properties from type 'ZodString': _regex, _addCheck, email, url, and 29 more` (I realise that the error could be avoided by an additional intermediate schema variable - that's not the point).

As the logic extends into the tree of variants, this type of code becomes hard to maintain.

### Proposal

Inspired by [Knex modify](https://knexjs.org/guide/query-builder.html#modify), I propose to add a new generic method to `ZodType`, so that the example above could be converted to:

```ts
function create_user_schema(ctx: { city_nullable: boolean }) {
  return z.object({
    name: z.string(),
    address: z.object({
      city: z.string().modify(schema => {
        // Executed once upon schema creation - not when parsing
        return ctx.city_nullable ? schema.nullable() : schema
      }),
    }),
  })
}
```

The code becomes much simpler. The 'modification' is directly attached to the proper position inside the (possibly large) schema tree. The namespace is not polluted needlessly.

If I understand correctly, the actual implementation will be as simple as:

```ts
class ZodType {
  // TODO: add proper typings
  modify(fn) {
    return fn(this)
  }
}
```",,
1648702385,2280,Restrict z.enum options to existing type,"### Problem

I want to restrict options passed to `z.enum` to the existing type.

```ts
type Status = 'new' | 'accepted' | 'closed'

z.enum(['new', 'accepted']) // OK
z.enum(['new', 'approved']) // Invalid choice - should be somehow disallowed
```

Is there an elegant way to statically validate the typings of enum options?

### Solutions tried

```ts
z.enum(['new', 'accepted'] as Status[]) // Argument of type 'Status[]' is not assignable to parameter of type '[string, ...string[]]'.
z.enum(['new', 'accepted'] satisfies Status[]) // Argument of type '(""new"" | ""acepted"")[]' is not assignable to parameter of type '[string, ...string[]]'.
z.enum<Status>(['new', 'accepted']) // Expected 2 type arguments, but got 1
z.enum(['new', 'accepted'] as [Status, ...Status[]]) // works, but ugly
z.enum(['new', 'accepted'] satisfies [Status, ...Status[]]) // works, but ugly
z.enum(['new', 'accepted'] as const satisfies readonly Status[]) // works, but could it be simpler?
```

at least a built-in helper would be useful:

```ts
z.enum(['new', 'accepted'] as z.EnumOptions<Status>) // self explanatory
```",,
1646759572,2275,Numbers Bypass z.string().emoji(),"Just found a weird bug that was verified by another dev... numbers will bypass the z.string().emoji() check... probably because emojis are represented as numbers... or something along the sorts. Anyway, trying to figure out a solution and will pull request it if someone doesn't already beat me to it!",,
1645807038,2270,how can I validate an array of objects where each item should contain only one property ?,"Hello, I need to validate something like

```ts
[
       {""http://example.com/rel/1/"" : ""my meta 14""},
       {""http://example.com/rel/2/"" : ""345""}
]
```

It  is an **array** that should 
* contain only **objects**
* each object can only have **between 0 and 1 property**
* the property name **must be an URL**, but is **not strictly defined** (my users add them)

I tested this
```ts

//meta
const metaSchema = z.object()
.refine((obj) => {
  return isSinglePropObj(obj);
},
{
  message:
    ""The object can contain only one property.""
})
.refine((obj) => {
  return ObjIsUriKeys(obj);
},
{
  message:
    ""The object property name should be an URI.""
})
.array();


//checks that the object has maximum one property
const isSinglePropObj = (obj:object) => {
  return Object.keys(obj).length <= 1;
}

//check all keys of this object are URIs
const ObjIsUriKeys = (obj:object) => {
  return Object.keys(obj).every(k => isUriString(k));
}

//checks the string is an URI
const isUriString = (str:string) => {
  str.trim();
  try {
    new URL(str);
    return true;
  } catch (err) {
    return false;
  }
}


```

But it doesnt work because

```ts
const metaSchema = z.object()
```

needs parameters: 

> An argument for 'shape' was not provided

I don't know what I have to pass as shape since I don't know what will be the data passed - eg. don't know what the property name will be.

How can I manage to achieve this ?

Thanks !",,
1645626157,2269,v3.21.0 Incompatible with React Native environment,"### Description

[`zod >=3.21.0`](https://github.com/colinhacks/zod/releases/tag/v3.21.0) is incompatible in the default React Native 0.70 environment after https://github.com/colinhacks/zod/pull/2090

The issue seems to come from use of the `Unicode property escape` syntax, which is currently not supported by Hermes (the default React Native JS engine)
```ts
const emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
```

Easiest way to reproduce is by creating a new [Expo](https://expo.dev/) app with Hermes enabled.
",,
1645294213,2268,Get all default value from Zod schema,"Hi guys, is it possible to get the default value from Zod? Thank you so much , ie:
```
const schema = z.object({
  name: z.string().default('ABC')
});
const defaultVal = getAllDefaultVal(schema) // { name: ""ABC"" }
```",,
1644662848,2267,Error in regex for email validation in PR #1982 and #2058,"It was pointed out to me (https://github.com/colinhacks/zod/pull/1982#issuecomment-1487157041, #2154) that the regex I wrote has problems with some valid emails, I looked it again and I found the problem in the final part:
``` ts
([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))
```
I got confused between domain name, subdomains and top level domain.
I also saw PR #2157 from @colinhacks who wants to make the email regex simpler so if he decides he doesn't want to change it I could fix it",,
1644548220,2264,extending recursive types,"Hi, thanks for the great work!

I'm having an issue with the example on recursive types found in the documentation. Defining recursive types works well, but as soon as I try to extend from a recursive type, TypeScript complains. Here is what TypeScript is saying:
```
Property 'extend' does not exist on type 'ZodType<Category, ZodTypeDef, Category>'
```
Here is my example:
```TypeScript
const baseCategorySchema = z.object({
	name: z.string(),
});

type Category = z.infer<typeof baseCategorySchema> & {
	subcategories: Category[];
};

const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
	subcategories: z.lazy(() => categorySchema.array()),
});

// This is where the issue occurs
const filmCategorySchema = categorySchema.extend({
	director: z.string(),
});
```

I do understand, that `ZodType` could by something that isn't extendable, but I'm not sure how to tell zod that it is.",,
1643548342,2260,Generic schema builder compiles into invalid type definitions,"If you define a function which accepts a generic type parameter and returns a Zod object schema containing a string literal based on that type parameter then the code looks fine and typescript will compile it

The declaration file emitted is invalid though and cannot be imported into another project

### Minimal reproduction:
`./src/index.ts`
```TypeScript
import { z } from 'zod';

export const schemaBuilder = <V extends string>(version: V) => {
  return z.object({
    version: z.literal<V>(version),
  });
};
```

When compiled will emit the following declaration file
`./dist/index.d.ts`
```TypeScript
import { z } from 'zod';
export declare const schemaBuilder: <V extends string>(version: V) => z.ZodObject<{
    version: z.ZodLiteral<V>;
}, ""strip"", z.ZodTypeAny, z.objectUtil.addQuestionMarks<z.baseObjectOutputType<{
    version: z.ZodLiteral<V>;
}>, undefined extends V ? never : ""version""> extends infer T ? { [k_1 in keyof T]: z.objectUtil.addQuestionMarks<z.baseObjectOutputType<{
    version: z.ZodLiteral<V>;
}>, undefined extends V ? never : ""version"">[k_1]; } : never, z.baseObjectInputType<{
    version: z.ZodLiteral<V>;
}> extends infer T_1 ? { [k_2 in keyof T_1]: z.baseObjectInputType<{
    version: z.ZodLiteral<V>;
}>[k_2]; } : never>;

```

When imported this throws the errors:
```
./dist/index.d.ts:6:84 - error TS2536: Type 'k_1' cannot be used to index type 'addQuestionMarks<baseObjectOutputType<{ version: ZodLiteral<V>; }>, undefined extends V ? never : ""version"">'

./dist/index.d.ts:10:46 - error TS2536: Type 'k_2' cannot be used to index type 'baseObjectInputType<{ version: ZodLiteral<V>; }>'.
```

I can't seem to find where the `extends infer T` is coming from on line 6 anywhere in the Zod code. Same goes for the `extends infer T_1` on line 10

### Relevant configuration:
 - Zod version: 3.21.4
 - Typescript version: 4.9.5 (also tested on v5)
 - tsconfig.json:
 ```json
 {
  ""compilerOptions"": {
    ""lib"": [ ""es2015"" ],
    ""sourceMap"": true,
    ""target"": ""es5"",
    ""outDir"": ""./dist"",
    ""baseUrl"": ""./src"",
    ""declaration"": true,
    ""moduleResolution"": ""node"",
    ""esModuleInterop"": true,
    ""strict"": true
  },
  ""include"": [
    ""src/**/*.ts""
  ],
  ""exclude"": [
    ""node_modules""
  ]
}
 ```
- Build pipeline: Just running `tsc`

### Additional information
If the generic function directly returns a Zod literal schema based on the passed generic then everything seems to work fine. Only putting that literal into an object seems to break the definition",,
1643538607,2259,Add Ethereum address option for `z.string()`,"Hi, I've been loving integrating zod into our web3 projects. 

Often we have to verify whether a string is a valid Ethereum address or not, it would be extremely useful to have something like `z.string().ethereumAddress('Not a valid wallet address')`

We are currently doing something like this ([source](https://ethereum.stackexchange.com/a/146766)):
```
import { isAddress } from 'ethers'; // ethers v6

const Address = z.custom<string>(isAddress, ""Invalid Address"")
```
in order to validate addresses, but it would be much better to have native support.

This simple regex would be enough: `/^0x[a-fA-F0-9]{40}$`",,
1643451644,2258,Return data and errors,"I'm finally getting around to taking Zod for a spin. I'm using `safeParse` so things don't blow up, however it would be great if there was a way that it would still return the parsed data as well as any errors it finds.

My use case: 

I'm fetching a large amount of data and would like to display it all, even if there are a few errors. I can do this by using things like `z.coerce` and `.nullable()`, and I believe I can use `transform` (however I'm trying to be wary of performance).

Ultimately i'd like to be informed if there are any errors so I can do something about them, but I don't want to prevent the user from using the app, as it's very likely they wouldn't notice anyway.

If `safeParse` could return something like this it would be awesome:

```ts
{
   data: ParsedData,
   error: Errors[]
   success: Boolean
}
```
",,
1643188781,2257,Parsing Returns the Wrong Type,"The type extracted from parse and safe parse are optional on a basic ```z.object({})```.

I put together an codesandbox to demonstrate the issue based on the 2nd basic usage example.

[https://github.com/colinhacks/zod#basic-usage](https://github.com/colinhacks/zod#basic-usage)
[https://codesandbox.io/p/sandbox/angry-shadow-t3ot3s](https://codesandbox.io/p/sandbox/angry-shadow-t3ot3s?file=%2Fsrc%2Findex.ts)

Not sure if this is a bug or if I have something misconfigured. 

btw: the library is awesome",,
1643024773,2256,bug: `z.string().url()` is incosistent across browser,"Just learned that `z.string().url()` actually fails on firefox for `https://*.example.com` while it passes for every other browser.

Not too sure if this inconsistency is intended or not.

Happy to make a PR to help resolve the inconsistency with the `new URL` being used under the hood for FF.

On version `zod: 3.20.2`",,
1642422556,2251,Feature request deepRequired,"Hello,

I am at a point where I need to generate sample data from a schema and for that I need to have all possible values of the schema tree.

I notice there is a `.deepPartial` method but I need the opposite so the `.deepRequired` method.

Any reason this method does not exist ?

Thanks",,
1641524735,2249,Unable to work with objects when using `z.ZodType<T>` for circular dependencies,"This is a fantastic library, but I'm very new to it and am confused as to why the following does not work.

Below is part of my schema which follows the example for recursive types, as per the [the documentation](https://github.com/colinhacks/zod#recursive-types).
```ts
const baseProfileSchema = z
  .object({
    id: z.string().uuid(),
    userId: z.string().uuid(),
    groupId: z.string().uuid(),
    fullName: z.string(),
    isAdmin: z.boolean(),
    isSupporter: z.boolean(),
    default: z.boolean(),
    createdAt: z.string().datetime(),
    updatedAt: z.string().datetime(),
  })
  .strict();

type Profile = z.infer<typeof baseProfileSchema> & {
  group?: Group;
};

const baseConversationSchema = z
  .object({
    id: z.string().uuid(),
    groupId: z.string().uuid(),
    messages: z.string().array(),
    createdAt: z.string().datetime(),
    updatedAt: z.string().datetime(),
  })
  .strict();

type Conversation = z.infer<typeof baseConversationSchema>;

export const groupSchema: z.ZodType<Group> = baseGroupSchema
  .extend({
    profiles: z.lazy(() => profileSchema.array().optional()),
    conversations: z.lazy(() => conversationSchema.array().optional()),
  })
  .strict();

export const profileSchema: z.ZodType<Profile> = baseProfileSchema
  .extend({
    group: z.lazy(() => groupSchema),
  })
  .strict();
  ```
  
  I cannot work with any of the objects typed with `z.ZodType<T>` though.
  ```ts
  const newProfile = profileSchema.omit({});
  // Property 'omit' does not exist on type 'ZodType<Profile, ZodTypeDef, Profile>'.
  
  const partialProfile = profileSchema.partial()
  // Property 'partial' does not exist on type 'ZodType<Profile, ZodTypeDef, Profile>'.
  ```
  
  Can anyone provide some insight as to what I may be doing wrong? Thank you!",,
1640977570,2246,TypeScript error since Zod 3.19.1 when using refine ,"Description:
I recently upgraded my project's dependency on the Zod library from version 3.19.0 to 3.19.1, and I encountered a TypeScript error when using the preprocess() and refine() methods together. Here's the code I'm using:

```ts
import * as z from 'zod';

const ZID = z
  .preprocess((val: any) => {
    return val;
  }, z.string())
  .refine(
    (val: any) => {
      return val.toString();
    },
    (val: any) => ({
      message: `The ID provided (${val}) is in an invalid format`,
    })
  );

type ID = z.infer<typeof ZID>;

abstract class Abs<T> {
  zType: z.ZodSchema<T>;

  protected constructor(zType: z.ZodSchema<T>) {
    this.zType = zType;
  }
}

class Abc extends Abs<ID> {
  constructor() {
    super(ZID);
  }
}
```
Expected Behavior:
The TypeScript compiler should not produce any errors, and the Abc class should be able to extend the Abs class with the ZID schema.

Actual Behavior:
Instead, the TypeScript compiler produces an error on the super(ZID) line in the Abc class constructor, with the following message:

```
Argument of type 'ZodEffects<ZodEffects<ZodString, string, unknown>, string, unknown>' is not assignable to parameter of type 'ZodType<string, ZodTypeDef, string>'.
Types of property '_input' are incompatible.
Type 'unknown' is not assignable to type 'string'.
```
Steps to Reproduce:

Install Zod version 3.19.1 in a TypeScript project.
Define a Zod schema with the preprocess() and refine() methods, and use it in an abstract class.
Define a class that extends the abstract class and uses the Zod schema as its generic type parameter.
Environment:

Node.js version: 16.17.1
TypeScript version: 4.9.5
Zod version: 3.19.1
Additional Information:
This error did not occur with Zod version 3.19.0, so I believe it is a regression in version 3.19.1. Please let me know if you need any more information from me. Thank you!



",,
1640820904,2244,How to modify schema using generic typed functions.,"I just want to modify the schema using function and for that, i am using omit/pick functions in a generic typed function but omit/pick functions is not exist in generic typed functions for the schema.
Also, I have watched all functions of ZodType class but there is no omit/pick function.
A simple example is given below.
```ts

export const ProductSchema = z.object({
    id: z.string().uuid(),
    name: z.string(),
    quantity: z.number().int(),
    price: z.number().int(),
    salePrice: z.number().int(),
    description: z.string().nullable(),
    categoryId: z.string(),
    createdAt: z.coerce.date(),
    updatedAt: z.coerce.date(),
  })

export type Product = z.infer<typeof ProductSchema>

  
export function excludeDBOptionalFields<T extends z.ZodTypeAny>(schema: T){

 //here getting type error
  return schema.omit({
     id: true,
     createdAt: true,
     updatedAt: true
  });
}

const FinalProductSchema = excludeDBOptionalFields<Product>(ProductSchema)

```
Thank you for your time and consideration.",,
1640773220,2243,"when validation fails, transform is skipped but superRefine not","When some validation fails, it looks like transform is skipped but a future superRefine is not skipped, then superRefine tends to fail.
I checked the documentation but I didn't found something related to this behavior :(

```js
const schema = z
  .object({
    foo: z.string().email(),
  })
  .transform((arg, ctx) => {
    console.log(""transform"", arg);
    return { bar: arg.foo };
  })
  .superRefine((arg, ctx) => {
    console.log(""superRefine"", arg); // typescript always expects 'bar' attribute

    // This line tends to fail when transform is skipped
    if (arg.bar.length >= 35) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: ""It hould be less than 35."",
        path: [""bar""],
      });
    }
  });

console.log(schema.safeParse({ foo: ""test@example.com"" }));
console.log(schema.safeParse({ foo: ""averybigemailfortesting@example.com"" }));

// This fails on email validation, transform is skipped but superRefine not
console.log(schema.safeParse({ foo: ""testexample.com"" }));
```

![image](https://user-images.githubusercontent.com/15650777/227756161-70761cbd-6488-427a-b8e0-a3cf0828a155.png)
",,
1640629173,2242,`.parse()` reorders input object keys,"Is this expected? Can it be worked around? For instance,

```console
$ node
Welcome to Node.js v19.8.1.
Type "".help"" for more information.
> const {z} = require('zod')
undefined
> z.object({a: z.string(), b: z.number()}).parse({b: 1, a: 'x'})
{ a: 'x', b: 1 }
```",,
1640386861,2241,Exporting schemas from package breaks `instanceof`,"When I export a schema from a package and use that schema in another package, the `instanceof` operator doesn't work on `ZodError` or `Schema`. I'm also new to creating packages, so maybe there is something that I miss there!

How I'm using the exported schemas:

```ts
import { mySchema } from 'mylib';
import { z } from 'zod';

console.log(mySchema instanceof z.Schema); // false

try {
  mySchema.parse('');
} catch (error) {
  console.log(error instanceof z.ZodError); // false
}

// -----------------------------

const localSchema = z.object({});

console.log(localSchema instanceof z.Schema); // true

try {
  localSchema.parse('');
} catch (error) {
  console.log(error instanceof z.ZodError); // true
}
```

I have also created a [demo project](https://github.com/ahmafi/zoderror-showcase). 

I call the package that I create schemas in `mylib` and the package that I'm using those, is called `myprogram`. I'm using `npm link` to add `mylib` to `myprogram` package. And also, I'm transpiling the `mylib` with `npx tsc`. Then you can test the code in `myprogram` with `npx tsx index.ts`.

A [maybe related thing](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-extending-built-ins-like-error-array-and-map-work) that I read about this. But I also checked that you are addressing this issue on `ZodError` class constructor.
",,
1639542192,2238,How can I access Request during a validation?,"My app will reuse a lot of rules, so I wanted to have those common rules in an external file

For some rules, I want to show more descriptive error messages depending on the user-type. If it's a developer, i want to explain exactly what's wrong, if it's an admin, I want to give them useful information, but if it's a user, I want to conceal the exact reason and just let them know a problem occurred.

I have a workaround that works pretty well. I'm just wondering if its the best way. My code is typescript, but I'll use JS for brevity

```ts
CommonValidations = {
    messages(req) {
        return {
            subjectRule: rule,
            messageKeyRule: ..refine(() => {
                if (!messageKeyRegexTest) {
                    if (req.user.isAdmin()) {
                        return ""Failed to generate key, configuration error probably""
                    } else {
                        return ""Something went wrong""
                    }
                }
            })
        }
    }
}
```",,
1638243304,2236,z.string().url() seems to accept any string,"Hello, I think I may have found a bug with URL validation.

Indeed, I am trying to validate an object which has a property â€œticketLink"" that should be an URL (z.string().url())

This is my schema : 
```ts

const schema = z.object({
    projectId: z.string().uuid(),
    title: z.string().min(5).max(100),
    description: z.string().max(255).optional(),
    punchTypeId: z.string().uuid(),
    hours: z.number().min(0.25).max(24),
    ticketLink: z.string().url(),
    billable: z.boolean().optional(),
    date: z.date(),
});
```

However, no matter what I am setting as a value for the `ticketLink` property, the schema does not return an error for this property, even if the value is not a valid URL.

For instance, validating this object :
```ts
const formState = {""date"": 2023-03-23T20:00:05.466Z, ""projectId"": ""28dfcf92-5b36-4976-1d48-08db1f3ca426"", ""ticketLink"": ""abc""}
schema.safeParse(formState)
```

doesn't raise an error for the `ticketLink` field, but ""abc"" should not be accepted as an URL.

We're using **""zod"": ""3.21.4""**",,
1637700873,2235,"How does it possible to make object value optional, in case the other field from the same object has particular value?","```
export const additionalRideParticipantsValidationSchema = (
  isNoParticipantsAdded: boolean = false,
) => {
  const fieldsArray = z.array(
    z.object({
      id: 
      participantPersonType, // In case this one has MINOR_PARTICIPANT_VALUE value
      firstName: stringFieldValidator({ isFirstOrLastNameField: true }), 
      lastName: stringFieldValidator({ isFirstOrLastNameField: true }), 
      email, // I want email to become optional
    })
  )

  return validateViaZod({
    [FIELD_GROUP]: isNoParticipantsAdded
      ? fieldsArray.optional()
      : fieldsArray,
  })
}
```",,
1635424191,2230,Embedded schema containing default value throws compilation error.,"A very obscure compilation error occurs when embedding a schema with a default value into another and then parsing data.
Consider the following code example:
```ts
import { z } from ""zod"";

export function validateInput<TSchema>(schema: z.Schema<TSchema>, inputdata: any) {
  return schema.parse(inputdata);
}

export const Schema1 = z.object({
  myString: z.string().default(""""), // Remove the default and it works
});

export const Schema2 = z.object({
  related: Schema1,
});

const data = {};
export type Dto = z.infer<typeof Schema2>;
const parsedData: Dto = Schema2.parse(data); // This works
const parsedDataWrapped: Dto = validateInput(Schema2, data); // This does not work
```
Throws the error
```
error TS2322: Type '{ related: { myString?: string | undefined; }; }' is not assignable to type '{ related: { myString: string; }; }'.
  The types of 'related.myString' are incompatible between these types.
    Type 'string | undefined' is not assignable to type 'string'.
      Type 'undefined' is not assignable to type 'string'.

18 const parsedDataWrapped: Dto = validateInput(Schema2, data); // This does not work
```

I assume this is a bug? Removing the `.default("""")` makes the compilation works.

Using TSC 4.9.5 and zod 3.20.6

Thanks!",,
1635190687,2229,.refine is not working as expected,"I'm using zod version 1.11.9 and facing weird issue with **refine** method.

Below is code snippet:

![bf2bb8a0-fe58-4065-aeb4-5af8cdf22872](https://user-images.githubusercontent.com/79619791/226827959-451aaf6b-fe7a-4808-bbca-d86003c203e9.jpg)

**Expected Result:** parsing should be failed
**Actual Result:** parsing is successful, even both logs are being called but still parsing is successful.

Logs:
![3df824e9-c777-4a37-8a18-1e5f72b6c329](https://user-images.githubusercontent.com/79619791/226827715-d1a3e95f-eb21-4e37-8438-8c9c61d5b4d0.jpg)
",,
1635127102,2228,zod z.string().emoji() does not throw error for numbers ,"does not throw errors for numbers 
https://codesandbox.io/p/sandbox/adoring-boyd-vj7ikr?welcome=true",,
1634743895,2227,Proto pollution vulnerability when using `z.record(z.object())` ,"Hello,

I've found a minor security vulnerability when using `z.record(z.object())` with proto pollution. Consider the following example:
```tsx
  const schema = z.record(
    z.object({
      b: z.string(),
    })
  );

  const data = JSON.parse(`{
    ""c"": {
      ""b"": ""world""
    },
  ""__proto__"": {
    ""b"": ""world2""
  }
}`);

  const result = schema.parse(data);

  console.log(result.b); // world2
```

I would assume `result.b` should be `undefined` after the parsing, but instead the data in `__proto__` is polluted to the object, i.e accessing `result.b` gives me `world2`",,
1634468010,2226,Keep type after parsing,"Is there any way to get which type parsed.
I am parsing some json file and would like to show different ui elements based on the actual type of keys.
For example I have key which could be a string, number or array of strings or numbers. 

@JacobWeisenburger 
Update0: 

Here I tried to achieve the idea using transform. Is there any better way to do this?
```js
const testType = z.union([
    z.string().transform((val) => {

        return {
            value: val,
            type: 'string'
        };
    }),
    z.number().transform((val) => {
        return {
            value: val,
            type: 'number'
        }
    })
]).array()

const testArray = [1, ""string"", 2, 3];

const parseResult = testType.safeParse(testArray);

if (parseResult.success) {
    console.log(parseResult.data);
} else {
    console.log(parseResult.error)
}
```",,
1633905098,2223,Generic over ZodObject extend inferred as any,"```ts
const Entity = <E extends AnyZodObject>(base: E) =>
  base.extend({
    _id: z.string(),
    createdAt: z.date(),
    updatedAt: z.date(),
  })

const UserBase = z.object({
  name: z.string(),
  age: z.number()
})

const User = Entity(UserBase)

const res = User.parse({})

// The inferred type does not match User :(
// const res = {
//   [x: string]: any;
//   [x: number]: any;
//   [x: symbol]: any;
// }


```",,
1632972205,2222,Support runtime validating typed values,"Hello! Iâ€™d like support for the following simple use case. This is following an [SA question](https://stackoverflow.com/questions/75706537/how-to-get-static-type-checking-and-auto-complete-for-the-parse-method/75716440#75716440) where someone didn't understand what I was trying to do.

# Use case

Letâ€™s say I have two objects - a `Horse` and a `Rider`. I make a schema for each of them like this:

```typescript
const Horse = z.animal(""human"")
const Rider = z.animal(""horse"")
```

There is a part of the code where I get the `horse` and the `rider` from different places, where the value is either an `any` or type asserted with dubious reliability.

```typescript
const horse = horseGetter() // any
const rider = riderGetter() // any
```

Now, I want to validate both of these. One way would be to do it like this:

```typescript
const horse = Horse.parse(horseGetter())
const rider = Rider.parse(riderGetter())
```

But the thing is, `horse` and `rider` appear so often in my code that I want to group them into a `knight`:

```typescript
const Knight = z.object({
    horse: Horse,
    knight: Knight
})
```

And if I do that, I would like to validate everything at the same time like this:

```typescript
const knight = Knight.parse({
    horse: horseGetter(),
    rider: riderGetter()
})
```

This encapsulates the `horse` and `rider` into one object that can be moved around more easily and makes validating them more concise.

Here I find something annoying â€“ `parse` takes an `unknown`, not `z.input<Schema>`, so I donâ€™t have auto-complete when writing that code. Itâ€™s also not statically validated, although it easily could be. If it were, a spelling mistake could be caught at compile time instead of runtime:

```typescript
const knight = Knight.parse({
    hosre: horseGetter(), // compiles, fails at runtime
    rider: riderGetter()
})
```

# The `check` method

My idea is to add a simple method called `check` that just calls `parse`, but has a different static type:

```typescript
declare module ""zod"" {
    export interface ZodType<Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output> {
        check(value: Input): Output;
    }
}

ZodType.prototype.check = function (value) {
    return this.parse(value);
};
```

This is a bit weird since usually, a `TypeScript` interface makes sense in `JavaScript` as well, but I think it makes sense for this library.

Anyway, the `check` method can be used for the following:

1. Validating type-asserted values, uses of `any`, etc, like what I described above.
2. When the schema has refinements that canâ€™t be translated to the type system. Here having the correct type isnâ€™t enough.
3. Transforming values known to be correctly typed.

I deliberately didnâ€™t add a `safeCheck` method because there should be an exception when a runtime type doesnâ€™t match the compile-time type. 

Here is an example of code using the method:

```typescript
ListRef.check({
        id: probablyId,
        title
    });
```
",,
1630658635,2216,Properties that are inferred Zod types are always dropped from any mapped types that involve key mapping.,"I'm tracking an odd issue with Zod in this StackOverflow thread: https://stackoverflow.com/questions/75778970/why-is-an-inferred-generic-zod-string-type-considered-assignable-to-never/75779088#75779088

It seems that any property with a `z.infer`'d type from a generic type gets dropped whenever participating in a conditional key mapping.

```
export type FilterNothing<T> = { [P in keyof T as T[P] extends T[P] ? P : P]: T[P] }

class Test<Z extends z.ZodString> {
    foo(args: FilterNothing<{ key: number, value: z.infer<Z>, bar: Date }>) {

        const { key, value, bar } = args;
    }
}
```

[Playground here](https://www.typescriptlang.org/play?ts=5.0.2#code/JYWwDg9gTgLgBAbwF4F84DMoRHA5EiAE1wG4AoMgUwA9JY4YBPMSuAMWABsZKoA5CDAAWwAHYBzADwAVAHxwAvIjgBtAApwxcANaVGEdHGlwAhgGcj6gLpwaPUYQvTrcAPxwNALg9XvztTYoFADGnOZOlGYwkgBattT2jnBIAHQxRADKMFBi4vIIZHBFGBAQABQmUOJm3hzcvALCuZIIOnreogCuIABGvAA0cABuJpydlN6pYui8sbKDPZXeACImPHAosgCUiBTF+3DBEKJRyrqMgyNjlAuVG4qmVWbk+0EoQA)

In the above code, the condition is a noop... all keys are always mapped, and yet `value` is still dropped.

Any idea why / how this could be possible? ",,
1630308376,2214,ZodObject fails on writing to readonly cache prop.,"I am working on a flow form where each step is an imported module which exports its own schema. I am using react-hook-form for this.

Not all steps of the form have validation. The form works well until I get to my first step with a zod resolver:

```
export const schema = z
  .object({
    [MONTHLY_WITH_ME]: z.boolean(),
    [MONTHLY_WITH_TEAM]: z.boolean(),
    [CUSTOM_NEEDS]: z.boolean(),
  })
  .partial()
  .refine(
    (options) => Object.values(options).some(Boolean),
    {
      message: 'Please select at least one option to continue',
      path: ['formErrors'],
    }
  )
```

This schema is tested and the tests work great.

Now I've tried having this flow form and having this isolated step in its own form on the same page and the results are getting weird:

- If I validate the isolated step form the schema works
- If I validate the isolated step form FIRST and then process through the flow form, the schema works on the intended step.
- If I validate the flow form first then neither form will have the validation work on the intended step.

I pass a resolver to the Form's config in each case using `zodResolver(currentStep[1].schema)`:

```
<Form config={{resolver: zodResolver(currentStep[1].schema)`}} />
```

The error thrown in the console is not giving much away and is misleading, it comes from a file from another package: https://github.com/react-hook-form/resolvers/blob/master/zod/src/zod.ts#L70.

The actual error being thrown comes from this package:

```
TypeError: Cannot assign to read only property '_cached' of object '#<ZodObject>'
    at ZodObject._getCached (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:14132:30)
    at ZodObject._parse (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:14146:49)
    at ZodObject._parseAsync (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:12599:29)
    at ZodEffects._parse (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:15417:22)
    at ZodEffects.safeParseAsync (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:12644:39)
    at ZodEffects.parseAsync (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:12626:35)
    at _callee$ (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:462:84)
    at tryCatch (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:386:1357)
    at Generator.<anonymous> (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:386:4174)
    at Generator.next (http://localhost:8910/static/js/src_pages_HomePage_HomePage_tsx.chunk.js:386:2208)
```

I've tried using async with the resolver but it didn't do much.

Below is the full code:

```
// FlowForm.tsx
function usePresentationUi({ currentStep }) {
  return { Scene: currentStep?.[1].default }
}

const Container = ({
  currentStep,
  resolver,
  Scene,
  onBack,
  onPass,
  onSubmit,
}) => (
  <Form onSubmit={onSubmit} config={{ resolver }}>
    <h2>
      {'FlowForm'} - {`FormStep - ${currentStep?.[0]}`}
    </h2>
    <Scene onBack={onBack} onPass={onPass} />
    <FormError />
    <FieldError name=""formErrors"" />
  </Form>
)

export default function FlowForm({ steps, withValidation }) {
  const flowFormProps = useFlowForm({ steps, withValidation })

  const ui = usePresentationUi({ currentStep: flowFormProps.currentStep })

  return ui.Scene ? (
    <Container
      key={`FormStep - ${flowFormProps.currentStep?.[0]}`}
      {...flowFormProps}
      Scene={ui.Scene}
    />
  ) : null
}
```

```
// useFlowForm.ts
import { atom, useRecoilState } from 'recoil'
import { v4 as uuidv4 } from 'uuid'

import { UseFlowForm } from './types'
import { zodResolver } from './zodResolver'

const formStore = atom({ key: 'flowForms', default: {} })

function useFlowForm({ steps }) {
  const [storeData, store] = useRecoilState(formStore)

  const form = React.useRef(uuidv4())

  const setStep = (step) => (forms) => ({
    ...forms,
    [form.current]: { ...forms[form.current], step },
  })

  React.useEffect(() => {
    const show = Object.entries(steps)[0]
    store(setStep(show))
    // store((forms) => ({ ...forms, [form.current]: { step: show } }))
  }, [])

  const currentStep = React.useMemo(
    () => storeData[form.current]?.step,
    [storeData]
  )

  const onBack = () => {}

  const onPass = () => {}

  const onSubmit = (data) => {
    console.log('submitting', data)

    const current = storeData[form.current].step[0]

    const next = Object.entries(steps).reduce((Q, [key], N) => {
      if (!Q && key === current) {
        return Object.entries(steps)?.[N + 1]
      }

      return Q
    }, undefined)

    store(setStep(next))
  }

  return {
    currentStep,
    resolver: currentStep?.[1].schema
      ? zodResolver(currentStep[1].schema)
      : undefined,
    onBack,
    onPass,
    onSubmit,
  }
}

export default <UseFlowForm>useFlowForm
```

```
// The step component with its own schema.

import { Button, ButtonGroup, Checkbox, Text, VStack } from '@chakra-ui/react'
import * as z from 'zod'

import { Controller, FieldError } from '@redwoodjs/forms'

import { Step } from './types'

const MONTHLY_WITH_ME = 'monthlyWithMe'

const MONTHLY_WITH_TEAM = 'monthlyWithTeam'

const CUSTOM_NEEDS = 'customNeeds'

export const schema = z
  .object({
    [MONTHLY_WITH_ME]: z.boolean(),
    [MONTHLY_WITH_TEAM]: z.boolean(),
    [CUSTOM_NEEDS]: z.boolean(),
  })
  .partial()
  .refine(
    (options) => {
      alert('red')
      console.log(options, Object.values(options).some(Boolean))
      return Object.values(options).some(Boolean)
    },
    {
      message: 'Please select at least one option to continue',
      path: ['formErrors'],
    }
  )

const ActiveContributionProgram: Step = ({ onPass }) => (
  <>
    <Text>Active Contribution Program</Text>
    <Text m={4}>
      {`""The success of each of us is the success of everyone"", and the Active
        Contribution Program is exactly about that.

        To support you on your road
        to success, we'd like to assign a Core Team member to you. Regular
        meetings with them and you or your team will provide the extra support
        needed to make sure you don't waste precious time exploring beaten
        paths. We don't want you to repeat solutions, we want to scale them with
        you!`}
    </Text>
    <Text m={4}>I&rsqos;d like to enroll with the following preferences:</Text>
    <VStack m={4}>
      <CheckboxControlled
        name={MONTHLY_WITH_ME}
        testid=""input.monthlyWithMe""
        label=""Monthly meeting with me only""
      />
      <CheckboxControlled
        name={MONTHLY_WITH_TEAM}
        testid=""input.monthlyWithTeam""
        label=""Get in touch for custom needs""
      />
      <CheckboxControlled
        name={CUSTOM_NEEDS}
        testid=""input.customNeeds""
        label=""Get in touch for custom needs""
      />
      <FieldError name=""customNeeds"" color=""red"" />
    </VStack>
    <ButtonGroup gap={4} p={4}>
      <Button onClick={onPass} data-testid=""button.onPass"">
        Hard pass
      </Button>
      <Button type=""submit"" data-testid=""button.onSubmit"">
        I&rsquo;m in
      </Button>
    </ButtonGroup>
  </>
)

const CheckboxControlled = ({ label, name, testid }) => (
  <Controller
    name={name}
    render={({ field }) => (
      <Checkbox {...field} data-testid={testid}>
        {label}
      </Checkbox>
    )}
  />
)

export default ActiveContributionProgram
```
",,
1630278774,2213,properties of variables with null or undefined values should not be accessed,"Variable 'effect' may have a null value originated from the expression 'null' at multiple lines. But its property is accessed at this point without null check.

    const effect = this._def.effect || null;

    if (effect && effect.type === ""preprocess"") {
      const processed = effect.transform(ctx.data);

effect variable may have a null value, which is assigned to it when this._def.effect is null. However, the code attempts to access a property of effect without checking if it is indeed not null.

",,
1629610909,2209,`Writeable<T>` incompatibility with latest TS nightly,"In the most recent `typescript@next` nightly build (`5.1.0-dev.20230317`), something subtle seems to have changed with mappings over tuple types, resulting in the following error when typechecking a project with Zod in its dependencies.

```
node_modules/zod/lib/types.d.ts:698:129 - error TS2344: Type 'Writeable<T>' does not satisfy the constraint '[string, ...string[]]'.

698 declare function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(values: T, params?: RawCreateParams): ZodEnum<Writeable<T>>;
                                                                                                                                    ~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:706:97 - error TS2344: Type 'Writeable<ToExtract>' does not satisfy the constraint '[string, ...string[]]'.

706     extract<ToExtract extends readonly [T[number], ...T[number][]]>(values: ToExtract): ZodEnum<Writeable<ToExtract>>;
```

Anyone hitting this can work around it for now by either:
 - using a stable TypeScript release (this was just flagged by an early-warning CI run in a project I maintain)
 - setting `skipLibCheck: true` to ignore the error (along with any other issues, real or fake, in `.d.ts` files)",,
1629303915,2208,"As a zod beginner, I would like to imporve my ts-to-zod developer experience with LLM's z.prompt() support.","The zod project is the best choice for developers who require accurate LLM prompting using Typescript, thanks to having some of the most proficient developers in the field.

```ts
import ""https://deno.land/std@0.179.0/dotenv/load.ts"";
import { Configuration, OpenAIApi, } from ""npm:openai@3.2.1"";
import { assertEquals, assertStringIncludes, assertThrows } from ""https://deno.land/std@0.179.0/testing/asserts.ts"";
import { z } from ""https://deno.land/x/zod@v3.21.4/mod.ts"";
class SchemaPromptInput {
  static readonly Enum = {
    LargeLanguageModelsChatProider: z.enum([""openai"", ""microsoft-azure"", ""google-cloud"", ""llm404"", ""taichung""]),
    RequestModel: z.enum([""gpt-3.5-turbo-0301"", ""gpt-3.5-turbo"", ""gpt-4"", ""code-davinci-002"", ""gpt-404""])
  }
  static readonly promptArg = z.object({
    provider: SchemaPromptInput.Enum.LargeLanguageModelsChatProider.optional().default(""openai""),
    model: SchemaPromptInput.Enum.RequestModel.optional().default(""gpt-3.5-turbo""),
    message: z.string().min(20).max(100).includes('schema').includes("" named ""),
    tstype: z.string().includes('type'),
  })
  // deno-lint-ignore no-explicit-any
  static readonly isPrompt = (v: any): v is SchemaPromptInput.TypePromptArg => SchemaPromptInput.promptArg.safeParse(v).success
}

// deno-lint-ignore no-namespace
namespace SchemaPromptInput {
  export type TypePromptArg = z.infer<typeof SchemaPromptInput.promptArg>
}

// z.prompt({}) ?
const zPrompt = (arg: SchemaPromptInput.TypePromptArg) => {
  if (SchemaPromptInput.isPrompt(arg)) {
    return `You are a thoughtful assistant that helps the developer do tasks on Typescript. 
Answer as concisely as possible for each response (e.g. don't be verbose). When it makes sense, 
use markdown syntax to output code. If outputting code, include the programming language. 
Use the examples below as a guide.
  
Example 1:
Task: use the type from third-party typescript packages in my schema named ""SchemaPromptInput""
Context:
export type prompt = {
  message: string
}
Output:
\`\`\`ts
export class SchemaPromptInput {
  static readonly prompt = z.object({
    message: z.string().min(20).max(100).includes('schema'),
  })
  static readonly isPrompt = (v: any): v is SchemaPromptInput.TypePrompt => SchemaPromptInput.prompt.safeParse(v).success
}
export namespace SchemaPromptInput {
  export type TypePrompt = z.infer<typeof SchemaPromptInput.prompt>
}
\`\`\`


Example 2:
Task: use the type in my schema named ""SchemaOpenAiMessage""
Context:
export type Role = ""system"" | ""assistant"" | ""user"";
export type Message {
  role: Role;
  content: string;
}

Output:
\`\`\`ts
export class SchemaOpenAiMessage {
  static readonly Enum = {
    Role: z.enum([""system"", ""user"", ""assistant""]),
  }
  static readonly openAiMessage = z.object({
    role: SchemaOpenAiMessage.Enum.Role,
    content: z.string().min(2).max(1000),
  })
  static readonly isOpenAiMessage = (v: any): v is SchemaOpenAiMessage.TypeOpenAiMessage => SchemaOpenAiMessage.openAiMessage.safeParse(v).success
}
export namespace SchemaOpenAiMessage {
  export type TypeOpenAiMessage = z.infer<typeof SchemaOpenAiMessage.openAiMessage>
}
\`\`\`

Example 3:
Task: use the type in my schema named ""SchemaHero""
Context:
export type Hero = {
  id: string;
  name: string;
  age: number;
}

Output:
\`\`\`ts
export class SchemaHero {
  static readonly hero = z.object({
    id: z.string().min(2).max(10).includes('FOO'),
    name: z.string().min(2).max(30),
    age: z.number().min(1).max(1000)
  })
  static readonly isHero = (v: any): v is SchemaHero.TypeHero => SchemaHero.hero.safeParse(v).success
}
export namespace SchemaHero {
  export type TypeHero = z.infer<typeof SchemaHero.hero>
}
\`\`\`
  
Begin.
Task: ${arg.message}
Context:
${arg.tstype}
Output:
\`\`\`ts
`
  } else {
    throw new Error('Prompt error. sample: use the type in my schema named ""SchemaBar""')
  }
}

const prompt101: SchemaPromptInput.TypePromptArg = {
  provider: SchemaPromptInput.Enum.LargeLanguageModelsChatProider.enum.openai,
  model: SchemaPromptInput.Enum.RequestModel.enum[""gpt-3.5-turbo""],
  message: 'use the type in my schema named ""SchemaFoo""',
  tstype: `
export type Role = ""admin"" | ""user"" | ""403"" ;
export type Group = ""Develop"" | ""Dreamer"" | ""404"";
export type Message = {
    group: Group
    content: string
}
export type User = {
  usename: string,
  password: string,
  amount: number,
  role: Role,
  message: Message
}
`}

const chatGpt = async (arg: SchemaPromptInput.TypePromptArg) => {
  if (SchemaPromptInput.isPrompt(arg) && arg.provider === ""openai"") {
    const openai = new OpenAIApi(new Configuration({
      apiKey: Deno.env.get(""OPENAI_API_KEY""),
    }))
    const content = zPrompt(arg)
    const resp = await openai.createChatCompletion({
      model: arg.model,
      messages: [{ role: ""assistant"", content }]
    });
    return resp;
  } else {
    throw new Error(""Parse Error"")
  }
}

Deno.test(""error prompt test"", () => {
  assertThrows(
    () => {
      const _errorPrompt = zPrompt({
        provider: SchemaPromptInput.Enum.LargeLanguageModelsChatProider.enum.taichung,
        model: SchemaPromptInput.Enum.RequestModel.enum[""gpt-404""],
        message: 'crete a zod schema for me',
        tstype: `type blah`
      })
    },
    Error,
    'Prompt error. sample: use the type in my schema named ""SchemaBar""'
  )
  assertStringIncludes(prompt101.message, ""SchemaFoo"")
})

const tseval = (code: string) => {
  const denoImport = `import { z } from ""https://deno.land/x/zod@v3.21.4/mod.ts"";\n${code}`
  return import(""data:application/typescript,"" + encodeURIComponent(denoImport));
};

Deno.test(""ts to zod"", async () => {
  const resp = await chatGpt(prompt101)
  const content = resp.data.choices[0].message?.content
  if (content) {
    // console.log(JSON.stringify(resp.data, null, 2))
    // remove markdown code tail ```
    const script = content.replace(""```"", """").trim();
    console.log(script)
    assertStringIncludes(script, ""class SchemaFoo"")
    const mod = await tseval(script);
    assertEquals(mod.SchemaFoo.isUser({}), false);
    assertEquals(mod.SchemaFoo.isUser({
      username: 'alice',
      password: '**********',
      amount: 10,
      role: ""admin"",
      message: {
        group: ""Develop"",
        content: ""blahblah""
      }
    }), true);
  }
})

/**
 * Please execute the following docker command to test and try to run the given openai example.
 * $ docker run --env OPENAI_API_KEY=blahblah --rm denoland/deno:alpine \
 *     test --allow-read=.env --allow-env=OPENAI_API_KEY --allow-net=api.openai.com \
 *     https://raw.githubusercontent.com/dltdojo/dltdojo-cd/main/cd23/dafu/hack/chatgpt104/zprompt.test.ts
 * 
------- output -------
export class SchemaFoo {
  static readonly Enum = {
    Role: z.enum([""admin"", ""user"", ""403""]),
    Group: z.enum([""Develop"", ""Dreamer"", ""404""]),
  }
  static readonly message = z.object({
    group: SchemaFoo.Enum.Group,
    content: z.string().max(200),
  })
  static readonly user = z.object({
    username: z.string().min(2).max(30),
    password: z.string().min(6).max(20),
    amount: z.number().min(0),
    role: SchemaFoo.Enum.Role,
    message: SchemaFoo.message,
  })
  static readonly isUser = (v: any): v is SchemaFoo.TypeUser => SchemaFoo.user.safeParse(v).success
}
export namespace SchemaFoo {
  export type TypeUser = z.infer<typeof SchemaFoo.user>
  export type TypeMessage = z.infer<typeof SchemaFoo.message>
  export type TypeRole = z.infer<typeof SchemaFoo.Enum.Role>
  export type TypeGroup = z.infer<typeof SchemaFoo.Enum.Group>
}
Check data:application/typescript,import%20%7B%20z%20%7D%20from%20%22https%3A%2F%2Fdeno.land%2Fx%2Fzod%40v3.21.4%2Fmod.ts%22%...
----- output end -----
ts to zod ... ok (16s)

ok | 2 passed | 0 failed (16s)
 */
```

If you have questions related to this schema matter, please see Issue #1917  for further information.",,
1628907912,2205,Email validation rejects email with special characters,"For example info@rÃ¤ucher.de gets rejected because of the ""Ã¤"".

In Chrome, special characters are automatically converted to ASCII on the client side and back. However, this is not the case with Firefox and Safari. So I have no problems in Chrome browsers, but in the others.

Im using simple z.string().email(), dont want to transform each to ASCII by myself and use my own validator.",,
1628026591,2204,How to validate a Generator?,"Is there a way to validate a generator?

By this, I mean something that will validate the generator as it's being iterated in the same way as functions are validated when called.

I tried to implement one from the specification but ran into problems:

1. Generators require a `this` context, but the `this` context is lost when validating a function.
2. There doesn't seem to be support for `Symbol` properties, which can be lost unexpectedly after parsing. So `Symbol.iterator` properties seem to be ignored.

What's the status on this?",,
1627774384,2203,Regression in type inference for a union of array types inside an object type,"I have some schema like the following:
```
z.object({
    arrayProp: z.union([z.string().array(), z.number().array()]),
}),
```

this used to produce the following type for the `arrayProp` key:  `string[] | number[]`.

since version 3.21.2 this produces the following type: 
`string[] | (string[] & number[]) | (string[] & undefined) | (number[] & string[]) | number[] | (number[] & undefined)`

this in turn causes many problems when trying to work with `arrayProp`, for example if I try to use an array predicate like `map`, I'm getting the following error: 
```
TS2349: This expression is not callable. Â Â Each member of the union type '(<U>(callbackfn: (value: string, index: number, array: string[]) => U, thisArg?: any) => U[]) | (<U>(callbackfn: (value: number, index: number, array: number[]) => U, thisArg?: any) => U[]) | ((<U>(callbackfn: (value: string, index: number, array: string[]) => U, thisArg?: any) => U[]) & (<U>(callbackfn: (value: num...' has signatures, but none of those signatures are compatible with each other.
```

However, if I remove the wrapper `z.object` and use the following schema: `z.union([z.string().array(), z.number().array()])` then I'm getting the correct type inference of `string[] | number[]`

Looking at the code for the 3.21.2 PR (https://github.com/colinhacks/zod/commit/4d016b772b79d566bfa2a0c2fc5bfbd92b776982#diff-a5a27c41f819170124f4fd4cf24b1d71b8ab2966a4bde235a7f8db53dc8ef486) suggests that this has to do with changes made to the internal`DeepPartial` type.

For now we're sticking with 3.21.1 version, but I would be happy to see that fixed as we use this pattern on multiple occasions across our project.",,
1627332424,2202,Discriminated Union error masking other validation errors,"I'm trying to validate a form with react-hook-form and zod/zodResolver. The schema is broadly as follows:

```ts
const SchemaA = z.object({
  fieldA: z.enum(['yes', 'no']),
  fieldB: z.enum(['yes', 'no']),
  fieldC: z.literal('no')
}

const SchemaB = schemaA.extend({
  fieldC: z.literal('yes'),
  subFieldC: z.enum(['yes', 'no'])
}
```

So, `SchemaB` is essentially `SchemaA` plus an extra field _if_ `fieldC` is set to yes. 
`fieldA` and `fieldB` will always be required, no matter which schema is in use.

When validating the schema, and if `fieldC` has not been set, the only error message appearing is 

`Invalid discriminator value. Expected 'no' | 'yes'`

The error messages for `fieldA` and `fieldB` are only showing validation errors once `fieldC` has passed validation.

Is there a way for me to show all validation errors?
",,
1626022248,2200,"`z.object` to be mergeable with `z.record`, or ability to define keys by a custom type","I have a type that's basically like this

```ts
type YKeys = `y${number}`;
type ZKeys = `z${number}`;
type DataKeys = `d${number}`;

type Point = {
  x: string;
  id: string;
} & Record<YKeys, number> & Record<ZKeys, number> & Record<DataKeys, { stuff: string }>

```

I have the schemas for the special keys
```ts 
const yKeysSchema = z.custom<`i${number}`>((val) => /^y(\d+)$/.test(val as string));
const zKeysSchema = z.custom<`i${number}`>((val) => /^z(\d+)$/.test(val as string));
const dataKeysSchema = z.custom<`i${number}`>((val) => /^d(\d+)$/.test(val as string));
```

and I used to be able to get by with just a superRefine call to a `pointValidityRefinement` function that will check the keys, with something like

```ts
const pointSchema = z.object({ x: z.string(), id: z.string() }).passthrough().superRefine(pointValidityRefinement);
```

But since the last update I get errors like 

```
Type 'objectOutputType<{ x: ZodNumber; id: ZodString; }, ZodTypeAny, ""passthrough"">' is not assignable to type 'Point'.
    'string' and '`y${number}`' index signatures are incompatible.
      Type 'unknown' is not assignable to type 'number | undefined'.
```

I tried to change the schema of the point to something like

```ts
const pointSchema = z.object({ x: z.string(), id: z.string() })
  .merge(z.record(yKeysSchema, z.number())
  .merge(z.record(zKeysSchema, z.number())
  .merge(z.record(dataKeysSchema, z.object({ stuff: z.string() }))
```
but that doesn't work.

Is there any way I can do this?

btw, I'm using TypeScript 4.8 and latest zod (3.21.4)",,
1625946806,2199,Schema type returned with .transform(),"Hi, this is my target Type, (look at companyName):
<img width=""331"" alt=""image"" src=""https://user-images.githubusercontent.com/82887830/225385816-d974e147-09ce-4755-ba67-4257c9013687.png"">

I'm creating this Schema to represent the API part and transform data to fit my target Type:
<img width=""856"" alt=""image"" src=""https://user-images.githubusercontent.com/82887830/225386156-842814fe-9086-4b0b-8702-b8e193dc6939.png"">

He understood that companyName is missing compare to target Type.

Now let's add this key, and why not modify the output structure to fit with my Target:

<img width=""471"" alt=""image"" src=""https://user-images.githubusercontent.com/82887830/225389089-157d8411-2892-4832-8dc6-a4a7f511ab01.png"">


Typescript is still complaining of missing companyName key. 

",,
1625086471,2198,Properties become optional in composable schemes (generics),"### Discussed in https://github.com/colinhacks/zod/discussions/2182

<div type='discussions-op-text'>

<sup>Originally posted by **kostysh** March 10, 2023</sup>
Hi,
playing with composable schemas and got unexpected behaviour. As in the example below every particular schema is NOT optional, but for some reason, the resulting schema exposes `container` options and their properties as optional.
What is wrong?
Here is an example of the code that demonstrates the issue (codesandbox): https://codesandbox.io/s/composable-zod-schemes-forked-13wuuc?file=/index.ts

```typescript
import { z } from 'zod';

const GenericQuerySchema = z.object({}).catchall(z.unknown());

type GenericQuery = z.infer<typeof GenericQuerySchema>;

const baseMessageSchema = z.object({
  id: z.string(),
});

const createOptsSchema = <T extends GenericQuery>(querySchema: z.ZodType<T>) =>
  baseMessageSchema.extend({
    query: querySchema,
    querySchema: z.instanceof(z.ZodType<T>),
  });

type OPTS<T extends GenericQuery> =
  z.infer<ReturnType<typeof createOptsSchema<T>>>;

const createExtMessageSchema = <T extends GenericQuery>(querySchema: z.ZodType<T>) =>
  baseMessageSchema.extend({
    query: querySchema,
  });

type ExtMessage<T extends GenericQuery> =
  z.infer<ReturnType<typeof createExtMessageSchema<T>>>;

const test = <T extends GenericQuery>(options: OPTS<T>): ExtMessage<T> => {
  const { id, query } = createOptsSchema<T>(options.querySchema).parse(options);
  // const query: z.objectUtil.addQuestionMarks<z.baseObjectOutputType<{
  //     id: z.ZodString;
  //     query: z.ZodType<T, z.ZodTypeDef, T>;
  //     querySchema: z.ZodType<z.ZodType<T, z.ZodTypeDef, T>, z.ZodTypeDef, z.ZodType<T, z.ZodTypeDef, T>>;
  // }>, requiredKeys<...>>[""query""] | undefined
  console.log('--->', id, query); // Why `query` is optional?
  return createExtMessageSchema<T>(options.querySchema).parse({
    id,
    query,
  })
};

const CustomQuerySchema = GenericQuerySchema.extend({
  hello: z.string(),
});

type CustomQuery = z.infer<typeof CustomQuerySchema>;

const result = test<CustomQuery>({
  id: 'aaa',
  query: {
    hello: '123',
  },
  querySchema: CustomQuerySchema,
});

console.log(result)
```

</div>

`zod` version: 3.21.4
`typescript` version: 4.9.5

> `strict` option is `true` in the `tsconfig.json`",,
1624687685,2197,Memoize the schema initialization function passed to z.lazy,"I noticed that `z.lazy` reruns the function passed to it every time you use the schema. Can it be changed to memoize the result instead?

See:
```ts
import { z } from 'zod';

const lazy = z.lazy(() => {
  console.log('initialize');
  return z.string();
});

lazy.parse('hello');
lazy.parse('world');
```
Logs out:
```
initialize
initialize
```",,
1624497852,2196,Change in 3.21.2 breaks assignability of schema created from generics' parsed and inferred type,"I have a need to create a zod object schema that only has one key-value pair. This may not be exactly the best way to do something like this (and this is a contrived example), but in version 3.21.1, it was possible to assign the parsed data to the inferred type of a schema created through generic parameters:

```ts
import { z } from 'zod';

const createSchemaAndParse = <K extends string, VS extends z.ZodString>(key: K, valueSchema: VS, data: unknown) => {
  const schema = z.object({
    [key]: vSchema
  });
  const parsed = schema.parse(data);
  const inferred: z.infer<z.ZodObject<{ [k in K]: VS }>> = parsed; // this line errors in 3.21.2
  return inferred;
};
createSchemaAndParse('foo', z.string(), { foo: '' });
```

Unfortunately, with 3.21.2 (and above), the above line now produces a type error.",,
1624243741,2195,intersection between `object()` and `record()` parsing fails,"I have an intersection between a `z.object()` and a `z.record()` that has a refined key. Parsing an input fails since it seems to require all the input keys to match the record and the object, despite typescript seeing it as valid against the type.

version: 3.20.6

Example:
```ts
type FooKey = `foo.${string}`
const isValidFooKey = (key: string): key is FooKey => key.startsWith(""foo."")
const Foo = z.record(
  z.string().refine(isValidFooKey),
  z.string(),
)
type Foo = z.infer<typeof Foo> // type Foo = { [x: `foo.${string}`]: string | undefined; }

console.log(Foo.parse({
  ""foo.x"": ""some string value"",
})) // succeeds, output: `{ 'foo.x': 'some string value' }`

const Bar = z.object({
  bar: z.string().optional(),
})
type Bar = z.infer<typeof Bar> // type Bar = { bar: string | undefined; }

console.log(Bar.parse({
  bar: ""another string value"",
})) // succeeds, output: `{ bar: 'another string value' }`

const BarAndFoo = Bar.and(Foo)
type BarAndFoo = z.infer<typeof BarAndFoo> // type BarAndFoo = { bar: string | undefined; } & Partial<Record<`foo.${string}`, string>>

console.log(BarAndFoo.parse({
  ""foo.x"": ""some string value"",
})) // succeeds, output: `{ 'foo.x': 'some string value' }`

console.log(BarAndFoo.parse({
  bar: ""another string value"",
})) /* fails with: ```ZodError: [
  {
    ""code"": ""custom"",
    ""message"": ""Invalid input"",
    ""path"": [
      ""bar""
    ]
  }
]``` */

console.log(BarAndFoo.parse({
  ""foo.x"": ""some string value"",
  bar: ""another string value"",
})) /* fails with: ```ZodError: [
  {
    ""code"": ""custom"",
    ""message"": ""Invalid input"",
    ""path"": [
      ""bar""
    ]
  }
]``` */

const x: BarAndFoo = {
  ""foo.x"": ""some string value"",
  bar: ""another string value"",
} // typescript is happy with this
```",,
1623322945,2194,External Types Library using inferred types from Zod Schema not being declared correctly,"**Background:**

I have a TS node service that uses zod schemas for validation, and types inferred from these, ie:

```JS
export type MyType = z.infer<typeof mySchema>;
```

These types are then exported into a private NPM library, so I can use them across other projects making use of the TS node service.

```
tsc --emitDeclarationOnly
```

**Problem:**

The types, within the TS node service (where they are defined) are working correctly and as expected, however the types exported / imported from the NPM package are incorrect.

Consider the example below...

```JS
const mySchema = z.object({
  id: z.string(),
  x: z.number(),
  y: z.number(),
});

export type MyType = z.infer<typeof mySchema>;
```

**Expected:**

_This is how they are being correctly inferred within the Node Service code_

```JS
type MyType = {
  id: string;
  x: number;
  y: number;
}
```

**Actual:**

_This is how they are being imported from the npm package within external code_

```JS
type MyType = z.infer<z.ZodObject<{
  id: z.ZodString;
  x: z.ZodNumber;
  y: z.ZodNumber;
}>>
```

**Bug:**

The exported type definitions should correctly match the inferred types.
",,
1622561993,2193,Email Validation rejects email address with a subdomain and hyphenated domain,"Yep. What a doozy, but this exact case showed up in our production data. Example in regex101 using the Zod email validation regex
https://regex101.com/r/J0w46t/1",,
1622082472,2192,refine() function gets called even when parser already failed within translate()/refine()/regex(),"This is very similar to this one:
https://github.com/colinhacks/zod/issues/2113

Happening in version 3.21.4

refine() function still runs even though a previous translate has already invalidated it.  It's getting passed some aribtrary object
instead of the string that it expects.
```typescript
const parseResult = z
	.unknown()
	.transform((x, ctx) => {
		if (typeof x === 'string') return x;

		console.log('I fail because input is a number (correct behavior)');
		ctx.addIssue({
			code: 'custom',
		});
		return z.NEVER;
	})
	.transform((x: string) => {
		console.log(""I don't get executed (correct behavior since transform above invalidated the input)"");
		return x;
	})
	.refine((x: string) => {
		//BUG
		console.log(""I shouldn't get called but I do!!!!"");
		console.log(`I should be a string but I am a ${typeof x}!!!`); //'object'
		console.log(x); // some sort of '{status:'aborted'} object (the value underlying z.NEVER?)
	})
	.safeParse(42);

console.log(`succeeded:  ${parseResult.success}`); // false (correct behavior)
```
EDIT:  looks like there are more scenarios that are causing this 'zombie refine' scenario.  Here's two more:
- A failure within a `refine` causing it:
```typescript
import * as z from 'zod';

const parseResult = z
	.string()
	.refine(x => false) // force anything/everything to fail
	.transform(x => {
		console.log(""I don't get called""); // correct
		return x;
	})
	.refine((x: string) => {
		console.log(""I shouldn't get called!!!!!!"");
		console.log(typeof x); // string
		console.log(x); // '123'
	})
	.safeParse('123');

console.log(`succeeded:  ${parseResult.success}`); // false (correct behavior)
```
- a failure within a `regex` causing it:
```typescript
import * as z from 'zod';

const parseResult = z
	.string()
	.regex(/abc/) // fail because input doesn't match regex
	.transform(x => {
		console.log(""I don't get called""); // correct
		return x;
	})
	.refine((x: string) => {
		console.log(""I shouldn't get called!!!!!!"");
		console.log(typeof x); // string
		console.log(x); // '123'
	})
	.safeParse('123');

console.log(`succeeded:  ${parseResult.success}`); // false (correct behavior)
```

These were pretty easy to stumble upon, so there are likely more out there as well.",,
1622043178,2191,New signature for Object.partial to exclude certain keys (opposite mask),"```
partial<Mask extends {
        [k in keyof T]?: true;
    }>(mask: Mask): ZodObject<objectUtil.noNever<{
        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
    }>, UnknownKeys, Catchall>;
```

Right now it's possible to provide a mask to `Object.partial()` to apply it only to certain keys.
I would like to be able to also do the opposite: make all properties optional except the provided ones.
Basically the additional signature would have `Mask extends { [k in keyof T]?: false }` instead of `true`.
Obviously you can't mix true and false because it would make no sense.",,
1622035747,2190,Object.nullable and Object.nonNullable,"`Object.partial()` is very handy to make properties optional, but sometimes you want to make properties nullable instead (for example when you make SQL unions) and there is no method to do so.

I'm achieving the same result with custom functions but it's very inconvenient:

```
export function toNullableOrOptionalShape(
  shape: ZodRawShape,
  type: ""nullable"" | ""optional""
): ZodRawShape {
  return Object.entries(shape).reduce<ZodRawShape>((acc, [key, value]) => {
    acc[key] = value[type]();
    return acc;
  }, {});
}

export function toNullableObject<
  T extends ZodRawShape,
  UnknownKeys extends UnknownKeysParam = UnknownKeysParam,
  Catchall extends ZodTypeAny = ZodTypeAny
>(
  object: ZodObject<T>
): ZodObject<
  {
    [k in keyof T]: ZodNullable<T[k]>;
  },
  UnknownKeys,
  Catchall
> {
  return new ZodObject({
    ...object._def,
    shape: () => toNullableOrOptionalShape(object.shape, ""nullable""),
  }) as any;
}
```

I would love to have an `Object.nullable()` method and I could PR it if you are interested in having such feature.

We also need the equivalent of `Object.required` (`Object.nonNullable`?) to mark fileds as non-nullable.",,
1621909364,2189,Exclude `NaN` from `z.number()` schema type,"TS is fully okay with this kind of schema:
`z.number().default(Number.NaN)`

`z.number()` schema returns a number type and `NaN` is of type number. All good here. 
but when we feed an `undefined` value to this schema parser fails with `""message"": ""Expected number, received nan""`.
So it happily substituted provided `NaN` and then rejected it. 
If zod considers `NaN` as not a valid number, it should be reflected in the type level too. 

I know I can fix the error with `z.number().or(z.nan()).default(Number.NaN)`. But that is not my point. My point is to have typing inline with validation so that forgotten `.or(z.nan())` would be immediately spotted and not gonna cause unexpected validation failure on runtime. ",,
1621835112,2188,z.object.pick could accept arrays,"When using `.pick` or `.omit`, it would be nice to have the method also accept an array with strings with keys to pick/omit. For example:
```javascript
z.object({
  name: z.string(),
  address: z.string(),
  phone: z.string()
}).pick(['name', 'phone']);
```
Has anyone thought of that? Any drawbacks? I would be happy to contribute.",,
1619984370,2186,Property 'ulid' does not exist on type 'ZodString'.,"Not sure if this is a known issue, but on the latest version of zod (3.21.4*) throws a typescript error on ulids ...

<img width=""548"" alt=""Screenshot 2023-03-11 at 12 08 09"" src=""https://user-images.githubusercontent.com/84131395/224483519-53ac6b92-d566-4255-b0d7-2ac491dc29ae.png"">

*at the time of writing ",,
1619808112,2185,Transformation History (Feature request),"Do you consider to add transformation history in the result?

### Use case

- logging
- debugging

### The problem

Currently we don't have such functionality. When we want to collect it manually it will fail with `z.union` because it will execute all code and only after it will select first successful result. So at the end we will collect all transformation even that are not presented in the final result.

### A proposed solution

I can work on this solution. It's required for our project. Just want to check that it's valuable and, when I implement it, it may be added to the source code.",,
1619628676,2184,Prisma XOR with Zod  > 3.21.1 not working,"We encounterd a bug when using generated prisma types with versions greater than `3.21.1`. 

You can reproduce the issue in the following repo:  https://github.com/chrishoermann/zod-prisma-types-bug

As you can read in the following discussion we first thought it was an issue with prisma, but after digging around and finding that the suspected type has been this way for a long time now @njdowdy found that this is a zod issue that happend somwhere in `3.21.2`

### Discussed in https://github.com/colinhacks/zod/discussions/2171

<div type='discussions-op-text'>

<sup>Originally posted by **chrishoermann** March  9, 2023</sup>
I've built a generator for prisma ([zod-prisma-types](https://github.com/chrishoermann/zod-prisma-types)) that throws a type error since prisma updated their `XOR` type in 4.11:

```ts
  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T
```

before this type update the following zod schema worked without problems:

```ts
export const UserCreateInputSchema: z.ZodType<Prisma.UserCreateInput> = z.object({
  id: z.string().cuid().optional(),
  email: z.string().email({ message: ""Invalid email address"" }),
  name: z.string().min(1).max(100).optional().nullable(),
  role: z.union([ z.lazy(() => UserCreateroleInputSchema),z.lazy(() => RoleSchema).array() ]).optional(),
  enum: z.lazy(() => AnotherEnumSchema).optional(),
  scalarList: z.union([ z.lazy(() => UserCreatescalarListInputSchema),z.string().array() ]).optional(),
  posts: z.lazy(() => PostCreateNestedManyWithoutAuthorInputSchema).optional(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutUserInputSchema).optional(),
  location: z.lazy(() => LocationCreateNestedOneWithoutUserInputSchema).optional(),
}).strict();

export const UserUncheckedCreateInputSchema: z.ZodType<Prisma.UserUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  email: z.string().email({ message: ""Invalid email address"" }),
  name: z.string().min(1).max(100).optional().nullable(),
  role: z.union([ z.lazy(() => UserCreateroleInputSchema),z.lazy(() => RoleSchema).array() ]).optional(),
  enum: z.lazy(() => AnotherEnumSchema).optional(),
  scalarList: z.union([ z.lazy(() => UserCreatescalarListInputSchema),z.string().array() ]).optional(),
  lat: z.number(),
  lng: z.number(),
  posts: z.lazy(() => PostUncheckedCreateNestedManyWithoutAuthorInputSchema).optional(),
  profile: z.lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
}).strict();

export const UserCreateArgsSchema: z.ZodType<Prisma.UserCreateArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  data: z.union([ UserCreateInputSchema,UserUncheckedCreateInputSchema ]),
}).strict()
```

so a simple union was sufficient to satisfy typescript. in Prisma 4.11 typescript now throws the following error because, as I see it, the `Without<...>` type can not be satisfied with a union anymore:
```
Type 'ZodObject<{ select: ZodOptional<ZodType<UserSelect, ZodTypeDef, UserSelect>>; include: ZodOptional<ZodType<UserInclude, ZodTypeDef, UserInclude>>; data: ZodUnion<...>; }, ""strict"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<UserCreateArgs, ZodTypeDef, UserCreateArgs>'.
  The types of '_type.data' are incompatible between these types.
    Type '(UserCreateInput | UserUncheckedCreateInput) & (UserCreateInput | UserUncheckedCreateInput | undefined)' is not assignable to type '(Without<UserCreateInput, UserUncheckedCreateInput> & UserUncheckedCreateInput) | (Without<...> & UserCreateInput)'.
      Type 'UserCreateInput & UserUncheckedCreateInput' is not assignable to type '(Without<UserCreateInput, UserUncheckedCreateInput> & UserUncheckedCreateInput) | (Without<...> & UserCreateInput)'.
        Type 'UserCreateInput & UserUncheckedCreateInput' is not assignable to type 'Without<UserUncheckedCreateInput, UserCreateInput> & UserCreateInput'.
          Type 'UserCreateInput & UserUncheckedCreateInput' is not assignable to type 'Without<UserUncheckedCreateInput, UserCreateInput>'.
            Types of property 'lat' are incompatible.
              Type 'number' is not assignable to type 'undefined'.
```

I'm currently a bit stuck on how to solve this issue because I don't really know how to implement the `Without<...>` type especially because the `z.ZodType<...>` does not provide the object helper methods that would have been my first guess on how to approach this. Any help is appreciated.
</div>",,
1619421131,2183,`z.inferFlattenedErrors` does not account for transforms/effects,"Originally reported in `zod-form-data`: https://github.com/airjp73/remix-validated-form/issues/250#issuecomment-1454827269

[Playground reproduction](https://www.typescriptlang.org/play?ssl=5&ssc=47&pln=5&pc=25#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFAxhAHYDO8EARgFZwC8KAdK2wFNqMABRJMECAC5eTKMDoBzEQEp0KnjCgBDRhKggRELgD44YuC21QZEHhONoVKqjACeYAXABq2gDbAxNowwPQAolA4UAxcvAqYAlAAYn7BMAJ0AsQRUQwAPO6eEJhw-CaUNPRMcFACMdz8PAzaCQAK1gwCYk5UwCUiAIS1DE0ArtTUdQxqCBRwcLSM8Jip8NzDPIlR9qvpdKqU8wD0R-PzAHoA-FTzi9Vb0AwyvgFBIeGRj7ErwZRoQA)

I'm not entirely clear on the details, but it appears that when using a `transform` (that seems to use `z.Effect` under the hood) `z.inferFlattenedErrors` does not match the type of `error.flatten()`

---

_Example from @airjp73_

```ts
import { z } from ""zod"";

const obj = z.object({ foo: z.string() }).transform(o => ({ bar: o.foo }))

type ValidationErrors = z.inferFlattenedErrors<typeof obj>;

const res = obj.safeParse({})

if (!res.success) {
  const flat = res.error.flatten();
  const errors: ValidationErrors = flat;
  // ^ type error here
}
```",,
1617479597,2176,"Json, prisma, passthrough - since 3.21.0","Hello,

maybe this is my misuse, but since 3.21.0 I am having the following issue:

I am using prisma - JSON field:

```prisma
model MyModel {
  // ...
  json JSON
}
```

and then the following zod schema:

```typescript
const schema = z.object({
  name: z.string(),
}).passthrough()

const data = schema.parse({
  name: 'hello',
  extra: 'something',
})
```

and trying to insert it into the DB:

```typescript
ctx.prisma.my_model.create({
  data: {
    json: data,
  }
})
```

Then since 3.21.0 I am getting the following:

```
TS2322: Type 'objectOutputType<{ name: ZodString; }, ZodTypeAny, ""passthrough"">' is not assignable to type 'JsonNull | InputJsonValue'. Â Â Type 'objectOutputType<{ name: ZodString; }, ZodTypeAny, ""passthrough"">' is missing the following properties from type 'readonly (InputJsonValue | null)[]': length, concat, join, slice, and 19 more.
```

Basically I want to store in the db whole json object, even if it contains some extra fields.
Maybe I was just misusing passthrough... Thanks


",,
1617014053,2172,Inferring type with `zod.input` when using `zod.coerce`,"```ts
const exampleObject = zod.object({
    date: zod.coerce.date()
});

export type exampleTypeInput = zod.input<typeof exampleObject>;
```

In this `exampleTypeInput` inferred for the attribute `date` has type `Date` Can this either be 'Any' or an option to add a type? Current issue means that we are unable to see this work with passing in a non `Date` value for example a `String`

",,
1616738517,2170,Discriminated union of another discriminated union,"Consider this use case where I have a requirement to make a validation schema for a complex form. User can either choose to fill the details of the form manually or upload a csv instead of filling the form.

```typescript
import { z } from ""zod"";

const SolarEnergySchema = z.object({
  type: z.literal(""Solar""),
  solarField1: z.string(),
  solarField2: z.string(),
  uploadCsv: z.literal(false)
});

const WindEnergySchema = z.object({
  type: z.literal(""Wind""),
  windField1: z.string(),
  windField2: z.string(),
  uploadCsv: z.literal(false)
});

const WaterEnergySchema = z.object({
  type: z.literal(""Water""),
  waterField1: z.string(),
  waterField2: z.string(),
  uploadCsv: z.literal(false)
});

const EnergyUnionSchema = z.discriminatedUnion(""type"", [
  SolarEnergySchema,
  WindEnergySchema,
  WaterEnergySchema
]);

const CSVSchema = z.object({
  uploadCsv: z.literal(true),
  csvFile: z.instanceof(File)
});

// Form Fields can be either of type EnergyUnionSchema or CSVSchema
const FormSchema = z.discriminatedUnion(""uploadCsv"", [
  EnergyUnionSchema, // type error
  CSVSchema
]);
```

The form itself is complex and has dependent fields based on a `Select` input for which I can make a discriminated union with the value of `Select` being the discriminator. Now I have a discriminated zod union which I want to combine with a schema for uploading the csv file but I when trying to do that I get these type errors. How do I achieve my required schema for this use case? I have attached a sandbox link with a simplified version of my schema requirements 

Sandbox link: https://codesandbox.io/s/weathered-darkness-6okw7n?file=/src/index.ts

I have tried using union instead of discriminated union but that doesn't work for my use case because I have using react-hook-form with zod as resolver. If I mark `upload` option to be true, I still get errors reported for the form details even though the user doesn't need to fill them. Ideally, if the `upload` option is true, other form fields should not be validated at all",,
1615991972,2169,z.string().email() allows slash in domain,"Hello!

We noticed that parsing with `z.string().email()` method allows a slash in the domain of an email. However, I think I found the regex you use for checking emails, and a slash in the email does not match that regex, so it seems like this is a bug. Let me know if you have any other questions.",,
1615740091,2168,"`z.enum().extract()`, and `z.enum().exclude()` should take variadic args","Before:
```ts
z.enum( [ 'foo', 'bar', 'baz' ] ).extract( [ 'foo', 'bar' ] )
```

After:
```ts
z.enum( [ 'foo', 'bar', 'baz' ] ).extract( 'foo', 'bar' )
```

I think this looks a lot cleaner, but I'm not sure of the implications for typescript. Any thoughts?",,
1615299282,2165,Zod incorrectly throws schema validation error when correct input passed.,"I am running zod on a production api, I have a global catch that if the application experiences an unrecoverable error it sends me an email. This morning I got an email with a zod error, however when I pulled google's stack driver logging I can see that the 'string' zod is complaining about is indeed a number. 99% of the calls to this api go through. This is concerning as this presents some unpredictable behavior from zod.


Input:
```ts
{
    dealUrl: 'https://access.booksi.com/bilmar-beach-resort',
    destination: 'St Pete Beach, Florida',
    guest: {
        address: 'Redacted',
        city: 'Lexington',
        country: 'United States',
        countryCode: 1,
        dateOfBirth: 'Redacted',
        email: 'Redacted',
        firstName: 'Sandra',
        lastName: 'Redactd',
        maritalStatus: 'Co-Hab',
        phone: 'Redacted',
        postalCode: 'Redacted',
        resID: {
            number: 509902,
        },
        spouseName: 'Redacted',
        stateSlashRegion: 'Redacted',
        street1: 'Redacted',
    },
    hotel: 'Bilmar Beach Resorts',
    requestedDates: {
        checkin: '04/24/2023',
        checkout: '04/28/2023',
    },
    roomType: 'Standard Room, Deluxe Studio',
}
```

schema: 

```ts
export const dateRequestSchema = z.object({
  hotel: z.string(),
  destination: z.string(),
  roomType: z.string(),
  requestedDates: z.object({
    checkin: z.string().regex(/\d\d\/\d\d\/\d\d\d\d/),
    checkout: z.string().regex(/\d\d\/\d\d\/\d\d\d\d/),
  }),
  dealUrl: z.string(),
  guest: z.object({
    resID: z.object({
      number: z.number(),
    }),
    phone: z.number(),
    email: z.string().email().optional(),
    address: z.string().optional(),
    firstName: z.string(),
    lastName: z.string(),
    spouseName: z.string().optional(),
    countryCode: z.number(),
    dateOfBirth:z.string().regex(/\d\d\/\d\d\/\d\d\d\d/), 
    maritalStatus: z.string(),
    street1: z.string().optional(),
    city: z.string().optional(),
    stateSlashRegion: z.string().optional(),
    postalCode: z.string().optional(),
    country: z.string().optional(),
  }),
})
```


output:

```ts
[
  {
    ""code"": ""invalid_type"",
    ""expected"": ""number"",
    ""received"": ""string"",
    ""path"": [
      ""guest"",
      ""resID"",
      ""number""
    ],
    ""message"": ""Expected number, received string""
  }
]
```",,
1614334825,2163,"Typecheck causes ""heap out of memory"" error ","`zod: 3.21.4`
`typescript: 4.9.5`

Running `tsc --noEmit` on a project that uses `zod` causes a ""JavaScript heap out of memory"" error.

This seems to only be an issue with zod `3.21.4`. Downgrading to `3.21.3` resolves it.

Sorry I don't have time to create a reproduction at the moment.",,
1614141017,2162,`z.input` is lost with `.catch(someValue)`,"When using `.catch`, I can no longer infer input value.
[reproduction](https://codesandbox.io/s/zod-catch-input-infer-yb0wo6) 

```ts
const schema = z.string().catch('String value')
// type is `undefined`, it should be `string`
type Input = z.input<typeof schema>
```",,
1613014619,2158,strictNullChecks=false makes z.object() properties optional,"Hi!

Turning off strictNullChecks in compilerOptions makes all object properties optional.

tsc -v: 4.9.5

tsconfig:
```ts
{
  ""compilerOptions"": {
    ""strictNullChecks"": false,
    ""strict"": true,
  }
}
```
**Example:**

```ts
const Dog = z.object({
  name: z.string(),
  age: z.number(),
});

type Dog = z.infer<typeof Dog>;
```

**Expected result:**
// equivalent to:
```ts
type Dog = {
  name: string;
  age: number;
};
```

**Actual result:**
// equivalent to:
```ts
type Dog = {
  name?: string;
  age?: number;
};
```",,
1612695002,2155,custom error message causes typeError,"using zod v3.21.3

this code causes typeError, which is not wrong with previous version(v3.20.6).
```ts
const px =
  z.custom <
  `${number}px` >
  ((val) => /^\d+px$/.test(val as string), ""custom error message"");
```

error message
```
Argument of type 'string' is not assignable to parameter of type 'CustomParams | ((input: any) => CustomParams)'
```

here is my code sandbox link.
https://codesandbox.io/s/upbeat-williams-scfj81?file=/src/index.ts",,
1612595326,2154,False positive for .email() validation with sub-domain present?,"I've come across what I believe to be some false positives with the string `.email()` validation, where it doesn't appear to like subdomains. Here is a simple repro:
```
import { z } from 'zod';

const data = [
  'me@z.com',
  'me@y.z.com',
  'me@z.co.jp',
  'me@y.z.co.jp',
];

for (const email of data) {
  console.log(z.string().email().safeParse(email));
}
```
which produces:
```
{ success: true, data: 'me@z.com' }
{ success: false, error: [Getter] }
{ success: true, data: 'me@z.co.jp' }
{ success: false, error: [Getter] }
```
This is flagging up validation errors in my project for real email addresses resembling the 4th entry in the above repro.
I can see from the code that this behavior is driven by a rather formidable looking regexp; please could you clarify - is a validation failure on an address such as `me@y.z.co.jp` intentional? Thanks!",,
1612460247,2153,Inconsistent typing of `parse` result when using generic schema types,"Following on from https://github.com/colinhacks/zod/issues/2146
I'm still having issues getting return values of functions that accept generic schemas to work right.

It now works perfectly if I'm nesting the schema inside a new schema. But if I'm simply using the schema as-is, the result type doesn't get inferred and gets typed as `any`.

https://tsplay.dev/mZ1zJN

```ts
import { z } from 'zod'

const zSchema = z.object({
  name: z.string()
})

function validate<TSchema extends z.ZodTypeAny>(
  thing: any,
  schema: TSchema,
) {
  return schema.parse(thing)
}

// typed as any
const result = validate({ name: ""zoddy"" }, zSchema)

function validate2<TSchema extends z.ZodTypeAny>(
  thing: any,
  schema: TSchema,
) {
  const nested = z.object({
    nested: schema
  })
  return nested.parse(thing)
}

// typed as { nested: { name: string; } }
const result2 = validate2({ nested: { name: ""zoddy"" }}, zSchema)
```",,
1612240833,2151,Use _id with own string,"Sorry to ask here but wondered how to setup my User object with my own string as the _id using TS:
**users.model.ts**
```ts
import { db } from './../../../db';
import * as z from 'zod';
import { WithId } from 'mongodb';

export const User = z.object({
    email: z.string().email(),
    forename: z.string().min(3),
    surname: z.string().min(3),
    picture: z.string(),
    createdAt: z.date(),
    updatedAt: z.date(),
    _id: z.string(),
    role: z.string().default('user')
});

export type User = z.infer<typeof User>;
export type UserWithId = WithId<User>;
export const Users = db.collection<User>('users');
```
Seems fine but when I use FindOne on the _id field it wants an ObjectId

**user.controller.ts**
```ts
import { User, Users, UserWithId } from ""./users.model"";
const user = await Users.findOne({ _id: new ObjectId(req.params.id) });
```
Which obviously it can't do to a rrq.param.id string like ""MyUserIDIsAString""

Any help appreciated",,
1610393390,2146,Can't generically compose + transform schema without type error,"Say I want to do something like this:

https://tsplay.dev/mq9bjm
```ts
import { z } from 'zod'

async function stripOuter<TData extends z.ZodTypeAny>(schema: TData, url: string): Promise<TData> {
  const zStrippedResponse = z
    .object({
      topLevelKey: schema,
    })
    .transform(data => {
      return data.topLevelKey
      //     ^?
    })
  
  return fetch(url)
    .then(response => response.json())
    .then(data => zStrippedResponse.parse(data))
}
```
I get the following type error:
```ts
Property 'topLevelKey' does not exist on type '{ [k in keyof baseObjectOutputType<{ topLevelKey: TData; }>]: baseObjectOutputType<{ topLevelKey: TData; }>[k]; }'.
```

Is this something I should be able to do? Any pointers where I'm going wrong?",,
1609879080,2142,Zod 3.20 and TS 4.5+ Causes tsserver High CPU,"The combination of Zod 3.20 and TS 4.5+ is causing my project tsserver to have considerable slow down and degrades the developer experience.

Other seem to be having the same issues: https://stackoverflow.com/questions/74881472/slow-typescript-autocompletion-in-vs-code-for-zod",,
1609870490,2141,Anyone have a good example for the docs for `z.custom`,"the current example is not very good, because it could easily be solved with z.string().regex().
https://github.com/colinhacks/zod#custom-schemas

I would like an example where you can't solve it easily with another zod schema.",,
1608986726,2135,Make `z.object().passthrough()` transform infered type,"When you are using the `passthrough` function on an object schema, you are effectively affecting the result of the `parse function and allow it to return additional keys.
However, the `z.infer`Â type utils doesn't reflect it

Indeed, the 2 following schemas return the same infered type

```ts

const schema1 = z.object({ foo: z.string() });
const schema2 = z.object({ foo: z.string() }).passthrough();

type Schema1 = z.infer<typeof schema1>
// Schema1 = { foo: string; }

type Schema2 = z.infer<typeof schema2>
// Schema2 = { foo: string; }

```

While there is a difference in the return of `parse`

```ts

const result1 = schema1.parse({ foo: 'test', bar: 'test' })
// result1 = { foo: 'test' };

const result2 = schema2.parse({ foo: 'test', bar: 'test' })
// result2 = { foo: 'test',  bar: 'test };

```

I think it would be useful to change the behaviour of `z.infer` (and thus the return type of the `parse` function) to reflect this difference.
For example:

```ts

const schema = z.object({ foo: z.string() }).passthrough();

type Schema = z.infer<typeof schema>
// Schema = { foo: string; [key: string | number | symbol]?: unknown; }

```",,
1608794872,2133,Strict `z.tuple(...)`,"Can we have the equivalent of `z.object(...).strict()` but for tuples? Currently the tuple type is inferred as `[A, B, ...unknown[]]` which does not match `[A, B]`(TypeScript  4.9.4). Using `z.tuple([zodA, zodB]).rest(z.never())` does not solve the problem.",,
1607630877,2131,Inverse of `z.infer`?,"I am not looking to generate dynamic code from static code like in #53. `z.infer` goes from `z.ZodType` to ""unwrapped"" TypeScript types. How do you implement the inverse? I tried the following but does not seem to work:

```
X extends z.infer<infer Y> ? Y : never
```",,
1607600893,2129,"Convenience refinements for ZodEnum, ZodNativeEnum","I have a Zod native enum:
```ts
enum HttpMethod {
  DELETE = 'DELETE'
  GET = 'GET'
  HEAD = 'HEAD'
  OPTIONS = 'OPTIONS'
  POST = 'POST'
  PUT = 'PUT'
}

const httpMethod = z.nativeEnum(HttpMethod)
```

And then I use that in another zod parser:
```ts
const getRequest = z.object({
  method: z.literal(HttpMethod.GET)
})
```

This works fine, but it would be nice to be able to get a version of the `httpMethod` parser that only accepts `'GET'`. I can do it with a refinement:
```ts
const getRequest = z.object({
  method: httpMethod.refine(m => m === HttpMethod.GET)
})
```

I was just hoping for something shorter and more expressive, like
```ts
const getRequest = z.object({
  method: httpMethod.GET
})
```
",,
1607486244,2128,Suggestion: Alternate name alias for .catch(),"For those of us using strict linting, `.catch()` on anything means a promise catch clause... except for when it comes to `zod`. This can result in a lot of false-positive linting results.

It would be useful if there was also an unambiguously non-promise-related alternate name to use for this method, like `.fallbackValue()`.",,
1607325481,2127,DeepPartial Array length validation,"Hi! So just stumbled upon this, it would appear that something in 3.8 broke the way array().min() works with deepPartial()

If you check this codepen 

https://codepen.io/pasco82/pen/GRXmJgV?editors=0011

with v 3.7.1

```
{
  ""success"": false,
  ""error"": {
    ....
  }
}
```

but with v 3.8.1

```
{
  ""success"": true,
  ""data"": {
    ""clientContacts"": []
  }
}
```

Is there a change in syntax i've missed somewhere?

thanks in advance ðŸ‘ 

",,
1605663247,2124,`z.enum()` breaks if you pass it an actual enum or array created by destructuring enum using Object.values()`,"This can't possibly be how Zod is designed to handle enum validation...

I would have thought this would work:

```ts
import { z } from 'zod';

enum PizzaType {
  Canadian = 'Canadian',
  Cheese = 'Cheese',
  Hawaiian = 'Hawaiian',
  MeatLovers = 'Meat Lovers',
  Pepperoni = 'Pepperoni',
  Vegetarian = 'Vegetarian',
}

const orderSchema = z.object({
  id: z.number(),
  type: z.enum(PizzaType)
})

const order = {
  id: 1,
  type: 'Canadian'
}

orderSchema.safeParse(order)
```

Looks good to me. Logical. Simple. Should definitely work. Right?

```bash
error TS2769: No overload matches this call.
      Overload 1 of 2, '(values: readonly [string, ...string[]], params?: RawCreateParams): ZodEnum<[string, ...string[]]>', gave the following error.
        Argument of type 'typeof PizzaType' is not assignable to parameter of type 'readonly [string, ...string[]]'.
      Overload 2 of 2, '(values: [string, ...string[]], params?: RawCreateParams): ZodEnum<[string, ...string[]]>', gave the following error.
        Argument of type 'typeof PizzaType' is not assignable to parameter of type '[string, ...string[]]'.

    34     .enum(PizzaType)
                  ~~~~~~~
```

Okay, well that's weird. I guess I'll just do `Object.values(PizzaType)`?

```ts
const orderSchema = z.object({
  id: z.number(),
  type: z.enum(Object.values(PizzaType))
})
```

```bash
error TS2769: No overload matches this call.
      Overload 1 of 2, '(values: readonly [string, ...string[]], params?: RawCreateParams): ZodEnum<[string, ...string[]]>', gave the following error.
        Argument of type 'typeof PizzaType' is not assignable to parameter of type 'readonly [string, ...string[]]'.
      Overload 2 of 2, '(values: [string, ...string[]], params?: RawCreateParams): ZodEnum<[string, ...string[]]>', gave the following error.
        Argument of type 'typeof PizzaType' is not assignable to parameter of type '[string, ...string[]]'.

    34     .enum(Object.values(PizzaType))
                  ~~~~~~~~~~~~~~~~~
```

Uh, okay... How about destructuring into a new array of strings.

```ts
const orderSchema = z.object({
  id: z.number(),
  type: z.enum([...Object.values(PizzaType)])
})
```

```bash
error TS2769: No overload matches this call.
      Overload 1 of 2, '(values: readonly [string, ...string[]], params?: RawCreateParams): ZodEnum<[string, ...string[]]>', gave the following error.
        Argument of type 'typeof PizzaType' is not assignable to parameter of type 'readonly [string, ...string[]]'.
      Overload 2 of 2, '(values: [string, ...string[]], params?: RawCreateParams): ZodEnum<[string, ...string[]]>', gave the following error.
        Argument of type 'typeof PizzaType' is not assignable to parameter of type '[string, ...string[]]'.

    34     .enum([...Object.values(PizzaType)])
                  ~~~~~~~~~~~~~~~~~
```

Okay, well, I don't know how much uglier I need to get... I mean this would be even uglier, but I guess I could try:

```ts
const orderSchema = z.object({
  id: z.number(),
  type: z.enum([
      PizzaType.Canadian,
      PizzaType.Cheese,
      PizzaType.Hawaiian,
      PizzaType.MeatLovers,
      PizzaType.Pepperoni,
      PizzaType.Vegetarian,
    ]
})
```

```bash
âœ… Yup! Looks good to me!
```

WHY, ZOD!? WHY!? ðŸ˜­",,
1605326764,2122,UUID validation fails,"Using Zod 3.20.6.

I have a guid that doesn't pass validation. Unit tests:

```
import { z } from 'zod';

describe('Validation Tests', () => {
  // f4405c78-1a39-4d59-9d8a-7e56d5e13294
  // 852e395d-693e-ed11-809a-c971856d9437

  it('should succeed, correctly', async () => {
    const schema = z.object({
      value: z.string().trim().uuid(),
    });
    const parsed = schema.safeParse({ value: 'f4405c78-1a39-4d59-9d8a-7e56d5e13294' });
    expect(parsed.success).toStrictEqual(true);
  });

  it('should succeed, but does not', async () => {
    const schema = z.object({
      value: z.string().trim().uuid(),
    });
    const parsed = schema.safeParse({ value: '852e395d-693e-ed11-809a-c971856d9437' });
    expect(parsed.success).toStrictEqual(true);
  });
});
```
",,
1605170684,2121,z.discriminatordUnion can't handle Unions,"`z.discriminatordUnion()` can't handle `z.union()`

```ts
const baseAttribute = const baseAttribute = z.object({
  name: nameSchema,
  code: z.string(),
});
const linkAttribute = baseAttribute.extend({
  type: z.literal('Link'),
  options: z.object({
    code: z.string(),
  }),
});
const otherAttribute = baseAttribute.extend({
  type: z.union([
    z.literal('Time'),
    z.literal('GeoJson'),
    z.literal('Boolean'),
  ]),
});

export const attributeSchema = z.discriminatedUnion('type', [linkAttribute, otherAttribute]);
```

I've just seen that you want to deprecate discriminatedUnion from #2109 

But I was hoping this would be a super quick fix.
```ts
else if (type instanceof ZodUnion) {
  const accumulator = [];
  for ( const option of type.options ) {
    const types = getDiscriminator(option);
    if (types === null) {
      return null; // nested is of unknown type.
    }
    accumulator.push(...types);
  }
  return accumulator;
}
```",,
1604551141,2120,toLowerCase is not a function,"Hi there! 

Anyone else experiencing this?

## Code

```ts
await z.object({
    text: z.string().toLowerCase(), 
    another_text: z.string(), 
}).strict().safeParseAsync(_some_object)
```

## Expected behavior
No error thrown

## Actual Behavior
`TypeError: __vite_ssr_import_4__.z.string(...).toLowerCase is not a function`",,
1602019834,2114,get `keys` from object shape,"I checked the docs but couldn't find a way to do something like the _pseudo-code_ below...

```ts
const schema = z.object({
    foo: z.string(),
    one: z.object({
        two: z.object({
            three: z.string(),
            four: z.number(),
        }),
        five: z.string(),
    }),
    bar: z.number(),
});

const keys = schema.keys();

console.log(keys);
// [
// 	'foo',
// 	'one.two.three',
// 	'one.two.four',
// 	'one.five',
// 	'bar',
// ]
```

Any suggestions?",,
1601888293,2113,refine() function gets called even when parser already failed,"Using version 3.20.6

In certain scenarios, refine gets called even when the parser has already failed.   It seems like including a z.custom() can trigger this.

What's worse is that the type flowing into the refine's function (x) is different than what typescript thinks it is

Here's a minimal example:
```Typescript
const example1 = z
	.custom<number>(x => typeof x === 'number')
	.transform(x => String(x))
	.refine(x => {
		console.log(typeof x); // prints 'Object'
		console.log(""I get called even though I shouldn't!!!"");
		return true;
	})
	.safeParse({}); //will fail because it is not a number

console.log(example1.success); // false (like it should be)
```
And here's a more complex example with the same issue
```Typescript
const example2 = z
	.union([z.number(), z.string(), z.custom<number>(x => typeof x === 'number')])
	.refine(() => true)
	.pipe(z.any())
	.or(z.date())
	.pipe(z.any())
	.refine(x => {
		console.log(""I get called even though I shouldn't!!!!!!!!!"");
		return true;
	})
	.safeParse(true); // will fail immediately because it's a bool
```

As a work-around, using `.transform(x,ctx)=>...) ` approach to validate seems to work.",,
1601817790,2112,Documentation describes features that are not yet published on npm,I tried using `z.string().ip()` which is documented on https://zod.dev/ but it's not working. Maybe the website should only be built when doing a npm publish?,,
1601707025,2110,Recursive type with fixed and arbitrary keys causes type error.,"I looked through the old issues and the closest I could find was [this](https://github.com/colinhacks/zod/issues/1436), but I confirmed that the fix does not apply here because I'm already in strict mode.

Version info:
**Typescript**: ""^4.9.4""
**Zod**: ""^3.20.2""

Verified that `""strict"": true` is set in my tsconfig.json.

# The issue

I am trying to make a nested tree of arbitrary string keys where only the _leaf_ nodes have a defined structure.

```typescript
const DataFieldSchema = z.object({
  name: z.string(),
  description: z.string().optional(),
  required: z.boolean().optional().default(false),
  type: z.string().optional().default(""string""),
});
type DataField = z.infer<typeof DataFieldSchema>;

type Nested = DataField | { [key: string]: Nested };
const NestedDataFieldSchema: z.ZodType<Nested> = z.lazy(() =>
  z.union([DataFieldSchema, z.record(NestedDataFieldSchema)])
);
```
I verified that the `Nested` type permits the structure I'm looking for.
```typescript
const x: Nested = {
  ANY: {
    FIELD: {
      description: ""foo"",
      name: ""bar"",
      type: ""baz"",
      required: true,
    },
  },
};
// satisfies the type
```

However, NestedDataFieldSchema throws the following compilation error:
```
Type 'ZodLazy<ZodUnion<[ZodObject<{ name: ZodString; description: ZodOptional<ZodString>; required: ZodDefault<ZodOptional<ZodBoolean>>; type: ZodDefault<...>; enumValues: ZodOptional<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, ZodRecord<...>]>>' is not assignable to type 'ZodType<Nested, ZodTypeDef, Nested>'.
  Types of property '_input' are incompatible.
    Type '{ description?: string | undefined; type?: string | undefined; required?: boolean | undefined; enumValues?: { value: string; description: string; }[] | undefined; name: string; } | Record<string, Nested>' is not assignable to type 'Nested'.
      Type '{ description?: string | undefined; type?: string | undefined; required?: boolean | undefined; enumValues?: { value: string; description: string; }[] | undefined; name: string; }' is not assignable to type 'Nested'.
        Type '{ description?: string | undefined; type?: string | undefined; required?: boolean | undefined; enumValues?: { value: string; description: string; }[] | undefined; name: string; }' is not assignable to type '{ [key: string]: Nested; }'.
          Property 'description' is incompatible with index signature.
            Type 'string' is not assignable to type 'Nested'.
```

It seems to be an issue with the fact that DataField is a complex type, since when you use only primitive values at the leaf, it works fine (such as in the JSON example in the readme). My best guess is that there's an issue with it parsing arbitrary keys alongside well-defined keys.

The only workaround I've been able to find is to change the Nested type to 
```typescript 
type Nested = DataField | { [key: string]: Nested | string | boolean}
```
but this means losing the type guards around the defined keys, at which point I might as well just permit arbitrary JSON.

Am I just implementing this incorrectly? Any help on this would be appreciated, as it's a pretty serious hindrance to being able to rewrite some of the configuration JSON in our project.
",,
1600929378,2106,Deprecating `z.discriminatedUnion`?,"Superceded by https://github.com/colinhacks/zod/issues/3407

---

I'm planning to deprecate `z.discriminatedUnion` in favor of a ""switch"" API that's cleaner and more generalizable. You can dynamically ""switch"" between multiple schemas at parse-time based on the input.

```ts
const schema = z.switch(()=>{
  return Math.random() ? z.string() : z.number()
});
```

I expand more on the `z.switch` API later. Let's talk about `z.discriminatedUnion`.

## Why

 `z.union` naively tries each union element until parsing succeeds. That's slow and bad. Zod needed some solution.

`z.discriminatedUnion` was a mistake. The API was good but I had reservations about the implementation. It required fiddly recursive logic to exrtract a literal discriminator key from each union element.

<img width=""584"" alt=""Screenshot 2023-02-27 at 2 07 02 AM"" src=""https://user-images.githubusercontent.com/3084745/221534750-4652a10c-0c6d-4c62-a06b-918ca112c250.png"">

It's a bad sign when a method or class requires weird recursive traversal of other schemas. For starters, Zod is designed to be *subclassable*. Users can theoretically subclass `ZodType` to implement custom schema types. But logic like this `instanceof` switch statement don't and can't account for any user-land schema types. 

But the main problem is just that this kind of pattern is bad and introduces a lot of edge cases. It means that only certain kinds of schemas are allowed as discriminators, and others will fail in unexpected ways. There are now dozens of issues that have been opened regarding these various edge cases. The PRs attempting to solve this problem are irredeemably complex and introduce even more edge cases.

- https://github.com/colinhacks/zod/issues/1773
- https://github.com/colinhacks/zod/issues/1667
- https://github.com/colinhacks/zod/issues/1384
- https://github.com/colinhacks/zod/issues/1757
- https://github.com/colinhacks/zod/issues/1504
- https://github.com/colinhacks/zod/issues/1136
- https://github.com/colinhacks/zod/issues/1477
- https://github.com/colinhacks/zod/issues/1424
- https://github.com/colinhacks/zod/pull/1213
- https://github.com/colinhacks/zod/issues/1490
- https://github.com/colinhacks/zod/issues/1181
- https://github.com/colinhacks/zod/issues/1075
- https://github.com/colinhacks/zod/issues/1444
- https://github.com/colinhacks/zod/issues/1868
- https://github.com/colinhacks/zod/issues/1878


> The `.deepPartial` API has this same problem. I'm deprecating it for the same reason.

Many of those issues are asking for non-literal discriminator types:

```ts
type MyUnion = 
  | { type: ""a"", value: string }
  | { type: ""b"", value: string }
  | { type: ""c"", value: string }
  | { type: string, value: string }
  | { type: null, value: string }
  | { type: undefined, value: string }
  | { type: MyEnum, value: string }
  | { type: { nested: string }, value: string }
  | { type: number[], value: string };
```

Imagine each of those elements are represented with Zod schemas. Zod would need to extract the `type` field from each of these elements and find a way to match the incoming `input.type` against those options. In the general case, Zod would extract the `type` field from the shape of each component `ZodObject` and check `input.type` against those schemas until a match is found. At that point, we're back to doing a parse operation for each element of the union, which is what `z.discriminatedUnion` is supposed to avoid doing. (It's still doing less work than the naive `z.union` but still.)

Another issue is composability. The existing API expects the second argument to be an array of `ZodObject` schemas.

```ts
z.discriminatedUnion(""type"", [
  z.object({ type: z.literal(""a""), value: z.string() }),
  z.object({ type: z.literal(""b""), value: z.string() }),
])
```

This isn't composable, in that you can't nest discriminated unions or add additional members. 

```ts
const ab = z.discriminatedUnion(""type"", [
  z.object({ type: z.literal(""a""), value: z.string() }),
  z.object({ type: z.literal(""b""), value: z.string() }),
]);

const abc = z.discriminatedUnion(""type"", [
  ab,
  z.object({ type: z.literal(""c""), value: z.string() }),
]);
```

- https://github.com/colinhacks/zod/issues/1618
- https://github.com/colinhacks/zod/issues/1610
- https://github.com/colinhacks/zod/issues/1884

Yes, Zod could support both `(ZodObject | ZodDiscriminatedUnion)[]` as union members, but that requires additional messy logic that reflects a more fundamental problem with the API. It also makes increasingly difficult to enforce typesafety on the union - it's important that all union elements have a `type` property, otherwise the union is no longer discriminable.

## Replacement: `z.switch`

```ts
const schema = z.switch(input => {
  return (typeof input) === ""string"" ? z.string() : z.number();
})

schema.parse(""whatever""); // string | number
```

A discriminated union looks like this:

```ts
const schema = z.switch((input) => {
  switch(input.key){
    case ""a"":
      return z.object({ key: z.literal(""a""), value: z.string() })
    case ""b"":
      return z.object({ key: z.literal(""b""), value: z.number() })
    default:
      return z.never()
  }
});
schema.parse({ /* data */ });
// { key: 'a', value: 'asdf' } | { key: 'b', value: number }
```

Ultimately the `z.switch` API is a far more explicit and generalizable API. Zod doesn't do any special handling. The user specifies exactly how the `input` will be used to select the schema. `z.switch()` accepts a function. The `ResultType` of that function is inferred. It will be the union of the schema types returned along all code paths in the function. For instance:

```ts
const schema = z.switch(()=>{
  return Math.random() ? z.string() : z.number()
});
```

Zod sees that the return type of the switcher function is `ZodString | ZodNumber`. The result of the `z.switch` is `ZodSwitch<ZodString | ZodNumber>`. The result of `schema.parse(...)` is `string | number`.

You can represent discriminated unions explicitly like this:

```ts
const schema = z.switch((input) => {
  switch(input.key){
    case ""a"":
      return z.object({ key: z.literal(""a""), value: z.string() })
    case ""b"":
      return z.object({ key: z.literal(""b""), value: z.number() })
    default:
      return z.never()
  }
});
schema.parse({ /* data */ });
// { key: 'a', value: 'asdf' } | { key: 'b', value: number }
```

This can be written in a more condensed form like so:

```ts
const schema = z.switch((input) => ({
  a: z.object({ key: z.literal(""a""), value: z.string() }),
  b: z.object({ key: z.literal(""b""), value: z.number() }),
}[input.key as string]));
  
schema.parse({ key: 'a', value: 'asdf' });
// { key: 'a', value: 'asdf' } | { key: 'b', value: number }
```

It's marginally more verbose. It's also explicit, closes 30+ issues, eliminates a lot of hairy logic, and lets Zod represent the full scope of TypeScript's type system. `z.discrimininatedUnion` is too fragile and causes too much confusion so it needs to go.",,
1600742410,2105, Property 'min' does not exist on type 'ZodDate'.,"```ts
date_of_birth: z
    .date()
    .min(`${new Date().getFullYear() - 17}-01-01`, {
      message: 'Please provide a valid date 0f birth',
    })
    .max(`1900-01-01`, { message: 'Please provide a valid date 0f birth' })
    .optional()
    .nullish(),
```",,
1599965691,2104,Zod + React-hook-form + lingui,"Wondering if anyone has come across the following issue:
I am using `zod` & `react-hook-form` & `lingui`.

I would like to display a translated error message to the user and not sure what is the best approach.
I would like to keep the schema outside of React if possible, but would still like to be able to supply detailed error messages.
The issue is, once react-hook-form takes in the information from `zod`. A lot of the information disappears.
Example:
```tsx
const myFormSchema = z.object({
  name: z.string().min(3)
})

function MyForm(){
  const formMethods = useForm({ resolver: zodResolver(myFormSchema) })
  ...
}
```

The error  I would get from react-hook-form here is the following:
```{ type: ""too_short"", message: ""ZOD's DEFAULT ERROR MESSAGE HERE"", ref: (THE INPUT REF HERE) }```
Which is not enough detail to generate the translated message.

So I end up doing this:
```tsx
function MyForm(){
  const t = useTrans()
  const myFormSchema = z.object({
    name: z.string().min(3, t(""form_errors.min_length"", { label: t(`name`), min: 3 }))
  })
  const formMethods = useForm({ resolver: zodResolver(myFormSchema) })
  ...
}
```

Which I feel, defeats the purpose of `zod` because I would like to auto-infer the type of the schema and also reuse it. 
But in this state, it doesn't exist outside of React.

Any advice? Is there something I'm doing wrong?",,
1599851035,2101,Typescript Errors for flattened error object,"I am using SvelteKit and it's form actions. When my server.ts file returns a fail, SvelteKit puts the result into the `ActionData` object, which it assigns for you

<img width=""315"" alt=""image"" src=""https://user-images.githubusercontent.com/52610563/221380911-9576c072-d512-40f6-bddd-9db56bf7d487.png"">

I'm kicking back Zod validation errors:
<img width=""469"" alt=""image"" src=""https://user-images.githubusercontent.com/52610563/221380864-acbda672-d926-49ae-bffa-450b6cab9d65.png"">

Everything actually works, so this could be deemed minor, but Typescript doesn't like the form.errors object
<img width=""1291"" alt=""image"" src=""https://user-images.githubusercontent.com/52610563/221380813-6009339c-4677-4ebe-90ef-8a9d93178283.png"">

Reading the docs, I see the Extract type signature section, but not being a native TS guy, I'm getting a touch lost with it. Can anyone assist with how to get TS happy?
",,
1597452582,2093,Can I use Zod in TypeScript Older versions?,"I'm working in a project running in `node 12.22` and `TypeScript ^3.7.4`

in the readme it has specified `TypeScript 4.5+`, but I assume that is for the current version of Zod. Is there any release where I can use the tool in this version of typescript?",,
1596612703,2091,Select Option validation,"hi dev. i have problem with select option.
if use z.string ( we select or not still success)
if use z.string and min 1 ( when null show error but when select still error)

please help me.
love you and team",,
1596094322,2089,Feature Request: Better ZodObject generics,"In TS projects I find I am frequently defining schemas based on an existing type using this process:

```ts
const userSchema: ZodSchema<User> = z.object({
    name: z.string(),
    email: z.string().email()
})
```

However the generic `ZodSchema` strips all the `ZodObject` properties like `partial` and `shape` from the type so when writing functions that take a ZodObject we need to typecast from schema to object. 

It would be very helpful to have a `ZodSchemaObject` generic that would map to type with all the properties of `ZodObject`",,
1596013720,2088,Min and max use spaces and characters.,"I have recently found out that When `z.string().max()` is used it also counts the Characters and spaces within each string. This is not good at all. Spaces are not characters they are just nothing. This is not a good idea I thought it would just count the actual characters only. This should not be done at all. The length of a string and how many characters are written are different things. Please make it so that spaces are ignored when the string is being evaluated or at least create an ignore spaces method.   


To prove that this is true I have decided to create a repo to showcase this problem https://stackblitz.com/edit/typescript-urjdak. It's a repo that uses random text to write up to 300 words. 

In order to test out my thesis all you have to do is remove one of the spaces and the test that I have created will just pass. 

If you want to understand what I'm talking about even more go to this site [Word Count Jet](https://www.wordcountjet.com/)
Then paste the below text in there

```
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Eu turpis egestas pretium aenean pharetra magna ac. Nisi vitae suscipit tellus mauris a. Vel risus commodo viverra maecenas accumsan lacus vel. NKEDnasjns aaeldm3ewo;sn ypkqw lie. 
```


 ",,
1595795464,2086,Implement TypeScript generic functions.,"Since zod tries to resemble TypeScripts API and its types, I think it would be awesome if some built in utility typescript functions were available in zod too

Here are a few examples how these generic functions would work

```ts
const eventSchema = z.union([
  z.object({
    type: ""success"",
    data: z.any(),
  }),
  z.object({
    type: ""error"",
    message: z.string(),
  }),
]);

z.extract(eventSchema, z.object({ type: z.literal(""error"") })); // result: z.object({ type: ""error"", message: z.string() });
```

```ts
z.required(
  z.object({
    foo: z.string().optional(),
    bar: z.string().optional(),
  })
);

/**
 * result:
 *
 * z.object({
 *   foo: z.string(),
 *   bar: z.string()
 * })
 */
```",,
1595599358,2085,export 'z' (imported as 'z') was not found in 'zod' (module has no exports),"With webpack. All I'm doing is:

```ts
import { z } from 'zod'
```

and webpack is not able to import it

```
WARNING in ./myFile.ts 56:10-18
export 'z' (imported as 'z') was not found in 'zod' (module has no exports)
```",,
1595396401,2084,"Feature Request : A ""create a schema according to this type"" helper","Hello there,

What do you think about this discussion?

If this is something you are interested in, what's the direction to add this feature?


### Discussed in https://github.com/colinhacks/zod/discussions/1928

<div type='discussions-op-text'>

<sup>Originally posted by **rphlmr** January 24, 2023</sup>
Hello,

What about adding a helper that takes a type and ""forces"" you to create a schema according to this type?

Can be useful, for example, to create a schema derived from a Prisma Model.

```ts
type Implements<Model> = {
  [key in keyof Model]-?: undefined extends Model[key]
    ? null extends Model[key]
      ? z.ZodNullableType<z.ZodOptionalType<z.ZodType<Model[key]>>>
      : z.ZodOptionalType<z.ZodType<Model[key]>>
    : null extends Model[key]
    ? z.ZodNullableType<z.ZodType<Model[key]>>
    : z.ZodType<Model[key]>;
};

export function implement<Model = never>() {
  return {
    with: <
      Schema extends Implements<Model> & {
        [unknownKey in Exclude<keyof Schema, keyof Model>]: never;
      }
    >(
      schema: Schema
    ) => z.object(schema),
  };
}

// usage
export type UserModel = {
  id: string
  email: string | null
  name: string
  firstName: string
  createdAt: Date
}

export const UserCreateSchema = implement<Omit<UserModel, ""createdAt"" | ""id"">>().with({
  email: z.string().email().nullable(),
  name: z.string(),
  firstName: z.string(),
});

export type UserCreatePayload = z.infer<typeof UserCreateSchema>
```

This is maybe not perfect, but I use this on my projects and I'm pretty happy with It.

Force to put `nullable` `optional` or `nullish` when Model requires it.
Unknown properties are forbidden and cause a TS error.

Discussed here : https://github.com/colinhacks/zod/issues/372#issuecomment-830094773</div>",,
1594759072,2080,"The ""exact"" issue field isn't documented (used by too_big and too_small)","Per the title, I've noticed that the functionality added in #1620 (to address #1611) was never documented in [ERROR_HANDLING.md](https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md).

Feeling too lazy to make a PR myself, so this is just a PSA.",,
1593935551,2077,`z.enum` with generic array is breaking `z.object` inference ,"Source:
https://stackoverflow.com/questions/75523855/zod-enum-with-generic-array

I changed the source code to use the exact generics `z.enum` uses and it still didn't work.
```typescript
import { z } from 'zod';

function objectWithGenericEnum<U extends string, T extends Readonly<[U, ...U[]]>>(
    options: T
) {
    const enumValidator = z.enum(options);
    const a =  z.object({
        data: enumValidator,
    });
    return a.transform((v) => v.data); // Property 'data' does not exist on type '{ [k in keyof baseObjectOutputType<{ data: ZodEnum<Writeable<T>>; }>]: baseObjectOutputType<{ data: ZodEnum<Writeable<T>>; }>[k]; }'.(2339)
}
```

If we instead use this line, the data property is present.

```typescript
...
    const enumValidator = z.enum(['fish', 'sushi']);
...
// data is now defined
```
",,
1593800508,2076,Recursive types doc example stop working with .brand(),"If there is a branded schema in the shape, [the recursive types doc example](https://zod.dev/?id=recursive-types) stop working.
``` ts
const baseCategorySchema = z.object({
  - name: z.string(),
  + name: z.string().brand(""CategoryName""),
});

type Category = z.infer<typeof baseCategorySchema> & {
  subcategories: Category[];
};

const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({
  subcategories: z.lazy(() => categorySchema.array()),
});
```
categorySchema has TS error:
TS2322: Type 'ZodObject<extendShape<{ name: ZodBranded<ZodString, ""CategoryName"">; }, { subcategories: ZodLazy<ZodArray<ZodType<Category, ZodTypeDef, Category>, ""many"">>; }>, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<Category, ZodTypeDef, Category>'.
   Types of property '_input' are incompatible.
 Â Â Â Â Type '{ name: string; subcategories: Category[]; }' is not assignable to type 'Category'. 
Â Â Â Â Â Â Type '{ name: string; subcategories: Category[]; }' is not assignable to type '{ name: string & BRAND<""CategoryName"">; }'. Â Â Â Â Â Â Â Â Types of property 'name' are incompatible.
 Â Â Â Â Â Â Â Â Â Â Type 'string' is not assignable to type 'string & BRAND<""CategoryName"">'.
 Â Â Â Â Â Â Â Â Â Â Â Â Type 'string' is not assignable to type 'BRAND<""CategoryName"">'.

Thanks.",,
1593616125,2075,Typing generic functions (like a transformer) correctly,"Given the following function type: 
ChunkTransformFunc<P, R> = (chunk: P) => R

I want to be able to express: 

1. The Param should be of type P 
2. The Return Type should be of type R (normally unrelated to P) 

ChatGPT Gives me something like this: 

```ts
const ChunkTransformFuncSchema = z
  .function(z.zodTuple([z.unknown() as any]), z.unknown())
  .args(z.zodTuple([z.unknown() as any] as const))
  .transform((func) => {
    const [inputSchema, outputSchema] = z.getParsedType(func);
    return z.function(inputSchema[0], outputSchema);
  });
```

But this has some problems: 
1. z.zodTuple does not exist => rewriting to z.tuple() 
2. Then this line does not work anymore, due to readonly something somewhere: `.args(z.tuple([z.unknown() as any] as const));`

I would like to have something like a `z.generic()` function which allows a generic to be defined as input and to be retrieved as an output type for example. 
Maybe like this: 

```ts
z
.function(z.generic('P'), z.generic('R'))
.args(z.generic('P))
.returns(z.generic('R'))
```",,
1592620543,2074,Custom schema example for template literals gives type error,"In the [Custom schemas](https://github.com/colinhacks/zod#custom-schemas) section of the docs, this example is given for creating a template literal schema:
```ts
const px = z.custom<`${number}px`>((val) => /^\d+px$/.test(val));
px.parse(""100px""); // pass
px.parse(""100vw""); // fail
```

As is, this example shows an error on val being passed into test:

> `Argument of type 'unknown' is not assignable to parameter of type 'string'.`

`z.custom()` takes parameter `check?: ((data: unknown) => any) | undefined`, while `test.()` takes parameter `string: string`.

I think ideally, there should be a way to annotate  or infer the type of `data`, but that section is pretty empty.
I found two ways around the type error, one of which would be good to update the docs with:
```ts
const pxWithAs = z.custom<`${number}px`>((val) => /^\d+px$/.test(val as string));
const pxWithTemplate = z.custom<`${number}px`>((val) => /^\d+px$/.test(`${val}`));
```

[Playground link showing the error and ways around](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgNwBQFA9NXAKIAeAhuADYCmWOeAFjDDABnAFy0A5sBi8ArgCMAdAGNc1FW2AA7XsyUBrIdSLFqAYiUyhMXAFohS3hxDMhFFZqtwwjOAF4UypbWIAA8AAYAJAiaMiByHFBo3mEAfAAUaQBuzGwAlH4pcNQAegA6xADU3hHUCjAcVlk5ubmU3gpgzFBCHGkARACMAAxD3n2tRXSdQq7tnd29gyOZAO7jZJNYzMBsVLRwACorEHArzACeQnBdEDKaxHDSXAk4UG4QHvDeAOpSvACCV38yECVlw4SiMTiCSSjFSGWyeQKRTKlWqtXqjUR1yuVigWnELUo7k8Pz+BycYDYzHqfgCFjBoUi0Vi8USyXSTSRvkKJXKVUYNTqDRgaWZiLQYSJQA)

I don't like either of these that much, and I'll probably be using `z.templateLiteral()` after #1786 is merged, but the docs example should be updated with whatever method is recommended to avoid the error.",,
1591985431,2072,"Is there a way to deepPick, similar to deepPartial?","### Problem
I want to pick deeply nested properties.
In the example below, I want to get the validation schema for the school name property, which is 2 levels deep from the initial ""person"" object. Using the method ```pick```, I can extract properties that are 1 level deep and I can get the ""school"" object. However, I cannot go deeper and get the properties of the school object. Is there another way to achieve this?

### Schema:
```ts
const person = z.object({
  name: z.string(),
  school: z.object({
    id: z.number(),
    name: z.string()
  })
});
```

### Desired solution
```ts
const justSchoolName = person.deepPick({
  school: {
    name: true
  }
});
```
",,
1590963851,2070,Built-in way to coerce null to undefined,"Right now I'm doing something like this:

```typescript
const coerceNullToUndefined = <Type>(value : Type | null | undefined) : Type | undefined => {
    return value === null ? undefined : value;
};

const apiResponseSchema = z.object({
    name: z.string().nullish().transform(coerceNullToUndefined)
});
```

That makes the resulting value a little more sane; I don't have to worry about dealing with both null and undefined.

It would be awesome if it was possible to have a built-in way to do this, like:

```typescript
const apiResponseSchema = z.object({
    name: z.string().nullish().coerceNullToUndefined()
});
```",,
1590775832,2065,"When `z.infer` a `Record` with `Brand` as a key, it becomes a Partial Record.","When `z.infer` a `Record` with `Brand` as a key, it becomes a Partial Record.

With defining a Record type normally:
```ts
import { z } from ""zod"";
const zodKey = z.string().brand(""zodKey"");
type ZodKey = z.infer<typeof zodKey>;

type ZodRecord = Record<ZodKey, number>;
// type ZodRecord = {
//   [x: string & z.BRAND<""zodKey"">]: number;
// }
```

With defining a Record type with `z.infer`:
```ts
import { z } from ""zod"";
const zodKey = z.string().brand(""zodKey"");
const zodRecord = z.record(zodKey, z.number());

type ZodRecord = z.infer<typeof zodRecord>;
// type ZodRecord = {
//   [x: string & z.BRAND<""zodKey"">]: number | undefined;
// }
```

It has `undefined`.",,
1590744625,2064,Partial from intersection,"Hi, how to make omit, partial, etc in zod intersection object?

[here the playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgLABQlA9NXACoAWwAznK3CAJ5wDGAhiwCmAGjgB1Rv3hCAjgFdgAN34AbIQDt4MCHBjMWAfkowuYIXACSxOAF5E7YgC44LGFGAaA5ugDcJswsAYXk3XCEoOysbADIHDX4QIRc3D28-APM4AAV+WGA1ELCkyPtc-LUAHiKdEoA+fyoKXggNN0cAZV5GIRB+KOQAOggAIwArIV4YAAokYGcUQdTPL2mASnQ1yha2+F5Q2oiunr6o+ePe-kH+DWJpodGJqdm4BKSXIeXvdc2t5tb2mA8jACqoauEoBdTvZ9sUjt1LoMgRVVD9aHoDHAvBAZFAcFAaHQ4MSSaSyeSKZTyQA9YxNQlwABC8hgYmA8AA7tAANbsTBwVTAbkWfSsTLBA4QgBMUTmCy+Xl8r0SyVc7hWGQopiy5RBhUlJRlZWBoOqBoiUrqlG2APg5wRfSNi0ekxmco+S3V3zWYjeqs+XtWGzQfx2gJN+rhkId-Cd9pOsaREdRf2tWsCEhw3nBJQGg08mAilW1Qgg-ORerB5ujCatFHRxNp4rgQWgUFdOYieYLRZLZbgFdBnZrl0tcHRTA4HA5UjtryEQmIYhGLPYGk4PAEwis88Xa5gEWEU2ArTgahYEAZjcMQA)",,
1590642947,2062,Strict by default or strict deep,"Hi, I would like to either have strict on all of my types or something like `.deepStrict()` that propagates down on all sub objects in my schema. Now it's too easy to miss out on defining a schema as strict I think.",,
1590525150,2061,"Unexpected ""Invalid literal value"" error in z.union()","Hi, First of all, thank you for creating very useful validation library.
I've faced wired(?) behavior while using z.union().
Is this bug? or if this is expected behavior how can I avoid it to show wrong errors?

# Problem
zod shows invalid literal value though it has correct value.

# Reproduction Repo
I've made a simple reproduction repo [here](https://github.com/tomohirohiratsuka/zod-union-debug)

# Reproduction Step
In the reproduction repo above...

```terminal
npm i 
```

```terminal
npm run dev
```
 1. Open [http://localhost:3000](http://localhost:3000).
 2. Click submit.
 3. It shows Invalid URL error as expected.
 4. Select ""Designer"" in Job select box.
 5. It shows, Invalid literal value, expected ""engineer""

<img width=""288"" alt=""ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ 2023-02-19 10 30 10"" src=""https://user-images.githubusercontent.com/32760882/219907250-7bd9169f-8173-40be-ba15-73adc61d1afc.png"">
<img width=""229"" alt=""ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ 2023-02-19 10 30 26"" src=""https://user-images.githubusercontent.com/32760882/219907257-d5a4b092-6095-4643-aea1-0cce1f11e4d0.png"">
<img width=""345"" alt=""ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ 2023-02-19 10 30 44"" src=""https://user-images.githubusercontent.com/32760882/219907260-40430039-a70b-4529-9173-ffda8fbf7523.png"">

# Schema
```typescript
const developmentLanguageSchema = z.union([z.literal('typescript'), z.literal('go'), z.literal('rust')])
const toolSchema = z.union([z.literal('Adobe XD'), z.literal('Figma'), z.literal('Sketch')])
const schema = z.union([
    z.object({
        job: z.literal('engineer'),
        language: developmentLanguageSchema,
        graduate: z.literal('bachelor'),
    }),
    z.object({
        job: z.literal('engineer'),
        language: developmentLanguageSchema,
        graduate: z.literal('master'),
        url: z.string().url()
    }),
    z.object({
        job: z.literal('designer'),
        tool: toolSchema,
        graduate: z.literal('bachelor'),
    }),
    z.object({
        job: z.literal('designer'),
        tool: toolSchema,
        graduate: z.literal('master'),
        url: z.string().url()
    })
])
```",,
1590517989,2060,Lazy Parsing (Feature request),"This is something I've often felt would be useful in zod.

### Use case

- I'm calling an external api
- I want to parse the data I get back, to ensure nothing unexpected happens when I consume the data
- Certain properties I need 100% of the time, others I only need in special cases.

### Example

Here's a contrived example:

```typescript
const productSchema = z.object({
  id: z.string(),
  name: z.string(),
  isAvailableInBlue: z.boolean()
});

const offerProduct = async () => {
    const res = await fetch('https://some-api/product');
    const json = await res.json();
    const product = productSchema.parse(json);
    
    if (customerRequestedProductInBlue()) {
        if (!product.isAvailableInBlue) {
          console.log(`Sorry, ${ product.name } is not available in blue`);
          return;
        }
    }
    
    console.log(`Would you like a ${ product.name } today?`)
}
```

In this case:
- I need to be 100% sure `product.name` is present, and is a string
- I only care about `product.isAvailableInBlue` if the customer actually requested a blue product

So far so good. But let's say the api maintainer changes `isAvailableInBlue` to be an integer `0` or `1` -- which is obviously a backwards-incompatible change, but that happens.

Now: my code will error out 100% of the time when I call `productSchema.parse(json)`

### The problem

In cases like this, where I have no control over the external API, obviously it's annoying when a type changes like this, and I want my code to fail rather than assuming `product.isAvailableInBlue` is a boolean.

BUT, ideally I'd like it to only fail at runtime when I try to access `product.isAvailableInBlue`. That way so long as the customer is not requesting a blue product, my code will continue to run.

That way, I still have a bug I need to go fix, but the damage is much more minimal than `productSchema.parse(json)` failing 100% of the time. Most of my customers can still complete a checkout.

### A proposed solution

What I'd love to see is something like `productSchema.lazyParse()`:

```typescript
const productSchema = z.object({
  id: z.string(),
  name: z.string(),
  isAvailableInBlue: z.boolean()
});

const offerProduct = async () => {
    const res = await fetch('https://some-api/product');
    const json = await res.json();
    const product = productSchema.lazyParse(json);
    
    if (customerRequestedProductInBlue()) {
        if (!product.isAvailableInBlue) {
          console.log(`Sorry, ${ product.name } is not available in blue`);
          return;
        }
    }
    
    console.log(`Would you like a ${ product.name } today?`)
}
```

In this model, zod will only parse the top-level `product` object to make sure it has the right shape, but it will not validate any specific value types until I actually access the property and try to use it at runtime.

This change means I get the best of both worlds: my code keeps working when it's possible to keep working, and fails with an obvious type-error when I try to access a property which could not be parsed.

Obviously this doesn't make sense to do all the time; for example if I'm parsing an api request to my own api server, I want to be able to parse it all in one go and return a 4xx error if something is incorrect. But when I'm consuming data from an external source like this, it's often helpful to only error out at the point where my code definitely can not continue to run safely.

Thoughts on this?",,
1590494802,2059,Support IP address validation,"I have been adding email validation with ip address, I can make IP validation a build-in feature.
The result is like:
```js
z.string().ip({ version: ""v4"" });
```
or
```js
z.string().ipv4();
z.string().ipv6();
```",,
1590298092,2056,It looks like `.refine()` removes `.shape`,"Here's my example:

```typescript
const fooSchema = z.object({foo: z.string()})
type Foo = z.infer<typeof fooSchema.shape.foo>
const barSchema = z.object({bar: z.string()}).refine(({bar}) => bar.length > 0)
type Bar = z.infer<typeof barSchema.shape.bar>
```

In this case, `barSchema.shape` TypeScript complains:

```
Property 'shape' does not exist on type 'ZodEffects<ZodObject<{ bar: ZodString; }, ""strip"", ZodTypeAny, { bar: string; }, { bar: string; }>, { bar: string; }, { bar: string; }>'.ts(2339)
```

Is this intended behaviour? Or maybe I'm using `.refine()` incorrectly?

Thanks a lot for zod, I've been a loyal fan for many years and the project has only continued to improve. It's a real treat to define schemas once and use them for both types and at runtime. ðŸ§¡ ",,
1589528693,2052,.omit() inoperative with .passthrough(),"`.omit()` doesn't do anything when using `.passthrough()`: the omitted keys are still there.

```ts
import { z } from 'zod'; // zod@3.20.6

// Our schema, just two known keys `a` and `b`
const schema = z.object({ a: z.number(), b: z.number() });

// We want to omit `b`, but preserve unknown keys
// No luck here: we get { a: 1, b: 2, x: 654 }
console.log(schema.omit({ b: true }).passthrough().parse({ a: 1, b: 2, x: 654 }));

// Still not what we want: { a: 1, b: 2, y: 286 }
console.log(schema.passthrough().omit({ b: true }).parse({ a: 1, b: 2, y: 286 }));

// Workaround for expected result: { a: 1, z: 123 }
console.log(schema.passthrough().transform(({ b, ...res }) => res).parse({ a: 1, b: 2, z: 123 }));
```

Am I doing something wrong? Am I not supposed to chain those two methods?

I understood that `.passthrough()` would just pass unknown keys, not omitted ones:
> https://www.npmjs.com/package/zod#passthrough
> By default Zod object schemas strip out unrecognized keys during parsing.
> Instead, if you want to pass through unknown keys, use `.passthrough()`.",,
1589162451,2051,using required() on an object with a nullish() attribute breaks validation and typing,"Please take a look at this code sample:
```typescript
const testCase = z
  .object({
    attributeOne: z.string(),
    attributeTwo: z.string().nullish(),
  })
  .required();

const test = testCase.parse({ attributeOne: ""Test"" });
```
`testCase.parse({ attributeOne: ""Test"" })` does not throw an error, even though I would expect it to because of the `required()` function.

These two code samples do however throw the expected error:
```typescript
const testCase = z
  .object({
    attributeOne: z.string(),
    attributeTwo: z.string().optional(),
  })
  .required();

const test = testCase.parse({ attributeOne: ""Test"" });
```
```typescript
const testCase = z
  .object({
    attributeOne: z.string(),
    attributeTwo: z.string().nullable(),
  })
  .required();

const test = testCase.parse({ attributeOne: ""Test"" });
```

Using `.optional().nullable()` in place of `.nullish()` also does not produce the expected error.

This not only breaks the validation logic of `.parse()` and `.safeParse()`, the resulting type is also incorrect.
The type of `test` in my first code sample is
```typescript
{
  attributeOne: string;
  attributeTwo: string |Â null;
}
```
even though `attributeTwo` is `undefined`.

Is this the correct behaviour?
 ",,
1588000390,2047,`.catch()` removed `undefined` from output type,"```ts
const schema = z.object( {
    foo: z.string().nullish(),
    bar: z.string().nullish().catch( undefined ),
} )
type Data = z.output<typeof schema>
// type Data = {
//     foo?: string | null | undefined
//     bar: string | null // should allow undefined
// }

console.log( schema.parse( { foo: 'foo', bar: 42 } ) )
// { foo: 'foo', bar: undefined }
```",,
1586485059,2040,shortcut for literals in objects?,"To write 
```
const Schema = z.object({
    name: ""mia""
})
```

instead of 
```
const Schema = z.object({
    name: z.literal(""mia"")
})
```",,
1583045314,2036,Many methods have massive compiler performance drawbacks,"I spent much of last week investigating why my work's codebase was taking 2-3 seconds to populate autocomplete or refresh code-intelligence during code changes, and after a lot of tsc tracing and replacing Zod types with `any`, I found that basically the entire time is being taken up processing Zod types - specifically those using masking (Extend, Omit, Pick) methods.

After removing all uses of masking and dropping back to Zod 3.19 on the suggestion of some comments in the issues, the codebase is now down to 1.5 seconds for autocomplete which is still a lot of time.

I've written this up in a little more detail [here](https://dev.to/nicklucas/typescript-runtime-validators-and-dx-a-type-checking-performance-analysis-of-zodsuperstructyuptypebox-5416) and have a small-scale reproduction [here](https://github.com/Nick-Lucas/gapstack/tree/main/packages/light-type-benchmarks) which was used in the benchmarks.

Eventually I do plan on a more in-depth benchmarking across a larger variety of methods, as these benchmarks are a somewhat blunt instrument, but it would be great to see type inference performance improved across the board as Zod is lagging behind the competition even in the most basic situations.",,
1580771916,2026,Zod schema serialize/deserialize,"How can I serialise/deserialize zod schema?

So that I can store it in database for example as a string and reuse later when needed.",,
1580684208,2025,Support validation of relative URLs,"Using a schema of
`urlLocal: z.string().url().optional(),`

will fail validation for a relative URL such as
`/blog/blog-post-1/`

I see this in the [Zod source code](https://github.com/colinhacks/zod/blob/master/src/types.ts#L686):

```ts
} else if (check.kind === ""url"") {
  try {
    new URL(input.data);
  } catch {
```

So without a `base` parameter `URL()` will throw an exception for relative urls. The [URL()](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL) documentation explains:

> If `url` is a relative URL, `base` is required, and will be used as the base URL. 
> 
> TypeError | `url`Â (in the case of absolute URLs) orÂ `baseÂ +Â url`Â (in the case of relative URLs) is not a valid URL.


I'm able to work around this issue using custom validation logic via refinements:

`urlLocal: z.string().refine((val) => new URL(val, 'http://localhost')).optional(),`

But maybe this should be built-in?",,
1580640149,2024,Invalid Url when validating a MSSQLServer connection string,"I'm using zod with the t3 stack. 

The server runs the following validation on schemas.
```ts
export const serverSchema = z.object({
  DATABASE_URL: z.string().url(),
  NODE_ENV: z.enum([""development"", ""test"", ""production""]),
  NEXTAUTH_SECRET:
    process.env.NODE_ENV === ""production""
      ? z.string().min(1)
      : z.string().min(1).optional(),
  NEXTAUTH_URL: z.preprocess(
    // This makes Vercel deployments not fail if you don't set NEXTAUTH_URL
    // Since NextAuth.js automatically uses the VERCEL_URL if present.
    (str) => process.env.VERCEL_URL ?? str,
    // VERCEL_URL doesn't include `https` so it cant be validated as a URL
    process.env.VERCEL ? z.string() : z.string().url(),
  ),
  CLIENT_ID: z.string(),
});
```

My database url looks like the following:
```ts
DATABASE_URL=""sqlserver://localhost:1433;initialCatalog={MyDatabase};integratedSecurity=true;trustServerCertificate=true;""
```

This is the error that's occurring: 
âŒ Invalid environment variables:
 DATABASE_URL: Invalid url

I see the code is using the new URL constructor and when I plug it in to dev tools, I get the following which may cause the error:
![image](https://user-images.githubusercontent.com/17712276/218238469-a5eaa744-3f84-4bf9-9155-2d34f2e2e009.png)

Is this intentional and should I be using some other form of validation or is this a bug?

Thank you",,
1579549682,2021,Denoland release stuck at 3.20.5,For some reason the 3.20.6 release has failed to publish to Denoland. The latest release is at 3.20.5: https://deno.land/x/zod@v3.20.5,,
1578535256,2020,Unable to pass a zod schema to a function and have it be typed correctly by typescript,"Suppose I have a function that accepts a zod schema and runs the parse function on some data like:

```typescript
import { z, ZodTypeAny } from 'zod'

type Opts<Z extends ZodTypeAny> = {
  // ...other db opts
  schema: Z
}
export const findOne<T = any, Z extends ZodTypeAny = never> = async (opts: Opts<Z>) => {
  // ...logic to read db

  const item = await dbQuery()

  if (!item) return
  if (opts.schema) return schema.parse(item)
  return item as T
}

const User = z.object({
  id: z.string(),
  username: z.string(),
  createdAt: z.string()
})

// expect user to be of type `typeof User`
const user = await findOne({ /** opts */, schema: User })
```
I would expect all zod schemas to extend the `ZodTypeAny` type, but I get the error `Property 'received' is missing in type 'ZodInvalidLiteralIssue & { fatal?: boolean | undefined; message: string; }' but required in type 'ZodInvalidLiteralIssue'.` when I pass the `User` schema into the function.
",,
1577907406,2017,All members in every type of a discriminated union are optional,"```typescript
const myUnion = z.discriminatedUnion(""status"", [
  z.object({ status: z.literal(""success""), data: z.string() }),
  z.object({ status: z.literal(""failed""), error: z.instanceof(Error) }),
]);


type myUnion = z.infer<typeof myUnion>
// This evaluates to
type myUnion = {
    status?: ""success"";
// ****** ^ - all members are optional
    data?: string;
} | {
    status?: ""failed"";
    error?: Error;
}
```

Tried explicitly forcing the members to be required results in the same type (i.e., all members for each discriminated union type are optional)

```typescript
const myOtherUnion = z.discriminatedUnion(""status"", [
  z.object({
    status: z.literal(""success""), data: z.string()
  }).required(),
//  ^ this doesn't seem to make any difference in the output type
  z.object({ status: z.literal(""failed""), error: z.instanceof(Error) }).required(),
]);

type myOtherUnion = z.infer<typeof myOtherUnion>
// This evaluates to the same type as before
type myOtherUnion = {
    status?: ""success"";
    data?: string;
} | {
    status?: ""failed"";
    error?: Error;
}
```

This is a major issue when trying to fold the discriminated union using ts-adt `match` as it expects the discriminant to be required (not optional). If there's a better way to work with the resulting discriminated union, please share.

Thanks",,
1577291450,2016,[BUG] `extend()` remove the '?' from optional type after upgrading 3.20.3 -> 3.20.4/3.20.5,"[Playground](https://www.typescriptlang.org/play?ts=4.9.5#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgFBkDGEAdgM7wCudAplHALwoB0EARgCsWlGAAoEwYgC4eNRiD5tRASgA0cGgEMQLGcm4MowGgHMVvMDGC1NAGxVplZOHG4sAHjBY1i4miwB3AGkWAE89bj4ICFsWTRpzCEtrLXtlRwoYULAWOABVVnYufWNMNgAeLJyITDhmNgA+CgB6ZrgANzY6FJkAZm4AJgAGbgAWOGg4fuHuAFYyKtyCtgB9SkYoKG8YFc6obtpORGcXSRk5BTYAbjgTjW1dOENjEzgAHzqfFkxjFmIbuCtODlAC0BAA-Pg4FsQBBOsQ4HxQgQPF4fCpyC4NIEQuFEdFYvF3p9iN9fv9AW1QRCoTC4X9Ecj8KjvL5lOQ0C02nsDjQ+oMRr0FtkloUVmAtu1rMxdl0UkcEHczhp5IooDc7lodOCZM9TMTGF8fv4KZqcWEdfiYnEaAajeSrmQ0EA)

```typescript
import { z } from 'zod'

const user = z.object({id: z.number(), name: z.string().optional()})
  .extend({newKey: z.boolean().optional()})

type User = z.infer<typeof user>

// version: 3.20.4 or 3.20.5
type User_current_version = {
   id: number; 
   name: string | undefined;  // <- '?' removed by 'extend()'
   newKey: boolean | undefined; // <- '?' removed by 'extend()'
}

// version: 3.20.3
type User_previous_version = {
   id: number; 
   name?: string | undefined; 
   newKey?: boolean | undefined;
}
```
",,
1576629723,2014,Allow superRefine to use async callback,"I have a use case in which I need to run asynchronous code with `await` inside of the superRefine callback, but it fails typesafety since this function cannot be asynchronous. Is it possible to switch this so that `async` functions are allowed?
Example:
```ts
const CreateUserSchema = z
  .object({
    username: z.string(),
    email: z
      .string()
      .email(""Enter a real email please."")
      .optional(),
    name: z.string().optional(),
    password: z
      .string()
      .min(1, ""Please enter a password."")
      .min(8, ""Password must be at least 8 characters.""),
    roles: z.string(),
  })
  .superRefine(async (values, ctx) => {
    const user = await getUser(values)
    if (user.user !== null) {
      ctx.addIssue({
        code: ""custom"",
        message: ""Username already taken."",
        path: [""username""],
      });
    }
  }
```",,
1575925157,2012,ZodObject second generic arg is required after upgrading 3.20.2 -> 3.20.3,"Hi, after upgrading from `3.20.2` to `3.20.3`, my code is broken, because `ZodObject` now requires at least 2 generic params, eg
```
ERROR in ./apps/api/src/app/utils/misc.ts:81:5
TS2707: Generic type 'ZodObject<T, UnknownKeys, Catchall, Output, Input>' requires between 2 and 5 type arguments.
    79 |   prefix?: P,
    80 | ): P extends ''
  > 81 |   ? z.ZodObject<T> | z.ZodObject<{ [key in keyof T]: z.ZodNull }>
       |     ^^^^^^^^^^^^^^
    82 |   :
    83 |       | z.ZodObject<CapitalizeAndPrefixProps<T, P>>
    84 |       | z.ZodObject<{
```
If this change was intended could someone help me fixing the code?
```typescript
export function outerJoinSchema<T extends z.ZodRawShape, P extends string = ''>(
  shape: T,
  prefix?: P,
): P extends ''
  ? z.ZodObject<T> | z.ZodObject<{ [key in keyof T]: z.ZodNull }>
  :
      | z.ZodObject<CapitalizeAndPrefixProps<T, P>>
      | z.ZodObject<{
          [key in keyof CapitalizeAndPrefixProps<T, P>]: z.ZodNull;
        }> {
  const prefixedSchema = prefix
    ? prefixPropsSchema(capitalizePropsSchema(shape).shape, prefix)
    : z.object(shape);
  const nullSchema = Object.keys(prefixedSchema.shape).reduce(
    (result, key) => {
      result[key] = z.null();
      return result;
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    {} as any,
  ) as z.ZodObject<{ [key in keyof typeof prefixedSchema.shape]: z.ZodNull }>;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return z.union([prefixedSchema, nullSchema]) as any;
}
```
The function takes zod shape and generates a union of the original shape and same shape where all props are null. Optionally the props are prefixed. Eg:
`outerJoinSchema({ foo: z.string() }, 'prefix')` 
=>
```ts
z.union([
  z.object({ prefixFoo: z.string() }),
  z.object({ prefixFoo: z.null() }),
])
```
Originally it was supposed to take schema instead of shape, but I couldn't make it work type-wise.",,
1575873229,2011,type error,"in type.d.ts file, Some type errors occur hereï¼š Writeable<FilterEnum<T, ToExclude[number]>>
version: '3.20.3'
![image](https://user-images.githubusercontent.com/44263381/217505000-f6dd7310-410f-40e9-b1e7-5e3b02490d09.png)
",,
1575696878,2010,Support some type-specific validations at top level,"```js
z.number().int(); // value must be an integer
```

No other type supports `int` validation.  Consider supporting the concise

```js
z.int(); // value must be an integer
```",,
1575163360,2008,"Creating a recursive, generic schema gives a type error","Consider the following code (which is in my knowledge correct):
```ts
import { z } from ""zod"";

const ASchema = z.object({
  foo: z.string(),
});

type NestedSchema<T> = {
  item: T;
  children: NestedSchema<T>[];
};

const createNestedSchema = <T>(schema: z.Schema<T>) => {
  const b: z.ZodType<NestedSchema<T>> = z.lazy(() =>
    z.object({
      item: schema,
      children: createNestedSchema(schema).array(),
    })
  );

  return b;
};

const b = createNestedSchema(ASchema);

type B = z.infer<typeof b>;
```

However, the code above fails with a type error here:
```ts
const b: z.ZodType<NestedSchema<T>> = z.lazy(() =>
```

With the error:
```
Type 'ZodLazy<ZodObject<{ item: ZodType<T, ZodTypeDef, T>; children: ZodArray<ZodType<NestedSchema<T>, ZodTypeDef, NestedSchema<T>>, ""many"">; }, ""strip"", ZodTypeAny, { [k_1 in keyof addQuestionMarks<{ item: T; children: NestedSchema<T>[]; }>]: addQuestionMarks<{ item: T; children: NestedSchema<T>[]; }>[k_1]; }, { [k_3 in keyof addQuestionMarks<{ item: T; children: NestedSchema<T>[]; }>]: addQuestionMarks<{ item: T; children: NestedSchema<T>[]; }>[k_3]; }>>' is not assignable to type 'ZodType<NestedSchema<T>, ZodTypeDef, NestedSchema<T>>'.
  Types of property '_type' are incompatible.
    Property 'item' is missing in type '{ [k_1 in keyof addQuestionMarks<{ item: T; children: NestedSchema<T>[]; }>]: addQuestionMarks<{ item: T; children: NestedSchema<T>[]; }>[k_1]; }' but required in type 'NestedSchema<T>'
```

Am I doing something wrong or is this a bug?",,
1574873845,2005,Schema narrowing,"Hi,

I'm trying to define a base schema and have a function which takes in a narrowing schema and returns the parsed narrowed value.  Is this possible using this library?

```ts
import { z } from ""zod"";

const baseSchema = z.object({
  name: z.string(),
});

function getName<T extends z.infer<typeof baseSchema>>(
  schema: z.Schema<T>
): T[""name""] {
  const data = ""John"";

  // Error:
  // Element implicitly has an 'any' type because expression of type '""shape""' can't be used to index type 'ZodType<T, ZodTypeDef, T>'.
  // Property 'shape' does not exist on type 'ZodType<T, ZodTypeDef, T>'
  return schema[""shape""][""name""].parse(data);
}

const narrowedSchema = z.object({
  name: z.literal(""John""),
});

// Type of name should be 'John' instead of 'string'
const name = getName(narrowedSchema);
```",,
1574689740,2003,Access to the string email regex,"Could the string email [regex pattern](https://github.com/colinhacks/zod/blob/master/src/types.ts#L523) be exported?
Or accessed somehow by passing `zod.string().email()` as param?
### Motivation:
html input of `type=""email""` is more permissive than `zod email`, alloing for example `a@b`, which zod does not allow.

Html input has the `pattern` [attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/pattern).

We would like thus to be able to then pass the zod email regex pattern to the html pattern attribute, so then the browser can be in charge of not submitting the form if invalid, showing the appropriate error, etc. Otherwise, we have to call `onSubmit`, with `zod.SafeParse` and if not success manually set/show the error on the input.

Thank you.",,
1573582687,1998,Can there be better typescript inference for z.string().startsWith and endsWith?,"When using z.string().startsWith() or endsWith() the typescript inferred type is simply string. Can there instead be a way to convert strings that have startsWith or endsWith declarations to typescript interpolated literals?

If not, is there any way to control what typescript type zod will infer to?

![image](https://user-images.githubusercontent.com/49543791/217133560-e2c027bd-12ee-4543-aacb-7044e57f4df9.png)
",,
1572979469,1996,Coerce makes the schema 'nullable' by default,"## Description
[Description of the issue, including context and why it's a problem]
When using coercion for any value, the resulting schema is nullable by default. This is a problem because I couldn't find a way to revert the 'nullable' status.

## Steps to Reproduce
1. Create a schema using the `coerce` attribute, like `const stringSchema = z.coerce.string()`

## Expected Behavior
`stringSchema.isNullable() === false`

## Actual Behavior
`stringSchema.isNullable() === true`

## Additional Information
Here is a [demo](https://codesandbox.io/s/zod-demo-forked-ymootx?file=/src/index.ts) to demonstrate the issue",,
1572206531,1992,Ability to provide warnings,"I'm very much unsure if this belongs in zod - probably not - but I'm similarly unsure of how to approach this. 

I'd like to validate with zod but also provide warnings or hints to users in certain situations.

```typescript
const MyNumberSchema = z.number().min(0).max(1)
const MyNumberWarningSchema = z.number().min(0).max(0.1)

const MyNumberWithWarning = MyNumberSchema.warn(MyNumberWarningSchema)
```

I can imagine `.warn()` taking a normal zod schema, but handling it differently:
- If a value is *valid* when parsed against the warning schema, it generates a warning
- Warnings are nearly identical to errors in how they work, except `warning` is used instead of `error` in the types and objects generated.

The only way I can think of to do this now is to generate a second ""inverse"" schema, then change the error messages to be more warning-like. 

Thoughts? ",,
1571557017,1990,Extended use of .extend and .merge cause TS instantiation failures,"I'm creating a migration tool for versioned data from a backend service, and I'm using Zod for both compile- and run-time type checks. My hope was to be able to express the types changing over time with `.extend` (eg. `const v2Type = v1Type.extend({ ... })`) so that it was more concise and consumable, but it quickly hits the ""Type instantiation is excessively deep and possibly infinite.(2589)"" error. (Probably related, https://github.com/colinhacks/zod/issues/1879)

The following are greatly simplified examples â€” in the actual use-case, I have schema factory functions and many properties defined on each version. But even with no properties defined, both `.extend` and `.merge` fail at the 15th version.

[Typescript Play for `.extend`](https://www.typescriptlang.org/play?ts=4.9.5#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgFBkDGEAdgM7wAqAnmAKYCMcAvCgHQQARgCs2lGAAoEaAJRkANm3gw2DDgC5+wGpjZQAPDFZsImOC3YcAfBWr0mxgEw9zxjnzYAPFTWJTZCkpwKgyOmsh82roGRuymruyONlS0DAlsAMwuFmyOHt5svv5yisqqMBnhkTp6hsbxORnJdmk5ACzZxhn5Pn7SJUEhMG1VUbWxJmbtzakO7ACsnextPYV9AaXB5fOjNTH1U8bzM-bpAGxLbPOrRf2BZQxnu9F1cYfsZyetxgDsl2c3dYDB4wH7PcYHdI-L5zNgADkuP0BxXuWwYcPB+ze6ThMPSAE5LnDkXdNkN8ZjXpMCXichwAAyXfEkjaDcoMykTBpuem0txcXh0+ks4FomAcDRaPZU7mWay2WbpDjOQX8kWoobKzmQulJBWnOlZVWWPJeXoosnsypSl5c96cJr676WDrGh3qy1qEY2iHYultPmWRZujgrM1rC1stQ7H1Y6l045AA)
[Typescript Play for `.merge`](https://www.typescriptlang.org/play?ts=4.9.5#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgFBkDGEAdgM7wAqAnmAKYCMcAvCgHQQARgCs2lGAAoEaAJRkANm3gw2DDgC5+wGpjZQAPDFZsImOC3YcAfBWr0mxgEw9zxjnxB6A5mwnIBImKS0jJyisqqMI6a-tq6Bkbspq7sjjZUtAwpbADMLhZsjh7evv5CouJSsmFKcCoMOTF8cXqGxskFOel2WQUALPnGOcVQPn4BFcHVCrX1MH1NLQntZv3dmQ7sAKyD7H0jY2WBlSE1EQxbizqtiSarxlvr9tkAbLtsWwelE0FVoTPnGAvK7xNpJe7sF5PXrGADs7xeX3G5V+pwBdUisJBNxW2Vh0M2bAAHO9YUijpM-mcMQwidjluDskSCdkAJzvInkn4nabhGkwVn0sF3NksgocAAM71ZXJRPP+fLmkqFtw6bglYrcXF44olsuOUwVs0iHA0WmuDJF4ustg22Q4zh1Wv1lLRipN0XNoNVEM4aVtz3FeSdliKnlG3zlhupSsaXpxjKDmssAxDnGG4cO3Oj6KVC3jlrVKeTnB2aY4+0zkYNVNzJsuBeFRdLViAA)

Any suggestions for workarounds or alternatives are greatly appreciated â€” I've started looking into the source, but I wanted to reach out before digging too deep.",,
1570888140,1986,TSC generates wrong typedefs from zod ,"The other day I needed to use a zod schema which defined either all of the properties in an object or none of them. Basically something like 
```ts
const ExampleSchema = z.object(
  { openingHours: z.date(), closingHours: z.date() }
);
type Example = z.infer<typeof ExampleSchema>;

// we want this to be correct
const example: Example = { 
    openingHours: new Date(),
    closingHours: new Date(),
};

// we want this to be correct
const example: Example = {};

// we want this to be incorrect
const example: Example = { 
    closingHours: new Date(),
};
```
Just creating a schema like that was not enough for me, so I jumped ahead and created a factory that generates such schemas based on the object with required properties. The code turned out to be pretty short and easy, the type definitions were correct, I was happy.

```ts
export function defineAllOrNothingSchema<T extends Record<string, ZodType>>(
  objectWithAllProperties: T
) {
  const allProperties = z.object(objectWithAllProperties);
  const objectWithNoneOfTheProperties = Object.keys(
    objectWithAllProperties
  ).reduce(
    (prev, key) => ({ ...prev, [key]: z.undefined() }),
    {} as {
      [Key in keyof T]: z.ZodUndefined;
    }
  );
  const noneOfTheProperties = z.object(objectWithNoneOfTheProperties);

  return allProperties.or(noneOfTheProperties);
}

const ExampleSchema = defineAllOrNothingSchema(
  { openingHours: z.date(), closingHours: z.date() }
);

type Example = z.infer<typeof ExampleSchema>;

// correct
const example: Example = { 
    openingHours: new Date(),
    closingHours: new Date(),
};

// correct
const example: Example = {};

// incorrect
const example: Example = { 
    closingHours: new Date(),
};
```  

The problem comes when I tried to compile it with `tsc`.  
<details><summary><b>tsconfig.json</b></summary>

```json
{
  ""include"": [""./define-all-or-nothing-schema.ts""],
  ""compilerOptions"": {
    ""noUncheckedIndexedAccess"": true,
    ""allowSyntheticDefaultImports"": true,
    ""esModuleInterop"": true,
    ""forceConsistentCasingInFileNames"": true,
    ""moduleResolution"": ""node"",
    ""noFallthroughCasesInSwitch"": true,
    ""noImplicitAny"": true,
    ""noImplicitReturns"": true,
    ""noUnusedLocals"": false,
    ""noUnusedParameters"": false,
    ""strict"": true,
    ""target"": ""es2021"",
    ""sourceMap"": false,
    ""lib"": [""es2017""],
    ""removeComments"": false,
    ""composite"": true,
    ""incremental"": true,
    ""module"": ""commonjs"",
    ""declaration"": true,
    ""outDir"": ""./lib/cjs"",
    ""declarationDir"": ""./lib/typedefs/""
  },
}
```

</details>

 `lib/typedefs/define-all-or-nothing-schema.d.ts`

```ts
import { z, ZodType } from ""zod"";
export declare function defineAllOrNothingSchema<
  T extends Record<string, ZodType>
>(
  objectWithAllProperties: T
): z.ZodUnion<
  [
    z.ZodObject<
      T,
      ""strip"",
      z.ZodTypeAny,
      z.objectUtil.addQuestionMarks<{
        [k_2 in keyof T]: T[k_2][""_output""];
      }> extends infer T_1
        ? {
            [k_1 in keyof T_1]: z.objectUtil.addQuestionMarks<{
              [k in keyof T]: T[k][""_output""];
            }>[k_1];
          }
        : never,
      z.objectUtil.addQuestionMarks<{
        [k_2_1 in keyof T]: T[k_2_1][""_input""];
      }> extends infer T_2
        ? {
            [k_3 in keyof T_2]: z.objectUtil.addQuestionMarks<{
              [k_2 in keyof T]: T[k_2][""_input""];
            }>[k_3];
          }
        : never
    >,
    z.ZodObject<
      { [Key in keyof T]: z.ZodUndefined },
      ""strip"",
      z.ZodTypeAny,
      z.objectUtil.addQuestionMarks<
        {
          [Key in keyof T]: z.ZodUndefined;
        } extends infer T_5 extends z.ZodRawShape
          ? {
              [k_5 in keyof T_5]: {
                [Key in keyof T]: z.ZodUndefined;
              }[k_5][""_output""];
            }
          : never
      > extends infer T_3
        ? {
            [k_1_1 in keyof T_3]: z.objectUtil.addQuestionMarks<
              {
                [Key in keyof T]: z.ZodUndefined;
              } extends infer T_4 extends z.ZodRawShape
                ? {
                    [k_4 in keyof T_4]: {
                      [Key in keyof T]: z.ZodUndefined;
                    }[k_4][""_output""];
                  }
                : never
            >[k_1_1];
          }
        : never,
      z.objectUtil.addQuestionMarks<
        {
          [Key in keyof T]: z.ZodUndefined;
        } extends infer T_8 extends z.ZodRawShape
          ? {
              [k_2_3 in keyof T_8]: {
                [Key in keyof T]: z.ZodUndefined;
              }[k_2_3][""_input""];
            }
          : never
      > extends infer T_6
        ? {
            [k_3_1 in keyof T_6]: z.objectUtil.addQuestionMarks<
              {
                [Key in keyof T]: z.ZodUndefined;
              } extends infer T_7 extends z.ZodRawShape
                ? {
                    [k_2_2 in keyof T_7]: {
                      [Key in keyof T]: z.ZodUndefined;
                    }[k_2_2][""_input""];
                  }
                : never
            >[k_3_1];
          }
        : never
    >
  ]
>;
export declare function defineSchemaWithRequiredTuplesOfProperties<
  T extends Record<string, ZodType>,
  U extends Record<string, ZodType>
>(
  allOrNothingProperties: T,
  otherProperties: U
): z.ZodIntersection<
  z.ZodObject<
    U,
    ""strip"",
    z.ZodTypeAny,
    z.objectUtil.addQuestionMarks<{
      [k_2 in keyof U]: U[k_2][""_output""];
    }> extends infer T_1
      ? {
          [k_1 in keyof T_1]: z.objectUtil.addQuestionMarks<{
            [k in keyof U]: U[k][""_output""];
          }>[k_1];
        }
      : never,
    z.objectUtil.addQuestionMarks<{
      [k_2_1 in keyof U]: U[k_2_1][""_input""];
    }> extends infer T_2
      ? {
          [k_3 in keyof T_2]: z.objectUtil.addQuestionMarks<{
            [k_2 in keyof U]: U[k_2][""_input""];
          }>[k_3];
        }
      : never
  >,
  z.ZodUnion<
    [
      z.ZodObject<
        T,
        ""strip"",
        z.ZodTypeAny,
        z.objectUtil.addQuestionMarks<{
          [k_5 in keyof T]: T[k_5][""_output""];
        }> extends infer T_3
          ? {
              [k_1_1 in keyof T_3]: z.objectUtil.addQuestionMarks<{
                [k_4 in keyof T]: T[k_4][""_output""];
              }>[k_1_1];
            }
          : never,
        z.objectUtil.addQuestionMarks<{
          [k_2_3 in keyof T]: T[k_2_3][""_input""];
        }> extends infer T_4
          ? {
              [k_3_1 in keyof T_4]: z.objectUtil.addQuestionMarks<{
                [k_2_2 in keyof T]: T[k_2_2][""_input""];
              }>[k_3_1];
            }
          : never
      >,
      z.ZodObject<
        { [Key in keyof T]: z.ZodUndefined },
        ""strip"",
        z.ZodTypeAny,
        z.objectUtil.addQuestionMarks<
          {
            [Key in keyof T]: z.ZodUndefined;
          } extends infer T_7 extends z.ZodRawShape
            ? {
                [k_7 in keyof T_7]: {
                  [Key in keyof T]: z.ZodUndefined;
                }[k_7][""_output""];
              }
            : never
        > extends infer T_5
          ? {
              [k_1_2 in keyof T_5]: z.objectUtil.addQuestionMarks<
                {
                  [Key in keyof T]: z.ZodUndefined;
                } extends infer T_6 extends z.ZodRawShape
                  ? {
                      [k_6 in keyof T_6]: {
                        [Key in keyof T]: z.ZodUndefined;
                      }[k_6][""_output""];
                    }
                  : never
              >[k_1_2];
            }
          : never,
        z.objectUtil.addQuestionMarks<
          {
            [Key in keyof T]: z.ZodUndefined;
          } extends infer T_10 extends z.ZodRawShape
            ? {
                [k_2_5 in keyof T_10]: {
                  [Key in keyof T]: z.ZodUndefined;
                }[k_2_5][""_input""];
              }
            : never
        > extends infer T_8
          ? {
              [k_3_2 in keyof T_8]: z.objectUtil.addQuestionMarks<
                {
                  [Key in keyof T]: z.ZodUndefined;
                } extends infer T_9 extends z.ZodRawShape
                  ? {
                      [k_2_4 in keyof T_9]: {
                        [Key in keyof T]: z.ZodUndefined;
                      }[k_2_4][""_input""];
                    }
                  : never
              >[k_3_2];
            }
          : never
      >
    ]
  >
>;
```

and the errors:

`Type 'k_1' cannot be used to index type 'addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>'.` at line 17

`Type 'k_3' cannot be used to index type 'addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>'.` line 26 
and so on.

The generated type uses zod's complex types and after being compiled they seem incorrect and full of error messages. I took a look myself and began to understand why they are wrong but can't seem to work out why they are generated in such a way that they are now wrong although no indication of errors is present in the code. Maybe it's some incompatibility between my tsconfig and zod? I also setup a minimal working example in a git repo so you can reproduce the problem and check out everything in piece and quiet. Here's the repo: https://github.com/18ivan18/zod-create-all-or-nothing-schema. 

Every piece of advice is welcome. ",,
1570811318,1984,z.object generated types.,"Let's say I have an object

```ts
const Dog = z.object({
  name: z.string(),
  age: z.number(),
});
```
that I want to create a version of it with all properties optional.

```ts
const OptionalDog = z.object({
  name: z.string().optional(),
  age: z.number().optional(),
});
```

or change each property's value
```ts
const SelectableDog = z.object({
  name: z.enum([""0"", ""1""]),
  age: z.enum([""0"", ""1""]),
});
```
How would I go about generating `OptionalDog` and `SelectableDog` from `Dog`?",,
1570369831,1983,.deepPartial with union support,"Given the following example comparing `.deepPartial` to `PartialDeep` from type-fest.

```ts
import { z } from 'zod'
import type { PartialDeep } from 'type-fest'

const ZodFoo = z.object({
  bar: z.object({
    zed: z.union([
      z.object({
        a: z.string(),
      }),
      z.object({
        b: z.string(),
      }),
    ]),
  }),
})

type Foo = z.infer<typeof ZodFoo>

const ZodPartialFoo = ZodFoo.deepPartial()
type PartialFoo = z.infer<typeof ZodPartialFoo>

let f: PartialFoo
// f.bar?.zed // a and b are not optional

let g: PartialDeep<Foo>
// g.bar?.zed // a and b are optional
```

Is it possible zod `deepPartial` can handle unions making all properties of each type in the union optional as well?",,
1570279963,1981,Add warning for long parses,"To ensure users are aware of when zod is causing performance issue, add `console.warn` when a parse takes longer than 500ms (or pick a number). Sometimes this can be difficult to discover since javascript is IO heavy, cpu is rarely the performance bottleneck, but when it is, it would be good to know. 
",,
1570125100,1980,Bring your own branded / opaque types?,"Hi, I'm just digging into Zod for the first time, and I see you support branded types (yay!).
My project already has a bunch of branded types defined using [`ts-essentials` opaque types](https://www.npmjs.com/package/ts-essentials#Opaque-types), with parsing functions for those types via the ""companion object"" pattern.

My question is, is there a way to have Zod use my already existing branded/opaque types and their accompanying parsers?",,
1569261672,1979,Able to validate invalid email,"Currently, I'm able to pass this as email and get no issues.
```
imran@345934898929^&^&*&**#$%*&%#imran.com
```

```
pawan.anand@%9y8325&%#%$&#$R%&#$%R&#$%R&%#$R%%^^%5rw3ewe.r.ef.d.d.d.d.d.aaaa.wef.co
```

",,
1568513639,1978,Binding zod.function(),"Hi!

I am trying to bind a zod function and it fails to:
```js
class Foo {
  foo(x: number) {
    console.log(this, x)
  }
}

z.function().args(z.number()).implement(Foo.prototype.foo).apply({ x: 1 }, [2])            // prints ""undefined 2""
z.function().args(z.number()).implement((x) => console.log(this, x)).apply({ x: 1 }, [2])  // prints ""undefined 2""
```

I wonder how to fix that?

TIA
",,
1568393546,1977,Problems with `.transform` and generics,"### Discussed in https://github.com/colinhacks/zod/discussions/1972

<div type='discussions-op-text'>

<sup>Originally posted by **stuartkeith** February  1, 2023</sup>
Hi, I'm having trouble using `.transform` inside a function where Zod is using a generic passed into that function. For example (note this is a contrived example, not my actual use case):

```ts
function helper<Type extends string>(type: Type) {
    return z
        .object({
            type: z.literal(type),
            foo: z.number(),
        })
        .transform((obj) => {
            return {
                // does not work - obj.type does not exist on `obj`
                type: obj.type,
                // this is fine
                fooDoubled: obj.foo * 2,
            };
        });
}

const Hello = helper(""hello"");
const Goodbye = helper(""goodbye"");
```


The type of `obj` inside `transform` is:

```ts
obj: { [k_1 in keyof z.objectUtil.addQuestionMarks<{
    type: Type;
    foo: number;
}>]: z.objectUtil.addQuestionMarks<{
    type: Type;
    foo: number;
}>[k_1]; }
```

`obj.type` is not accessible on the object at all. I can see the expected `type: Type` generic is there but it appears that the `addQuestionMarks` type is losing the generic.

This also happens if I use `Type extends z.ZodLiteral<string>` and pass that in directly.

I'm not sure if this is a known limitation of zod or a bug/missing feature. Is there any way of getting around this? Thanks.</div>",,
1568196050,1974,Can't use an imported string array as parameter for `z.enum()`,"Hi! 

I'm my applications I like to create constant files which will be use a lot between files, keeping easier to maintain. 

In a project, I have the following constant:

```typescript
// in constants.ts
export const allowedLanguages = ['de', 'fr', 'en']
```

And when I tried to use that constant as parameter, to validate a contract using `zod.enum()` I have the following error:
<img width=""264"" alt=""image"" src=""https://user-images.githubusercontent.com/44659603/216356558-297fe9b9-447c-4f37-92a8-207b17592fea.png"">

<img width=""978"" alt=""image"" src=""https://user-images.githubusercontent.com/44659603/216356511-0e61af90-3142-4c9c-af10-6648fc56ed01.png"">

Is this a bug or intended? Why can't I use an exported array here? Feels bad having to edit all my schemas that will use language, as my supported languages grows...

Thanks for the time, and I'd be happy to help to allow this if possible ;) 
",,
1566694994,1971,Type 'ZodString' is not assignable to type 'string'.,"I've tried to define scheme, it looks like this:

```js
import { z, defineCollection } from 'astro:content'

const blog = defineCollection({
  schema: {
    title: z.string(),
    description: z.string(),
    date: z.string().transform((str) => new Date(str)),
    image: z.object({
      src: z.string(),
      alt: z.string(),
    }),
    tags: z.array(z.string()),
    updated: z.string(),
    draft: z.boolean(),
  },
  slug: ({ defaultSlug }) => {
    return defaultSlug
  },
}) ...
```

I think this `description: z.string()` trigger the getter `get description(): string | undefined;`, 

but I don't know why the code still run as supposed to do.",,
1564934619,1965,Indexed type access with Zod,"Consider the following typescript code, which represents some data entry inside a database and the update command that is sent over the network (untrusted) 
```ts
interface Data {
    id: string;
    prop1: number;
    prop2: string;
    prop3: boolean;
}

interface DataUpdate<T extends keyof Data> {
    target: string; // the id
    prop: T;
    val: Data[T];
}
```

In this situation, it would be ideal to be able to use `zod` to validate the data, since it's transmitted over the network. However, it does not seem like there is a way currently to do an indexed type access with `zod`. While we can currently do the rest of the objects using the following code, we can't really do the `val` property with zod. 

```ts
const Data = z.object({
    id: z.string(),
    prop1: z.number(),
    prop2: z.string(),
    prop3: z.boolean(),
});

const DataUpdate = z.object({
    id: z.string(),
    prop: Data.keyof(),
});
```

Is this a new feature that can be added? Or am I missing something here?


",,
1563348805,1960,ZodObject not assignable to ZodTypeAny,"I've encountered this issue since updating to 3.20.2 (have also tried going down to 3.20.1 and 3.20.0, but it only disappears in 3.19), where I get ```""Argument of type ZodObject<....> is not assignable to parameter of type ZodTypeAny. Type ZodObject<...> is missing the following properties from 'ZodType<any, any, any>': catch, pipe.```

I've tried searching for a solution to the issue but cannot seem to find anything.

Reproduction steps:
- Create a file `1.ts`
- Add some sort of zod object to this file. `export const a = z.object({ ... });`
- Then import said zod object into another file `2.ts`, where you try to use it in another zod object (so basically nesting them).
- `const b = z.object({ someName: a })`

This worked in previous versions but I just cannot seem to get it working in this update. I'd love to hear any feedback on this, and maybe hear if I'm doing anything wrong or if it's a known issue.

Thanks!",,
1563329628,1959,ZodIssueCode type is an interface rather than enum,"I really love zod and thank you to everyone for their work on it ðŸ™ 

I am working with zod in GraphQL and I noticed that the `ZodIssueCode` type is an interface rather than an enum. The code [here](https://github.com/colinhacks/zod/blob/master/src/ZodError.ts#L18) suggests that it is intended to be an enum, but the `arrayToEnum` function [here](https://github.com/colinhacks/zod/blob/master/src/helpers/util.ts#L19) seems to return an object rather than an enum.

In the module's build code I see the following in zod/lib/ZodError.dts:

```ts
export declare const ZodIssueCode: {
    invalid_type: ""invalid_type"";
    invalid_literal: ""invalid_literal"";
    custom: ""custom"";
    invalid_union: ""invalid_union"";
    invalid_union_discriminator: ""invalid_union_discriminator"";
    invalid_enum_value: ""invalid_enum_value"";
    unrecognized_keys: ""unrecognized_keys"";
    invalid_arguments: ""invalid_arguments"";
    invalid_return_type: ""invalid_return_type"";
    invalid_date: ""invalid_date"";
    invalid_string: ""invalid_string"";
    too_small: ""too_small"";
    too_big: ""too_big"";
    invalid_intersection_types: ""invalid_intersection_types"";
    not_multiple_of: ""not_multiple_of"";
    not_finite: ""not_finite"";
};
```

It seems an enum would be a better type. Is there a reason why it is done this way? Would you be open to a pull request changing the ZodIssueCode to an enum?

Thank you!",,
1562863603,1958,"all properties are inferred as optional, even if strict and strictNullChecks are set to true","I have a simple validator and i am exporting the types like this
```
import type { z } from 'zod';
import type { cardValidator, imageBlockValidator, textBlockValidator } from 'validators';

export type ValidatedCard = z.infer<typeof cardValidator>;
export type ValidatedTextBlock = z.infer<typeof textBlockValidator>;
export type ValidatedImageBlock = z.infer<typeof imageBlockValidator>;
```

when I import the type into another package I am getting typescript errors along the lines of `object.property is possibly 'undefined'` i have seen some bugs here regarding this and usually the answer is to set `strict` to `true` in `tsconfig.json` but I've done that already and it still doesn't work
here is my `base.json` which is imported in all other packages
```
{
	""$schema"": ""https://json.schemastore.org/tsconfig"",
	""display"": ""Default"",
	""compilerOptions"": {
		""composite"": false,
		""declaration"": true,
		""declarationMap"": true,
		""esModuleInterop"": true,
		""forceConsistentCasingInFileNames"": true,
		""inlineSources"": false,
		""isolatedModules"": true,
		""moduleResolution"": ""node"",
		""noUnusedLocals"": false,
		""noUnusedParameters"": false,
		""preserveWatchOutput"": true,
		""strict"": true,
		""target"": ""ES6"",
		""outDir"": ""dist"",
		""strictNullChecks"": true
	},
	""exclude"": [""node_modules""]
}
```
I have added the `strict` and `strictNullChecks` to `true` in the local configs as well just to make sure it wasn't an import issue and I still got the same error, after each step I reinstalled everything and restarted vscode just in case that was the issue but it didn't work",,
1562586519,1956,issues with customizing error messages,"Hi,

I'm using Zod with SvelteKit and [typesafe/i18n](https://github.com/ivanhofer/typesafe-i18n) to create a multilingual site.

One of the main requirements is to display localized error messages according to the selected locale.

At the moment, I have the following code blocks:

```ts
import { z } from ""zod"";
import { get } from ""svelte/store"";
import LL from ""$i18n/i18n-svelte"";

const contactSchema = z.object({
	name: z
		.string({
			required_error: get(LL).formRequiredError({ field: get(LL).name() }),
			invalid_type_error: get(LL).formInvalidError({ field: get(LL).name(), type: get(LL).text() }),
		})
		.min(3)
		.max(20),
	surname: z
		.string({
			required_error: get(LL).formRequiredError({ field: get(LL).surname() }),
			invalid_type_error: get(LL).formInvalidError({
				field: get(LL).surname(),
				type: get(LL).text(),
			}),
		})
		.min(3)
		.max(20),
	email: z
		.string({
			required_error: get(LL).formRequiredError({ field: get(LL).email() }),
			invalid_type_error: get(LL).formInvalidError({
				field: get(LL).email(),
				type: get(LL).email(),
			}),
		})
		.email(),
	company: z
		.string({
			required_error: get(LL).formRequiredError({ field: get(LL).company() }),
			invalid_type_error: get(LL).formInvalidError({
				field: get(LL).company(),
				type: get(LL).text(),
			}),
		})
		.min(3)
		.max(20),
	phone: z
		.string({
			required_error: get(LL).formRequiredError({ field: get(LL).phone() }),
			invalid_type_error: get(LL).formInvalidError({
				field: get(LL).phone(),
				type: get(LL).text(),
			}),
		})
		.min(3)
		.max(20),
	message: z
		.string({
			required_error: get(LL).formRequiredError({ field: get(LL).message() }),
			invalid_type_error: get(LL).formInvalidError({ field: get(LL).message(), type: get(LL).text() }),
		})
		.min(20)
		.max(3000),
});

export { contactSchema };
```

Right now, Zod is bypassing the locale consideration and just displaying the messages in whatever language is selected as the base.

Am I doing something wrong with Zod?",,
1561545264,1955,Generating type definitions for a library with zod and i get an error,"I am getting this error when running build command
```
[vite:dts] Start generate declaration files...
src/cards.ts:3:27 - error TS2589: Type instantiation is excessively deep and possibly infinite.

  3 const categoryValidator = z.object({
                              ~~~~~~~~~~
  4  label: z.string(),
    ~~~~~~~~~~~~~~~~~~~
... 
  6  group: z.string()
    ~~~~~~~~~~~~~~~~~~
  7 });
    ~~

```
the `categoryValidator` is only referenced once in the same file so I am sure it's not a circular dependency, what could be causing this? It's annoying to debug this because it takes vite over 30 minutes to give up which means I have to wait 30 minutes before I get the error

Edit: I removed this validator and added it inline but I was still getting the same error, I didn't get to see the error because as mentioned it takes forever but it was there",,
1561103283,1949,Interaction between zod and TypeScript handling of .catchall,"zod seems to handle `.catchall` on an object differently than the corresponding TypeScript type it generates. Given the following schema:

```typescript
const schema = z.object({
  foo: z.string(),
})
  .catchall(z.number());
```

zod will happily validate it:

```typescript
schema.parse({ foo: 'hi', bar: 0 });

// âœ… no error
```

However, if you look at the corresponding inferred type:

```typescript
type Schema = z.infer<typeof schema>;

// type Schema = {
//   [x: string]: number;
//   foo: string
// }
```

that type seems unsatisfiable directly in TypeScript:

```typescript
const x: Schema = { foo: 'hi', bar: 0 };

// Type '{ foo: string; bar: number; }' is not assignable to type '{ [x: string]: number; foo: string; }'.
//   Property 'foo' is incompatible with index signature.
//     Type 'string' is not assignable to type 'number'.
```

I'm not entirely sure what the right behavior here is - should `catchall` require that all values on the shape be assignable to the catchall type? Is there some other way to declare what the output type is? (Is there some way to declare a constant of type `Schema` that TypeScript is happy with?)",,
1560120353,1946,method request: `isValid` method that returns whether the passed data is valid or not,"**About the issue:**

If you want to check whether the passed data is valid, you have to parse and bind a catch method to it.

In small use cases like checking whether a single input field passes the check, this could be quick and helpful, being a one-liner.",,
1559196031,1944,Retrieve default values from schema,"I am trying to build a form abstraction around Zod. Currently it works as follows:
```ts
const  = useForm({
  schema: z.object({
    name: z.string(),
    demo: z.number(),
  }),
  // This object is of type `Partial<z.infer<S>>` where `S` is the schema above.
  defaultValues: {
    name: ""todo""
  }
});
```

Now I would like to remove the `defaultValues` argument and use Zod's built-in defaults for better DX. Like the following:
```ts
const  = useForm({
  schema: z.object({
    name: z.string().default(""todo""),
    demo: z.number(),
  }),
});
```

The way `useForm` works internally is that it needs the default values so it can set them to the HTML `input` elements. I was hoping Zod would give me all of the default values similar to the manually written `defaultValues` argument I was previously using.

I saw in issue #201 it was recommended to use `schema.parse({})`. This does not work for my use case because I don't want to be required to set a default value on every field.

In issue #213 there was another workaround but it would greatly comprise DX so it doesn't work for me either.

I think this could be fixed by either:
 - Providing a method to get the default values from the schema. `schema.getDefaults()`
 - Providing a way to parse a schema which instead of failing on errors would return a partial object of all fields it could successfully parse. This would make `schema.parse({})` work and it would just not include all fields without a default set.

Thanks for any help that can be provided and I have been loving using Zod in my projects!",,
1558552675,1942,Question about error handling with custom schemas,"Zod provides a method to define custom schemas via `z.custom()` but I have not found a straightforward way to report any errors / issues. Here's an example:

```ts
const f = z.custom<string[]>(arg => {
    if (typeof arg !== 'string') {
        // How to report errors / issues?
        return z.NEVER;
    }
    return arg.split(',');
});
```

From the [example](https://zod.dev/?id=custom-schemas) in the docs it seems that `z.custom()` can only validate but not parse. I did find a workaround with using `transform` but it does not feel right.

```ts
const f = z.custom<string[]>().transform((arg: any, ctx) => {
    if (typeof arg !== 'string') {
        ctx.addIssue({ code: 'custom' });
        return z.NEVER;
    }
    return arg.split(',');
});
```",,
1558173880,1938,Need Help | Not found in Doc | Optional fields ,"Hello 

I have a scenario, I have 2 fields and both of the fields are optional, the tricky thing user can leave both of the fields blank but if the user wants to input he can give value to one of the fields only

```
const paymentObject = z.object({
  creditorAccountIban: z.string().min(15).max(34),
  description: z.string().optional(),
  paymentReference: z.string().optional()
});
```

so description and paymentReference can be empty, but if the user wants to input only one can have a value either description or paymentReference.


Please give me some good examples

",,
1557830560,1937,Need Help: Not found in the doc,"Hello all,
I need your help because I didn't find in the documentation how to convert this example into Zod.

```typescript
interface SomeArray {
  id: string; // uuid
  createdAt: number; // timestamp
}

interface TestItem {
  id: string;
  name: string;
  someArray: SomeArray[];
  date: number;
}

export class Test {
  constructor(
    public id: string = '', // uuid
    public name: string = '',
    public someArray: SomeArray[] = [],
    public date: number // timestamp
  ) {}

  static fromJson(data: TestItem): Test {
    return new Test(data.id, data.name, data.someArray, data.date * 1000);
  }
}

const MOCK: Test = {
  id: 'uuid',
  name: 'test',
  someArray: [{ id: 'uuid', createdAt: 190000 }],
  date: 19000,
};

const getData = Test.fromJson(MOCK);

console.log(getData)

```",,
1557619500,1935,Boolean schema is incorrectly typed as z.number ,"```javascript
// schemas.ts

export const schemas = {
  string: z.string,
  number: z.number,
  boolean: z.number /* --> should be z.boolean */,
  unknown: z.unknown,
  null: z.null,
  undefined: z.undefined,
  date: dateSchema,
  literal: z.literal,
  union: z.union,
  array: z.array,
  object: z.object,
};
```

This leads to always triggering the invalid type error when using `q.boolean()`",,
1557187827,1934,Default on ZodObject behaviour,"I might be misusing or misunderstanding the `default()` function on a ZodObject, but I would have expected these implementations to behave similarly:


```typescript
const MySchema = z.object({
  a: z.string().default('a'),
  b: z.number().default(1),
  c: z.boolean().default(true),
})

const MySchema2 = z
  .object({
    a: z.string(),
    b: z.number(),
    c: z.boolean(),
  })
  .default({ a: 'a', b: 1, c: true })

console.log(MySchema.parse({})) // { a: 'a', b: 1, c: true }
console.log(MySchema2.parse({})) // throws ZodError
```

Is this expected behavior or a bug? I'd be more then happy to make a contribution :)",,
1557049563,1933,Access to value in `.catch` that failed to parse.,"I'd like to be able to access the value that failed parsing in `.catch` and do something with it. For example:

```typescript
const schema = z
  .discriminatedUnion(""type"", [
    z.object({ type: z.literal(""type1"") }),
    z.object({ type: z.literal(""unknown""), value: z.unknown() })
  ])
  .catch((val: unknown) => ({ type: ""unknown"" as const, value: val }));

const result = schema.parse({ type: ""some-other-type"" });
// result would look like
// {type: ""unknown"", original: { type: ""some-other-type"" }}
```

Then in other places I can maybe log what the original value was, or try to do some more parsing in the `.catch` callback itself",,
1556054801,1929,`z.coerce.date().parse(null)` validates successfully,"This is a bit of a gotcha:
```typescript
z.coerce.date().safeParse(null).success // true
```

It's not technically unexpected, though:
```typescript
new Date(null) // Thu Jan 01 1970 10:00:00 GMT+1000 (Australian Eastern Standard Time)
```

I'm happy to PR a docs update briefly describing this gotcha, unless the project wants to address this by changing how `z.coerce.date()` works internally.

(IMO it should _not_ change `z.coerce.date()` as just calling `new Date()` without any other logic is very tidy.)",,
1552278787,1923,Literal errors don't return received field on error ,"Examples

```javascript
const data = z.literal(4324).safeParse(431)
```
```javascript
const data = z.literal(""something"").safeParse(""else"")
```

return at data.error.issues schema:

```javascript
{
    code: 'invalid_literal',
    expected: 'something',
    path: [],
    message: 'Invalid literal value, expected ""something""'
  }
```

But this example

```javascript
const data = z.string().safeParse(1)
```

return at data.error.issues schema

```javascript
  {
    code: 'invalid_type',
    expected: 'string',
    received: 'number',
    path: [],
    message: 'Expected string, received number'
  }
````

Is this expected behavior?



",,
1552065537,1921,Disable validations Per environments (i.e. do not validate on Production),"Hi All,

this looks like a really great project, but I was looking for a way to set it up so that real-time validations will only be done on Non-Production environments.

the idea is to make sure that production environment will run as fast as possible.
similar to what redux have with their ""production mode"".

is there any way to achieve this?
are there any plans to add something like that?

Thanks,
Gal
",,
1551958331,1918,Add maxPrecision to ZodNumber,"This would allow for quickly defining currency types where decimal places are allowed, but `1.001` is not valid. ",,
1551834969,1917,Schema from TypeScript type,"Right now Zod is useful when used from the start of a project, no doubt. 

However, I have some issues when it comes to the real-world usage of Zod when it comes to third-party libraries and existing codebases.

For example, it's currently impossible to use types from third-party packages in your schemas without first redefining those types in your own code as Zod schemas. This makes for a horrible developer experience in the first instance as now I have to inspect the types in the third-party package in much more detail than I otherwise would and I have to write a bunch of additional boilerplate.

However, it gets worse if/when that third-party package changes the type definition. Maybe they add new properties. Maybe they rename or remove something. Either way, even if I wasn't using/relying on those properties I now have to change my code to match.

My ideal developer experience here would be something like this:

```ts
import { z } from 'zod'
import { SomeType } from 'some-third-party-package'

const MySchema = z.object({
  myProperty: z.string(),
  otherProperty: z.deduce<typeof SomeType>() // Zod would inspect the type and deduce a schema or object shape automatically
})

export type MyType = z.infer<typeof MySchema>
```

There is also the issue of retrofitting Zod into existing TypeScript projects. Typically dev teams will find it difficult to get buy-in for additional work that the people holding the purse strings will perceive as ""rework"" that's not going to produce any tangible benefit to the value of the software or the revenue the company makes. Basically, why would they pay for that when they could be paying for new features to be added that they can charge their customers more money for?

From the suggestion above, the same idea could then also be used to give true TypeScript first capabilities to Zod **and** allow a much easier uptake on older projects with little to no additional developer overhead:

```ts
import { z } from 'zod' // added in retrofit

// Existing type in the project
export type User {
  name: string
  age: number
}

// To retrofit Zod into an older project the developer could use the `deduce<T>()` function 
// to produce schemas directly from their existing types
export const UserSchema = z.deduce<typeof User>()
```

Now the developer can use the Schema to achieve the runtime type protection they want, and the bosses are happy because the developer didn't take time to rewrite old code rather than build new features.

",,
1551252534,1915,Allow cancellation through AbortSignal,"Add a second parameter to parseAsync to pass a `AbortSignal` for aborting the parsing.

That `AbortSignal` would be passed then to `refine` and `superRefine` to stop any asynchronous validation.

Example:
```ts
const schema = z.object({
  username: z.string.refine(async (value, {signal})=> {
    const { isValid } = await fetch('/api/validate-user?username='+value, {signal})
                              .then(response => response.json())
    return isValid
  }, { message: ""The username you choose is not valid"" }
})",,
1550505140,1913,`z.enum` does not allow adding a custom error for `invalid_enum_value`,"When. I define a `z.enum` I'm only able to define custom errors for `invalid_type_error` and `required_error` but not for `invalid_enum_value`.

When the user for example choose the ""empty"" option from the Select, the form will choose the `invalid_enum_value` but I cannot personalize the error.

Am I using it in the wrong way, or should `enum` expose that property to be customized?",,
1549936329,1912,Custom error messages with variables,"In `yup` you can pass the error message as a second argument, the same as in `zod`.
The difference is that in `yup` it can be a `string` or a `function` that returns a `string`.
Here's an example:

```typescript
// Passing a string (same as zod)
string().max(64, ""Max: 64"");

// Passing a function
string().max(64, ({ max }) => `Max: ${max}`)
string().min(2, ({ min }) => `Min: ${min}`)
string().length(64, ({ length}) => `Length: ${length}`)
```

_Originally posted by @bulicmatko in https://github.com/colinhacks/zod/discussions/1909#discussioncomment-4731518_
    ",,
1548837818,1911,Calling `isOptional()` on a `coerce.bigint` throws an error,"Try the following code:
```ts
const bigintSchema = z.coerce.bigint();
const isOptional = bigintSchema.isOptional();
```

That code should be able to run IMO, but now it throws an error, `TypeError: Cannot convert undefined to a BigInt`",,
1548265752,1908,Question: Custom error messages with variables?,"Is there a way to set custom error messages with variables?
Here's an example to better explain my question:

 ```typescript
// An example with react hook
// useIntl comes from `react-intl`

function useValidationSchema() {
  const intl = useIntl()

  return string()
    .max(64, {
      message: intl.formatMessage({
        id: ""s3BfNQ"",
        defaultMessage: ""Max length is 64"",
      }),
    })
}
```

The problem with this example is the duplication of the max value `64` in the validator and in the translation.

Ideally, I would want something like this:

 ```typescript
// An example with react hook
// useIntl comes from `react-intl`

function useValidationSchema() {
  const intl = useIntl()

  return string()
    .max(64, {
      message: ({ max }) =>
        intl.formatMessage(
          {
            id: ""s3BfNQ"",
            defaultMessage: ""Max length is {max}"",
          },
          { max }),
    })
}
```

This way, if the max value changes, there's no need to update all translations.
This is the way `yup` does it.

I checked the docs and opened issues and could not find anything like this.

PS: Big Thanks to the author and all the contributors for this great lib. Amazing work!





",,
1548226973,1907,Use operator IN to filter a query by a JSON attribute.,"Include the `IN` operator to filter by a JSON column. 

Something like that:
`const dbQuery: any = { 
      where: { 
        jsonField: {
          path: '$.jsonpath',
          in: ['value_1', 'value_2']
        },
      orderBy: {
        text_field: 'asc'
      }
    };`",,
1537969872,1901,Better Recursive type's example and method,"The current example required user to declare the types twice
```typescript
interface Category {
  name: string;
  subcategories: Category[];
}

// cast to z.ZodType<Category>
const Category: z.ZodType<Category> = z.lazy(() =>
  z.object({
    name: z.string(),
    subcategories: z.array(Category),
  })
);

Category.parse({
  name: ""People"",
  subcategories: [
    {
      name: ""Politicians"",
      subcategories: [{ name: ""Presidents"", subcategories: [] }],
    },
  ],
}); // passes
```
Instead we could use `z.infer` and Typescript's type union to reduce duplicative code
```typescript
const _Category = z.object({
  name: z.string(),
})
type CategoryType = z.infer<typeof _Category> & {
  subcategories: CategoryType[]
}
const Category: z.ZodType<CategoryType> = z.lazy<any>(() =>
_Category.extend({
  subcategories: z.array(Category),
}));

Category.parse({
  name: ""People"",
  subcategories: [
    {
      name: ""Politicians"",
      subcategories: [{ name: ""Presidents"", subcategories: [] }],
    },
  ],
}); // passes
```

This way, we could write most of our definition under `_Category` and save the need to write an interface.
",,
1536897013,1898,Validator for cuid2?,"Hello, thanks for a great project! Now that cuid is deprecated, any chance of getting a validator for [Cuid2](https://github.com/paralleldrive/cuid2)?",,
1535736261,1896,z.coerce.bigint() throws error when when using safeParse,"Given this code:

```ts
const schema = z.coerce.bigint();

const unknownInputFromUser = undefined;

// This throws
schema.safeParse(unknownInputFromUser);
```

schema.safeParse will throw an error.

link to repro: https://codesandbox.io/s/solitary-smoke-39qo2w?file=/src/index.js:49-179

Thank you for zod! Working on a project that uses it currently and it's a delight!",,
1535303055,1895,"When using `.catch` with default value, it can return invalid type","Since catch value allows us to pass `z.input` value, it won't fallback to default value.
`.catch` should either require `z.output` value, or zod should also parse value provided to catch.

[reproduction](https://codesandbox.io/s/musing-rumple-6iq8f9?file=/src/index.ts)

```ts
import { z } from ""zod"";
// this allows `.catch(undefined)` since `z.input` is `string | undefined`, but it should require `string`, since 
// default value will not be applied in case of an error
const stringSchema = z.string().default(""hello"").catch(undefined);
const stringResult = stringSchema.parse(111);
// ts says stringResult type is string, but value is undefined
console.log(""stringResult"", stringResult);
```",,
1534690643,1893,`z.ZodType` and `refine` not working as expected,"Consider the following code:
```ts
const stringIsValid = (value: string): value is ""a"" | ""b"" =>
  [""a"", ""b""].includes(value);

const ASchema = z.object({
  type: z.string().refine(stringIsValid),
});

type A = z.infer<typeof ASchema>;

interface B {
  id: string;
  children: (z.infer<typeof ASchema> | B)[];
}

const BSchema: z.ZodType<B> = z.lazy(() =>
  z.object({
    id: z.string(),
    children: z.array(z.union([ASchema, BSchema])),
  })
);
```
type `A` is correctly inferred as:
```ts
{
    type: ""a"" | ""b"";
}
```

But when creating the `BSchema`, and assigning it to `z.ZodType<B>` I get the following error:
```ts
Type 'ZodLazy<ZodObject<{ id: ZodString; children: ZodArray<ZodUnion<[ZodObject<{ type: ZodEffects<ZodString, ""a"" | ""b"", string>; }, ""strip"", ZodTypeAny, { type: ""a"" | ""b""; }, { ...; }>, ZodType<...>]>, ""many"">; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'ZodType<B, ZodTypeDef, B>'.
  The types of '_input.children' are incompatible between these types.
    Type '({ type: string; } | B)[]' is not assignable to type '({ type: ""a"" | ""b""; } | B)[]'.
      Type '{ type: string; } | B' is not assignable to type '{ type: ""a"" | ""b""; } | B'.
        Type '{ type: string; }' is not assignable to type '{ type: ""a"" | ""b""; } | B'.
          Type '{ type: string; }' is not assignable to type '{ type: ""a"" | ""b""; }'.
            Types of property 'type' are incompatible.
              Type 'string' is not assignable to type '""a"" | ""b""'
```

Is this a bug or am I doing something weird? Zod-version is `3.20.2` and typescript version is `4.8.4`",,
1534662895,1892,"`.parse()` Typescript linter accepts anything (string, number...)","Hi,

I didn't find someone having my issue so I'm probably doing something wrong but... I can't figure the solution out.

Let's say I have:
```ts
const TestSchema = z.object({
  email: z.string(),
});

TestSchema.parse('hello');
```

The last line will not throw an error with the Typescript whereas when hovering the parse function I can see:
```ts
(method) ZodType<{ email: string; }, ZodObjectDef<{ email: ZodString; }, ""strip"", ZodTypeAny>, { email: string; }>.parse(data: unknown, params?: Partial<z.ParseParams> | undefined): {
    email: string;
}
```

**Note that I use `strict: true` in my `tsconfig.json` (and at runtime, `zod` throws an error obviously).**

A ""workaround"" would be to always do this:
```ts
const TestSchema = z.object({
  email: z.string(),
});
type TestSchemaType = z.infer<typeof TestSchema>;

TestSchema.parse(<TestSchemaType>'hello');
```
... but it's pretty verbose and annoying.

Any idea what's the issue to get the linter working normally?

Thank you,

EDIT: it seems a solution would be to use
```ts
const typedParse = <Schema extends z.ZodSchema> (
  schema: Schema, data: z.infer<Schema>
): z.infer<Schema> => schema.parse( data )

typedParse(ATest, 'hello');
```
(ref: https://github.com/colinhacks/zod/issues/1748#issuecomment-1364572126)

... but I don't get why this is not used by default?",,
1534056659,1890,"One of, for zod strings ","Using zod, I missed a property of `oneOf`, like have in yup, for example:
```js
yup.string().oneOf(['horse', 'apple'])
```
In zod, is there any similar property to use in a string?",,
1533761098,1889,Add a getter for `multipleOf` on `ZodNumber`,"While creating [`uniforms-bridge-zod`](https://www.npmjs.com/package/uniforms-bridge-zod), I had a need to get the resulting `multipleOf` to use it in a `<input type""number"">`'s `step` attribute. Right now, I have to work around it a little:
```ts
type ZodNumberCheck = ZodNumberDef['checks'][number];
const step = field._def.checks.find(
  (check): check is Extract<ZodNumberCheck, { kind: 'multipleOf' }> =>
    check.kind === 'multipleOf',
);
```

_([source](https://github.com/vazco/uniforms/blob/6353c831673adc9a786932c4ab60483c59de3d9c/packages/uniforms-bridge-zod/src/ZodBridge.ts#L173-L181))_, but I thought that exposing it similarly to `maxValue` for `max` and `minValue` for `min` would be a nice feature.

I have to problems with that, though:
1. What if there are multiple `multipleOf`s? Ideally we'd need to calculate least common multiple of them, but maybe using the first one is enough?
2. What should be the name? `multipleOfValue` or `stepValue` stay in-align with `max`/`maxValue`, but aren't ideal.

I can file a PR for that.",,
1532933476,1884,discriminated union cant be nested,"Currently it is impossible to allow discriminated unions as argument to another discriminated union.
Typescript however allows that so it should be allowed in zod as well

Example Typescript and zod:
https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgLABQlMAnmAKZwCCcAvIpXHMcAM4DGUUMAB2AQxjQAjAC44MKAFd6Abk5wQvAOZzeC0VrUU0lanUYAhFuwTqwYqGJCy4IxSABG9KEa48BQiCiEtAATHKYYgA2vKrq-oLC4pJQLpEx9JQmVBS0DHAWFmwcFH58iUHJYXIKyr5w9o4g4a7uXj7x5YHBKWnRsVmmueYFxQAUVnAAPgUWAJRDeYwAwsUsMxZDlPwQInpYIuNgcstzbAB8JerAmHBjAIRgAHQJ3VWpZ7alXHA3d48vLpJEJQUKfdQ-OA7PYQKL0J5RCBaMbPRpOKQLb5cDD0DIlSFcaG8WHwxHI1EOJxgiHodQ4vFfSFEkkIpEop6aLSY7GDHJE+AAfWsKCeEA8ACt6PwYGNGXAoPRJdL6MQ5MgEcAYN5omNavQ5gAadSctVPPRCETIzFoTHbXb7AWTdjqsVKmVynj0ZaKGDLCB6XimtyebxjQ3qBWKWKqkVRTXaqJjdKxcPfBVulWmuNaxyJ5P6rK2ij8uCOorO0USqXu9QAdwAFhIg21Q6muJHo1n47ndUp9Ua04rq5nY92dfnrUWS47iurXsCtcQAKoiYC7Mb4Dsq-AGuAAbUdTF3ZYAukWAPTnuDeHBQXh2vaC1YV+eVCQqldrkQb9PD0i7g8j1LCwzyGS9fhETBvGAuBa2gABre9hnyAAtFDZyeUQoKgAAeJYIFuR1zkoIA

Here is the code for reference:

```ts
import { z } from 'zod'

type A = {
  discriminator1: true;
  msg: string;
}

type BA = {
  param1: number;
  discriminator2: false;
  discriminator1: false
}

type BB = {
  discriminator2: true;
  param2: number;
  discriminator1: false
}

type B = (BA | BB)

type C = A | B


const fn = (p: C) => {

  if (!p.discriminator1) {
    if (!p.discriminator2) {
      console.log(p.param1)
    } else {
      console.log(p.param2)
    }
  } else {
    console.log(p.msg)
  }
}

const _A = z.object({
  rejected: z.literal(true),
  msg: z.string()
})

const _BA = z.object({
  dieCutCosts: z.number(),
  reused: z.literal(false),
  rejected: z.literal(false)
})

const _BB = z.object({
  what: z.number(),
  reused: z.literal(true),
  rejected: z.literal(false)
})

const _B = z.discriminatedUnion('reused', [_BA, _BB])

// errors
const _C = z.discriminatedUnion('rejected', [_A, _B])

// infer _B works
type ZZ = z.infer<typeof _B>
```",,
1532276911,1879,Typescript function return type error when creating new schema with ZodObject.merge() and ZodObject.partial(),"Not sure if I'm doing something wrong or it's an issue with zod. I'm trying to create a factory function to make a new ZodObject schema from two existing schemas. However I'm having trouble creating a return type for the function to match the new schema it returns. When I do this:

```typescript
function createSchemaWithMergeAndPartial2<
  BaseShape extends ZodRawShape,
  CommonShape extends ZodRawShape
>(
  baseSchema: ZodObject<BaseShape>,
  commonSchema: ZodObject<CommonShape>
): z.ZodObject<
  z.extendShape<
    BaseShape,
    {
      [k in keyof CommonShape]: z.ZodOptional<CommonShape[k]>;
    }
  >
> {
  return baseSchema.merge(commonSchema.partial());
}
```
typescript will complain about the returned value, saying `Two different types with this name exist, but they are unrelated`. I've made a [CodeSandbox](https://codesandbox.io/s/zod-merge-and-partial-typescript-issue-xil6we) to demonstrate the issue.

I could leave the return type off and let typescript figure it out itself but unfortunately this is just a stripped down example. In my actual project I have many factory functions creating new schema, many of which are composed of several nested factory functions and when I don't provide return types for these functions typescript complaining that `Type instantiation is excessively deep and possibly infinite.` so I'm hoping providing the return types will fix that issue.",,
1532020959,1878,discriminatedUnion with array element as discriminator,"I haven't found a way to create a discriminated union with array element as first discriminator. 

Example code that I'm trying to execute:

```ts
const transferFeeSchema = discriminatedUnion('feeType.0', [

    object({
        feeType: array(literal('fixed')),
        isAllowed: literal(true),
        baseFee: coerce.number().min(0, 'Can\'t be negative')
    }),
    object({
        feeType: array(literal('percentage')),
        isAllowed: literal(true),
        percentage: coerce.number().min(0, 'Can\'t be negative')
    })
])
```

Is there any way to achieve this with Zod?",,
1531464675,1873,"Can't provide custom error message for enum ""invalid_enum_value"" error","Here is my schema:
```ts
export const testSchema = z.object({
  privacy: z.enum([""public"", ""unlisted"", ""private""], {
    required_error: ""Privacy setting is required"",
    invalid_type_error: ""Privacy setting must be a string"",
    invalid_enum_value: ""Privacy setting must be public, unlisted, or private"",
  }),
});
```
Here are my tests:


```ts
// privacy setting is undefined
testSchema.parse({});

// resulting error
{
  expected: ""'public' | 'unlisted' | 'private'"",
  received: 'undefined',
  code: 'invalid_type',
  path: [Array],
  message: 'Privacy setting is required'
}

// privacy setting is invalid type
testSchema.parse({ privacy: 123 });

// resulting error
{
  expected: ""'public' | 'unlisted' | 'private'"",
  received: 'number',
  code: 'invalid_type',
  path: [Array],
  message: 'Privacy setting must be a string'
}

// privacy setting value is invalid
testSchema.parse({ privacy: ""test"" });

// resulting error
{
  received: 'test',
  code: 'invalid_enum_value',
  options: [Array],
  path: [Array],
  message: ""Invalid enum value. Expected 'public' | 'unlisted' | 'private', received 'test'""
}
```
As you can see I overrode the error message for `required_error` and `invalid_type_error` and both messages correctly showed up in the errors. However, I also overrode `invalid_enum_value` error message but the error is still displaying the default message.
",,
1531332659,1872,Denial of service with array validations?,"Based on Zod's `README.md` and the mentioned libraries using Zod that are linked within that document, I would assume that Zod is designed to be used in potentially highly security-critical situations as a first line of defense against malicious users sending invalid data, i.e., in form validations, when parsing/validating HTTP request bodies, etc. If that is not the case, please (also) interpret this ticket as a request to clearly indicate the intended use cases of the library.

If my understanding is correct, however, I think there might be a security issue around the handling of arrays: Assuming a Zod schema `z.number().max(1).array()`, parsing the value `new Array(1000000).fill(5)` yields 1000000 validation errors, taking `safeParse` **3 seconds** to generate the completely useless list of errors. For an array length of 10000000 (one additional 0), the Nodejs process crashes due to an out-of-memory error on my machine.

Is is also possible to generate an array like `const a = [1,2,3]; a[1000000000] = 4`. In that case, after about **20 seconds** (!), `safeParse` of the same example schema (see above) crashes with an error: `TypeError: Cannot read properties of undefined (reading 'status')  at ParseStatus.mergeArray (.../node_modules/zod/lib/helpers/parseUtil.js:62:19)...`. The huge computation time during which the entire Nodejs main thread is blocked is obviously problematic. The error that is thrown seems unintentional, i.e. this might even be a Zod bug and the 1000000000 error messages should have been reported.

By the way, I used the lastest version of Zod, 3.20.2, for my tests.

Now, you could say that there should be other lines of dense against such attacks, such as the maximum request body size. You could also use the array schema's `length` function to restrict the maximum allowed array length (if there is some meaningful upper bound for your particular use case). And all of that is true, but it violates the secure by default/by design principle.

As asked above, isn't the point of Zod that I can just pass it some data that I want to ensure to have a certain shape/schema? So are my findings above the intended behavior of Zod? Other issues like #1403 seem to suggest that Zod's design explicitly wants to return all errors to the user, which is clearly undesirable from a security (in particular: availability) perspective. If the behavior is intentional, I don't see how Zod can be recommended for security-critical applications and use cases like the libraries mentioned in the `Readme.md`. Yes, it doesn't leak data, but it endangers the availability of a system since it facilitates denial of service attacks. This behavior might be surprising to users; it clearly was surprising to me.

The fact that this project doesn't even seem to have a security policy defined (at least none that I could easily find; I expected to find it [here](https://github.com/colinhacks/zod/security)) also doesn't look like security is a primary concern. I would have preferred to not report this (potential) issue publicly in a GitHub issue.",,
1530911818,1868,Discriminated Union based on nested object property?,"Hi there!

I've been playing around with Zod a lot lately and I've been defining a lot of different schemas. When I was reading up on discriminatedUnions, it got me thinking if the following was possible to define in zod:

```ts
{
   subscription: {
      type: 'typeA' | 'typeB'
  },
  event: {
      id: 1234 // only present in typeA subscriptions
      name: ""abc""
  }
}
```

I could make this property option and use `refine` to check if type is typeA and then enforce id to be present, which is what I am currently going with.
However I'd like to define a discriminatedUnion based on the subscription type and then define the event object accordingly.

Is there any way this can be achieved?

e.g

```ts
z.discriminatedUnion(""subscription.type"", [
  z.object({ 
    subscription: z.object({ 
      type: z.literal(""typeA"") 
    }) 
  }),
  z.object({ 
    subscription: z.object({ 
      type: z.literal(""typeB"") 
    }) 
  }),
])
```

Thanks!",,
1530455056,1864,How to use string array values as object keys?,"I have a list of strings: `const filenames = z.enum(['one', 'two', 'three']);`

..and want use those values as the possible keys of an object: 

```ts
const hashes = z.object({
    [filenames]: z.string().length(40)
});
```

Is something like that possible is Zod? Any suggestions?",,
1530079980,1861,Question: why is `_errors` an array?,"Why are the error messages always in array form? I have not found an example in the docs of multiple error messages for one field. I cannot figure out how to make the error messages array have more than one element.

Example:

```js
x.error?.flatten()
```

Gives:

```js
{
  formErrors: [],
  fieldErrors: { 
    username: [ 'Expected number, received string' ],
    password: [ 'Must contain capital letters' ]
  }
}
```

The above is the result of ``Why does the `username` key correspond to an array? That array is supposed to be an array of strings (`string[]`), right? Why is it an array if it's always only one element? **Why not just have the `username` key correspond to a string?**

This isn't just with the `.flatten()` method. It's the way errors are represented everywhere.",,
1529286018,1858,Default message for required errors,"Hi, I would like to replace yup with Zod. Yup has a way to create custom error messages, however you set properties, you are not given a function with the context of the message so you can not specify the name of the property in the error message.  ZodErrorMap is far better.  However, I don't see any way to set a default message for a required field.  e.g. a schema property is required and the data has no value for that property.  I would say that for form validation at least this is 80% of the job. Is there some way to create a custom error message similar to ZodErrorMap that would allow this?
Thanks",,
1528820785,1855,Coerce bigint throws `TypeError` instead of `ZodError`,"Consider the following code:
```ts
var zod = require(""zod"")

const testSchema = (schema, invalidData) => {
   try {
      schema.parse(invalidData);
   } catch (e) {
       if (e instanceof zod.ZodError) {
          console.log(""throws ZodError"");
       } else {
          console.log(`throws other error (${e.message})`);
       }
   }
}

console.log(""case 1"");
testSchema(zod.object({
   foo: zod.string(),
}), {}); // throws ZodError

console.log(""case 2"");
testSchema(zod.object({
   foo: zod.coerce.number()
}), {
  foo: ""invalid""
}); // throws ZodError

console.log(""case 3"");
testSchema(zod.object({
   foo: zod.coerce.bigint(),
}), {}); // throws other error (Cannot convert undefined to a BigInt)

console.log(""case 4"");
testSchema(zod.object({
   foo: zod.coerce.bigint(),
}), { foo: ""invalid"" }); // throws other error (Cannot convert invalid to a BigInt)
```
(Playground: https://runkit.com/embed/bk8jnwfz1tkq) 

I would expect that all cases would throw a `ZodError`, but it seems as BigInt throws a `TypeError` instead.

Tested with zod `3.20.2` on node `16.18`

This is a bug, right?",,
1528647157,1854,Method `.pick` / `.omit` might be misleading,"Hi there,

I was using zod with some great methods and found out `.pick/ .omit` might be a bit misleading.

[According to the document](https://zod.dev/?id=pickomit), both of the methods accept a object that contains a key with a value which looks like this:
```ts
const Recipe = z.object({
  id: z.string(),
  name: z.string(),
  ingredients: z.array(z.string()),
});

const JustTheName = Recipe.pick({ name: true });
const NoIDRecipe = Recipe.omit({ id: true });
```

but the [actual behavior](https://github.com/colinhacks/zod/blob/master/src/types.ts#L2152) (not sure was intended or a logic error) is just looping through the given object's key. No matter the value is there or not (truthy or falsy), as long as the key exist in the object it will just effect the schema which seems a bit pointless to having the value with it.

I suggest the value should be also consider, for example:
```ts
const shouldOmit = true

Schema.omit({
   name: shouldOmit, //true
   age: !shouldOmit //false
})

Schema.parse({ 
  name: 'Charlie',
  age: 20
})  // { age: 20 }
```


Any thoughts? ",,
1527946434,1850,Object key/value order changes after parsing,"This seems like an odd behavior, and I don't know if this is intended or not. When using `z.object` the parsed return value matches the same key/value order as defined in the schema (not according to the original data).

Example:
```javascript
const Schema = z.object({
  one: z.number(),
  two: z.number(),
  three: z.number(),
})

const data = { three: 3, two: 2, one: 1 };

Schema.parse(data) // returns { one: 1, two: 2, three: 3 }
``` 

Is there a workaround for this? In my case the order of the key/values is very important because we are using the data object as a signature message, and if the order changes at all, then the signature will be different.",,
1527266073,1844,nullish and min together,"Is there a way to accomplish something like this 
`z.string().nullish().min(5, 'field can not be less than 2 character')`

field can be empty and if is not empty must be more than 5 character",,
1526466504,1839,Caught errors are not distinguishable from uncaught errors,"In v3.20.x errors handled via the `catch` operator are logged along with errors that actually cause the parsing to fail. This makes it difficult to differentiate ""fatal"", uncaught errors from non-fatal, caught/handled errors. This isn't a huge deal in smaller schemas, but becomes very tedious with larger ones.

Is there a way to suppress caught errors from `parse` and `safeParse`, or perhaps mark them as caught?

### Example
See the [interactive example on Stackblitz](https://stackblitz.com/edit/typescript-oxmrfa?file=index.ts), but here's the code for a minimal reproduction:
```typescript
const schema = z.object({
  stringProp: z.string(),
  numberPropWithCatch: z.number().catch(0),
});

schema.parse({
  // This value is of incorrect type and causes the parsing to fail
  stringProp: {},
  // This value is of incorrect type as well, but DOESN'T
  // cause parsing to fail as it's caught in the schema.
  // However, the error is reported in the overall list
  // of parsing errors.
  numberPropWithCatch: '',
});
```

Running this code results in an error **as expected**, but notice how both the fatal and caught errors are displayed:
![image](https://user-images.githubusercontent.com/13987407/211425161-6358df95-eeb2-45c1-bfff-b2555a0e7295.png)
",,
1526466035,1838,Retrieve the resolving schema from a ZodPromise,"Hey all -- I was playing around with ZodPromise and hoping to add this functionality in a PR. I checked out the [CONTRIBUTING.md](https://github.com/colinhacks/zod/blob/master/CONTRIBUTING.md) first and it asked I open an issue. So here I am....

ZodPromise is created with a second Zod type that is checked when the promise resolves. I'd like to be able to access the schema the ZodPromise was created with. For example

```ts
import { z } from 'zod';

const Foo = z.literal('foo')
const MyPromise = z.promise(Foo)

MyPromise.resolves() // should be a method that returns the Foo schema declared above
```
I'm not sure there is a way to do this at the moment and I'm open to suggestions on variable naming and such. If this is something that makes sense to PR I can draft something but looking for some feedback first. Thanks.",,
1525419766,1836,TypeScript integration?,"I can't find this section in the docs.

For example, the corresponding section of the Yup docs:
https://github.com/jquense/yup#typescript-integration

```ts
import { object, number, string, ObjectSchema } from 'yup';

interface Person {
  name: string;
  age?: number;
  sex: 'male' | 'female' | 'other' | null;
}

const schema: ObjectSchema<Person> = object({
  name: string().defined(),
  age: number().optional(),
  sex: string<'male' | 'female' | 'other'>().nullable().defined();
});
```

How to do the same with Zod?",,
1525339320,1835,`refine()` breaks `deepPartial()`,"`deepPartial()` is not actually deep, if nested object has `refine()` on it.
Example 1, works:
```ts
const test1 = z
  .object({
    inner: z.object({
      data: z.string(),
    }),
  })
  .deepPartial();

type Test1 = z.infer<typeof test1>;

/*
type Test1 = {
    inner?: {
        data?: string | undefined;
    } | undefined;
}
*/
```
Example 2, doesn't work, `innerWithRefine` is not partial:
```ts
const test2 = z
  .object({
    innerWithRefine: z
      .object({
        data: z.string(),
      })
      .refine((value) => true),
  })
  .deepPartial();

type Test2 = z.infer<typeof test2>;

/*
type Test2 = {
    innerWithRefine?: {
        data: string; // is not optional, but it is supposed to be
    } | undefined;
}
*/
```",,
1524446805,1834,Error [ERR_PACKAGE_PATH_NOT_EXPORTED],"I am trying to add a new function as follows:

```js
import { z } from 'zod';
import { errorUtil } from 'zod/lib/helpers/errorUtil';

// ...
z.ZodString.prototype.numeric = function (
    message = 'Invalid numeric string',
) {
  return this._addCheck({
    kind:  'regex',
    regex: /^\d+$/,
    ...errorUtil.errToObj(message),
  });
};
```

This works with webpack etc, but not in Nodejs, I get the following error:

```
Error [ERR_PACKAGE_PATH_NOT_EXPORTED]: Package subpath './lib/helpers/errorUtil.js' is not defined by ""exports"" in node_modules/zod/package.json
```

The solution maybe to add that `helpers` path to `exports` in zod's `package.json`",,
1524272568,1833,Improve Zod Type Inspection,"Currently, there is no general purpose way to retrieve the types contained within a zod type. There a disparate apis such a `.shape` for ZodObject, `.element` for ZodArray, `.items` for ZodTuple, `.unwrap` for ZodNullable, and `innerType` for ZodEffects. As the Zod ecosystem grows, more and more third party libraries want to inspect zod types. 

I propose a new api on ZodType which enables general purpose inspection. A working title for this might be `innerTypes`.

Example of usage 
```ts
z.object({
    foo: z.string(),
    bar: z.number(),
    nested: z.object({
        baz: z.boolean()
    })
}).innerTypes() // returns [{ path: 'foo', schema: ZodString }, { path: 'bar', schema: ZodNumber }, { path: 'nested', schema: ZodObject }]
```",,
1522244106,1831,Add title for meta,"There is already describe https://github.com/colinhacks/zod/commit/e2389b0312fb1b280a90d4bd1f10d099178aec9a , please add a title for schema, want to use like json schema , but missing title makes generate form and other ui harder.",,
1522193287,1829,Schema and ZodSchema undocumented,"Looking at the code, I can see that `ZodType` is aliased as `ZodSchema` and `Schema`: https://github.com/colinhacks/zod/blob/master/src/types.ts#L4309

```ts
export { ZodType as Schema, ZodType as ZodSchema };
```

But I see no mention of this in the documentation. Are those aliases meant to be used? If so, should the documentation reflect that?",,
1520900443,1823,Declaration for Generic Function Returning a ZodObject ,"Hello,

## The Issue

I'm currently facing errors in the declaration generated for a generic function returning a `ZodObject` in which the generic, a `T extends ZodTypeAny`, is used. It follows the pattern laid out [in the readme](https://github.com/colinhacks/zod#writing-generic-functions).

The actual function works fine, it's just the declaration causing me problems when using this project in another (see below for details)

## Minimal Reproducible Example

```ts
// test.ts
import { z } from 'zod';
export const a = <T extends z.ZodTypeAny>(b: T) => z.object({ someKey: b });
```

```ts
// package.json
{
  ""scripts"": { ""build"": ""rm -rf dist && tsc -b tsconfig.json"" },
  ""dependencies"": { ""zod"": ""^3.20.2"" },
  ""devDependencies"": { ""typescript"": ""^4.9.4"" }
}
```

```ts
// tsconfig.json
{
  ""compilerOptions"": {
    ""target"": ""es2016"",
    ""module"": ""commonjs"",
    ""declaration"": true,
    ""outDir"": ""dist"",
    ""esModuleInterop"": true,
    ""forceConsistentCasingInFileNames"": true,
    ""strict"": true,
    ""skipLibCheck"": true
  }
}
```

Then `npm run build` generates `./dist/test.d.ts`

## The Error

```ts
// ./dist/test.d.ts
import { z } from 'zod';
export declare function a<T extends z.ZodTypeAny>(b: T): z.ZodObject<{
    someKey: T;
}, ""strip"", z.ZodTypeAny, z.objectUtil.addQuestionMarks<{
    someKey: T[""_output""];
}> extends infer T_1 ? { [k_1 in keyof T_1]: z.objectUtil.addQuestionMarks<{
    someKey: T[""_output""];
}>[k_1]; } : never, z.objectUtil.addQuestionMarks<{
    someKey: T[""_input""];
}> extends infer T_2 ? { [k_3 in keyof T_2]: z.objectUtil.addQuestionMarks<{
    someKey: T[""_input""];
}>[k_3]; } : never>;
```

Both `extends infer...` lines give the error:

`Type 'k_x' cannot be used to index type 'addQuestionMarks<{ someKey: T[""_output""]; }>'. [2536]`

## Finally

Its thoroughly possible I've missed something obvious so please let me know if that's the case

If not, then any workaround you can think of would be appreciated",,
1518598020,1816,ZodCatch should have an `input` of `any`,"Everything fits a `ZodCatch`. Even if the underlying parsing fails, we return a `valid` result, with the catch value in the `data` field.

Any specific reason for not typing the `input` of `ZodCatch` as `any`?",,
1518590943,1815,Do we have any roadmap somewhere?,"ðŸ‘‹ Do we have any roadmap posted somewhere?

I want to contribute more but I don't have a clear way of where the library is heading. I'm submitting a lot of PRs but without any idea of what are the next steps for Zod.

That would be nice if we had a roadmap somewhere that I could use to guide my next PRs.",,
1518131358,1812,Zod defaulting to optional properties,"version: 3.20.2

# Repro
<img width=""320"" alt=""image"" src=""https://user-images.githubusercontent.com/3680671/210465144-d81a1704-9b98-40be-bfe0-79c321c93c8d.png"">

# Expected
No error.

# Observed
The inferred type of parsed values makes all properties optional.
```
Type '{ a?: string; }' is not assignable to type '{ a: string; }'.
  Property 'a' is optional in type '{ a?: string; }' but required in type '{ a: string; }'.ts(2322)
```",,
1517787578,1810,Is there a zod method to Rename the key? ,"Something like this, 

```
const schema = z.object({
    user_id: z.string() // <--- some method here to mutate the key,
});

let input = { user_id: 1234qwer5678 }

let output = schema.parse( input )

console.log(output) // returns { id: 1234qwer1234 }
```
",,
1517549514,1807,Bug: `.catch` causes `undefined` types inside `z.object`,"### Bug: `.catch` causes `undefined` types inside `z.object`.

This issue appears to be different to https://github.com/colinhacks/zod/issues/1737 (fixed by PR https://github.com/colinhacks/zod/pull/1733)

ðŸš€ Example outside `z.object`:
```ts
import { z } from 'zod';

const schema = z.string().catch('asdf');

const result = schema.parse(undefined);
//      ^? string

console.log(result); // ""asdf""
```

ðŸš§ Example inside `z.object`:
```ts
import { z } from 'zod';

const schema = z.object({
  value: z.string().catch('asdf'),
});

const result = schema.parse({});
//      ^? { value?: string }

console.log(result); // { value: ""asdf"" }

// Why is `result.value` possibly undefined?
```


Reproduction:
https://stackblitz.com/edit/typescript-sucpqa?devToolsHeight=100&file=index.ts",,
1517258377,1805,Fix zod enum `.option` property documentation in Readme,"> You can also retrieve the list of options as a tuple with the `.options` property:

According to the doc in the Readme, the `.option` property is supposed to return a tuple, but in the actual implementation, it returns an array. This is also illustrated by the example juste bellow in the doc:

> FishEnum.options; // [""Salmon"", ""Tuna"", ""Trout""]);

The doc should be updated to state that the `.options` properties return an array instead of a tuple",,
1515913229,1795,Error handling on coerce ,"I believe to have found a non critical bug, but I am not sure as I bring only limited knowledge in JS.

Code:

```ts
let array = [""1"", ""string""];

let validate = z.coerce
                .number()
                .array()
                .optional()
                .safeParse(array);

console.log(validate.error.issues)
```

Result:
```ts
[
  {
    code: 'invalid_type',
    expected: 'number',
    received: 'nan',
    path: [ 1 ],
    message: 'Expected number, received nan'
  }
]
```

I'd have assumed to get ""received: 'string'"", got 'nan' instead.",,
1514824723,1785,Date Array,"Closed, actually an issue with another package and not zod",,
1514786647,1784,Dark mode in the documentation,"Hi, is it possible to have dark mode in the documentation? I see zod.dev documentation being generated from the README.md file, so was wondering. I guess docsify is used? Thanks!",,
1514766769,1783,Add `sensitive` to `ZodSchema`,"I noticed in #595 the discussion regarding sensitive values. It would be great to add the `ZodError` to structured logging like through `pino` so that things like `path` can be directly searched to find / deduplicate issues in logs, but sensitive values can get logged due to the `received` field as well as some of the localized messages:

https://github.com/colinhacks/zod/blob/9828837fb94f1500ef362b20ca5fe35eed1b6d0e/src/locales/en.ts#L7-L13

Perhaps one could write code like the following to make sure `received` is `undefined` by adding a `sensitive: boolean` to the appropriate Zod types, as well as the localized messages appropriately not interpolating the sensitive value:

```typescript
const databasePassword = z.sensitive.string().min(1).safeParse(process.env.MY_DATABASE_PASSWORD);
if (!databasePassword.success) {
  log.error({
    err: databasePassword.error // all `received` fields are not set
  }, 'Invalid database password: %s', databasePassword.error.message);
  return null;
}
```

Useful for credentials like passwords, and PII like email. Redaction in `pino` cannot be used in a workaround in all cases due to https://github.com/pinojs/pino/issues/1612.",,
1514277190,1777,Zod literal parse error missing 'received' field,"```ts
z.literal('a').parse('b')
```
throws the following error: 
```ts
[
  {
    ""code"": ""invalid_literal"",
    ""expected"": ""a"",
    ""path"": [],
    ""message"": ""Invalid literal value, expected \""a\""""
  }
]
```
It would be great if it included the `received` field so that you could tell what you got instead of the literal. This is especially useful for when you have unions of literals; the `received` field will help you find what literal you need to add.",,
1513731234,1773,Enumerated discriminator,"Is there a way to let me specify a discriminator value from a set of possible values?

For example here I want to have three possible values for the discriminator but I can pass in anything in a `z.literal` for the discriminator value. I tried to put the discriminator in a base object and parse it as an enum but it looks like it's being overridden completely when I use the `and()` which prevents me from:
- Enumerating and type check that all discriminator values exists(as I've hardcoded it in my code base).
- Not having to include ""fortress"" in the discriminatedUnion, since there's no special about a fortress other than the base structure attributes I want to exclude it from the discriminated union, but then it can't parse fortress.

```ts
const structureIds = [""farm"", ""fortress"", ""barracks""] as const;

const baseStructureSchema = z.object({
  level: z.number(),
  position: z.number(),
  health: z.number(),
  id: z.enum(structureIds),
});

const structureSchema = baseStructureSchema.and(
  z.discriminatedUnion(""id"", [ // this overrides id: z.enum(structureIds)
    z.object({ id: z.literal(""farm""), peasants: z.number() }),
    z.object({ id: z.literal(""barracks""), trainers: z.number() }),
  ])
);
```",,
1513680674,1772,Make error codes first class citizens,"Currently Zod is heavily reliant on error messages instead of error codes. For example ZodError makes it easy to get error messages, but does not provide help in getting error codes out in a simple format. `refine` only allows to pass error message, but no error code. This is problematic i18n wise since error messages, especially builtin ones are pretty free form English. by providing easy way to get & set error codes, any i18n system would be easy to make zod compatible since error codes are easy to map to localization keys.

Currently if one would want to use refine & standard errors, you'd need to set your custom error code as errorMessage in `refine`, and parse errorCode in cumbersome way out of standard errors from Zod error. if error codes would always be available & easily customizable, developer could solely rely on error codes instead.",,
1512895716,1769,Add `shallow: boolean` to parse method options,"I want to use zod and [immer](https://github.com/immerjs/immer) together, but zod's `parse` method makes a deep clone of the passed variable and messes up immer's `produce` method result.

Can we add a `shallow: boolean` option to parse methods options to avoid this? Or a deep clone is absolutely necessary?",,
1512865714,1768,"ZodObject methods (pick, omit, partial, etc.) for discriminatedUnion","In issue #56 it was proposed to add `ZodObject` methods to intersections and unions.
This was never implemented, because both `z.intersection` and `z.union` do not make any assumptions about the underlying types.

`z.discriminatedUnion` does however assume all underlying types to be objects so it would be both useful and make sense to add the ZodObject methods to it.
",,
1512478287,1767,Add a label function as like yup,"I have used YUP which provides a label for changing the value of key.
like address:
```ts
yup.string().required().max(150).label('Address')
```

But Zod has not any simple function as like that. ",,
1511010630,1760,3.20: Input type of a schema with a coercion,"I believe there is a confusion with the way how the new `coerce` feature works together with the inferring of the input type.

Here is the example with the `ZodString` having `coerce` enabled:

```ts
const schema = z.coerce.string(); // ZodString
console.log(schema.parse(123)); // ""123"", no errors
type SchemaInput = z.input<typeof schema>; // string
const input: SchemaInput = 123; // TS2322: Type 'number' is not assignable to type 'string'.
```

Under the hood, as per my understanding, the schema actually accepts `any` type of the input, making a `String` out of them.
However, inferring the input type of such schema returns `string`, so the `coerce` feature is not taken in account on the typescript level.

I believe, the `z.coerce.string()` should create `ZodType<string, ZodStringDef, any>` (input type â€” `any`, not equal to the output type â€” `string`).

what do you think, @colinhacks ?",,
1510435234,1757,Invalid type error with discriminatedUnion and or,"I have the following type:

```ts
const productItemBase = z.object({
  type: z.literal(""product""),
  title: z.string(),
});

const productItem = productItemBase
  .extend({ url: z.string() })
  .or(productItemBase.extend({ description: z.string() }));

const contentItem = z.object({
  type: z.literal(""content""),
  title: z.string(),
  url: z.string(),
  imageUrl: z.string(),
});

const documentItem = z.object({
  type: z.literal(""document""),
  title: z.string(),
  url: z.string(),
  documentType: z.string(),
});

export const schema = z.object({
  items: z.array(
    z.discriminatedUnion(""type"", [productItem, contentItem, documentItem])
  ),
});
```

Expected:
No type error

Actual:
Type error on the `productItem` inside the discriminatedUnion. (The type error disappears if I replace it with productItemBase, of course)",,
1509649914,1750,Why is strict mode required,Our projects are a long way away from being able to flip on strict mode. Zod requires strict mode. Is there any compromise? Perhaps some minimum set of options that we can turn on that zod needs.,,
1509546625,1748,`parse.typed(...)` or some kind of typed parse method,"It'd be nice to have zod help the developer max out their chances of parsing a valid object, when it's manually constructed. Example:

```ts
const User = z.object({
  name: z.string().regex(/^\w+ \w+$/),
  age: z.number(),
})

User.parse({
  name: 'Bob',
  birthdate: new Date('1970-01-01'),
})
```

The above code compiles, but we have enough information to _know_ that it'll throw a ZodError at runtime. It'd be nice if there was a method like

```ts
User.parse.typed({
  name: 'Bob',
  birthdate: new Date('1970-01-01'),
})
```

Where the expected input type was `Input` (from the `ZodType<Output, Def, Input>`) rather than `unknown`. So the above code would error because the developer used `birthdate` instead of `age`.

This would be especially useful for types with a custom `.refine` or `.regex` method or similar where it could be misleading to use _just_ a type declaration:

```ts
const user: z.infer<typeof User> = {
  name: ""Robert'; -- DROP TABLE Students; --""
  age: 40,
}
```

The above will compile, and implies that the `const user` is a validated `User` instance, but it isn't because `name` doesn't match the regex. The current options are to do the above, which is safe-looking at compile time, but unsafe at runtime, or to use `.parse(...)` which is unsafe at compile time and safe-ish at runtime (but will throw errors).",,
1509384760,1747,String `.endsWith` & `.startsWith` could perhaps be typed more strongly,"If the passed value was a literal, we could have a generic in ZodString that will include a prefix / suffix.

Use case:
At the moment, I am using the code below to validate that a value is a specific ID format that has a constant prefix

```ts
export function id<P extends IdPrefixes>(prefix: P) {
	return z
		.string()
		.refine((value): value is `${P}_${string}` => pika.validate(value, prefix));
}
```

Imagine if this could be done with just `.startsWith` and `.endsWith` â€” ZodString could then have a single generic of the output, which would default to just a string and can be made more specific with these two methods.

<img width=""785"" alt=""CleanShot 2022-12-23 at 14 02 47@2x"" src=""https://user-images.githubusercontent.com/25351731/209348315-61d308e4-6581-4210-91ed-b02398adb85c.png"">

Should note that I am not sure if this is a good idea or not, but I wanted to just throw the idea out either way â€” it's a use case I have very frequently and always use `.refine` to solve.
",,
1508549533,1744,No `.endsWith` or `.startsWith` string methods on Deno,"I'm using Zod 3.16.1 with Deno and I'm not able to use the `.endsWith` or `.startsWith` string methods. As far as I can tell, all of the other string methods are supported, like `.regex`, `.url`, `.uuid`.

```
$ deno --version
deno 1.29.1 (release, x86_64-unknown-linux-gnu)
v8 10.9.194.5
typescript 4.9.4
```",,
1508018451,1743,`CreateParams` get lost when calling any of the root-level methods,"```ts
const MySchema = z.string({ description: 'this is a string schema' }).optional()
// => No longer has the description associated with it
```

This is because we are not passing the `CreateParams` to these methods on the root-level `ZodType` class.

Instead of:

```ts
nullable() {
  ZodNullable.create(this);
}
```

We should find a way to pass the `CreateParams` as well.

```ts
nullable() {
  ZodNullable.create(this, /* => */ params);
}
```",,
1507942065,1741,Zod v3.20.2 causing stalled build in CRA project,"Started using Zod in a create-react-app project in combination with `react-hook-form`. Everything works fine except building the project.

No error is thrown, the build simply freezes and is stalled. When running `npm run build --verbose` it just pretty much stops completely after the first initial logs that happen within approx. 20ms. 

It seems to be a problem with the, at this time, latest version v3.20.2. After downgrading Zod to v3.19.1, it builds normally.",,
1507518878,1740,ZodType not working as expected with branded schemas,"When passing a branded string to the `ZodType` generic, the type being returned is more strict than the original schema.

For example:

```ts
const SomeBrandedString = z.string().brand<""some-brand"">();

type SomeBrandedString = z.infer<typeof SomeBrandedString>;

const test: z.ZodType<SomeBrandedString> = SomeBrandedString;
```

Would give the following error:


```
Type 'ZodBranded<ZodString, ""some-brand"">' is not assignable to type 'ZodType<string & BRAND<""some-brand"">, ZodTypeDef, string & BRAND<""some-brand"">>'.
  Types of property '_input' are incompatible.
    Type 'string' is not assignable to type 'string & BRAND<""some-brand"">'.
      Type 'string' is not assignable to type 'BRAND<""some-brand"">'.ts(2322)
```

Zod v3.20.2
",,
1507285584,1737,.catch() does not preserve type with .optional(),"zod version: `3.20.2`
issue: `z.string().optional().catch(undefined)` comes out as `string` instead of `string | undefined`

```
const someSchema = z.object( {
  optionalCatch: z.string().optional().catch(undefined)
})
type Some = z.infer<typeof someSchema>

type WrongType = Some[""optionalCatch""]
```

the type of `WrongType` comes out as `string` instead of `string | undefined` however the argument to `catch` does test for undefined.
",,
1505738016,1734,URL validation broken on react native,I just discovered that URL validation doesn't work on react native because the default react native polyfill does no throw errors for invalid URLs. Maybe it would be worth adding a note to the docs that recommends using the following spec compliant polyfill in react native instead: https://www.npmjs.com/package/react-native-url-polyfill,,
1505108681,1732,Feature Request: Pass more data to catch to simplify error reporting and fallbacks,"# Level 1 - pass error and input
```ts
export const schemaWithErrorCapture = <
  O,
  D extends ZodTypeDef,
  S extends Schema<O, D, unknown>,
>(
  schema: S,
): ZodCatch<ZodNullable<S>> => {
  return schema.nullable().catch((cause, input) => {
    captureException(
      new Error(`parse failed for ${schema.description || 'UnnamedSchema'}`, {
        cause,
      }),
      { extra: { dataRaw } },
    );
    return null;
  });
};

const dataOrNull = schemaWithErrorCapture($Response).parse(dataRaw);
```

# Level 2 - enable transformations in catch - avoids nullable in my case:
```ts
export const schemaWithErrorCapture = <
  O,
  D extends ZodTypeDef,
  S extends Schema<O, D, unknown>,
>(
  schema: S,
): ZodCatch<S, null> => {
  return schema.catch((cause, input) => {
    captureException(
      new Error(`parse failed for ${schema.description || 'UnnamedSchema'}`, {
        cause,
      }),
      { extra: { dataRaw } },
    );
    return null;
  });
};

const dataOrNull = schemaWithErrorCapture($Response).parse(dataRaw);
```

# Level 3 - pass also the schema - enables a generic function to be used in catch:
```ts
const handleParseError = (
  error: ZodError,
  input: unknown,
  schema: Schema,
): null => {
  captureException(
    new Error(
      `parse failed for ${schema.description || 'UnnamedSchema'}`,
      { cause: error },
    ),
    { extra: { input } },
  );
  return null;
};

const dataOrNull = $Response.catch(handleParseError).parse(dataRaw);
```

---
# What I have currently - safeParse:
```ts
const parseSchemaHard = <
  O,
  D extends ZodTypeDef,
  S extends Schema<O, D, unknown>,
>(
  schema: S,
  dataRaw: unknown,
): z.infer<S> | null => {
  const result = schema.safeParse(dataRaw);

  if (!result.success) {
    captureException(
      new Error(`parse failed for ${schema.description || 'UnnamedSchema'}`, {
        cause: result.error,
      }),
      { extra: { dataRaw } },
    );
    return null;
  }
  return result.data;
};

const dataOrNull = parseSchemaHard($Response, dataRaw);
```
",,
1504885585,1731,"Zod is really really slow once he detect an error during validation, why ?","Hi,

I was searching a better way to control my user input in my API. So I try to compare some libraries to select the faster that match with my needs. For that I write this code :
```Typescript
import { z } from ""zod"";

const UserZod = z.object({
    name: z.string().min(3).max(20),
    age: z.number().min(0).max(120),
    address: z.object({
        street: z.string().min(3).max(200),
        number: z.number().min(0).max(120),
        city: z.string().min(3).max(200),
        country: z.string().min(3).max(200),
        zip: z.string().min(3).max(200),
    })
});

setTimeout(async () => {
    console.log(""Start comparison on 1_000_000 iterations"");

    const startZod = Date.now();
    for (let i = 0; i < 1_000_000; i++) {
        UserZod.safeParse(data);
    }
    console.log(""zod: "" + (Date.now() - startZod) + ""ms"");
})
```

However, the time used to perform the validation goes from simple to sixfold... Let's take the example of the following data, the first one is good but the second one has an error in the name since it is 1 character too short
```
// 947ms for 1_000_000 iterations
const data = {
    name: ""Joe"",
    age: 13,
    address: {
        street: ""Main Street"",
        number: 12,
        city: ""New York"",
        country: ""USA"",
        zip: ""12345""
    }
}

// 5724ms for 1_000_000 iterations
const data = {
    name: ""Jo"",
    age: 13,
    address: {
        street: ""Main Street"",
        number: 12,
        city: ""New York"",
        country: ""USA"",
        zip: ""12345""
    }
}
```

I don't understand why it's so slow as soon as an error exists... In my opinion, there are some things in the code that slow things down a lot with an error.
Moreover, the more errors there are, the more the execution time is increased (with 5 errors, the time is almost multiplied by 13)

Do you have any ideas where this could come from?
(in my opinion there are also some things that could be done to improve performance such as an option in the parse function to stop at the first error, etc.)",,
1503599918,1725,"How to add ""examples"" Openapi keyword to body request ?","Hi, 
thanks for this great library.

How to add the ""examples"" to schema using zod ?
This is a snippet of my OpenApi3 Swagger schema. 
```
""/media"": {
	""post"": {
		""summary"": ""Return a media file with format and type as required"",
		""tags"": [
			""media""
		],
		""requestBody"": {
			""content"": {
				""application/json"": {
					""schema"": {
						""type"": ""object"",
						""properties"": {
							""mediaType"": {
								""type"": ""string""
							},
							.... (omitted)
						}
					},
	---> ???			""examples"": {     
						""example1"": {
							""value"": {
								""mediaType"": ""CHART"",
								... (omitted)
							}
						},
     ... (omitted)
```",,
1502502877,1724,Dynamic Validation,"Hello, 
I have a for loop of inputs like this : 
```vue
<VField v-for=""socialMedia in socialMediaChecked"" :id=""socialMedia.socialMedia.name"">
    <VLabel v-if=""socialMedia.checked"">Customer's {{ socialMedia.socialMedia.name }} URL:</VLabel>
    <VControl v-if=""socialMedia.checked"" icon=""feather:chevrons-right"">
        <VInput type=""text"" placeholder="""" autocomplete="""" v-model=""socialMedia.url""
            :key=""socialMedia.socialMedia.id"" />
    </VControl>
</VField>
```
and I want to do the same validation on them for every input and every input have a unique key , how to do a dynamic validation on these inputs using Zod? ",,
1502037051,1721,How to transform empty strings into null? `z.emptyStringToNull()`,"
How to support  empty strings for `z.string().datetime({ offset: true }).nullish()` schema 
if the string value is **empty**, I want it converted to `null` or keep the original value ie., `""""`

the following code throw error
```ts
import { afterAll, beforeAll } from 'vitest';
import { z } from 'zod';


describe('Test zod validations', () => {

	it('should correctly handles a valid ISO date-string', () => {
		const valid_from = '2022-12-14T22:07:10.430805+00:00';
		const valid_to = undefined; <-- this works
                 const valid_to = null; <-- this works
                 const valid_to =""""; <-- this is not working


		const schema = z.string().datetime({ offset: true }).nullish();

		expect(schema.parse(valid_from)).toStrictEqual(valid_from);
		expect(schema.parse(valid_to)).toStrictEqual(valid_to);
	});
});
```
ERROR
```
ZodError: [
  {
    ""code"": ""invalid_string"",
    ""validation"": ""datetime"",
    ""message"": ""Invalid datetime"",
    ""path"": []
  }
]


Serialized Error: {
  ""addIssue"": ""Function<>"",
  ""addIssues"": ""Function<>"",
  ""errors"": [
    {
      ""code"": ""invalid_string"",
      ""message"": ""Invalid datetime"",
      ""path"": [],
      ""validation"": ""datetime"",
    },
  ],
  ""flatten"": ""Function<flatten>"",
  ""formErrors"": {
    ""fieldErrors"": {},
    ""formErrors"": [
      ""Invalid datetime"",
    ],
  },
  ""format"": ""Function<format>"",
  ""isEmpty"": false,
  ""issues"": [
    {
      ""code"": ""invalid_string"",
      ""message"": ""Invalid datetime"",
      ""path"": [],
      ""validation"": ""datetime"",
    },
  ],
}
```
",,
1501625633,1718,Add `.meta()` to zod types,"Inspecting zod objects directly can be really useful for developing certain types of libraries. Of course tons of libs are already doing it - everything in the `zod-to-x` section of the documentation for example. Zod already supports some forms of meta data (custom error messages are a sort of metadata), which is extremely useful for things like building forms.

What if it were possible to attach arbitrary information, (or even just a string) via a `meta` function call? Having an explicit ""meta"" field could allow library developers to have their code react to zod schemas with much higher levels of customization, which could in turn allow us to improve developer experience in new ways. 

The example I have in mind is this - Lets look at a tRPC procedure with a zod schema as an input validator:

```ts
getPosts: t.procedure.input(z.object({
  id: z.string().meta(""The id of the post.""),
  search: z.string().meta(""Returns posts with this term in the body"").
})).query(() => {
  //...
}),
```

Here we're attaching a description to each input parameter. Now we can do things like generating documentation directly from our validation schemas. Anyone who's developing a library that inspects zod schemas would have much more flexibility in the types of APIs they'd be able to develop.

It doesn't have to be a string, it could be any other typed object. One solution could be `.meta<MetaType>()`, or maybe an optional interface for generating a meta enabled client (probably a lot more difficult to create?) `export const z = createZodClient<Meta>()`

Selfishly, I'm developing a tool that inspects TRPC router and generates a manual testing / documentation UI automatically, which generates forms based on input zod schemas. With a `meta` function like this, it would allow developers to create documentation per input field with a minimal amount of effort. For me I'd just want a string but IDK if there are use cases for more complex objects or not

Would really love to add something like this, thoughts?",,
1501483774,1716,Cannot get e.target.value,"I have a select like this :

`  <select onChange={(e)=> console.log(e.target.value)} {...register('language')}
`
in which the change doesn't trigger `e` at all. Only by removing `{...register('language')` am I able to get the value. How can get the value on change? ",,
1501448375,1715,`require_error` in string not working when also using `min`,"Hello,

I want to show an error message to tell the user that they have to fill in their name when it is empty, but when I have the following:
```ts
z.string({ require_error: ""Name is required"" }).min(2, { message: ""Name must be at least 2 characters""});
```
it always shows `Name must be at least 2 characters` even when the string is empty. I only want to show this error message if there is at least 1 character filled in, and not when the string is empty.

",,
1498831806,1706,"Type ""string"" format ""binary""","Hello guys, 
I tried to upload a file using zod validator, this must be run also on Swagger
```
body: {
        type: 'object',
        properties: {
          file: {
            type: 'string',
            format: 'binary',
          },
        },
      },
```
How to set with zod an object similar ? 
Thank's ",,
1498756131,1705,Type inference doesn't work when spreading shapes,"Hello,

I frequently deal with schemas like this :

    {
        enabled: false
    } | {
        enalbed: true;
        // a whole bunch of stuff in here
    }

so I wrote a little utility function :

    const withEnabled = <T extends ZodRawShape>(shape?: T) =>
        z.union([
            z.object({
                enabled: z.literal(false),
            }),
            z.object({
                enabled: z.literal(true),
                ...shape,
            }),
        ]);

However when I infer the type of a schema which includes properties defined using this 

    const MySchema = z.object({
        filters: withEnabled({
            something: z.string()
        })
    })
    type MySchema = z.infer<typeof MySchema>

The added shape is not taken into account. Here I see only the enabled true|false

I'm obviously missing something, but what ?

Many Thanks!",,
1498327100,1704,[Suggestion] Instruct users to return `z.NEVER` in `.superRefine()` when providing a type predicate,"As the validation result **solely depends on whether `ctx.addIssue()` is called**,

https://github.com/colinhacks/zod/blob/ad4385439d7c0d7a584052dee5aa578fde5a6efd/README.md?plain=1#L1891

and the return value is only used to satisfy the type predicate and is **always thrown away**,

https://github.com/colinhacks/zod/blob/c9e4ed4095d77f5b43a5ba11d8f76b56ea48e5c6/src/types.ts#L3821-L3822

to prevent users from **accidentally forgetting to call `ctx.addIssue()` while returning a boolean value** as described in the example,

https://github.com/colinhacks/zod/blob/ad4385439d7c0d7a584052dee5aa578fde5a6efd/README.md?plain=1#L1931-L1945

instructing users to **return `z.NEVER` instead of a boolean** at the end (indicating the value is ***never*** used) just like the **early return** case when providing a type predicate may be a good idea.

```ts
  .superRefine((arg, ctx): arg is { first: string; second: number } => {
    if (!arg) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom, // customize your issue
        message: ""object should exist"",
      });
    }

    return z.NEVER;  // this should satisfy the typing
  })
```",,
1498316224,1703,Datetime validation with offset should allow all variants from ISO-8601,"Currently datetime validator allows only offset in format `[+-]hh:mm`, but ISO-8601 defines also `[+-]hhmm` or `[+-]hh`.

```ts
z.string().datetime({offset: true}).parse(""2022-01-01T00:00:00+01:00"") // success
z.string().datetime({offset: true}).parse(""2022-01-01T00:00:00+0100"") // error
z.string().datetime({offset: true}).parse(""2022-01-01T00:00:00+01"") // error
```

Current pattern fragment for offset:
```
(([+-]\\d{2}:\\d{2})|Z)
```
Proposed:
```
(([+-]\\d{2}(:?\\d{2})?)|Z)
```",,
1498114215,1701,How to write a tuple with spread type?,"In TypeScript, you would write:

```typescript
type A = [""A"", ...string[]];
```

How would you define that type definition using Zod?

[Playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBALzgMyhEcBECIBNMDcAUDAJ5gCmcAggM60WwCiAjgK4CGANgDzUA0cAEIA+OAF4acCgA8YFAHa5awuAH44ACiHS5i5VI0wobKgC4U3BgEo4F5FYrEiAehdxcFWsCgVcJcipqCTgAbUxqTEEAOljaY2AFAHNQgF1U5zc4AGM2KF8FGCJsiAV4xGDJBGiYNjAuCk1Q6q5geShuTQjMa0Fq+KhEpM1raI58jlIR1OtM91z8xXhfWjYuIrJKOAAlLzX4KujE5EYeTYoIZAqRYjg4LIA9NSIX87gAYQALCmyAaxC6AxmOxuHxBLtVusbkQ7rDHmogA)",,
1497415417,1697,Proper introspection APIs for handy utils?,"I'd like to be able to parse searchParams with Zod. Here's a utility I built for that:

```ts
import { z } from 'zod'

export function parseSearchParams<SchemaType extends z.ZodRawShape>(
	sp: URLSearchParams,
	schema: z.ZodObject<SchemaType>,
) {
	const rawValues: Record<string, Array<string> | string> = {}
	const schemaProps = schema._def.shape()
	for (const key of sp.keys()) {
		const values = sp.getAll(key)
		const propSchema = schemaProps[key]
		if (propSchema && values.length === 1 && !isExpectingArray(propSchema)) {
			rawValues[key] = values[0]
		} else {
			rawValues[key] = values
		}
	}

	return schema.parse(rawValues)
}

function isExpectingArray(schema?: z.ZodTypeAny): boolean {
	if (!schema?._def) return false

	const { typeName } = schema._def
	if (typeName === 'ZodArray') return true
	if (['ZodUnion', 'ZodIntersection'].includes(typeName)) {
		return schema._def.options.some(isExpectingArray)
	}
	if (['ZodOptional', 'ZodNullable', 'ZodDefault'].includes(typeName)) {
		return isExpectingArray(schema._def.innerType)
	}
	if (typeName === 'ZodLazy') {
		return isExpectingArray(schema._def.getter())
	}
	return false
}

const searchParams = new URLSearchParams()
searchParams.append('starportIds', '123')
searchParams.append('starportIds', '456')
searchParams.append('cityIds', '789')
searchParams.append('cityIds', '101112')
searchParams.append('brandIds', '131415')
searchParams.append('brandIds', '161718')
searchParams.append('modelIds', '192021')
searchParams.append('modelIds', '222324')
searchParams.append('hostIds', '252627')
searchParams.append('hostIds', '282930')
searchParams.append('capacityMin', '31')
searchParams.append('capacityMax', '32')
searchParams.append('dailyChargeMin', '33')
searchParams.append('dailyChargeMax', '34')
searchParams.append('hostRatingMin', '5')
searchParams.append('shipRatingMin', '4')
searchParams.append('availabilityStartDate', '2021-01-01')
searchParams.append('availabilityEndDate', '2021-01-02')

const result = parseSearchParams(
	searchParams,
	z.object({
		starportIds: z.array(z.string()),
		cityIds: z.array(z.string()),
		brandIds: z.array(z.string()),
		modelIds: z.array(z.string()),
		hostIds: z.array(z.string()),
		capacityMin: z.coerce.number().positive(),
		capacityMax: z.coerce.number().positive(),
		dailyChargeMin: z.coerce.number().positive(),
		dailyChargeMax: z.coerce.number().positive(),
		hostRatingMin: z.coerce.number().min(0).max(5),
		shipRatingMin: z.coerce.number().min(0).max(5),
		availabilityStartDate: z.string().refine(
			v => /\d{4}-\d{2}-\d{2}/.test(v),
			val => ({ message: `Invalid date: ${val}` }),
		),
		availabilityEndDate: z.string().refine(
			v => /\d{4}-\d{2}-\d{2}/.test(v),
			val => ({ message: `Invalid date: ${val}` }),
		),
	}),
)

console.log(result)

/*
Logs:

{
  starportIds: [ '123', '456' ],
  cityIds: [ '789', '101112' ],
  brandIds: [ '131415', '161718' ],
  modelIds: [ '192021', '222324' ],
  hostIds: [ '252627', '282930' ],
  capacityMin: 31,
  capacityMax: 32,
  dailyChargeMin: 33,
  dailyChargeMax: 34,
  hostRatingMin: 5,
  shipRatingMin: 4,
  availabilityStartDate: '2021-01-01',
  availabilityEndDate: '2021-01-02'
}
*/
```

The tricky bit is the fact that searchParams can have multiple of the same key (so you can't just do `searchParams.entries()`). So what my utility does is to first get all the properties on searchParams with `getAll`, then determines whether you were hoping for an array of values and if you are it will double check there's only one value and then add only one value to the resulting object. If you're hoping for an array then it leaves it as an array. If you were not hoping for an array but there's more than one value it leaves it as an array and the later `parse` call will result in an error (as desired).

My problem is that to determine whether you want an array I need to inspect the schema you've provided and it looks like I'm using a pseudo-private API for that (and TypeScript isn't happy with that). Specifically the `_def` property.

Is there a better way to do what I'm doing?

EDIT: I changed from `schema: z.ZodSchema<SchemaType>` to `schema: z.ZodObject<SchemaType>` and that made TypeScript much happier. But I still want to make sure that there's no better way to do this since I'm using a pseudo-private property ðŸ˜…

EDIT 2: I handled other zod types that wrap the array type so you can use `default`, `optional`, `union` etc.",,
1497010438,1696,Feature Request: Context Data for custom validations,"It would be great if custom validations with refine or superRefine could access data that is given as a parameter to parse, parseAsync, safeParse or safeParseAsync.

Joi for example allows to give a context object as a second parameter to its validate function which then can be evaluated in custom rules.",,
1496398521,1694,"add access to RawCreateParams[""description""] in errorMap context","I would like to generate labelled error messages. Let's say I have the following:

```ts
const Place = z.string({description: ""place""}).min(1)
```

Setting errorMap
```ts
z.setErrorMap((issue, ctx) => {
  // ... to_small && type string
  return {message: `${ctx.description}: should contain at least ${issue.minimum} character(s)`}
  // ...
})
```

Now I can pass errorMap to the type constructor like z.string and hence the description is accessible in the context. But not in the refinements. And you also have to pass the function to all types explicitly. There is the possibility to create a helper function that constructs the rawParams, however the chainable and flexible api makes wrapping and extending sometimes a huge pain ain ass. Example: z.array() and z.type().array().

maybe for this purpose you can also use a more appropriate field name like ""label"" instead of ""description"". To be honest I did not find any use-case for the ""description"" field in RawCreateParams so far and it seems to be undocumented.

Motivation: Sometimes you might want to just list problems if you don't have a (typical) form. So it would be useful if error messages could  be labelled.

I can then map the issues to a string[] of errors.",,
1496230889,1693,Is it normal that a Tuple is valid if a value is empty ? ,"[Zod v.3.20.2]

Hello, I'm a in use case where I can have tuple like that: `[<1 empty>, ""toto""]`
In this case the safeParse method return a success with `[""toto""]` in `result.data`. Is this the expected behavior ?
I found no ""simple"" way to make the parser return an error. (Maybe by using .refine or by creating a custom rule)


Code to reproduce in RunKit
```ts
  var z = require(""zod"")
  
  const test = []
  
  test[1] = ""toto""
  
  const ZodTupleTest = z.tuple([z.number(), z.string()]);
  
  ZodTupleTest.safeParse(test)
```

That said, it's a very usefull lib ;) ",,
1496027394,1692,Feature Request: pattern properties in `z.object({})`,"JSON schema provides the possibility to define a regex that is tested against property names. If it matches, the respective property needs to fit the defined schema.

If I understand correctly, such functionality could already be implemented in `zod` using a refinement. However, I think, it would be beneficial to have this kind of functionality without the need for custom logic. That is, because then tooling built on top of `zod` could translate these requirements in a standardized way, e.g. JSON schema as mentioned above.

Proposal:
```typescript
const CustomProperty = z.string()

const objectWithPatternProperties = z.object({}).setKeyPattern(/^x-[a-z-]+$/, CustomProperty)
```

Haven't contributed to `sod` yet, but I'd be happy to give it a try myself :)",,
1495445587,1690,required should remove defaults,"At the moment required only removes optionality rather than defaults.
This leads to somewhat nonintuitive behavior:

```ts
const t = z.object({ foo: z.string().default("""") });  // foo is optional in input
const t2 = z.required({ foo: true }); // foo is still optional in input
t2.parse({}); // is ok but shouldn't
```",,
1495294803,1689,Inferred recursive types,"I'm working on a library that needs type definitions at runtime, and I wanted to use Zod as it's the _â€œlingua francaâ€_ of runtime type definitions. However, my library will make heavy use of recursive types, and working with these is currently very cumbersome in Zod. The [Recursive types section](https://zod.dev/?id=recursive-types) of the documentation reads:
> You can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can't be statically inferred. Instead you'll need to define the type definition manually, and provide it to Zod as a ""type hint"".
> Unfortunately this code is a bit duplicative, since you're declaring the types twice: once in the interface and again in the Zod definition.

I wonder if such a limitation is necessary, since TypeScript supports recursion even on anonymous types. For example, if we define the following helper types...
```typescript
const TAG = Symbol('TAG');
type Tag<N extends string> = { [TAG]: N };
type RecursiveType<Name extends string, Self extends object, O = Self>
    = O extends Tag<Name> ? RecursiveType<Name, Self>
    : O extends Array<infer V> ? Array<RecursiveType<Name, Self, V>>
    : O extends object ? { [K in keyof O]: RecursiveType<Name, Self, O[K]> }
    : O;
```
... we can create the `Category` type without having its definition reference itself:
```typescript
type Category = RecursiveType<'Cat', {
  name: string;
  subcategories: Tag<'Cat'>[];
}>;

const x: Category = { name: ""foo"", subcategories: [42] }; // error
const y: Category = {
  name: ""bar"",
  subcategories: [
    { name: ""qux"", subcategories: [] }
  ]
}; // ok
```
[Link to TS Playground.](https://www.typescriptlang.org/play?#code/FAehAIAsFMBsAdoCcDOxgGMD2A7FAXcAFQEEBxcAXnAGUBPAWwCMtYAKAclLI4EoBuYPjqJiAQwDmAHgBy4aAA980HABMU4AkgCWOCQD4q4AN7gA2twC6ALnByAvoOGiAStAwBXVNoBu0IiLQsmIM0PJKKuqa+Dp6ADS0cABm4cpqGlhMAFbu+AkA8kY0yfrA4OVGhYppUUSSwaGGAPzgbp7efgGIDdAJxbBJpRXgtlUR6eAkSEhidFK6ScjgAGrNk9OzUm1eKL7+gT19yQmrQxWjqZEZ2bngLaZmANLguuAA1tB0WCn5Nq3uOz2XSCMhCvUSAwKT0shnsZXO4HygnQYHASABHTCzjCqmgSV02nw2lw6Gx4AAwmJlBIsEg6EZtpjgVIOJT8BwEsZ4TgwbYtLoJIJyigPEwMFToDSdNAULY6tJWVSOPozJZBPZ9MjQBBFCF4LAZehsHhCApbGzJbT6dRTDzQrYAERJLBYB0JEViiVS7Qy2xmAAsACZLOBHOBUcgkLTMLgCOA6OavVajFzynboI6mGIkG74R7xdTaT7ZeZ4eVbbzwA6AI4eBRuzSiguW6Ul1Wh+GWYBh1FYN7AIA)

It is then hard to imagine that Zod couldn't support recursive types with full static inference using an API like this:
```typescript
const Category = z.label('Cat', z.object({
  name: z.string(),
  subcategories: z.ref('Cat').array(),
}));
```

Is there a good reason why this isn't a part of Zod already? Or should I try to make a PR for this?

----

**EDIT:** Changed the last code snippet, so that it uses methods `z.label` and `z.ref` instead of `z.recursiveType` and `z.tag`, becaue I think the new methods are easier to understand.",,
1494533813,1687,zod url fails when having port number and field/value pairs,"### Discussed in https://github.com/colinhacks/zod/discussions/1479

<div type='discussions-op-text'>

<sup>Originally posted by **RicardoValero95** October 11, 2022</sup>
This url works fine
`""sqlserver://database-test.amazonaws.com;database=x;user=y;password=z;trustServerCertificate=true""`

But this doesn't
`""sqlserver://192.168.100.10:1433;database=x;user=y;password=z;trustServerCertificate=true""`

</div>",,
1494051678,1685,"Smileys are allowed in email, both name and domain","teðŸ˜€st@mðŸ˜€ail.com is a valid email address from Zod perspective
",,
1492860132,1682,Preprocess breaks relationship between TypeOf<T>/infer<T> and ZodType<T>,"Given a generic T, I'm trying to type the result of a function as the schema which can create T. This breaks however if the schema has a preprocessed field. I've broken the issue down to:

```Typescript
import { z, ZodType, ZodtypeDef } from 'zod'

const noPreprocessObjSchema = z.object({
  date: z.date(),
});
type NoPreprocessObj = z.infer<typeof noPreprocessObjSchema>;

const preprocessObjSchema = z.object({
  date: z.preprocess(
    (arg) => (typeof arg === 'string' ? new Date(arg) : arg),
    z.date(),
  ),
});
type PreprocessObj = z.infer<typeof preprocessObjSchema>;

const noPreprocessParser: z.ZodType<NoPreprocessObj> = noPreprocessObjSchema;
const preprocessParser: z.ZodType<PreprocessObj> = preprocessObjSchema; // Error:Â The types of '_input.date' are incompatible between these types. Type 'unknown' is not assignable to type 'Date'
```

Is the recommend solution that I type the prepocessor as `ZodType<Date, ZodTypeDef, Date>`?",,
1492815263,1681,add `ZodURL` to validate parts of a url.,"Hey ðŸ‘‹ 

Currently we got `z.string().url()`. It remains a string after the check.
There are more things we could validate in a url, but it'll feel really awkward to put url-specific methods on `ZodString`.

Now that we have `z.coerce` & `z.pipe`, might be a good idea to add the following options:

```ts
z.url(); // native `URL` instance.
z.coerce.url(); // coerce to native `URL` instance.
z.string().transform(value => new URL(value)).pipe(z.url());  // pipe to native `URL` instance for further checks.
```

and have checks like:

```ts
z.url().protocol('https');
z.url().port(1234);
z.url().search({
  age: z.coerce.number().int().min(1),
}); // alternatively could be called `searchParams`.
z.url().username('admin');
z.url().password('123456789');
z.url().pathname(/^\/users\/\d+\/settings$/);
// etc. etc..
```



-----

I'd love to open a PR if this sounds good..",,
1492714503,1679,v3.20 and v3.20.1 breaks my app for some reason,"Probably something (a regex?) iOS can't handle.

<img width=""483"" alt=""Screenshot 2022-12-12 at 21 39 10"" src=""https://user-images.githubusercontent.com/66249/207149660-56fea993-66b7-4736-ad94-51e8ceee540d.png"">
",,
1492637621,1677,3.20: ZodString::isDatetime â€” Cannot read properties of undefined,"Reproduction

```ts
const schema = z.string().datetime();
const { isDatetime } = schema;
isDatetime(); // TypeError: Cannot read properties of undefined (reading '_def')
```

does not affect `isEmail`.

Most likely reason is that `isDatetime` described as method, not getter prop like `isEmail`.
It's unbound.

```ts
// source
    isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === ""datetime"");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === ""email"");
    }
```",,
1492531328,1676,[Date] Parsing of DateOnly strings,"3.20 introduced `z.string().DateTime()` for cleaner string->DateTime parsing. However, it only supports strings containing both Date _and_ Time

An API I'm working with includes only the Date part (today would be `2022-12-12`). This API is written in C# using the [DateOnly](https://learn.microsoft.com/en-us/dotnet/api/system.dateonly?view=net-7.0) struct.

The built-in JavaScript `new Date(<string>)` does work with DateOnly strings, so I don't see a huge reason not to support it as well. I don't know what the API for it would be though, but the two most obvious ones that I could think of are the following:

1. An additional option in the `string().DateTime()` function: `dateOnly: boolean`
2. A separate `string().Date()` function (or `string().DateOnly()`)

(As an aside, C# also has a [TimeOnly](https://learn.microsoft.com/en-us/dotnet/api/system.timeonly?view=net-7.0) struct, but I don't really see how that would be parseable into a JavaScript primitive)",,
1492222007,1673,.catch callback method runs even if parsing succeeds,"Example:

```js
const q = require('zod').number().catch(() => { console.log('run') })
q.parse(10); // returns 10

// but this logs ""run""
```

In this example, I wouldn't expect the callback to `catch` to run - that would match the behavior of `Promise#catch`.",,
1492194342,1672,"Unexpected `z.coerce.boolean()` result with ""false""","Yes, yes, it makes sense that what you are doing under the hood is `Boolean(""whatever"")` and that means `Boolean(""false"")` equates to true... 

But I believe this is a silly enough gotcha that it is worth to note in the docs.. 
Or even if there was a `z.coerce.boolean({ treatStringFalseAsFalse: true })` 

I just don't want people to get confused.. 

```ts
Number(String(123)) === 123 // makes sense
Boolean(String(false)) !== false // will be a head scratcher at first glance
```",,
1492079254,1671,date validation optional not working,"Hello i am trying to validate date but i want it optional that means if the user enter a date then validate it but if he/she left it with no value i don't want to validate it.
`birth_date: zod.date().optional(),`
that's not worked for me",,
1491773219,1669,3.20 introduced breaking change for `ZodDiscriminatedUnionDef`,"I just wanted to note that 3.20, while claiming to have no breaking changes, did change the number of type arguments for `ZodDiscriminatedUnionDef` from 3 to 2. This led to breakages such as https://github.com/StefanTerdell/zod-to-json-schema/issues/31, which may be tricky to navigate in a cross-version-compatible manner.",,
1491713155,1668,Safari Unsupported Email Regex,"The email regex defined here https://github.com/colinhacks/zod/blob/master/src/types.ts#L518 is not supported on Safari.
```TypeScript
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
// eslint-disable-next-line
const emailRegex =
  /^(([^<>()[\].,;:\s@""]+(\.[^<>()[\].,;:\s@""]+)*)|("".+""))@((?!-)([^<>()[\].,;:\s@""]+\.)+[^<>()[\].,;:\s@""]{2,})(?<!-)$/i;
```

This is the problematic capture group: `(?<!-)`. This is a negative lookbehind, which isn't supported on Safari https://caniuse.com/js-regexp-lookbehind. Sorry, I'm not sure what it should be re-written to, but I find that https://regexr.com/ is fantastic for testing regular expressions (and highlights the issue with the negative lookbehind too).",,
1491021677,1667,[BETA 3.20] Using transforms with discriminatedUnion,"### Issue
I'd like to use Zod to label my parsed data and use it in a discriminatedUnion

Example:
```javascript
import { z } from ""zod"";

const NotFoundSchema = z
  .undefined()
  .transform(() => ({ _tag: ""not_found"" as const }));
const SuccessSchema = z.object({ status: z.number().min(200).max(299) }).transform(x=> ({...x, _tag: ""success"" as const}));
const InternalErrorSchema = z.object({ status: z.number().min(500).max(599) }).transform(x=> ({...x, _tag: ""internal_error"" as const}));

// Type 'ZodEffects<ZodObject<{ status: ZodNumber; }, ""strip"", ZodTypeAny, { status: number; }, { status: number; }>, { _tag: ""internal_error""; status: number; }, { status: number; }>' is missing the following properties from type 'ZodObject<{ _tag: ZodTypeAny; } & ZodRawShape, any, any, { [x: string]: any; }, { [x: string]: any; }>': _cached, _getCached, shape, strict, and 14 more.ts(2740)ZodTypeAny; } & ZodRawShape, any, any, { [x: string]: any; }, { [x: string]: any; }>': _cached, _getCached, shape, strict, and 14 more.ts(2740)
const ResponseStatusSchema = z.discriminatedUnion(""_tag"", [
  InternalErrorSchema,
  SuccessSchema,
  NotFoundSchema
]);

ResponseStatusSchema.parse({status:500})
```

https://codesandbox.io/s/confident-stallman-l1ej5p?file=/src/index.tsx

I thought 3.20 addressed this with #1290

If this is something Zod does not intend to cover, any recommendations on a working alternative?  I currently use ts-pattern to pattern match out the correct item after using Zod to parse, but it's twice the work as Zod could give me the pattern match for free while parsing.

Thanks!",,
1489326176,1665,Docs in PDF for offline reading,"I just created the Zod docs in pdf for offline reading. 
You can find it out from https://read-doc-download-pdf.vercel.app/#src=/docs/frameworks/zod/en/index.html.
You need to print it out as PDF.
I just needed it for myself but I thought someone may want to read it offline as well, so here you go.
",,
1489242527,1664,adding generics to an inferred type,"Is there a way to add generics to a type that is generated using z.infer? Here's what I am trying to achieve:
```
const Schema = z.object({
    run: z.function().args(z.any({description: 'this is the value i want to make as generic'})).returns(z.number())
})
type Schema = z.infer<typeof Schema>

// pseudo code i want to achieve
const userSchema: ColumnSchema<{name: string}> = {
    run: (user) => {
        return user.name.length
    }
}
```",,
1488302723,1661,Getting maxLength,"Hi.
I want to check if a property of a schema has a maxLength.
If I try the following I get an error because unwrap() either does NOT exist because it's not optional OR because .maxLength does not exist on on it if it IS optional
ERROR IS - Property 'maxLength' does not exist on type 'ZodOptional<ZodString>'.

```ts
const maxLen = PatientDetails.shape.familyName.isOptional()
    ? PatientDetails.shape.familyName.unwrap().maxLength || undefined
    : PatientDetails.shape.familyName.maxLength || undefined
```
I just want to reliable check if it has a maxLength or not no matter if it optional or not.

Anybody know how to do this ??? I am sing TypeScript if that make any difference i.e the above failure.",,
1485355600,1656,Is there a validation type for zod types themselves?,"First of all, thank you for your work - great library!

Say I need to parse/validate an object where certain values need to be a zod schema type. Example:

```
const Schema = z.object({
  name: z.optional(z.string()),
  description: z.optional(z.string()),
  schema: z.optional(
    z.record(
      z.union([
        // z.zodStringType(),
        // z.zodNumberType(),
        // z.zodBooleanType(),
      ])
    )
  ),
});

function parseSchema(schema: Schema) {
  return Schema.safeParse(schema);
}

parseSchema({
  name: ""User Schema"",
  description: ""This is a user schema."",
  schema: z.object({ firstName: z.string(), lastName: z.string() }),
});
```

Is there a built in way to achieve something like this? ",,
1485104730,1654,Match one or more schemas,"`.union`/`.or` will match against each schema in order and return the first match. However, I want to match one _or more_ schemas. There currently does not seem to be a way to do that with Zod.",,
1482671428,1649,Recursive Tuple not working as expected,"Hey all, sorry to bother you! I have a bit of a head scratcher here (this could just be a lack of typescript foo) I've been trying to do a recursive tuple using Zod and when I run my script I am getting the following error:
```
 return new TSError(diagnosticText, diagnosticCodes, diagnostics);
           ^
{ TSError: â¨¯ Unable to compile TypeScript:
examples/Markdown.ts:87:14 - error TS2322: Type 'ZodLazy<ZodTuple<[ZodUnion<[ZodNativeEnum<{ readonly A: ""a""; readonly ABBR: ""abbr""; readonly ACRONYM: ""acronym""; readonly B: ""b""; readonly BDO: ""bdo""; readonly BI: ""big""; readonly BR: ""br""; readonly BUTTON: ""button""; ... 24 more ...; readonly VAR: ""var""; }>, ZodNativeEnum<...>]>, ZodObject<...>, ZodNullable<...>], n...' is not assignable to type 'ZodType<Markdown, ZodTypeDef, Markdown>'.
  Types of property '_type' are incompatible.
    Type '[""object"" | ""map"" | ""code"" | ""address"" | ""article"" | ""aside"" | ""blockquote"" | ""canvas"" | ""dd"" | ""div"" | ""dl"" | ""dt"" | ""fieldset"" | ""figcaption"" | ""figure"" | ""footer"" | ""form"" | ... 49 more ... | ""var"", {}, Markdown[], ...unknown[]]' is not assignable to type 'Markdown'.
      Target allows only 3 element(s) but source may have more.

87 export const Markdown: z.ZodType<Markdown> = z.lazy(() =
```
This is my actual code implementation: **Markdown.ts**
```typescript
// TAGS has been simplified here for readability
const TAGS = { BR: ""br"", P: ""p"", SPAN: ""span"" } as const

type Children = string | Markdown

type Markdown = [
  typeof TAGS[keyof typeof TAGS],
  {},
  Children[] | null
]


export const Markdown: z.ZodType<Markdown> = z.lazy(() =>
  z.tuple([
    z.nativeEnum(TAGS),
    z.object({}),
    z.nullable(z.array(Markdown))
  ])
)

// This typing works:
const sample: Markdown = [
  ""p"",
  {},
  [
    ""Let us know how we can help!"",
    [
      ""br"",
      {},
      null
    ],
    [
      ""span"",
      {},
      [
        ""Hello Jim!""
      ]
    ]
  ]
]
```

I then have a little node script that I run to take the schemas and generate JSON Schemas from this and that is where the error is thrown, but it appears to be an actual Typescript error. The Markdown.ts file doesn't show any Typescript errors, the type that I use with the `sample` data seems to work a okay, and this error appears at run time. I'm not sure if this is maybe me not groking Typescript tuples well enough or if this should theoretically be working and there is something not aligning on the zod side of things.

",,
1480430145,1647,Inner discriminated union,"**Issue statement:**

As developer, I want to be able to create sub-unions under union without requirement to change parent-union key or within

[Playground](https://codesandbox.io/s/recursing-ully-i2286z)

**Expected behaviour:**

- All tests are passed

**Current behaviour:**

```
/sandbox/node_modules/zod/lib/types.js:1457
            throw new Error(""The discriminator value could not be extracted from all the provided schemas"");
                  ^
Error: The discriminator value could not be extracted from all the provided schemas
    at Object.create (/sandbox/node_modules/zod/lib/types.js:1457:19)
    at Object.<anonymous> (/sandbox/src/index.ts:7:15)
    at Module._compile (node:internal/modules/cjs/loader:1105:14)
    at Module.m._compile (/sandbox/node_modules/ts-node/src/index.ts:1597:23)
    at Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Object.require.extensions.<computed> [as .ts] (/sandbox/node_modules/ts-node/src/index.ts:1600:12)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)
    at phase4 (/sandbox/node_modules/ts-node/src/bin.ts:579:12)
```

**Repro code:**

```typescript
import test from ""tape"";
import { z } from ""zod"";

const carScheme = z.object({
  name: z.string(),
  settings: z.discriminatedUnion<""model"", string, any>(""model"", [
    z.object({ model: z.literal(""AI-controlled""), copilot: z.boolean() }),
    z.object({
      model: z.literal(""Human-controlled""),
      copilot: z.literal(false)
    }),
    z.discriminatedUnion<""network"", string, any>(""network"", [
      z.object({
        model: z.literal(""Human-controlled-2""),
        network: z.literal(""Wi-Fi"")
      }),
      z.object({
        model: z.literal(""Human-controlled-2""),
        network: z.literal(""Bluetooth"")
      })
    ])
  ])
});

test(""valid for 1"", (t) => {
  t.true(
    carScheme.safeParse({
      name: ""valid"",
      settings: {
        model: ""AI-controlled"",
        copilot: true
      }
    }).success
  );
  t.end();
});

test(""valid for 2"", (t) => {
  t.false(
    carScheme.safeParse({
      name: ""valid"",
      settings: {
        model: ""Human-controlled"",
        copilot: false
      }
    }).success
  );
  t.end();
});

test(""valid for 3"", (t) => {
  t.false(
    carScheme.safeParse({
      name: ""valid"",
      settings: {
        model: ""Human-controlled-2"",
        network: ""Bluetooth""
      }
    }).success
  );
  t.end();
});

test(""valid for 4"", (t) => {
  t.false(
    carScheme.safeParse({
      name: ""valid"",
      settings: {
        model: ""Human-controlled-2"",
        network: ""Wi-fi""
      }
    }).success
  );
  t.end();
});
```

",,
1479770431,1646,Issue/PR review help and Roadmap,"Hi @colinhacks! Like many other folks, I'm really happy with `zod`'s no nonsense approach (I chafed one too many people with `io-ts` in the past). It's become a fun package I plan on spending more time helping on, and it seems that's the case for others too based on the [number of PRs](https://github.com/colinhacks/zod/pulls). 

With that said, some of the issues are pretty old (with the oldest one at around [~2 yrs](https://github.com/colinhacks/zod/issues/97)). Also [some issues aren't truly ""stale""](https://github.com/colinhacks/zod/issues/1075#issuecomment-1253254225) and the stalebot seems a bit aggressive. I realize this isn't _that_ bad for a 14k repo - but I'm sure you are quite busy, so I'm wondering if there's a place where the community can get a sense of where you need help the most, or what your feature roadmap is? I took a look but couldn't find one readily available. 

I started poking around at the oldest issues and encouraging folks to triage/self-report the still valid ones. However, I suppose you will want to at some point start saying ""yea or nay"" to some recurring themes along with ideas on implementation (i8n, etc). 

Perhaps you are already doing this, but do you have other trusted collaborators with issue triage/PR review/merge privileges? Otherwise it'd be great to give people some heads-up that the turnaround time might be longer than they expect. 

My whole thrust is to help you help us! A good turnaround on PR review and issue closure keeps the package healthy and makes newcomers (like myself) eager to contribute. Not to mention that it develops a sense of commitment to quality and shared ownership. Would love to hear your thoughts. Thanks again for this great tool!",,
1479686335,1645,Q: Any easy way to translate error messages?,"Hi,

Is there a general way to translate error messages to a single or multiple languages? 

Let's say pass a property containing all error properties to be translated, be static or dynamic (given values), to a main instance of zod or something alike?

From what I currently see, I have to pass to every single validation in every schema, so, repetition.",,
1479645902,1644,Recursive type with discriminated union,"Hey ðŸ‘‹

How to transform this recursive discriminated union to zod?

```ts
interface TextInput {
  type: 'text-input';
}

interface Group {
  type: 'group';
  components: AppComponent[];
}

type AppComponent = TextInput | Group;
```

what would the zod version look like?

My attempt:

```ts
import { z } from 'zod';

const TextInputSchema = z.object({
    type: z.literal('text-input'),
});

const GroupSchema = z.object({
    type: z.literal('group'),
    components: z.array(ComponentSchema),
});

const ComponentSchema = z.discriminatedUnion('type', [TextInputSchema, GroupSchema]);

```

but that doesn't work due to the error that `[...] type is referenced directly or indirectly in its own initializer`.",,
1479516836,1643,Schema introspection of optional or required fields,"Hello to everybody,
I am building my forms with zod as a validation solution. Currently I am struggling with finding out, if a field inside an object is required or not. I use this, to display the red asterisk next to a form field so that my schema definition from zod is used for the display and always in sync with the user interface. I have been using the following snippet which has worked out so far:

```ts
const isRequired = (name, schema) => !schema._def.shape()[name]?.isOptional(),
```

This introspects the schema deeper in the tree of my components and checks if inside the `_def.shape()` object there is a field with `name` that is not optional. 

Right now I have a more complex form approach where I am using `superRefine` to manually add issues for a field to be required so this approach doesn't work:

```ts
const schema = z.object({
  attendeeType: z.nativeEnum(AttendeeType),
  company: z.string().optional(),
}).superRefine(({ attendeeType, company }, { addIssue }) => {
  if (attendeeType === AttendeeType.BUSINESS && !company) {
    addIssue({
      code: TOO_SMALL, 
      inclusive: true,
      minimum: 1,
      path: ['company'], 
      type: 'string' 
    })
  }
})
```

Has someone an idea how I get this information for all cases?",,
1478767883,1639,Encapsulates the response logic of safeParse and return a discriminated union,"Hi,

how can I do a reusable generic function to encapsulate the logic of the `safeParse` discriminated response?, something like
```typescript
function zodParse<T>(schema: ZodSchema, fetchResult: any): {
  success: false,
  error: ZodError,
  message: string
} | {
  success: true,
  data: T,
} {
  const parsedResult = schema.safeParse(await fetchResult.json())
  if (!parsedResult.success) {
    return { success: false, error: parsedResult.error, message: parsedResult.error.message }
  }
  return { success: true, data: parsedResult.data } // how to return the type passed on schema?
}

```

I would like to be able to call this function in a return and capture the types where I call the function. I am trying to do it but I get only the field that is in both results objects `success`

![image](https://user-images.githubusercontent.com/4810013/205883669-3e776a5f-d5bb-4731-ae7c-28059f8e6472.png)


Any help appreciated,
Thanks

",,
1477981961,1638,[Bug]Error validate email,"- I use zod and react-hook-form when I validate emails but adding a dash at the end doesn't trigger the error

- I tried using emailRegex in zod doc but no error trigger

- I'm wondering if the problem is there or not?

- I tried with yup and got the trigger error

```
import { useCallback, VFC } from ""react"";
import { SubmitHandler, useForm } from ""react-hook-form"";
import { zodResolver } from ""@hookform/resolvers/zod"";
import * as z from ""zod"";

const auth = z.object({
  email: z
    .string()
    .email(""æ­£ã—ã„ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„""),
  password: z.string()
});


const user = z.object({
  firstName: z
    .string()
    .min(1, { message: ""1æ–‡å­—ä»¥ä¸Šå…¥åŠ›ã—ã¦ãã ã•ã„"" })
    .max(10, { message: ""10æ–‡å­—ä»¥ä¸‹ã§å…¥åŠ›ã—ã¦ãã ã•ã„"" }),
  lastName: z
    .string()
    .min(1, { message: ""1æ–‡å­—ä»¥ä¸Šå…¥åŠ›ã—ã¦ãã ã•ã„"" })
    .max(10, { message: ""10æ–‡å­—ä»¥ä¸‹ã§å…¥åŠ›ã—ã¦ãã ã•ã„"" }),
  phoneNumber: z.string().regex(/^0\d{9,10}$/, {
    message: ""æ­£ã—ã„é›»è©±ç•ªå·ã®å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„""
  }),
  role: z.enum([""admin"", ""user""])
});
```
![image](https://user-images.githubusercontent.com/39109300/205795003-f7fcd40f-0524-4714-9226-e664d4e4a938.png)

![image](https://user-images.githubusercontent.com/39109300/205794262-5b0b6c51-6ecf-4bfe-a500-a443cbc4ce8d.png)

![image](https://user-images.githubusercontent.com/39109300/205794327-b13a71ff-e8f0-4df6-8fae-7238d4b54a6e.png)




",,
1477307694,1637,Get all possible ZodErrors from a Schema,"Hello! I am creating an API framework that uses Zod to guarantee full type-safety, and the unique part in my framework is the ability to output ""types"" for every route, automatically. (This allows a frontend/developer to interact with the backend/API, and have 100% type-safety, automatically)


This type-safety *includes errors* that can come from the userInput being invalid.

I'm able to get the ""input"" from [zod-to-ts](https://github.com/sachinraja/zod-to-ts), but this doesn't have anything for the expected ""output"" types, or errors.


Effectively, I'm not sure how to do *any* of the following. Any tips or advice would be appreciated. I'm not sure if it's even possible, so :)

```
const example = z.object({
	simple: z.string(), // How can I get the possible ""z.string()"" error?

	// How can I get the ""default"" value? ""my-default""
	default: z.string().default('my-default'),

	// Doing it with messages wouldn't be a fun way to do it, but that's a backup method I could do (if absolutely necessary)
        // but... I'm not sure how to even get access to the message :P
	message: z.string().refine((value) => value.length > 10, { message: 'The length must be greater than 10.' }),

	// How can I get access to the ""refine"" errors?
	refinedToLength: z.string().refine((value) => value.length > 10),

	// The initial input is a String, but this isn't specified? Is it possible to specify this?
	// Additionally, how can I get the ""input"", AND the ""output""?
	preprocessedToNumber: z.preprocess((val) => Number(val), z.number()), // todo I have no idea how this works

	// Ideally, it would work for a combination of these as well (preprocesses, transforms, refines, etc)
	multipleTransforms: z
		.string()
		.transform((value) => value.length)
		.transform((value) => value + 1),
});
```

The format of the errors doesn't really matter; I just need some way to know what all valid errors are :)
Thanks in advance!",,
1476852578,1636,"[Bug] Different result for infer and parse using ""and"" and ""passthrough""","The type from `z.infer<typeof schema>` does not allow `a.z`, but the result from `schema.parse` returns it. See example below:

```typescript
import * as z from 'zod'

const a = z.object({
  a: z.object({
    x: z.string(),
  }),
})

const b = z.object({
  b: z.object({
    y: z.string(),
  }),
}).passthrough()

const schema = a.and(b)

type Test = z.infer<typeof schema>

const test: Test = {
  a: { x: 'foo', z: 'bar' }, // ts complains about ""z"" here
  b: { y: 'foobar' },
}

const parsed = schema.parse(test)

console.log(parsed)
// { a: { x: 'foo', z: 'bar' }, b: { y: 'foobar' } }
```

Btw, thanks for a fantastic library. If there's anything I can help with, let me know.",,
1476441121,1634,`z.custom<T>()` documentation missing.,"Sometimes we just want the type inferences, but not checking them.

The `z.as<T>()` can give you the ability to still use the Type inference but you don't need to change the `T` also to a Zod object.

For example, we can use it like this:
```ts
const HandleFuncZod = z.any().as<(
	req: IncomingMessage,
	res: ServerResponse
) => void>()
type HandleFunc = z.infer<typeof HandleFuncZod>
```

Because we are not able to transform the IncomingMessage and ServerResponse into zod objects and we actually don't need to do that. This is nice hook in many cases. 

The checking process is still available. For example:
```ts
const TaskZod = z.object({
	id: z.string()
}).as<{
	content: TaskContent,
	id: string
}>()
type Task = z.infer<typeof TaskZod>
```

Zod will still check the object being passed to the `.parse()` function by this: `z.object({
	id: z.string()
})`. But the type `Task` is being inferred as `{
	content: TaskContent,
	id: string
}`.

This feature is providing a nice flexibility. Before this, we can probably only use Zod in some data checks because there are many datas that don't need to be checked and types that can't be used in Zod (e.g. the IncomingMessage in the http module) (or using them for the entire app with a bunch of trivial tricks). But after this, Zod can be used in the whole app.",,
1476301342,1633,Type inference with `.default()` isn't telling the right thing,"If we have a Zod type:
```ts
const ExampleZod = z.number().default(0)
type Example = z.infer<typeof ExampleZod>
```

The type of Example is `number` but not `number | undefined`.

It already has a default value, why is it still required?",,
1474879296,1630,[Suggestion] Stricter boolean coerce option,"Since we're currently using Svelte Kit with form actions that make heavy use of the [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) browser api, the new Zod 3.20 release is a very much welcome improvement, specifically the new coercion functionality (since all form post values are serialized as strings over the wire).

One suggestion/request I have is to allow boolean coerce to take a `strict` option that would check for explicit boolean strings:

_Current:_

```js
const schema = z.coerce.boolean();
schema.parse(""true""); // => true
schema.parse(""false""); // => true
```

_Suggestion:_

```js
const schema = z.coerce.boolean({ strict: true });
schema.parse(""true""); // => true
schema.parse(""false""); // => false
schema.parse(""123""); // => ZodError
```

_Update: If you're using SvelteKit like me, then worth taking a look at [sveltekit-superforms](https://github.com/ciscoheat/sveltekit-superforms). We're using it now and haven't looked back._",,
1474210267,1628,Field becomes optional when value is any or unknown,"```ts
const s = z.object({ x: z.unknown() })
type s = z.infer<typeof s>
// s has { x?: unknown } but should be { x: unknown }
```

",,
1474102414,1627,Impossible to provide custom issue code,"In your [documentation](https://zod.dev/ERROR_HANDLING?id=zodissuecode) said

> This is the error code throw by refinements (unless you are using `superRefine` in which case it's possible to throw issues of any `code`)

But when i provide custom code TS complains
```
TS2322: Type '""duplicated_id""' is not assignable to type '""invalid_enum_value"" | ""invalid_type"" | ""unrecognized_keys"" | ""invalid_literal"" | ""invalid_union"" | ""invalid_union_discriminator"" | ""invalid_arguments"" | ""invalid_return_type"" | ... 6 more ... | ""too_small""'.```",,
1473617256,1626,[Feature request] Make fields important,"It would be good a feature like:

`
const schema = z.object({
  id: z.number().positive().important(),
  name: z.string().min(5),
  ...
});
`

That would stop/break all the validation if has an error in the chain order.

It could also be used like:

`
const schema = z.object({
  id: z.number().positive(),
  name: z.string().min(5),
  ...
}).important({
  id: true
});
`

So for example if the field `id` has an error the field `name` would not be validated, is a good idea when you have for example refines that depend on top data, hope this can be implemented, Thanks. :)",,
1473567185,1625,Problem when specifying which properties to make required,"Following the example in the [readme.required](https://github.com/colinhacks/zod#required):

```
const user = z.object({
  email: z.string(),
  username: z.string(),
}).partial();

const requiredEmail = user.required({
  email: true,
})
```

<img width=""314"" alt=""Screenshot 2022-12-02 at 4 14 05 PM"" src=""https://user-images.githubusercontent.com/9437192/205404896-7dde9a8d-7198-42b2-bc16-2997a670c4eb.png"">

I get the following error

> Expected 0 arguments, but got 1.
",,
1470209599,1622,Better localisation support,"The ability to localize error messages should be made easier. For example, the default mapping make use of `util` in `../helpers/util` which does not seem to be exported.

Are localised errors a planned feature? If so, then `src/errors.ts` will have to export them externally (i.e. make them available). There is also the question of using [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) with or without region names? ",,
1469294711,1618,Nested discriminated unions,"I have a hierarchy of objects, where the first level uses a `type`-property to discriminate, and the second level uses a `subtype`.

An example diagram showing 3 instances on the first level (Foo, Bar & Baz), and then Baz having two subtypes under it (Able & Baker):

```
    [root]
   /  |   \
Foo  Bar   Baz
          /   \
        Able  Baker
```

It's possible to type this in TS with something like
```
type NestedDu = 
   { type: ""foo"" }
 | { type: ""bar"" }
 | { type: ""baz"", subtype: ""able"" }
 | { type: ""baz"", subtype: ""baker"" };
```
(Of course there are more fields on each property, but just keeping it minimal for the ease of understanding)

I tried to construct a Zod-schema using the following
```
const nestedDU = z.discriminatedUnion('type', [
    z.object({
        ""type"": z.literal(""foo"")
    }),
    z.object({
        ""type"": z.literal(""bar"")
    }),
    z.discriminatedUnion('subtype', [
        z.object({
            ""type"": z.literal(""baz""),
            ""subtype"": z.literal(""able"")
        }),
        z.object({
            ""type"": z.literal(""baz""),
            ""subtype"": z.literal(""baker"")
        }),
    ]),
]);
```

But this doesn't work, since the outer discriminated union doesn't allow the inner one. 

Is there any way to make this work as-is - or would it need additional work on Zod itself to make it work? I can try to create a PR if needed, but maybe it's already possible and I'm just missing something.

Kind regards
Morten",,
1469103177,1616,ZodFormattedError does not propagate the custom error format to recursive fields,"`ZodFormattedError` accepts two type params. 

```ts
export type ZodFormattedError<T, U = string>
```

`T` is the type of the input schema and `U` is the type of each error entry. `U` is important when [providing a custom issue mapper](https://github.com/colinhacks/zod/blob/0c4fc53239e89b4349559c7cdb4bc50c5442ab49/src/ZodError.ts#L204). `ZodFormattedError` uses `T` to define the shape of the formatted error object, but it does not propagate `U` to the fields of this object. E.g.:

```ts
... ZodFormattedError<NonNullable<T>[K]>
```

This means that typing fails when trying to access custom error types of a `ZodFormattedError.

Example: the following code should pass typechecking [sandbox](https://codesandbox.io/s/typescript-playground-export-forked-f7llzb?file=/index.ts:0-310):

```ts
import { z } from ""zod"";

const Thing = z.object({
  name: z.string().min(2)
});

const result = Thing.safeParse({ name: ""a"" });
if (!result.success) {
  const formatted = result.error.format((issue) => ({
    code: issue.code,
    message: issue.message
  }));
  console.log(formatted.name?._errors?.code);
}
```

But instead it fails with `Property 'code' does not exist on type 'string[]'.ts(2339)'",,
1468306756,1614,How to implement a generic fetch function that validates the query parameter and json result,"I'm trying to implement a generic fetch function that abstracts away the validation of the query parameters and the json return using `zod` schemas.
I came up with the following prototype but cannot seem to figure out how to type the zod schema parameter:

```typescript
import {z} from 'zod';

const zodFetch = async <TQuerySchema, TResponseSchema>(url: string, querySchema: TQuerySchema, query: z.infer<typeof TQuerySchema>, responseSchema: TResponseSchema): Promise<z.infer<typeof TResponseSchema>> => {
	const response = await fetch(url, {
		method: 'POST',
		headers: {
			'content-type': 'application/json;charset=UTF-8',
		},
		body: JSON.stringify({
			query: querySchema.parse(query),
		}),
	});

	return responseSchema.parse(await response.json());
};


const test = async () => {
	const fooSchema = z.number();
	const barSchema = z.string();

	const response = await zodFetch('https://foobar', fooSchema, 1, barSchema);

	console.log(response);
};

void test();
```",,
1466989509,1611,Create exact error message for z.array().length().,"Given this schema:

`const testSchema = z.array(z.number()).length(4);`

For arrays with less than 4 elements, it returns the message: 
>Should have at least 4 items

For arrays with more than 4 elements, it returns the message: 
>Should have at most 4 items

I wish instead for it to return a message explaining that it should be precisely 4 items:
>  Should have exactly 4 items

I know I could achieve that with a custom refine validation, but it would be nice to have it baked in.

Of course, if you find this suggestion valid, I could make a PR for it.",,
1466417805,1610,Nested discriminated unions,"I've got an object that has discriminated unions within discriminated unions:

```json
[
  {
    ""_id"": ""98439752-0cd4-406b-982f-1bbf1df5480d"",
    ""type"": ""data"",
    ""subtype"": ""subtype-1"",
    ""data"": {
      ""id"": ""a8d44d3f-c18a-4178-990c-f543ab8f3a8d"",
      ""url"": ""https://www.google.com"",
      ""title"": {
        ""en"": ""English title""
      }
    }
  },
  {
    ""_id"": ""4f674fe7-368f-4b15-924b-7e61dd982961"",
    ""type"": ""data"",
    ""subtype"": ""subtype-2"",
    ""data"": {
      ""id"": ""160a6427-ec74-4488-bceb-8cebac86b55f"",
      ""path"": ""/"",
      ""description"": ""this is another subtype""
    }
  },
  {
    ""_id"": ""aba34b25-8a33-4046-a62f-c5ff9a6befef"",
    ""type"": ""reference"",
    ""referent"": {
      ""id"": ""b940a1e8-3733-425f-b1ef-667c2ecdab04"",
      ""type"": ""document""
    }
  },
  {
    ""_id"": ""aba34b25-8a33-4046-a62f-c5ff9a6befef"",
    ""type"": ""reference"",
    ""referent"": {
      ""id"": ""b940a1e8-3733-425f-b1ef-667c2ecdab04"",
      ""type"": ""file""
    }
  }
]
```

On the first level the type discriminator is the field `type`. For `type: 'data'`, we can further discriminate the type by the field `subtype`.

When I try to do this with nested usage of `discriminatedUnion` like this:

```ts
import { z } from 'zod';

import data from './data.json';

const ReferenceSchema = z.object({
  _id: z.string(),
  type: z.literal('reference'),
  referent: z.object({
    id: z.string(),
    type: z.enum(['document', 'file']),
  }),
});

const Subtype1Schema = z.object({
  _id: z.string(),
  type: z.literal('data'),
  subtype: z.literal('subtype-1'),
  data: z.object({
    id: z.string(),
    url: z.string().url(),
    title: z.object({
      en: z.string(),
    }),
  }),
});

const Subtype2Schema = z.object({
  _id: z.string(),
  type: z.literal('data'),
  subtype: z.literal('subtype-2'),
  data: z.object({
    id: z.string(),
    path: z.string(),
    description: z.string(),
  }),
});

const DataSchemma = z.discriminatedUnion('subtype', [
  Subtype1Schema,
  Subtype2Schema,
]);

export const Schema = z.array(
  z.discriminatedUnion('type', [ReferenceSchema, DataSchemma])
);

const rc = Schema.parse(data);
```

I get an error saying:

> Error: The discriminator value could not be extracted from all the provided schemas

How can I achieve that once my code checks if `type === 'data'` TypeScript knows that now, there's a field `subtype` and an object called `data`?

_You can play with this example here: https://stackblitz.com/edit/typescript-piewve?devToolsHeight=33&file=index.ts_",,
1465115850,1606,"Add an option to all checks (.min(), .url(), .regex(), ...) to abort early","In some cases, it might be desirable to abort early in any of the type specific validations - checks - like `.min`, `.url`, `.regex` and so on.
An example of this being useful is when they validate a parameter later used in an async refine (#1605), so without aborting early, the async refine is executed with an invalid input.
Currently, you can work around this by implementing these checks yourself using `superRefine`, but it's unnecessarily tedious and verbose. A much simpler way would be to add a `fatal` field to the checks' `message` parameter.",,
1465071956,1605,Stop parsing by each field with error,"Is there a way to stop parsing each field with an error and return the string error, instead of keep parsing the others rules of the fields and get an array?
For example if I have a custom rule that makes a Http validation and the field has an error, I would not want to do the Http validation... an alternative would be to get in the context of `superRefine` if the field has an error.

Thanks!.",,
1464776357,1603,Add an option to .refine() to abort early,"As mentioned in https://github.com/colinhacks/zod#abort-early, chained refinements are all executed, which may not be desirable in all cases. That is why `superRefine` has a way of _aborting early_ - preventing further refinements from being executed.
I propose adding this functionality to `refine` too.",,
1464776242,1602,Add a way for .superRefine() to narrow down the output type,"Currently, `refine` has a type guard which is used to narrow down the output type.

```js
refine<RefinedOutput extends Output>(
  check: (arg: Output) => arg is RefinedOutput,
  message?: /* ... */
): ZodEffects<this, RefinedOutput, RefinedOutput>;

superRefine: (
  refinement: RefinementEffect<Output>[""refinement""]
) => ZodEffects<this, Output, Input>;
```
I propose adding this functionality to `superRefine` as well.",,
1463577316,1598,Chaining refinements which narrow down types gives them inconsistent runtime/static types,"Validation continues after an unsuccessful refine(), which gives it an incorrect return type and can make subsequent effects unexpectedly throw.

Code:
```ts
import { z } from 'zod';

const isNotNull = <T>(val: T | null): val is T => val !== null;

const userSchema = z
  .object({
    type: z.literal('Staff'),
    age: z.number(),
  })
  .nullable()
  // Type guard, I would expect validation to halt here if value is null
  .refine(isNotNull, { message: 'Choose a user type.', path: ['type'] })
  // User is infered as non-null
  .superRefine((user, ctx) => {
    // This should always return false (even according to TS), but it doesn't
    console.log(`superRefine: Is user null: ${user === null}`);
    // If user is null, we get an exception here
    if (user.age < 18) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
      });
    }
  });

const goodResult = userSchema.safeParse({
  type: 'Staff',
  age: 20,
});
console.log({
  success: goodResult.success,
  output: goodResult.success ? goodResult.data : goodResult.error.issues,
});
const issueResult = userSchema.safeParse({
  type: 'Staff',
  age: 15,
});
console.log({
  success: issueResult.success,
  output: issueResult.success ? issueResult.data : issueResult.error.issues,
});
const bugResult = userSchema.safeParse(null); // Exception
console.log({
  success: bugResult.success,
  output: bugResult.success ? bugResult.data : bugResult.error.issues,
});
```
Output:
```
superRefine: Is user null: false
{ success: true, output: { type: 'Staff', age: 20 } }
superRefine: Is user null: false
{
  success: false,
  output: [ { code: 'custom', path: [], message: 'Invalid input' } ]
}
superRefine: Is user null: true
[TypeError: Cannot read properties of null (reading 'age')]
```
Expected output (last line):
```
{
  success: false,
  output: [ { code: 'custom', message: 'Choose a user type.', path: [Array] } ]
}
```

Yes, there is an easy workaround by adding an `if (user !== null) return;` (which I have used for now). But the exception comes out of nowhere and the runtime type is different from the static type (TS tells us user can't be null) which can be very confusing and make the issue hard to find.",,
1463139017,1597,How to dinamically enable/disable optional parts of a schema?,"I have quite a regular situation when one edits more than one group of fields on a form. And depending on some conditions (f.e. checkbox states), those groups can be displayed/hidden and correspondingly - should be validated/skipped.

Consider this simple form:

![image](https://user-images.githubusercontent.com/114060/203760600-5b1fce41-c15e-4d01-96ed-0f20eac4151f.png)

So we enter first and last names, and if we check ""More information"", a new part appears with two additional fields: email and address.

Here is a sandbox:
https://codesandbox.io/s/zod-problem-forked-r7xmcm?file=/src/index.ts

There are two base schemas:

```ts
const group1Schema = z.object({
  firstName: z.string(),
  lastName: z.string()
});

const group2Schema = z.object({
  email: z.string().email(),
  address: z.string()
});
```

And one with their combination for the form:

```ts
const schema = z.object({
  group1: group1Schema,
  group2: group2Schema.optional(),
  needGroup2: z.boolean()
});
```

The problem is that now it's not possible to submit this form w/o the second (optional) part.

There is no form in this sandbox (to keep it minimal) but there is the `defaultValues` const which imitates the corresponding property of the ReactHookForm `useForm()` hook.

As you see, you cannot even initialize such a form with empty values because they get validated and validation doesn't pass. Of course, this is expected behaviour, granted how I declared the schemas. 

Hence my question: **how to conditionally enable/disable parts of the schema**?

This form should pass to its submit handler the following:

1) if only first and last name entered and the checkbox is off:

```json5
{
 group1: {
   firstName: ""value"",
    lastName: ""value""
  },
  needGroup2: false // or underfined
}
```

2) if all values are entered and the checkbox is on:

```json5
{
 group1: {
    firstName: ""value"",
    lastName: ""value""
  },
  group2: {
    email: ""value@domain.com"",
    address: ""Some address...""
  },
  needGroup2: true
}
```

3) **IMPORTANT** if all values are entered, but the checkbox is OFF, the group2 should be discarded, and the result should be equal to the 1st reply:

```json5
{
 group1: {
    firstName: ""value"",
    lastName: ""value""
  },
  needGroup2: true
}
```

If you have any other ideas on how to solve such tasks, please share.

",,
1463083764,1595,Allows enum to be upper and lowercase,"Example
```ts
enum TERRITORIES {
US = 'US'
}

const territory = [TERRITORIES.US, TERRITORIES.US.toLowercase()] as const;

export const obj = z.object({
  territory: z.enum(territory).transform((value) => value?.toUpperCase()),
});
export type OBJType = z.infer<typeof obj>;

const t: OBJType = {
  territory: 'DE', // this is valid ts which shouldnt be :(
};
```

This makes the output be a of type string as the transform changes its type.

We could have a `z.fussyEnum` property that could allows us to pass a enum value and the output would be transformed to the enum value but also accepts the input in lowecase

Example
```ts
enum TERRITORIES {
US = 'US'
}

const territory = [TERRITORIES.US, TERRITORIES.US.toLowercase()] as const;

export const obj = z.object({
  territory: z.fussyEnum(territory)
});
export type OBJType = z.infer<typeof obj>;

const t : OBJType = {
territory: 'us' // valid but when parsed would be transformed to 'US'
}
```",,
1462750262,1593,Add method to remove defaults,"It would be helpful to have a method that removes all defaults from an object. Similar to `.partial()` or `required()`.

My use case is that I have a type for validating API input for both create and update. On update, I want to accept partial input but not have the defaults applied again. I can construct this type manually, but it's painful on a large schema.",,
1462487464,1592,BigInt refinements,"My guess is to include most of what's available on `z.number()`

```ts
z.bigint().min(5);
z.bigint().max(5);
z.bigint().gt(5);
z.bigint().lt(5);
z.bigint().positive(); //     > 0
z.bigint().nonnegative(); //  >= 0
z.bigint().negative(); //     < 0
z.bigint().nonpositive(); //  <= 0
z.bigint().multipleOf(5);
```",,
1462172398,1590,Typescript widening object properties of Zod enum type to string,"If I define `enum` and use it in the object, the object property still has the type of the `enum`:
```ts
enum A { a = ""a"" }

const a = { a: A.a }
// type of a is { a: A }
```

However, if I define the same enum using zod, the type of object property is `string` and not narrowed to enum anymore.
```ts
const A = z.enum([""a""])

const a = { a: A.a }
// type of a is { a: string }
```
",,
1461812999,1588,Object partial becomes unavailable if used after refine,"I don't know if it was intentional, but I actually don't see the reason for this to be done.",,
1461146642,1585,Getting bad linter message with safeParse,"Hi I am getting a bad linter message whit the method `safeParse()`

![imagen](https://user-images.githubusercontent.com/4810013/203487176-0f2afe76-0af0-479f-b6a4-1c401ee76c0a.png)

The functionality its working fine.",,
1460511242,1583,docs: CONTRIBUTING.md has stale links,Currently the `CONTRIBUTING.md` file points to the `playground.ts` file under `src/`. Just some small housekeeping.,,
1460299386,1582,intersect mapped enum record and object,"How would I create the equivalent to this with `zod`?
```
enum Status {
  NotStarted = 'not-started',
  InProgress = 'in-progress',
  CompletedSuccesfully = 'completed-succesfully',
  CompletedWithFailures = 'completed-with-failures',
  Failed = 'failed',
}
type StatusReports = {
  [k in Status]: number;
};

type StatusReport = StatusReports & {
  total: number;
};
const sr: StatusReport = {
  total: 5,
  [Status.NotStarted]: 1,
  [Status.InProgress]: 1,
  [Status.CompletedSuccesfully]: 1,
  [Status.CompletedWithFailures]: 1,
  [Status.Failed]: 1,
};
```
## problems I've encountered so far

defining the mapped key type  for `StatusReports` with `z.record()` and `z.nativeEnum(}` yields `Partial<Record<Status, number>>;`,  with the mapped properties incorrectly being optional
```
enum Status {
  NotStarted = 'not-started',
  InProgress = 'in-progress',
  CompletedSuccesfully = 'completed-succesfully',
  CompletedWithFailures = 'completed-with-failures',
  Failed = 'failed',
}
const StatusReports = z.record(z.nativeEnum(Status), z.number());
const sr: z.infer<typeof StatusReports> = {}; // const sr : Partial<Record<Status, number>>
```
even if the mapped key properties were correctly inferred as required, I haven't figured out a way to merge `z.record()` with `z.object({total: number})`
using `z.intersection()` like so complies but throws the following error when parsed at runtime
```
const StatusReportSchema = z.intersection(
  z.record(StatusReports, z.number().min(0)),
  z.object({ total: z.number().min(0) }),
);
```
`""Invalid enum value. Expected 'not-started' | 'in-progress' | 'completed-succesfully' | 'completed-with-failures' | 'failed', received 'total'""`
",,
1460033280,1581,Date tests are failing due to mismatching timezone,"The following test (using `Jest`) is failing due to mismatching timezone. My timezone is `-03:00`, and if I create the date objects with my timezone, the tests pass. I believe that the Zod library might be handling something with the machine's timezone instead of the timezone of the dates passed

```ts
test(""date parser error messages"", () => {
  const schema = z.date();

  expect(getErrorMessage(schema.safeParse(""2022-12-01""))).toEqual(
    ""Expected date, received string""
  );
  expect(
    getErrorMessage(
      schema.min(new Date(""2022-08-01"")).safeParse(new Date(""2022-07-29""))
    )
  ).toEqual(`Date must be greater than or equal to 8/1/2022`);
  expect(
    getErrorMessage(
      schema.max(new Date(""2022-08-01"")).safeParse(new Date(""2022-08-02""))
    )
  ).toEqual(`Date must be smaller than or equal to 8/1/2022`);
});
```

![image](https://user-images.githubusercontent.com/36773088/203346017-213073af-3464-40e9-b1fa-1e7538f31118.png)
",,
1459866338,1580,Property 'datetime' does not exist on type 'ZodString'.,"Since i am new to zod, i've been reading the documentation for a while and found the [z.string().datetime()](https://github.com/colinhacks/zod#datetime-validation) method.

However, when I tried that method on my project, I got an error that's says `Property 'datetime' does not exist on type 'ZodString'`.
![image](https://user-images.githubusercontent.com/97936043/203324675-14450d4e-bb02-4db5-8cfb-0b91b53486b0.png)


do you guys have any workaround for this problem?
",,
1459548825,1578,How to get the latest shape of a schema?,"Given the following schema, fetching the `literal` value is quite trivial:

```ts
const schema = z.object({ x: z.literal(""asd"") }).shape.x.value;
  // ^? ""asd""
```

But if I apply any effect, I no longer have to `shape`, since the schema is no ZodEffects rather than ZodObject:

```ts
const schema = z
  .object({ x: z.literal(""asd"") })
  .transform((prev) => ({ ...prev, x: ""asd2"" }))
  .transform((prev) => ({ ...prev, x: ""asd3"" }));
```

Is there a way I could do something like `schema.getFinalShape().x.value`?

I was able to write something like:

```ts
const schema = z
  .object({ x: z.literal(""asd"") })
  .transform((prev) => ({ ...prev, x: ""asd2"" }))
  .transform((prev) => ({ ...prev, x: ""asd3"" }))
  // .refine((prev) => prev.x === ""asd3""); // <-- this would break the function

function getFinalShapeOfZodObjectOrZodEffects<
  T extends z.ZodObject<any> | z.ZodEffects<any, any, any>
>(schema: T): z.infer<T> {
  if (schema instanceof z.ZodObject) {
    return schema.shape;
  }

  if (schema instanceof z.ZodEffects && schema._def.effect.type === ""transform"") {
    return schema._def.effect.transform(null, { addIssue: () => {}, path: [] }); // <-- It's a bit awkward
  }
}
```

but it would fail if the last ""effect"" would be a ""refinement"".",,
1458971713,1576,CHANGELOG.md is out of date,"Hey ðŸ‘‹ , thanks for your work on this project!

I was caught out today by the CHANGELOG.md file being out of date with the latest published Zod releases. If the changelog's no longer being updated, should it be removed altogether?",,
1456292482,1573,Union behaves differently depending on order,"Used `v3.19.1`.

`Union` seems to behave differently depending on the order.

```typescript
const Foo = z
  .object({
    a: z.number(),
    b: z.number(),
  })
  .partial();

const Bar = z
  .object({
    x: z.number(),
    y: z.number(),
  })
  .partial();

// the order of Foo and Bar is reversed
const Baz = z.union([Foo, Bar]);
const Qux = z.union([Bar, Foo]);

const onlyA = { a: 1 };
const onlyX = { x: 8 };
const all = { a: 1, b: 2, x: 8, y: 9 };

console.log(Baz.parse(onlyA)); // { a: 1 }
console.log(Qux.parse(onlyA)); // {}

console.log(Baz.parse(onlyX)); // {}
console.log(Qux.parse(onlyX)); // { x: 8 }

console.log(Baz.parse(all)); // { a: 1, b: 2 }
console.log(Qux.parse(all)); // { x: 8, y: 9 }
```

Is this expected behavior?
If so, I would appreciate it if you could tell me what I should do to achieve what I want to do.

**I want to express the following**
Object with optional properties `a` and `b`
or
Object with optional properties `x` and `y`

So I would expect a result like below.

```typescript
ExpectedSchema.parse({ a: 1, b: 2 }) // { a: 1, b: 2 }
ExpectedSchema.parse({ a: 1 }) // { a: 1 }
ExpectedSchema.parse({ x: 8, y: 9 }) // { x: 8, y: 9 }
ExpectedSchema.parse({ x: 8 }) // { x: 8 }
ExpectedSchema.parse({ c: 3 }) // {}

ExpectedSchema.parse({ a: 1, x: 8 }) // Error
ExpectedSchema.parse({ a: 1, b: 2, x: 8 }) // Error
```
",,
1455851160,1572,In the case of use `union` or `or` with an object it only parse to the first schema,"I have the following code:

```typescript
import { z } from 'zod';

export const todoSchema = z.object({
  id: z.string().uuid(),
  title: z.string().trim().min(1),
  completed: z.boolean().default(false),
  order: z.number().positive().default(1),
});

export const updateTodoSchema = z.union([
  todoSchema.pick({ completed: true }),
  todoSchema.pick({ order: true }),
  todoSchema.pick({ title: true }),
]);
```

I expect to receive an object with only one property to update `{ completed: boolean }` or `{ order: number }` or `{ title: string }`

But only the object with `completed` gets parsed, in the other cases the property is deleted and set `completed` to its default value

```typescript
updateTodoSchema.parse({ order: 2 });
// { completed: false }
```

## How to reproduce

Open https://stackblitz.com/edit/zod-union?file=src/schemas.spec.ts

In the console run:
```
npm run build; npm test
```",,
1455557621,1571,Pass schema to function and it returns infer-ed type of schema,"Hey, thank you so much for this library, it is awesome!!

I try to achieve validation function for http responses, that could:

1. accept  response schema as argument
2. validate response against schema
3. return validated response or throw an error

Below is my maximum I could create :sweat_smile:  and it works in simple cases.

```ts
async function requestWithValidate<T>(
	httpCall: () => Promise<unknown>,
	schema: z.ZodSchema<T>
): Promise<T> {
	try {
		const response = await httpCall();
		return schema.parse(response);
	} catch (e) {
		if (e instanceof ZodError) {
			e = e.format();
		}
		throw e;
	}
};
```

However, when I pass schema that contains `ZodEffect`(schema field with pre-processor for example) I have type incompatibility.
I have it for `Date` fields and for them I get `Type 'unknown' is not assignable to type 'Date'`

Pre-processor:
``` ts
const stringToDateConvert = z.preprocess((arg) => {
    if (typeof arg === 'string' || arg instanceof Date) {
        return new Date(arg);
    }
}, z.date());
```
Example schema:
``` typescript
z.object({
    id: z.number(),
    date: stringToDateConvert.nullable(),
}).nullable();
```

Could you please help with setup of generics for this function that could work even with any Zod type?",,
1454372602,1569,ZodObject.pick() looses shape type when schema is created via a function,"This is a similar issue to #1453 but relates to the pick function instead of the merge function and the workaround which @elmeister suggested of proving an explicit return type for the factory function does not appear to work here.

<hr />

Given a schema like:
```typescript
const baseSchema = z.object({
  foo: z.string(),
  bar: z.string()
});
```

If a subset of keys are picked from it like so:
```typescript
const schemaSubset = baseSchema.pick({ foo: true });
```

Then the infered type preduced by the schema should be an object with just that subset of keys, which it does:
![Screen Shot 2022-11-18 at 14 09 13](https://user-images.githubusercontent.com/346340/202608113-b747e365-519f-45af-bc41-cf5432005bb7.png)

However if a factory pattern is used to construct that subset schema like so:
```typescript
type ZodGetShape<Schema extends z.AnyZodObject> = ReturnType<
  Schema[""_def""][""shape""]
>;

function createSchema<
  BaseSchema extends z.ZodObject<ZodRawShape>,
  KeysSubsetObject extends { [k in keyof ZodGetShape<BaseSchema>]?: true }
>(baseSchema: BaseSchema, keysSubsetObject: KeysSubsetObject) {
  return baseSchema.pick(keysSubsetObject);
}
```
And a new schema is created using that function:
```typescript
  const schemaSubset = createSchema(baseSchema, { foo: true });
```

Then the type of resulting schema is just an empty object which is not very helpful:
![image](https://user-images.githubusercontent.com/346340/202608368-43d3c8bd-00d1-4f43-bdd9-fb52a1b18655.png)

I attempted to work around this by providing an explicit return type based on the [return type of ZodObject's pick function](https://github.com/colinhacks/zod/blob/6ce18f3de2ce29c3c3eb35ac08983d181311b40e/src/types.ts#L2018):

```typescript
type ZodGetShape<Schema extends z.AnyZodObject> = ReturnType<
  Schema[""_def""][""shape""]
>;

type ZodPick<
  BaseSchema extends z.AnyZodObject,
  Mask extends { [k in keyof ZodGetShape<BaseSchema>]?: true }
> = z.ZodObject<
  Pick<
    ZodGetShape<BaseSchema>,
    Extract<keyof ZodGetShape<BaseSchema>, keyof Mask>
  >,
  BaseSchema[""_def""][""unknownKeys""],
  BaseSchema[""_def""][""catchall""]
>;
```

This this ment the factory function now returns the correct type, however instead an error is given when attempting to return the new schema:
```typescript
function createSchema<
  BaseSchema extends z.ZodObject<ZodRawShape>,
  KeysSubsetObject extends { [k in keyof ZodGetShape<BaseSchema>]?: true }
>(
  baseSchema: BaseSchema,
  keysSubsetObject: KeysSubsetObject
): ZodPick<BaseSchema, KeysSubsetObject> {
  // If the return type for this function is correct then this should not fail but it does
  return baseSchema.pick(keysSubsetObject);
}
```
```
Type 'ZodObject<Pick<ZodRawShape, Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject>>, ""strip"", ZodTypeAny, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }>' is not assignable to type 'ZodPick<BaseSchema, KeysSubsetObject>'.
  Type 'Pick<ZodRawShape, Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject>>' is not assignable to type 'Pick<ReturnType<BaseSchema[""_def""][""shape""]>, Extract<keyof ReturnType<BaseSchema[""_def""][""shape""]>, keyof KeysSubsetObject>>'.
    Type 'Extract<keyof ReturnType<BaseSchema[""_def""][""shape""]>, keyof KeysSubsetObject>' is not assignable to type 'Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject>'.
      Type 'keyof KeysSubsetObject & keyof ReturnType<BaseSchema[""_def""][""shape""]>' is not assignable to type 'Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject>'.
        Type 'keyof KeysSubsetObject & keyof ReturnType<BaseSchema[""_def""][""shape""]>' is not assignable to type 'Extract<number, keyof KeysSubsetObject>'.
          Type 'Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject> | Extract<symbol, keyof KeysSubsetObject>' is not assignable to type 'Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject>'.
            Type 'Extract<symbol, keyof KeysSubsetObject>' is not assignable to type 'Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject>'.
              Type 'keyof KeysSubsetObject & symbol' is not assignable to type 'Extract<string, keyof KeysSubsetObject> | Extract<number, keyof KeysSubsetObject>'.
                Type 'keyof KeysSubsetObject & symbol' is not assignable to type 'Extract<number, keyof KeysSubsetObject>'.
                  Type 'Extract<symbol, keyof KeysSubsetObject>' is not assignable to type 'Extract<number, keyof KeysSubsetObject>'.
                    Type 'keyof KeysSubsetObject & symbol' is not assignable to type 'Extract<number, keyof KeysSubsetObject>'.
                      Type 'Extract<keyof ReturnType<BaseSchema[""_def""][""shape""]>, keyof KeysSubsetObject>' is not assignable to type 'Extract<number, keyof KeysSubsetObject>'.
                        Type 'keyof KeysSubsetObject & keyof ReturnType<BaseSchema[""_def""][""shape""]>' is not assignable to type 'Extract<number, keyof KeysSubsetObject>'.
                          Type 'keyof KeysSubsetObject & keyof ReturnType<BaseSchema[""_def""][""shape""]>' is not assignable to type 'keyof KeysSubsetObject & number'.
                            Type 'keyof KeysSubsetObject & keyof ReturnType<BaseSchema[""_def""][""shape""]>' is not assignable to type 'number'.ts(2322)
```

I've created a live example here and you can observe the constructed types by hovering over the relevant sections of code: https://codesandbox.io/s/zod-pick-typescript-issue-oskpx8",,
1453781375,1568,Contribute to Zod ESLint,"Hey @colinhacks and others,

I've started working on ESLint rules specific to Zod.

https://github.com/gajus/eslint-plugin-zod

The immediate use case was to ensure that we always use `strict()` when initializing objects.

However, I invite others to suggest ideas for other rules that you have use cases for and contribute them.",,
1452958750,1566,Intersection does not work with Date and Error,"I found two different cases where intersection does not work.

First with Date:
```typescript
const Schema = z.instanceof(Date).and(z.object({ foo: z.string().optional() }));
const date: z.infer<typeof Schema> = new Date();
date.foo = ""bar"";

const t = Schema.parse(date);
```
should work but it throws an error
```
Uncaught ZodError: [
  {
    ""code"": ""invalid_type"",
    ""expected"": ""object"",
    ""received"": ""date"",
    ""path"": [],
    ""message"": ""Expected object, received date""
  }
]
```


Then with Error:
```typescript
const Schema = z.instanceof(Error).and(z.object({ foo: z.string().optional() }));
const error: z.infer<typeof Schema> = new Error();
error.foo = ""bar"";

const parsed = Schema.parse(error); // { foo: 'bar' }
parsed instanceof Error; // false
```
the object returned by parse() does not match the type of the schema.

I might create two separated issues if you prefer.

This issue might be related to https://github.com/colinhacks/zod/issues/1471",,
1452172268,1563,"`pick`, `omit`, `require` & `partial` should use arrays instead of objects","I was wondering what the rationale behind `pick`, `omit`, `require` and `partial` expecting objects is?

Each value is optional and can only be true, so using
```ts
.pick(['foo', 'bar'])
```
feels more sensible than
```ts
.pick({ foo: true, bar: true })
```

There is another reason than convenience:  
Currently you can (accidentally) add properties, which do not exist on the original object.  
With an array you could ensure type safety.  

The signature would look like this
```ts
pick<Mask extends Array<keyof T>>(mask: Mask): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall>;
```

If you agree I could offer to implement this.
Either in a backwards compatible way (also accepting objects, using overloads) or as a breaking change.",,
1451014858,1562,Deep Pick/Omit,"It would be cool if we could extend the existing pick/omit utilities to pick/omit deeply where possible.

eg.

```ts
const DeepSchema = z.object({
    a: z.object({
      b: z.string(),
      c: z.string(),
    }),
  });
  
const DeepPickSchema = DeepSchema.pick({
  a: { b: true }
});

// Equivalent of:
z.object({
  a: DeepSchema.shape.a.pick( { b: true } )
});
```

I'm trying to work on this now but it's difficult to tame the types! 

This seems to work for the input of mask:

```ts
type DeepMask<T> = T extends ZodObject<infer Shape>
  ? DeepMask<Shape>
  : T extends ZodRawShape
  ? {
      [k in keyof T]?: true | DeepMask<T[k]>;
    }
  : never;
```",,
1450669504,1561,Property 'catch' does not exist on type 'ZodNumber'.,"Sorry for bothering you guys. I ran an example from the `README.md` and it's not compiling. Am I doing something wrong?

**Code:**

```typescript
import { z } from ""zod"";

const numberWithCatch = z.number().catch(42);

numberWithCatch.parse(5); // => 5
numberWithCatch.parse(""tuna""); // => 42
```
**Error:**

```
/home/<user>/.nvm/versions/node/v16.16.0/lib/node_modules/ts-node/src/index.ts:859
    return new TSError(diagnosticText, diagnosticCodes, diagnostics);
           ^
TSError: â¨¯ Unable to compile TypeScript:
trash/zod.ts:3:36 - error TS2339: Property 'catch' does not exist on type 'ZodNumber'.

3 const numberWithCatch = z.number().catch(42);
                                     ~~~~~

    at createTSError (/home/<user>/.nvm/versions/node/v16.16.0/lib/node_modules/ts-node/src/in
dex.ts:859:12)
    at reportTSError (/home/<user>/.nvm/versions/node/v16.16.0/lib/node_modules/ts-node/src/in
dex.ts:863:19)
    at getOutput (/home/<user>/.nvm/versions/node/v16.16.0/lib/node_modules/ts-node/src/index.
ts:1077:36)
    at Object.compile (/home/<user>/.nvm/versions/node/v16.16.0/lib/node_modules/ts-node/src/i
ndex.ts:1433:41)
    at Module.m._compile (/home/<user>/.nvm/versions/node/v16.16.0/lib/node_modules/ts-node/sr
c/index.ts:1617:30)
    at Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Object.require.extensions.<computed> [as .ts] (/home/<user>/.nvm/versions/node/v16.16.0
/lib/node_modules/ts-node/src/index.ts:1621:12)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12) {
  diagnosticCodes: [ 2339 ]
}
```",,
1448548858,1560,Require numbers to be finite by default?,"https://github.com/colinhacks/zod/pull/1546 (closed #512) added a new way of specifying that numbers should be finite but didn't address the question of whether numbers should be required to be finite by default.

Would a pull request to make numbers finite by default be accepted? It would have to be a breaking change, but I think it would improve consistency and help prevent errors for most zod users.

From the previous issue:

> I'd prefer that the default number implementation disallow non-finite values, so that z.number().parse(Infinity) throws an error. I think it'd be consistent with rejecting Number.NaN, since Infinity is a number-like thing in javascript that's not really a number, and NaN is already disallowed.",,
1448151324,1559,Any Zod middleware validator?,"Hi there ðŸ‘‹ 

First of all, I'm amazed at how easy it is to work with Zod compared to my previous experience with Joi/Yup. Great job! ðŸ‘Œ 

We decide to go with Zod as it was a breezy experience to integrate into our TypeScript codebase (frontend/backend) and we are somewhat happy with our decision so far.

We are now using a custom middleware for validating payloads on Express which is the web framework we choose to go with years ago, but we couldn't find a decent alternative to [`celebrate`](https://github.com/arb/celebrate) at the moment, and [`express-zod-api`](https://github.com/RobinTail/express-zod-api) seems to be too much for us right now, but maybe in the following months, we'll find something or even refining our current in-house solution to an OSS. ðŸ‘€ 

We hope to see Zod being the next big thing by improving its performance and adoption. ðŸš€ ",,
1446317422,1554,Zod complaining non empty field is empty with SolidJS,"I am using the latest version of solid js with zod.
I have set up a schema and am using the ```extend: [ validator({ schema })]```. The problem is when I reactively update a Signal, the form inputs are updated with the latest input values, but for some reason Zod cannot see them and keeps throwing errors because it thinks the inputs are empty when they are not. Copy/pasting the values back into the inputs fixes the error messages.

 ```ts
const [profile, setProfile] = createSignal<Profile | null>();

function fetch(uuid: string): Promise<Profile> {
    return Client.get(id);
}

const { errors, form, isValid } = createForm({
    extend: [
        validator({ schema }),
    ],
    onSubmit: (formValues: any) => {
      // do update 	
    },
    onError: (e) => Logger(e),
});

function getprofile(uuid: string) {
        fetch(uuid)
            .then((res) => {
                if (res.success) {
                    if (res.data) {
                        setProfile(res.data);
                    }
                }
            });
}

export default (props: { id: string }) => {
    return (
        <>
            <Switch>
                <Match when={profile()}>
                    <StoreProvider store={profile}>
                        <ProfileForm
                            errors={errors}
                            form={form}
                            isValid={isValid()}
                        />
                    </StoreProvider>
                </Match>
            </Switch>
        </>
    );
};

```

ProfileForm:
```ts
export default (props: Props) => {
    const [profile] = useStore()!;
    const { form } = props;
    return (
    <form use:form>
        <section>
            <input text=""name"" value={profile().name} />
        </section>
    </form> 
    ); 
});
```

Schema:
```ts
export default z.object({
    name: z.string().min(1, 'Enter a profile name'),
});

```",,
1445338074,1553,"Question: json map(string, object)","Please can someone confirm if this is possible and steer me in the right direction? I've tried a number of ways but I'm not getting there

Sample that errors:

```javascript
  const MyobjJson = {
    ""addresses"": {
      ""roger"": {
        ""address"": ""some street""
      },
      ""peter"": {
        ""address"": ""other street""
      }
    }
  };
  
  const schemaAddress=z.object({
    address: z.string()
  });

  const schemaAddresses=z.map(z.string(), schemaAddress)
  
  const schemaMyobj = z.object({
    addresses: schemaAddresses
  });

  var r = schemaMyobj.parse(MyobjJson)
  console.log(r)
```

Error...

```txt
    ZodError: [
    {
      ""code"": ""invalid_type"",
      ""expected"": ""map"",
      ""received"": ""object"",
      ""path"": [
        ""addresses""
      ],
      ""message"": ""Expected map, received object""
    }
  ]
  ```",,
1444640737,1552,Typesafe way to re map tuple,"I would like to write a function that can transform the elements of a zod tuple in a typesafe way. the goal is to make all elements in a tuple optional i.e `z.tuple([z.string(), z.number()])` => `z.tuple([z.string().optional(), z.number().optional()])`. so far I've written `z.tuple(inputSchema.items.map((schema) => schema.optional()))` which seems to work at runtime, but causes typescript errors and doesn't preserve the types/order of the tuple items when using `z.infer`. any ideas?",,
1444583247,1551,Addition of ZodIssueCode.invalid_literal custom error message broken. ,"Reference commit: [Add invalid_literal issue](https://github.com/colinhacks/zod/commit/823dda93193ab23f07b7e4625e54b1e8528cc530#diff-c54113cf61ec99691748a3890bfbeb00e10efb3f0a76f03a0fd9ec49072e410a)

ZodLiteral takes a `RawCreateParams`object that allow to customize error message.

That object is passed through `processCreateParams()`, but that function has not been updated to support the Ã¬nvalid_literal` type.

Before the commit in reference, it was possible to customize the error message using the 'invalid_type_error' property. But since the issue code is now **invalid_literal** instead of **invalid_type**, the default error message is returned every time. ([types.ts#L118](https://github.com/colinhacks/zod/blob/c617ad3edbaf42971485f00042751771c335f9aa/src/types.ts#L118))

It still possible to customize the ZodLiteral error message by passing a custom ZodErrorMap, but I wonder if the current behavior brought by the change was really intended.",,
1442526430,1550,".required({requiredProperty: true}) expects 0 arguments, but got 1","```ts
const optionalObject = z
    .object({
        name: z.string({ required_error: r.name.required }).min(3, r.name.min).max(20, r.name.max).trim(),
        email: z.string({ required_error: r.email.required }).email(r.email.email).trim(),
        confEmail: z.string({ required_error: r.email.required }).email(r.email.email).trim(),
        request: z.string({ required_error: r.request.required }).min(3, r.request.min).trim(),
        acceptedTerms: z.literal(true, { required_error: r.acceptedTerms.oneOf }),
    })
    .partial()
const requiredObject = optionalObject.required({name: true})
```
When calling optionalObject.required({name: true}), typescript complains that it's expecting 0 arguments, but got 1.
Indeed, when checking the source code, there is only required().
But the docs are saying that:
""You can also specify which properties to make required:

```ts
const requiredEmail = user.required({
  email: true,
});
```
""
How can I make only a property required from the whole schema which was turned into optional by .partial()?
",,
1438447631,1547,Allow array to return only valid items and not fail whole array,"When validating an array, I would like to only return the valid items in an array and not fail if one item fails. 

This is a very basic example
```ts
const schema = z.object({
  arr: z.array(z.number())
})

const result = schema.safeParse({arr: [1,2,""3""]})
```

I would like this to return only the valid items
``` ts
arr: [1,2]
```

I tried using `refine` on the array, but it seems to only be called when the array validates correctly. Is there a way to do this, or is this something you'd be willing to support?
",,
1437075018,1541,Optional or Nullable fields generate poor typings for `z.inferFormattedError`,"![image](https://user-images.githubusercontent.com/34945114/200127889-5fd1afe1-ca14-4380-9544-943ae07283f5.png)

This is valid, and `y` represents a possible string error.

![image](https://user-images.githubusercontent.com/34945114/200127906-9a16bbf4-a7e4-43ad-ad29-789d0df30ebf.png)

This, or the same with `.nullable()` produces a type containing only `x.fields._error`, the array is missing entirely.

Errors *can* and *do* occur here, as is visible with `JSON.stringify()` or other type-independent viewing methods, but the type created by `z.inferFormattedError` is wrong.",,
1435064664,1540,How can I make a property optional without adding `undefined` to its type?,"I'm trying to parse values into this type:

```ts
type FormattedText = { text: string; bold?: true; };
```

The `bold` flag, if present, is always the value `true`. Example test cases:

```js
// Valid values include
{ text: ""foo"" }
{ text: ""foo"", bold: true }

// Invalid values include
{ text: ""foo"", bold: false }
{ text: ""foo"", bold: undefined }
```

(This schema is designed to work with [Slate](slatejs.org), and the values are in a database. The design is therefore non-negotiable.)

I can't figure out how to configure zod to make the `bold` property optional, without also adding `undefined` to the type of the property. The `.optional()` method seems to do conflate the two: it makes the property optional, but also allows the value `undefined` if present. For example, `zod.parse` allows the value `{ text: ""foo"", bold: undefined }`.

I realize I could do this with `.refine()`, but then the constraint is not represented in the type system. I want the type of `.parse()` to be `{ text: string; bold?: true; }`.",,
1434551517,1539,When merging two zod objects (using .extend) they are deemed not equal,"Apologies in advance if this is a problem with `@type-challenges/utils` but I've never known it to be wrong before. 

I need to get two separate types to align as I'm (annoyingly) working with two separate type systems; one pre-built the other inferred from a Zod schema. 

This works well other than using  `STest1.extend(STest2.shape)` where `STest1` & `STest2` are Zod schemas. Minimum viable example below

```ts
import type { Equal, Expect } from '@type-challenges/utils'
import { z } from 'zod'

const STest1 = z.object({ a: z.string() })
const STest2 = z.object({ b: z.boolean() })
const STest = STest1.extend(STest2.shape)

type TISTest1 = z.infer<typeof STest1> // irrelevant
type TISTest2 = z.infer<typeof STest2> // irrelevant
type TISTest = z.infer<typeof STest>

type TTest1 = { a: string }
type TTest2 = { b: boolean }
type TTest = TTest1 & TTest2

export type Cases = [Expect<Equal<TISTest, TTest>>]
```",,
1434508483,1538,Any possibilities of supporting Date/DateTime as a Zod literal along with some validation methods?,"Fix Could also include a few Date/DateTime-specific validations? examples of some that I can think of are, 
1. MaxDaysInBetween(int): returns int number of days
2. MinDaysInBetween(int): returns int number of days
3. IsBeforeDate(Date) : returns Boolean
4. IsAfterDate(Date) : returns Boolean
5. IsUTC(Date) : returns Boolean
6. IsTimeZone(TZ): returns Boolean

Not sure if this is a valid issue request? Apologies if this doesn't make sense.",,
1433203491,1536,Anyway to do forbidden properties that have a default?,"I would like to have an object like so:

```ts
export const register = z.object({
  email: z.string().email(),
  password: z.string().superRefine(password),
  first_name: z.string(),
  last_name: z.string(),
  role: z.literal('user'),
  is_email_verified: z.literal(false)
});
```

But in this object I don't want the role or user to be parsed in but I would like default values if this makes sense. In Joi I would do:

`role: Joi.forbidden().default('user')`

This way I can add values to the object that weren't there initially.

Is there any way to do this in zod?",,
1432955066,1535,required method expecting 0 arguments,"I'm trying to build schema validation with **partial and required**, but **required method is giving error saying it expects 0 arguments**. Here is a bit of code, where ValidationObjects are where schema has been defined,
```
static getSafeReportValidation(body: unknown) {
        const getSafeReport = SafeReportValidationObject.merge(AdminValidationObject)
            .merge(PaginationValidationObject)
            // .pick({
            //     anonymous: true,
            //     reportType: true,
            //     toDate: true,
            //     fromDate: true,
            //     adminId: true,
            //     adminType: true,
            //     currectPage: true,
            //     perPage: true
            // })
            .partial({anonymous: true, reportType: true, toDate: true, fromDate: true, adminId: true, adminType: true})
            .required();

        return getSafeReport.parse(body);
    }
```
",,
1432257118,1533,Would love a release with fix for #1176 in it,"Hi,

I'm just wondering when the next release is likely? I would love to start making use of the fix for https://github.com/colinhacks/zod/issues/1176

Thanks!",,
1428870614,1532,Parsing without validation,"Sometimes it is beneficial to be able to turn off the validation part of `safeParse` while preserving the serialization part of it.

Most common example - enabling reply validation in testing/staging, but disabling it in production for performance reasons.

If this change is approved, I can work on a PR for it.",,
1426368064,1529,[Feature suggestion] A way to chain/pipe validations,"Hello,

First of all, thank you for making and maintaining this awesome library.

I started using `zod` to validate forms on a frontend project, and found myself doing things like:

```ts
const FormData = z.object({
  age: z.string().transform((x, ctx) => {
    const value = parseInt(x)
    if (isNaN(value) || value < 0) {
      ctx.addIssue({code: z.ZodIssueCode.custom, message: 'should be a positif integer'})
      return z.NEVER
    }
    return value
  }),
  worked_days_in_month: z.string().transform((x, ctx) => {
    const value = parseInt(x)
    if (isNaN(value) || value < 0 || value > 31) {
      ctx.addIssue({code: z.ZodIssueCode.custom, message: 'should be an integer between 1 and 31'})
      return z.NEVER
    }
    return value
  }),
})
```

Since all values coming from the HTML inputs are strings, I have to validate them using `z.string` then use `.transform` to convert them to numbers and do additional validation.

I think it will be easier if after converting them to numbers, I could chain them to a `z.number` with some additional checks, something like:

```ts
const FormData = z.object({
  age: z.string().transform(x => parseInt(x)).chain(z.number().int().min(0)),
  worked_days_in_month: z.string().transform(x => parseInt(x)).chain(z.number().int().min(0).max(31)),
})
```

So my suggestion is to add a method `.chain` (or `.pipe` or other name ...) that behaves as follows:

```ts
const a: ZodType // with types: _input = A and _output = B
const b: ZodType // with types: _input = B and _output = C

const c = a.chain(b) // gives a ZodType with _input = A and _output = C
```

Let me know if this is something you would be interested in adding to the library, I can try to make a PR for it if you agree.",,
1425916728,1527,Recursive type with promise - Recursive property returns a unresolved promise,"Hello all,

I just came across a case that confuses me.

The APIs response has a recursive structure. The object returned from the function call to the API is a promise.

I'm somewhat following the docs having an interface and then calling 

```
[...]z.ZodType<Something> =
	z.lazy(() =>
		z.promise(
			z.object({[...]
```

The non-recursive attributes are resolved, but the attributes of the recursive property are now a promise (even though they are contained in the object I get back). Somehow I seem to be missing how I should explain that the outer object is a promise, not every recursive element in it.

Would appreciate it if someone could jump in with an explanation ðŸ‘
",,
1425321326,1526,z.date() does not pick custom error messages,"Using latest `""zod"": ""^3.19.1""`
```ts
import { z } from ""zod"";
...
      dateOfBirth: z
        .date({
          required_error: ""Please select a date and time"",
          invalid_type_error: ""That's not a date!""
        })
...
```
![Screenshot from 2022-10-27 12-22-23](https://user-images.githubusercontent.com/115006985/198247467-3b9bf5f6-1f3c-4467-9cd2-b51bb33ace07.png)

",,
1424242706,1523,Add support to conditional typings ,"Hi there,

I've been working on a feature with dynamic schemas that I need to validate some rules, but I'm having trouble with typescript errors in `refine` or `superRefine`.

```ts
import { z } from 'zod';

// Dynamic condition that the user can change, for example
let isForm1Active = false;

// Basic schema
const form1Schema = z.object({
  name: z.string(),
  age: z.number(),
});

// Dynamic schema
const schema = z
  .object({
    form1: isForm1Active ? form1Schema : z.unknown(),
  })
  .refine((args) => {
    // args.form1.name is not accessible, ok

    if (isForm1Active) {
      // args.form1.name is still not accessible
      // maybe here, like in union types in typescript, this should work?
    }
  });

```

Is there another way to work with dynamic items without losing the type safety of zod?

Live preview:
https://stackblitz.com/edit/typescript-kaf78i?file=index.ts

Thanks in advance and congratulations on this lib, the syntax to validate everything is so neat! 
",,
1423851712,1522,Feature Requests - Codec-like behavior and derivative schemas,"Hello! Once again I am finding myself with the same dragons I did a few months back (maybe you remember?)
I am now older and wiser, and can more accurately present what specific feature I'm missing!

I wish there was a way to make zod act as a codec / iso, so that given `unknown`, `A` output and `B` input, I can do the following
```ts
// encode has the signature of (value: number) => string, or maybe theres a type error if the chain of encodes doesn't end up with the original type
const Dto = z.string().transform(Number).transform(n => n * 2).encode(n => String(n/2)) // ZodCodec<number,string>

declare const someInput: unknown
const a = Dto.parse(someInput) // type number
const b = Dto.unparse(someInput) // type error, unknown is not number
const b = Dto.unparse(a) // type string
```
it can be sorta done manually right now, but requires 2 separate schemas instead of a schema and mapper
```ts
const Dto = z.string().transform(Number)
const ParsedDto = z.number().transform(String)

const a = Dto.parse(someInput) // number
const b = ParsedDto.parse(someInput) // string
const b = ParsedDto.parse(a) // string
```
------------------

Taking the previous idea further,
I wish something like a derivative schema is possible, currently this is what is required for a similar functionality
```ts
export const None = z.object({
  _tag: z.literal(""None""),
})

export const Some = <T extends z.ZodTypeAny>(schema: T) =>
  z.object({
    _tag: z.literal(""Some""),
    value: schema,
  })

export const Option = <T extends z.ZodTypeAny>(schema: T) =>
  z.discriminatedUnion(""_tag"", [None, Some(schema)])

declare const fromNullable: <A>(value: A | null | undefined) => Option<A>
declare const isSome: <A>(value: Option<A> ) => value is Some<A>

const Dragon = z.object({
  dragonName: z.string().array().transform(s => s.join(' ')), // string[] -> string
  humanName: z.string().nullish().transform(fromNullable) // string? -> Option<string>
})

const DragonFriend = z.object({
  dragonName: z.string(),
  humanName: Option(z.string())
})
```
But it could be much more succinct and less error-prone if I could do something like this:
```ts
declare const fromNullable: <A>(value: A | null | undefined) => Option<A>
declare const isSome: <A>(value: Option<A> ) => value is Some<A>


const Dragon = z.object({
  dragonName: z.string().array().transform(s => s.join(' ')), // string[] -> string
  humanName: z.string().nullish().transform(fromNullable) // string? -> Option<string>
})

const DragonFriend = z.derive(Dragon, {
  dragonName: schema => schema.transform(s => `${s} the kind-hearted`),
  humanName: schema => schema.transform(o => isSome(o) ? o.value : ""Colin"")
})
```
-----------

these 2 features are iterative over each other, since my implementation idea for deriving the schema was leveraging codecs giving me type-safety for ""reverse getting"" inputs from parsed values. Basically as long as the input of the derived schema (`DragonFriend`) is typesafe to the `unparse` of the the source schema (`Dragon`), you can basically unparse and re-parse to ensure that the input for the derived schema is legal for both the source and the iteration.

```ts

const Dragon = z.object({
  dragonName: z.string()
    .min(4)
    .array()
    .min(2)
    .transform(s => s.join(' '))
    .encode(a => a.split("" "")), // ZodCodec<string, string[]>
  humanName: z.string()
    .nullish()
    .transform(fromNullable)
    .encode(o => o.value) // ZodCodec<Option<string>, string | null | undefined>
})

// hopefully possible
const DragonFriend = z.derive(Dragon, {
  dragonName: schema => schema.transform(s => `${s} the kind-hearted`),
  humanName: schema => schema.transform(o => isSome(o) ? o.value : ""Colin"")
})
```
and abstractly under the hood of dragonName schema:
```ts
// idk it comes from somewhere 
declare const originalCodec: ZodCodec<string, string[]>

// the `schema => schema.transform(...)` from above
declare const newSchema: <Z extends ZodTypeAny, N extends ZodTypeAny>(schema: Z) => N

// DragonFriend.parse implementation
// unlike regular schemas, does not parse `unknown` to `Dragon`, it parses `Dragon` to `DragonFriend`
const derivedParse = (toParse: z.CodecOutput<typeof originalCodec>) /* string */ => {
    const codecInput = originalCodec.encode(toParse) // string[]
    return newSchema(originalCodec).parse(codecInput) // string
}
```
The above suggestion unparses the input to the `derivedParse` and then re-parses it, making sure that the given object is not just of type `Dragon`, it's also a _valid_ `Dragon` before it declares it to be a `DragonFriend`



",,
1423298534,1520,README nullable reference is missing,"I think at some point [nullableString was called D](https://github.com/colinhacks/zod/blob/82e72ad359a0758e8bba69794c2880bb6d96be1e/README.md?plain=1#L773-L786). 

We should update the readme file",,
1423298520,1519,Brand type README example not working,"Currently, [brand type example](
https://github.com/colinhacks/zod/blob/82e72ad359a0758e8bba69794c2880bb6d96be1e/README.md?plain=1#L1969-L1989) is not working correctly since there are a couple of parenthesis missing.",,
1423198836,1518,ZOD [Error]: Schema with id 'Schema' already declared,"I am new to Fastify and Typescript. I am working on adding Zod schemas for validation and I am getting this error:

```
/app/node_modules/fastify/lib/schemas.js:32
    throw new FST_ERR_SCH_ALREADY_PRESENT(id)
          ^
FastifyError [Error]: Schema with id 'Schema' already declared!
    at Schemas.add (/app/node_modules/fastify/lib/schemas.js:32:11)
    at SchemaController.add (/app/node_modules/fastify/lib/schema-controller.js:58:30)
    at Object.addSchema (/app/node_modules/fastify/fastify.js:601:29)
    at /app/src/index.ts:23:12
    at Generator.next (<anonymous>)
    at /app/src/index.ts:8:71
    at new Promise (<anonymous>)
    at __awaiter (/app/src/index.ts:4:12)
    at main (/app/src/index.ts:32:12)
    at Object.<anonymous> (/app/src/index.ts:63:1) {
  code: 'FST_ERR_SCH_ALREADY_PRESENT',
  statusCode: 500
```
From Fastify docs:

```
FST_ERR_SCH_ALREADY_PRESENT
A schema with the same $id already exists.
```
I am not sure where eaxctly is this $id being set

When I just had one schema and was adding it to fastify in index.ts it was working:

```
for (const schema of userSchemas) {
   server.addSchema(schema);
}
```

But adding another schema, throws the above error:

```
for (const schema of [...userSchemas, ...teamSchemas]) {
   server.addSchema(schema);
}
```
`package.json` versions

```
 ""fastify"": ""^4.6.0"",
 ""fastify-cors"": ""^6.1.0"",
 ""fastify-zod"": ""^1.2.0"",
 ""zod"": ""3.19.1"",
 ""zod-to-json-schema"": ""^3.18.1""
```

`user schema:`

```
import { z } from 'zod';
import { buildJsonSchemas } from 'fastify-zod';
import {
  CreateUserRequest,
  UpdateUserRequest,
  UserResponse
} from '../../services/user/interface';

const createUserSchema: z.ZodSchema<CreateUserRequest> = CreateUserRequest;

const updateUserSchema: z.ZodSchema<UpdateUserRequest> = UpdateUserRequest;

const responseUserSchema: z.ZodSchema<UserResponse> = UserResponse;

export const { schemas: userSchemas, $ref } = buildJsonSchemas({
  createUserSchema,
  updateUserSchema,
  responseUserSchema
});
```

`team schema`

```
import { buildJsonSchemas } from 'fastify-zod';
import { z } from 'zod';
import {
  CreateTeamRequest,
  TeamResponse,
  UpdateTeamRequest
} from '../../services/team/interface';

const createTeamSchema: z.ZodSchema<CreateTeamRequest> = CreateTeamRequest;

const updateTeamSchema: z.ZodSchema<UpdateTeamRequest> = UpdateTeamRequest;

const responseTeamSchema: z.ZodSchema<TeamResponse> = TeamResponse;

export const { schemas: teamSchemas, $ref } = buildJsonSchemas({
  createTeamSchema,
  updateTeamSchema,
  responseTeamSchema
});
```
Any idea what I maybe missing here.

Here is the complete SO question:
https://stackoverflow.com/questions/73980097/zod-error-schema-with-id-schema-already-declared",,
1421838103,1515,Update email regex to use W3C's one?,"There is no 100% bullet proof email regex, but should you update it to use W3C's one? Currently I'm facing a bug that `a\b@c.com` is passed, when W3C's regex wouldn't pass it.

Current zod regex for email is:
```
(/^(([^<>()[\]\.,;:\s@\""]+(\.[^<>()[\]\.,;:\s@\""]+)*)|(\"".+\""))@(([^<>()[\]\.,;:\s@\""]+\.)+[^<>()[\]\.,;:\s@\""]{2,})$/i)
```

When [W3C suggests](https://html.spec.whatwg.org/multipage/input.html#email-state-(type=email)):
```
/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
```",,
1418657235,1512,Equality method to assert two zod schemas are the same,"When using react, it's probable a zod schema ends up in a useEffect inside of a component or hook

```ts
const zodSchema = z.object({
  username: z.string()
});
// fetch some data over http
useEffect(() => {...}, [query, zodSchema]
```

Every render, `zodSchema` is a new reference, meaning we get stuck in an infinite loop.

Conventional wisdom is wrap the zod schema in a memo

```ts
const zodSchema = useMemo(() => (z.object({
  username: z.string()
}));
// fetch some data over http
useEffect(() => {...}, [query, zodSchema]
```

However, if we want to provide our users a hook that abstracts data fetching like this
```ts
// fetch some data over http
const [resp, err] = useFetchData(query, zodSchema)
```

it'd be best if the `useFetchData` hook handled the memoization for the caller, but to do that, we'd need a way to compare zod two zod schemas for equality to short-circuit early. A react hook may implement a deep equality for a usecase like this, but we don't have a great way to do that since a zod object has a complex structure of nested objects and functions.

In some ways, I suppose this is almost a request for a serialization function in zod (which I realize some 3rd party libs like `zodToJsonSchema` already provide).

",,
1418211056,1511,safeParse needs to support the types of error that are allowed to parse.,"```Ts
const schema = Zod.object({
    id: Zod.number(),
    name: Zod.string(),
})

const result = schema.safeParse({id: 1, name: 999})
```
**Current Result:**
```
{
    error: ZodError: [ { ""code"": ""invalid_type"", ""expected"": ""string"", ""received"": ""number"", ""path"": [ ""name"" ], ""message"": ""Expected string, received null"" },
    success: false
}
```


**I want to get a parsed data structure**
```
{
    error: ZodError: [ { ""code"": ""invalid_type"", ""expected"": ""string"", ""received"": ""number"", ""path"": [ ""name"" ], ""message"": ""Expected string, received null"" },
    success: false,
    data: {id: 1, name: 999}
}
```",,
1418141153,1510,Support `exactOptionalPropertyTypes` for `partial` and `optional` helpers,"Hi!

Zod is adding the `undefined` type to all keys that are optional when using the different `.partial()` modifiers.

How about differentiating them by being present and undefined or just not present at all like typescript does with `exactOptionalPropertyTypes: true`.

Would it be possible to implement in zod? I guess it could be the default since if you don't care you don't care. Also just using the typescript `Partial` type will actually honor `exactOptionalPropertyTypes` by default (on the type level that is).",,
1416848720,1508,what's the best way to deep merge objects ?,"Hi,
Here's an example of the `.merge` behaviour : 

```ts
const childA = z.object({
  childA: z.string(),
});

const parentA = z.object({
  a: z.string(),
  child: childA,
});

const childB = z.object({
  childB: z.string(),
});

const parentB = z.object({
  b: z.string(),
  child: childB,
});

const notWorking = parentA.merge(parentB);
type NotWorking = z.infer<typeof notWorking>;
//type NotWorking = {
//  a: string;
//  child: {
//      childB: string;
//  };
//  b: string;
//}

const working = parentA
  .merge(parentB)
  .merge(z.object({ child: parentA.shape.child.merge(parentB.shape.child) }));
type Working = z.infer<typeof working>;
//type Working = {
//  a: string;
//  child: {
//      childA: string;
//      childB: string;
//  };
//  b: string;
//}
```

the working / not working is a poorly chosen way to express that I was expecting the `merge` function behaviour to propagate to children.

is there a recommended way to get the ""working"" one easily ? (maybe I didn't find the function in the doc).

looks like the `.and` / `intersection` do pretty much that but can't be extended so it's a dead-end in my situation.",,
1414987180,1505,add isJWT validation,isJWT() can be useful for validating user tokens sent in querystring parameters in WebSocket connections,,
1413528674,1504,Is there a way to combine `discriminatedUnion` with `lazy`?,"Hello,

I stumbled on this problem.

When using lazy (recursive types) I cannot use discriminatedUnion anymore.

```ts
import z from ""zod"";

type SomeOtherObject = {
  type: ""some-other-type"";
  randomProperty: string;
};

const someOtherObjectWithADiscriminatingType = z.object({
  type: z.literal(""some-other-type""),
  randomProperty: z.string()
});

type RecursiveElement = {
  type: ""recursive-element"";
  children: MyUnion[];
};

const recursiveElement: z.ZodType<RecursiveElement> = z.lazy(() =>
  z.object({
    type: z.literal(""recursive-element""),
    children: myUnion.array()
  })
);

type MyUnion = RecursiveElement | SomeOtherObject;
```


What works is
```ts
const myUnion = z.union([
  recursiveElement,
  someOtherObjectWithADiscriminatingType
]);
```

But I would love to use `discriminatedUnion` here.

```ts
const myUnion = z.discriminatedUnion(""type"",[
  recursiveElement,
  someOtherObjectWithADiscriminatingType
]);
```

Any way I can type lazy object recursiveElement somehow that it does not throw an error?

Here is this problem in CodeSandBox: https://codesandbox.io/s/lucid-wilson-k5x1pu?file=/src/App.tsx:682-792",,
1412476974,1503,## ðŸš€ Feature Proposal,"## ðŸš€ Feature Proposal

A clear and concise description of what the feature is.

## Motivation

Please outline the motivation for the proposal.

## Example

Please provide an example for how this feature would be used.

## Pitch

Why does this feature belong in FBT?

__Originally posted by @Juscc53 in https://github.com/facebook/fbt/issues/379__",,
1411631576,1500,Cannot use branding and flavoring with Lazy,"Hello,
I'm using flavoring concept while working with zod, and I stumbled upon typing the recursive pattern.
That is the case:
```ts
import {z} from 'zod';

type Flavored<
  T extends string,
> = string & {
  __flavor: T;
};

const flavored = <T extends string>(x: string): x is Flavored<T> => true;

const flavoredType = z.string().refine<Flavored<'flavor1'>>(flavored);

const fooSchema = z.strictObject({
  kind: z.literal('foo'),
  data: flavoredType,
});

type ComplexSchema =
  | z.infer<typeof fooSchema>
  | {
      kind: 'complex';
      schemas: ComplexSchema[];
    };

const complexSchema: z.ZodType<ComplexSchema> = z.lazy(() =>
  z.union([
    fooSchema,
    z.strictObject({
      kind: z.literal('complex'),
      schemas: z.array(complexSchema),
    }),
  ]),
);
```

It ends up with an error:
```
Type 'ZodLazy<ZodUnion<[ZodObject<{ kind: ZodLiteral<""foo"">; data: ZodEffects<ZodString, Flavored<""flavor1"">, string>; }, ""strict"", ZodTypeAny, { ...; }, { ...; }>, ZodObject<...>]>>' is not assignable to type 'ZodType<ComplexSchema, ZodTypeDef, ComplexSchema>'.
  Types of property '_input' are incompatible.
    Type '{ kind: ""foo""; data: string; } | { kind: ""complex""; schemas: ComplexSchema[]; }' is not assignable to type 'ComplexSchema'.
      Type '{ kind: ""foo""; data: string; }' is not assignable to type 'ComplexSchema'.
        Type '{ kind: ""foo""; data: string; }' is not assignable to type '{ kind: ""foo""; data: Flavored<""flavor1"">; }'.
          Types of property 'data' are incompatible.
            Type 'string' is not assignable to type 'Flavored<""flavor1"">'.
              Type 'string' is not assignable to type '{ __flavor: ""flavor1""; }'.
```

It seems like `data` loses its refinement in this case. If I change `data` to be `z.string()` everything works perfectly.",,
1410627698,1499,Zod Structure,"I am trying to add more validation's types, but this structure is so hard to understand because all types are in same file `types.ts` 

Sugestion:
at the moment `types.ts` has 4000 lines, what do you guys think to split it in one folder `types` and create files by type, ex:
```md
src/types
src/types/string.ts
src/types/number.ts
```",,
1410567279,1498,[Question] How to give type to Zod Arrays,"So I have a type 

e.g. `type QualityTypes = 'thing1' | 'thing2' |  'thing3' |  'thing4' |  'thing5'`

Now I want a zod array with `QualityTypes` as the type of the array when I infer the value of the zod object.

e.g.

```typescript
const personSchema = z.object({
    name: z.string().required(),
    qualities: z.array(z.string()).optional()
})

type Person = z.infer<typeof personSchema>;

/*
Person = {
    name: string;
    qualities: string[]
}
*/
```  

I wanna make it so that the qualities property says, `qualities: QualityTypes[]`
",,
1410290535,1497,The first time,@jusc55,,
1410187842,1496,parse with .or get wrong type ,"Here is the code:

```ts
const schema = z.object({ id: z.number().positive() }).or(
  z.object({
    IDs: z.number().positive().array().nonempty(),
  })
);

const result = schema.parse({ id: 1 });

result.id;
result.IDs;
```
Error: 

`Property 'id' does not exist on type '{ id?: number; } | { IDs?: [number, ...number[]]; }'.`

 `ÃProperty 'id' does not exist on type '{ IDs?: [number, ...number[]]; }'.`

![2022-10-15 at 10 39 PM](https://user-images.githubusercontent.com/6512574/195992292-74f3afac-a618-4032-ba61-cd562ec94229.png)
",,
1410144626,1495,[question] ZodType with ZodObject props,"Hello, how create zodtype with object props from external types?

```ts
// Generated type from API
type User = {
 id: number
 name: string
}

const UserSchema = z.ZodType<User> = z.object({
  id: z.number(),
  name: z.string()
})

UserSchema.pick  // not working
// Property 'pick' does not exist on type 'ZodType<User, ZodTypeDef, User>'.
```",,
1409741874,1493,Handling multiple forms with discriminated union,"ValidationSchema = z.object({
  ParentBlock: z.object({    
    **choiceOfForm** : z.enum
    DataBlock: z.discriminatedUnion(**choiceOfForm**, [
                 z.object({ choiceOfForm = 1, empty fields})   //corresponds to the basic form
                 z.object({ choiceOfForm = 2, just username/pw fields)   //corresponds to less basic form
                 z.object({ choiceOfForm = 3, user/pw + many fields})   //corresponds to advanced form
          ])
      })
})

**choiceOfForm** is an ENUM corresponding to 3 radio buttons. The corresponding form depending on selection. 
I would like to use ZOD's discriminatedUnion function to enable the correct form validation block depending on which **choiceOfForm** is selected (1,2 or 3). Is there a way to pass the **choiceOfForm** variable to the discriminatedUnion (enumHere, ...) to do this?

Thank you
    ",,
1407932991,1490,`discriminatedUnion` produces TS error when `.default` or `.preprocess` are applied,"[Playground link.](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgNwBQFAxhAHYDO8AYhBAMrUAWApiAIZwAvCgB0EAEYArHtRgAKBBThwYATzA8AXGIA2wGDyj9d8-Jjb4AlKOI9M-AK66F5y1YA0yuPx3JRTFDAdADm8p4UaFaUNPRMcABC-FCcvALCYpIycore6pp+ovqGxqb41I5MuNZeKiA8MFwkhYHBYRFRMbSM8EnIqXyCIv7EwAzUQSDB-IbEAKp0wPRm+Tz4HnAA2qwc3IMbSSl7AgC60bGMELo8RRBhfQMComDJDDyKPjpuEPjoVudAA)

Given this snippet:

```ts
import { z } from 'zod';

const FooSchema = z.object({
  type: z.literal('foo').default('foo'),
  a: z.string(),
});

const BarSchema = z.object({
  type: z.literal('custom'),
  method: z.string(),
});

const BazSchema = z.discriminatedUnion('type', [FooSchema, BarSchema]);
console.log(BazSchema.parse({ a: 'foo' }));
```

TypeScript produces this error:

```
$ tsc tmp.ts
tmp.ts:13:49 - error TS2322: Type 'ZodObject<{ type: ZodDefault<ZodLiteral<""foo"">>; a: ZodString; }, ""strip"", ZodTypeAny, { type?: ""foo""; a?: string; }, { type?: ""foo""; a?: string; }>' is not assignable to type 'ZodDiscriminatedUnionOption<""type"", Primitive>'.
  Type '{ type: z.ZodDefault<z.ZodLiteral<""foo"">>; a: z.ZodString; }' is not assignable to type '{ type: ZodLiteral<Primitive>; } & ZodRawShape'.
    Type '{ type: z.ZodDefault<z.ZodLiteral<""foo"">>; a: z.ZodString; }' is not assignable to type '{ type: ZodLiteral<Primitive>; }'.
      Types of property 'type' are incompatible.
        Property 'value' is missing in type 'ZodDefault<ZodLiteral<""foo"">>' but required in type 'ZodLiteral<Primitive>'.

13 const BazSchema = z.discriminatedUnion('type', [FooSchema, BarSchema]);
                                                   ~~~~~~~~~

  node_modules/zod/lib/types.d.ts:531:9
    531     get value(): T;
                ~~~~~
    'value' is declared here.


Found 1 error in tmp.ts:13
```

This code works at runtime however and Zod correctly parses the object:

```
{ type: 'foo', a: 'foo' }
```

Previously opened as #1263 but was closed as stale.",,
1404980059,1478,README: doesn't Zod support branded types?,"Noticed this, from the README (https://github.com/colinhacks/zod#runtypes):

> They DO support branded and readonly types, which Zod does not.

Is the branded bit no longer true? (readonly should also be supported in #1432, which I'm very much looking forward to.)",,
1403200287,1477,`discriminatedUnion` errors with `z.object().transform()`,"[Playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgNwBQFAxhAHYDO8AWiQGIQRwC8KAdBABGAKwCm1GAAoEMAJ5hRALn4AbYDFFQAhisn5MnfAEoANFk7LkfJlGB0A5pKNojfGNsYGoISdLkKzAwgXHgA+OD95UTMANx0AVyVzYKMjSlpGFhIAIS0oHn4hMQlIhUs+NQ1tXXxBPOMzOqhymztHZ1d3LU9oH1LouCaQ7nD+2ISkodT0+iY4VmJc1F4rYmAGalsQOy0NYgBVOmB6PX9RfDMAbQWOCDMF3KgAXTSKIA)

```ts
import { z } from 'zod';

const ZodFoo = z.object({type: z.literal('foo'), foo: z.string()})
  .transform(({type, foo}) => ({type, value: foo}));
const ZodBar = z.object({type: z.literal('bar'), bar: z.string()})
  .transform(({type, bar}) => ({type, value: bar}));

const ZodBaz = z.discriminatedUnion('type', [ZodFoo, ZodBar]);
```

I am not sure if this is even possible.

If not, is there a recommended workaround?",,
1401778222,1475,[feature] a custom validation logic register on schema object ,"I think it would be nice if there is a .validator schema method for register a custom validation logic, and ones  register a validator, the logic take place of the default logic, the validation completely  on your own. 
```
 const Circle = z.object({
    kind: z.literal('circle'),
    radius: z.number(),
  })
  const Square = z.object({
    kind: z.literal('square'),
    sidelength: z.number(),
  })
  
  const ShapeSchema = z.union([Circle, Square])
  .validator((v)=>{
    if(v.kind==='circle'){
      return Circle.safeParse(v)
    }
    return Square.safeParse(v)
  })
```

",,
1401535455,1473,zod.preprocess causes compilation error starting from 3.19.1,"After the recent release v3.19.1, the following code started to fail [compiling](https://codesandbox.io/s/beautiful-khayyam-kx97bw?file=/src/index.ts:0-282):
```ts
import * as zod from ""zod"";

const schema = zod.object({
  failureReasons: zod.preprocess(
    rel => [rel],
    zod.array(zod.object({})),
  )
});

export class Editor<
  S extends zod.ZodType<zod.TypeOf<typeof schema>>
    = typeof schema                    // <-- the error pops here
> {
  constructor(public schema: S) {}
}

```
This is the error from sandbox:
```
Type 'ZodObject<{ failureReasons: ZodEffects<ZodArray<ZodObject<{}, ""strip"", ZodTypeAny, {}, {}>, ""many"">, {}[], unknown>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' does not satisfy the constraint 'ZodType<{ failureReasons?: {}[]; }, ZodTypeDef, { failureReasons?: {}[]; }>'.
  The types of '_input.failureReasons' are incompatible between these types.
    Type '{}' is missing the following properties from type '{}[]': length, pop, push, concat, and 26 more.ts(2344)
```
@colinhacks The error is not reproduced with zod v3.19.0, I guess the root cause is this [commit](https://github.com/colinhacks/zod/commit/2893e1659875944198aff28a3ba404858f834ed8).

PS When I replicate the same setup in VSCode locally, the error is slightly different:
```
Type 'ZodObject<{ failureReasons: ZodEffects<ZodObject<{}, ""strip"", ZodTypeAny, {}, {}>, {}, unknown>; }, ""strip"", ZodTypeAny, { failureReasons: {}; }, { ...; }>' does not satisfy the constraint 'ZodType<{ failureReasons: {}; }, ZodTypeDef, { failureReasons: {}; }>'.
  The types of '_input.failureReasons' are incompatible between these types.
    Type 'unknown' is not assignable to type '{}'.ts(2344)
```
I couldn't locate the difference, but the general behaviour is still reflecting the error, so I post the issue as is.
",,
1401362480,1472,Can `ZodType` generic default be changed to `unknown`?,"### Proposed Change
```diff
class ZodType<
-  Output = any,
+  Output = unknown,
  Def extends ZodTypeDef = ZodTypeDef,
  Input = Output
```

### Example
I have seen this kind of wrapper function where `z.Schema` is missing the generic
```ts
// returns any
function parse(value: unknown, schema: z.Schema) {
  // do some other stuff ...
  return schema.parse(value)
}
```
I think it would be safer, if this function would return `unknown` by default.


Is there a reason why the generic in `ZodType` needs to defaults to `any` besides ergonomics?

Feel free to close or turn this into a discussion :)
",,
1401329776,1471,intersection of records differs from typescript,"```ts
const type = z.intersection(
  z.object({ a: z.null() }),
  z.record(z.string().refine((s): s is ""b"" => s === ""b""), z.undefined()),
)
const input: z.infer<typeof type> = { a: null, b: undefined }
type.parse(input)
```
should work according to the types but throws
```
ZodError: [
  {
    ""code"": ""custom"",
    ""message"": ""Invalid input"",
    ""path"": [
      ""a""
    ]
  },
  {
    ""code"": ""invalid_type"",
    ""expected"": ""undefined"",
    ""received"": ""null"",
    ""path"": [
      ""a""
    ],
    ""message"": ""Expected undefined, received null""
  }
]
```
A key is not required to match the index signature but if it does its value should match the intersection of value types.",,
1400760269,1470,Validating dynamically named object keys,"Hi there,

I'm running into a blocker with my use case. I have to validate an object with an arbitrary number of properties and dynamic key names:

```typescript
{ [key: string]: string }
```

I need to validate both `key` and `value` for each property. Is there a way to describe that in a zod Schema?

Cheers!",,
1400221862,1468,Links from zod.dev cause error,"From http://zod.dev clicking on any of the badges or links on the first section of the documentation cause an Error and do not work.

Error: `Failed to execute 'pushState' on 'History': A history state object with URL 'https://discord.gg/RcG33DQJdf' cannot be created in a document with origin 'https://zod.dev' and URL 'https://zod.dev/'.`",,
1398743278,1466,[feature] friendly CLI errors,"Add a more friendly format for CLI debug, I'm parsing env vars on next using zod, an error returns this:

```
  issues: [
    {
      code: 'invalid_type',
      expected: 'string',
      received: 'undefined',
      path: [Array],
      message: 'Required'
    }
  ],
  addIssue: [Function (anonymous)],
  addIssues: [Function (anonymous)],
  errors: [
    {
      code: 'invalid_type',
      expected: 'string',
      received: 'undefined',
      path: [Array],
      message: 'Required'
    }
  ]
}
```

I need to catch the exception, map the path into a string to see whats the field",,
1398477811,1465,Bug?: Optional Tuple Values,"I'm in a situation where I'd like to send an optional number of arguments in an array:

```ts
const schema = tuple([
	string(),
	number().optional()
])

type ZodType = z.infer< typeof schema >

// Conversion of type '[string]' to type '[string, number | undefined]' may be a mistake
// because neither type sufficiently overlaps with the other.
const ar = [ ""foo"" ] as ZodType
```

Is it possible to infer to `[ string, number? ]` instead of `[ string, number | undefined ]` ?",,
1396611921,1461,Fails to load from https://www.skypack.dev/,"Can you please fix the compatibility with skypack cdn, right now loading https://cdn.skypack.dev/zod produces following issues

```
/*
 * [Package Error] ""zod@v3.19.1"" could not be built. 
 *
 *   [1/5] Verifying package is validâ€¦
 *   [2/5] Installing dependencies from npmâ€¦
 *   [3/5] Building package using esinstallâ€¦
 *   Running esinstall...
 *   Cannot find module 'zod/locales/en.d.ts'
 *
 * How to fix:
 *   - If you believe this to be an error in Skypack, file an issue here: https://github.com/skypackjs/skypack-cdn/issues
 *   - If you believe this to be an issue in the package, share this URL with the package authors to help them debug & fix.
 *   - Use https://skypack.dev/ to find a web-friendly alternative to find another package.
 */

console.warn(""[Package Error] \""zod@v3.19.1\"" could not be built. \n[1/5] Verifying package is validâ€¦\n[2/5] Installing dependencies from npmâ€¦\n[3/5] Building package using esinstallâ€¦\nRunning esinstall...\nCannot find module 'zod/locales/en.d.ts'"");
throw new Error(""[Package Error] \""zod@v3.19.1\"" could not be built. "");
export default null;
```

It is very convenient way to load modules in https://observablehq.com/",,
1396285800,1460,Calling `isOptional` triggers preprocess callback,"Calling `isOptional` triggers preprocess callback.

Related to https://github.com/StefanTerdell/zod-to-json-schema/issues/23.

Here's a failing test case:

```typescript
test(""calling isOptional should not trigger preprocess function"", () => {
  let wasCalled = false;

  const pre = z.preprocess(() => {
    wasCalled = true;
  }, z.string());

  pre.isOptional();

  expect(wasCalled).toBe(false);
});
```",,
1395469255,1458,"Any way to avoid casting preprocess return type, normally returns unknown","When using preprocess the return type is ""unknown"":

schema:
```
export const Size = zod.object({
  width: z.preprocess((input) => {
    if (isNil(input)) return undefined;

    return parseInt(input as string, 10);
  }, z.number()),
});
```

type:
```
zod.ZodEffects<zod.ZodNumber, number, unknown>
```

casting it works:
```
export const Size = zod.object({
  width: z.preprocess((input) => {
    if (isNil(input)) return undefined;

    return parseInt(input as string, 10);
  }, z.number()) as zod.ZodEffects<zod.ZodNumber, number, number>
});
```

I did create a helper function:
```
function prepocessNumber() {
  return z.preprocess((input) => {
    try {
      if (isNil(input)) return undefined;

      return parseInt(input as string, 10);
    } catch (ex) {
      return input;
    }
  }, z.number()) as zod.ZodEffects<zod.ZodNumber, number, number>
}

export const Size = zod.object({
  width: prepocessNumber()
});
```

which gives me the expected return type (number).

Isn't clear to me if there is an alternative but maybe this is correct?
",,
1395328498,1457,Recursively defined objects should still be objects," Following the manaul on [Recursive Types](https://github.com/colinhacks/zod#recursive-types) , results in a type of ZodType which can not function as a ZodObject. namely it cannot be merged or passthrough. 

",,
1395003269,1456,Return type of `.default()` should not be nullable,"If I call `.default()`, why does it make the output type nullable?  If I have provided a default value, shouldn't the output never be `null`?",,
1394569982,1454,Derived arguments (computed props) within a schema,"Hey everyone!

Firstly â€“ Zod is awesome. Picked it up recently and I've been having a blast working with it. 
In recent weeks I've encountered a situation which I thought might benefit from a discussion here. 

We're currently in the process of refactoring an old codebase that used `mobx-state-tree` to manage it's state. MST has a really similar approach to Zod's runtime type system, with a nice API for adding computed properties to a schema:

```ts
const UserStore = types
  .model({
    users: types.array(User)
  })
  .views(self => ({
    get numberOfAdults() {
      return self.users.filter(user => user.age > 18).length
    }
  }))
```

Now, I came across [a good suggestion](https://github.com/colinhacks/zod/issues/641) to wrap Zod's `schema.parse({})` call in a factory function and add the computed functions in before returning:

```ts
const UserSchema = z.object({ name: z.string(), age: z.number() })

const UserCollectionSchema = z.object({
  users: z.array(UserSchema),
})

const createUserModel = (input: Partial<z.infer<typeof UserCollectionSchema>>) => {
  const model = UserCollectionSchema.parse(input)
  return {
    ...model,
    get numberOfAdults() {
      return model.users.filter((user) => user.age > 18).length
    },
  }
}

createUserModel({ users: [{ name: 'Jon', age: 29 }] }).numberOfAdults // => 1
```

This is a really clean suggestion, and would definitely be the route I'd look to take. However... consider the following change to the user schema: 

```ts
const UserSchema = z.object({ name: z.string(), dateOfBirth: z.date() })
```

Ideally I'd be able to expose `age` as a computed property, deriving its value from the date of birth field. This is difficult to achieve without nesting factories here - the consumer of `UserCollectionSchema` shouldn't care whether `age` is a derived property or not. The power here is in nested object schema's each adding their own computed properties that can be carried around alongside the validation logic.

I'm pretty new to using Zod - this might be entirely outside the scope of the project, or something Zod supports now/in the future. There seems to be a few outstanding discussions that relate to this subject but all seem either incomplete or stale, so I thought it was worth asking!

(Possibly related: https://github.com/colinhacks/zod/issues/38)",,
1394147341,1453,ZodObject.merge() looses base shape type when schema is created via a function,"Given two schemas like:
```typescript
const baseSchema = z.object({
  foo: z.string()
});

const extentionSchema = z.object({
  bar: z.string()
});
```

If they are merged together like so:
```typescript
const mergedSchema = baseSchema.merge(extentionSchema);
```
The resulting schema should produce a type that combines both existing schema, which it does:
![Screen Shot 2022-10-03 at 16 04 42](https://user-images.githubusercontent.com/346340/193505076-b397807c-af02-4953-be2a-730647d40342.png)


However if a factory pattern is used to construct that merged schema like so:
```typescript
function createSchema<
  BaseSchema extends z.ZodObject<ZodRawShape>,
  ExtentionSchema extends z.ZodObject<ZodRawShape>
>(baseSchema: BaseSchema, extentionSchema: ExtentionSchema) {
  return baseSchema.merge(extentionSchema);
}
```
And a new schema is created using that function:
```typescript
const mergedSchema = createSchema(baseSchema, extentionSchema);
```

Then the type of resulting schema extends an any object which is not very helpful:
![Screen Shot 2022-10-03 at 16 08 49](https://user-images.githubusercontent.com/346340/193505361-dab2266d-94c6-4f4f-be27-ffadfc45920a.png)

I've created a live example here and you can observe the constructed types by hovering over `objectBasedOnMergedSchema` on line 22 and 31: https://codesandbox.io/s/zod-merge-typescript-issue-ohz657?file=/src/index.ts",,
1394091695,1452,z.date.min and z.date.max are misleading,"Thank you team for supporting `Date` in the new releases.

However, I found the naming convention misleading compared to how developers usually think of `Date`.

Doc: https://github.com/colinhacks/zod#dates

<img width=""874"" alt=""image"" src=""https://user-images.githubusercontent.com/14172220/193499199-aea64861-2ec5-45b4-a2f6-398b2f6de4d9.png"">

For `z.date.min()`:
- For `Date` in computer science and programme in general, the earlier the date is, the smaller the epoch value is.
- Thus, when we use `min`, we expect it limits the earliest (smaller value in epoch time) date.

Vice versa for `z.date.max()`. 

I propose using `z.date.max()` to set the constraint of the latest date allowed (e.g. ""Too old""). `z.date.min()` to assess the condition of the earliest date allowed (e.g. ""Too young"")",,
1393910467,1451,schema.safeParseAsync method is ignoring the path param,"The `safeParseAsync` method on a zod schema is ignoring the provided `path` param

Here's the output when using `safeParse`:
```ts
const schema = z.object({
	debug: z.boolean(),
});

const result = schema.safeParse({}, { path: [""body""] });
console.log(result.success ? result.data : result.error.issues[0]?.path); // [""body"", ""debug""]
```

and `safeParseAsync`:
```ts
const schema = z.object({
	debug: z.boolean(),
});

const result = await schema.safeParseAsync({}, { path: [""body""] });
console.log(result.success ? result.data : result.error.issues[0]?.path); // [""debug""]
```

Zod version: 3.18.0",,
1393671415,1449,Option to pass `strict` as `.parse()` param,"We share zod schemas between BE and FE. 
It would be nice to point to BE, what data is excessive and can be removed. So we would like to keep everything ""as is"" on FE side, but add `.safeParse()` checks on BE side for that unnecessary extra nested object keys.
Unfortunately there's no way to do that, we can't just use say `.parse()` on FE side and `.parseStrict()` or something like that on BE side - we have to make this `.strict()` flag a part of the schema itself, while in many cases it's just an option how to use that schema.
Would be nice to have a method or flag to let `.parse()` behave differently and treat passed schema more strictly.",,
1392661476,1445,DiscriminatedUnion not working with nested form names,"Lets say I have 2 inputs
```<input type=""number"" name=""contact.type"" />```
```<input type=""text"" name=""contact.name"" />```

And a schema as follows:
```
const schema = z.object({
    contact: z.object({
        name: z.discriminatedUnion('contact.type', [
            z.object({
                type: z.literal(1),
                name: z.string().min(1),
            }),
            z.object({
                type: z.literal(2),
                name: z.string().min(2),
            })
        ],
    })
})
```

Zod complains about the 'contact.type' discriminationUnion not being assignable. It seems like it doesn't like the object notation, since changing all elements from contact.type to contacttype and updating schema fixed all these issue.


",,
1392567443,1444,feature request: combining/nesting/extending discriminated unions,"In our app we have some data coming from an external service that's modelled as a combination of 2 discriminated unions, e.g.
```ts
[
  { type: ""quote"", attribution: ""..."" },
  { type: ""textAndMedia"", mediaType: ""image"", image: {...} }
  { type: ""textAndMedia"", mediaType: ""video"", video: {...} }
]
```

But attempting to model it with zod fails with the error:  
`The discriminator value could not be extracted from all the provided schemas`
```ts
const t = z.discriminatedUnion(""type"", [
  z.object({ type: z.literal(""one""), foo: z.string() }),
  z.object({ type: z.literal(""two""), bar: z.string() }),
  z.discriminatedUnion(""secondType"", [
    { type: z.literal(""three""), secondType: z.literal(""a"") },
  ]),
]);
```

An extra problem we've ran into is the nested discriminator is defined elsewhere, but unlike objects it doesn't have a `.extend` method, and a `ZodDiscriminatedUnion` isn't a valid arg for `ZodObject.merge`
```ts
const otherDiscriminator = z.discriminatedUnion(""secondType"", [
  z.object({ secondType: z.literal(""a"") }),
  z.object({ secondType: z.literal(""b"") }),
]);
z.discriminatedUnion(""type"", [
  z.object({ type: z.literal(""one""), foo: z.string() }),
  z.object({ type: z.literal(""two""), bar: z.string() }),
  otherDiscriminator.extend({ type: z.literal(""three"") }),
]);
```
<details>
  <summary>Instead of extending I considered extracting the discriminator options and mapping over them, but zod can't infer that correctly. Code sample in toggle</summary>
<p>

```ts
const otherDiscriminatorOptions = [
  z.object({ secondType: z.literal(""a"") }),
  z.object({ secondType: z.literal(""b"") }),
] as const;

const otherDiscriminator = z.discriminatedUnion(""secondType"", [
  ...otherDiscriminatorOptions,
]);

z.discriminatedUnion(""type"", [
  z.object({ type: z.literal(""one""), foo: z.string() }),
  z.object({ type: z.literal(""two""), bar: z.string() }),

  z.discriminatedUnion(""secondType"", [
    ...otherDiscriminatorOptions.map((option) => ({
      type: z.literal(""three""),
      ...option,
    })),
  ]),
]);
```

</p>
</details>
",,
1392402357,1443,Document `.describe()`,"I don't think this feature is documented?

Related: https://github.com/StefanTerdell/zod-to-json-schema/issues/22",,
1391763241,1442,Q: why discriminatedUnion of one element is not possible,"According to `discriminatedUnion` type definition, it accepts a list of at least two elements.

My question is why is this implemented like this?

Question arose for the reason that I have a real use case where I have a factory function that would return parsers for n>=1 string literals i.e.

```
const makeApiIdParser = (literals: NonEmptyArray<string>) => z.preprocess(
  (uuid) => {
    if (typeof uuid !== 'string') throw new Error('must be a string');
    const [type, id] = uuid.split(SEPARATOR);
    return { type, id };
  },
  z.discriminatedUnion('type', literals.map((type) => z.object({
    type: z.literal(type),
    id: z.string(),
  })))
);
```

This function would generate parsers for such strings as `user::27f4ee03-e79e-470c-8d4e-fa28e8ac6089` but also a separate parsers for such strings as `blog::7fe494ab-a349-4896-87f2-24e2024d2cce` or `collective::69e23e02-546b-4c30-a532-b3f45e8498f8`

I could get by with if/else checking for my literals length, but it goes against normal intuition and would be akin to doing

```
const map = <T, R>(a: T[], f: (t: T) => R): R[] => {
  if (!a.length) return a;
  return a.map(f);
}
```

I hope this is a clear enough parallel to why I see the definition of `discriminatedUnion` as a bit weird.

There must be some technical restriction I don't see or some logical aspect I fail to recognize. 

Could someone please help me to understand the reason for this implementation of `discriminatedUnion`?",,
1391399725,1439,Support .examples(),"JSON Schema supports `examples` keyword (see https://json-schema.org/draft-06/json-schema-release-notes.html) which is helpful for providing examples of a given schema. While not used for validation, it is very valuable for JSON Schema and OpenAPI documents that could be derived from zod schemas.

Zod already supports `.describe(description)` command, `examples` command could work very similarly (`.examples(arrayOfExamples)`)

Nice-to-have - OpenAPI generally describes examples as records (see https://swagger.io/docs/specification/adding-examples/), so supporting `any[]` is preferable to cover all possible cases.",,
1389600201,1437,Lack of options to ignore errors,"We're introducing this beautiful library on FE side and encountered unpleasant aftermath of this decision - increase in the number and severity of site errors. 
The problem is that even if some, in other case not important, error is there - like some value is `undefined`, instead of an empty string - where we previously could have just some empty div - now the whole server response fails to be processed. 
In our case we have plenty of nested `.transform()`, so there's just no chance to pass and process them anyhow separately - to pass them additionally to some custom wrapper or anything like that - we have to rely on `zod`.
Would be nice to have some option to still enforce `.parse()` to keep proceeding with `.transform()`, even without guarantee of the final validity - since we already will have what we're looking for - information, that some data is in unexpected format - instead of ruined UI, which is a very high price to pay.",,
1388579067,1436,Issue with recurisve parsing and typescript,"So I have the following setup for parsing a recursive rules tree 

```
interface RuleNode {
    ruleId: string;
    description?: string[];
    children: RuleNode[];
    ruleOperation: RuleOperation;
    ruleField?: string;
    ruleValue?: string;
    ruleValueType?: RuleValueType;
}
export type RuleSyntaxTree = RuleNode;

export const RuleNode: z.ZodType<RuleNode> = z.lazy(() =>
    z.object({
        ruleId: z.string(),
        description: z.array(z.string()).optional(),
        children: z.array(RuleNode),
        ruleOperation: z.nativeEnum(RuleOperationInternal),
        ruleValue: z.string().optional(),
        ruleField: z.string().optional(),
        ruleValueType: z.string().optional(),
    }),
);
``` 

This gives me the following error on the validator. 

```
Type 'ZodLazy<ZodObject<{ ruleId: ZodString; description: ZodOptional<ZodArray<ZodString, ""many"">>; children: ZodArray<ZodType<RuleNode, ZodTypeDef, RuleNode>, ""many"">; ruleOperation: ZodNativeEnum<...>; ruleValue: ZodOptional<...>; ruleField: ZodOptional<...>; ruleValueType: ZodOptional<...>; }, ""strip"", ZodTypeAny, { .....' is not assignable to type 'ZodType<RuleNode, ZodTypeDef, RuleNode>'.
  Types of property '_type' are incompatible.
    Type '{ ruleId?: string; description?: string[]; children?: RuleNode[]; ruleOperation?: RuleOperation; ruleValue?: string; ruleField?: string; ruleValueType?: string; }' is not assignable to type 'RuleNode'.
      Property 'ruleId' is optional in type '{ ruleId?: string; description?: string[]; children?: RuleNode[]; ruleOperation?: RuleOperation; ruleValue?: string; ruleField?: string; ruleValueType?: string; }' but required in type 'RuleNode'.t
``` 

is there something im doing wrong? Can this code be simplified. ",,
1385107152,1427,possible to compare 2 schema?,"it is possible to check whether one schema equal to another schema?

something like
```ts
const w = z.object({
	a: z.number(),
})

const x = z.object({
	a: z.number(),
})

const y = z.object({
	a: z.string(),
})

isEqual(w, x) // true
isEqual(w, y) // false
```",,
1385068100,1426,Use default value on error,"I'd like to validate a value, and if that validation fails I don't care about the error - I want to use a default value.

```js
const strZ = z.string().default('hello world');
strZ.parse() // 'hello world'
strZ.parse('hi') // 'hi'
strZ.parse(23) // error, but I want 'hello world'
```

I can't figure out a clean way to do this without writing my own wrapper around zod. Is this supported already by the library?",,
1384688429,1425,[Date] Runtime branded date looses brand by parsing,"I made a branded date.  And used `z.date().refine` to check for brand. and it does not work.

```ts
import { z } from ""zod"";

const DATE_ONLY_SYMBOL = Symbol(""DATE_ONLY_SYMBOL"");
export type DateOnly = Date & { [DATE_ONLY_SYMBOL]: true };

export function isDateOnly(d: Date): d is DateOnly {
  return DATE_ONLY_SYMBOL in d;
}
export function asDateOnly(d: Date): DateOnly{
  const dateOnly = new Date(d) as DateOnly;
  dateOnly[DATE_ONLY_SYMBOL] = true;
  return dateOnly;
}

type ZodDateOnly = z.ZodType<DateOnly, z.ZodTypeDef, Date>;
export const DateOnlySchema: ZodDateOnly = z.date().refine(
  (d): d is DateOnly => isDateOnly(d) // here is always false
);

const dateOnly = asDateOnly(new Date());
isDateOnly(dateOnly); // true
DateOnlySchema.parse(dateOnly); // fails
```

[sandbox with code above](https://codesandbox.io/s/zod-branded-date-0cbmyf)

-----

I found a reason of this beahavior:
https://github.com/colinhacks/zod/blob/3b75ae584e31d8bd06f7298247cd3d27520cf881/src/types.ts#L1111-L1114

it also means the following behavior:
```ts
const dateOnly = asDateOnly(new Date());
isDateOnly(dateOnly); // true
const parsed = z.date().parse(dateOnly); // lost brand
isDateOnly(parsed); // false
```

I wondering if I should use another approach (not `z.date().refine`) to achieve my goal",,
1384612889,1424,Transformed objects in `.union()` vs `.discriminatedUnion()`,"Hello, thanks for the amazing package
I noticed that for the following two objects, first of which is transformed
```javascript
const TransformedObject = z.object({ a: z.literal('1') }).transform(val => val);
const AnotherObject = z.object({ a: z.literal('2') });
```
`.union()` will work just fine
```javascript
const Union = z.union([TransformedObject, AnotherObject]);
```
While `.discriminatedUnion()`
```javascript
const DiscriminatedUnion = z.discriminatedUnion('a', [TransformedObject, AnotherObject]);
```
Will produce the following error
```
Type 'ZodEffects<...>' is missing the following properties from type 'ZodObject<...>': 
_cached, _getCached, shape, strict, and 14 more.
```
So the question is to find out whether transformed objects shouldn't be used in `.union()`, or something is wrong with the input type check of the `.discriminatedUnion()`",,
1383512174,1423,"change export from ""import { z } from 'zod'"" to ""import { zod } from 'zod'""","Letter ""Z"" becomes a symbol of russian military in Ukraine - russian war. Zod - is a really useful and awesome package and we are really thankful to have such an open-source project. However, the letter ""Z"" become a symbol of evil, dictatorship, occupation, genocide ... and a lot of bad things, that shouldn't happen in our world

If you will consider changing it - we as consumers of this package will really appreciate it 

Thank you ",,
1382620180,1422,Refinement by providing another zod object,"I have troubles refining an existing schema by adding more constraints through another zod object. What I envision is something along the lines
```ts
const schema = z.object({
  name: z.string().min(3),
  age: z.number().min(18),
})

const refinement = z.object({
  name: z.string().max(10)
})

// Now
schema.refine(refinement)
// should be equivalent to
const schema = z.object({
  name: z.string().min(3).max(10),
  age: z.number().min(18),
})
```
This `refine` method is similar to the existing `extend` method, but should combine the assertions (and not overwrite them), and moreover ensure that `refinement` specifies a strict subset of the keys of `schema`.

Maybe `refine` as a word is already too overloaded, something like `narrowDown` or `specialize` maybe?",,
1382610043,1421,Validation of arguments via ts decorator,"It would be nice if function arguments could be automatically validated via typescript decorators. For example, something like this:
```ts
const schema = z.object({
  name: z.string().min(3).max(10),
  age: z.number().min(18),
})

class Test {
  @validation(schema)
  hello(input: { name: string; age: number }) {
    return 'test'
  }

  helloAgain(@validation(schema) input: { name: string; age: number }) {
    return 'test'
  }
}

// This throws
new Test().hello({name: 'something', age: 17})
```

A first POI of the function decorator can be found at 
https://github.com/JabRef/JabRefOnline/blob/3ccf2642888776507b87a2c46b7229f163628ae3/server/utils/validation.ts#L11-L34
 with test at https://github.com/JabRef/JabRefOnline/blob/main/server/utils/validation.spec.ts. I sadly don't have the time right now to complete this to a finished PR but I thought I'd share the idea.",,
1380765094,1420,Field does not exist on infered object if it's generic,"I'm trying to create a schema with a generic field where the specific validation doesn't matter, and I just want to infer the type correctly. Using `typescript@4.8.3` and `zod@3.19.1`, I get this weird error where `rawData` is stripped from the object completely if I'm using it as a generic:

```ts
import {z} from ""zod""

export type PlainObject = {[key: string]: unknown}

export function TransactionPropsSchema<T extends PlainObject>() {
	return z.object({
		id: z.string(),
		rawData: z.custom<T>((data) => z.object({}).safeParse(data)),
	})
}

export type TransactionProps<RawData extends PlainObject = PlainObject> =
	z.infer<ReturnType<typeof TransactionPropsSchema<RawData>>>

export class Transaction<RawData extends PlainObject = PlainObject> {
	constructor(public props: TransactionProps<RawData>) {}

	get id() {
		return this.props.id
	}

	get rawData() {
		return this.props.rawData // Property 'rawData' does not exist on type '{ [k_1 in keyof addQuestionMarks<{ id: string; rawData: RawData; }>]: addQuestionMarks<{ id: string; rawData: RawData; }>[k_1]; }'.
	}
}

// Creating a transaction works as expected
const tx = new Transaction({
	id: ""0"",
	rawData: {},
})
const tx2 = new Transaction<{foo: ""bar""}>({
	id: ""1"",
	rawData: {
		foo: ""bar"",
	},
})
```

I can fix the error with a type assertion in the getter or on the schema level, but I'm confused about why this error happens at all. 

How to reproduce: https://github.com/bkiac/generic-zod-object-field",,
1380116146,1419,Unexpected parse failure,"First off, thank you for Zod. It's indispensable.

I've created the below schema that should yield `type NameAndVitals = { name: string } & ({ age: number; } | {})`
```typescript
const vitalsSchema = z.object({ age: z.number() }).or(z.object({}).strict());
const nameAndVitalsSchema = z.object({ name: z.string() }).and(vitalsSchema);
```
Unfortunately, `{ name: ""trey"" }` fails to parse with `{""_errors"":[""Unrecognized key(s) in object: 'name'""]}`.

I debugged it and determined that it works as expected if I omit the `.strict()` from `vitalsSchema`. I don't understand why that would fix the issue. Is this a bug, or is this expected behavior?

Here's a [CodeSandbox](https://codesandbox.io/s/practical-silence-91983y?file=/src/index.ts:45-390) that exhibits the issue.

Also, my real-world scenario is much more complex. This is the minimal/contrived repro schema.
",,
1375366265,1413,.optional().default() should infer type as optional,"## Background

This issue is making a case that when an object is defined with optional, but default values - the underlying type should still be optional. When default is not chained to optional, the type should be required. The use case is for usage of schemas as input as well as an interface.

### Example

```ts
const captureOptionsSchema = z.object({
  url: z.string().url(),
  settings: z.object({
    width: z.number().min(320).optional().default(1280),
    height: z.number().min(320).optional().default(720),
  }).optional().default({}),
})

type CaptureOptions = z.infer<typeof captureOptionsSchema>;

/**
  type = {
    url: string;
    settings: {
      width: number;
      height: number;
    }
  }
*/
```

While technically the type above is correct for explaining what the input params look like, in something like the following, you'll need to define a second type:

```ts
function capture(options: CaptureOptions /* <-- this needs to be a different type */) {
  const params = captureOptionsSchema.parse(options);
  // ...
}
```

`CaptureOptions` in this case is not the correct type, Since there are defaults on width & height and settings sets defaults, passing these options should not be required. The catch is that `params` needs to have those props as required for correct typing.

IMHO I think a `optional().default()` chain should set the property's type as optional and it should be the dev's responsibility to use e.g. `params.settings!.width!` in the usage, instead of having to define another interface or type for the input options with Omits and Picks and Partials etc.

I hope this makes sense. I have checked through the docs and issues first in hopes of not duplicating or missing something, but if I am - please close this, but if possible advise me on a best practice here. ðŸ˜„ Thanks!",,
1373621112,1409,Reusable refine,"Quick question on making reusable code.

I've got some custom logic to check the range of dates.

```ts
const reasonableYears = 10

/**
 * Determines if the date is within a reasonable range from today (plus or minus 10 years)
 */
const isReasonableDate = (dateString: string) => {
  const date = new Date(dateString)
  const future = DateTime.now().plus({ years: reasonableYears }).toJSDate()
  const past = DateTime.now().minus({ years: reasonableYears }).toJSDate()
  return date < future && date > past
}

const isReasonableDateMsg = `Date is outside ${reasonableYears} year range`

```

I have to manually all this over and over on the refine.

```ts
const schema = z
  .object({
    'date-due': z
      .string()
      .nonempty()
      .refine((val) => isReasonableDate(val), {
        message: isReasonableDateMsg,
      }),
    'date-post': z
      .string()
      .nonempty()
      .refine(
        (val) =>
          new Date(val) <
          DateTime.now().plus({ days: 1 }).startOf('day').toJSDate(),
        {
          message: ""Post Date can't be later than tomorrow."",
        },
      ),
    'date-range-start': z
      .string()
      .nonempty()
      .refine((val) => isReasonableDate(val), {
        message: isReasonableDateMsg,
      }),
    'date-range-end': z
      .string()
      .nonempty()
      .refine((val) => isReasonableDate(val), {
        message: isReasonableDateMsg,
      }),
  })

```

Is there a way to write the refine logic so it can be called more efficiently? This situation is specifically extending an existing `schema`.

I'd like to be able to just pass something into the refine like this.

```ts
const date = z
      .string()
      .nonempty()
      .refine(isReasonableDate)
```

Is this possible with the current API?",,
1372359533,1408,Wrong type inference for required properties,"The code example from the [Object documentation](https://github.com/colinhacks/zod#objects) shows this example:

```ts
// all properties are required by default
const Dog = z.object({
  name: z.string(),
  age: z.number(),
});

// extract the inferred type like this
type Dog = z.infer<typeof Dog>;

// equivalent to:
type Dog = {
  name: string;
  age: number;
};
```

When that same example is used in my code, I get a different type inference:

```ts
// all properties are required by default
const Dog = z.object({
  name: z.string(),
  age: z.number(),
});

// extract the inferred type like this
type Dog = z.infer<typeof Dog>;

// equivalent to:
type Dog = {
  name?: string;
  age?: number;
};
```

None of the object properties seem required, and are marked as optional in the type inference.

Tested in zod versions 3.16.*-3.18.*",,
1371026964,1406,`fatal` missing from issue-type,"From [my question asked on Discord](https://discord.com/channels/893487829802418277/893488038477434881/1018893492342226994):

When adding an issue (e.g. via `ctx.addIssue` in `superRefine`), you can set whether the issue is `fatal` or not:

```ts
    ctx.addIssue({
      code: 'custom',
      fatal: true, // Allowed
      params: {
        foo: 'bar',
      },
      path: [],
      message: 'Some message',
    });
```
But when manually creating a new `ZodError` with a matching issue, Typescript complains that `fatal` does not exist:
```
    const err = new z.ZodError([
      {
        code: 'custom',
        fatal: true, // Not allowed, with typescript-error below
        params: {
          foo: 'bar',
        },
        path: [],
        message: 'Some message',
      },
    ]);
```
> Object literal may only specify known properties, and 'fatal' does not exist in type 'ZodCustomIssue & { message: string; }'

As mentioned in the reply to my question on Discord, there seems to be an oversight here. Is `fatal` is missing on `ZodCustomIssue` or `ZodIssueBase`, or is it ""correct"" that it doesn't exist there? I'm guessing not, since the `fatal` field does come back out on an issue when a fatal issue is created. Typewise, it seems to only be added to `IssueData`, which is the type `ctx.addIssue` accepts?

---

The reason why I ran into this, is because I have written a few ""custom schemas"" for often used ""types"", for re-use throughout my code-base, and to make sure they're done correctly, I've written some unit-tests for them:

```ts
    it('invalid should generate expected issue', () => {
      expect(AccountNumberSchema.safeParse('1234 56 78907')).toEqual({
        success: false,
        error: new z.ZodError([
          {
            code: 'custom',
            fatal: true, // Gives TS error, as mentioned
            params: {
              code: 'invalid_type',
              expected: 'account_number',
            },
            path: [],
            message: 'must be a valid account number',
          },
        ]),
      });
    });
```",,
1369015432,1405,Preprocess and parser Input type,"When using `z.preprocess`, the parser's `Input` type is set to the wrapped parser's `Input` type. In most cases, this is probably incorrect, and this prevents using `z.preprocess` with frameworks like tRPC without type errors.

Example:

```ts
const parser = z.preprocess((data) => Number(data), z.number());

function handle(data: z.input<typeof parser>) {
  return parser.parse(data);
}

handle(""42"");
// ts-error: Argument of type 'string' is not assignable to parameter of type 'number'.
```

^ That's a very simplified example of how this works in tRPC. I'm not sure what the ideal API is here. Maybe if we could explicitly annotate the preprocess argument? e.g.:

```ts
const parser = z.preprocess((data: string | number) => Number(data), z.number());

type Input = z.input<typeof parser>;
assertEqual<Input, string | number>(true);
```

Or alternatively, should `preprocess` simply always have an `Input` type of `unknown`? This seems like it would make the most sense, because using preprocess assumes you can handle any unknown value.

```ts
const parser = z.preprocess((data) => Number(data), z.number());

type Input = z.input<typeof parser>;
assertEqual<Input, unknown>(true);
```",,
1368965441,1403,[question] is it possible to stop parsing on the first error?,"I'm using Zod to validate HTTP payloads, some of which may be expensive to validate. Is it possible for `schema.parse()` and their friends to stop on the first error and return a single ZodIssue?",,
1368880995,1400,Feature request. Enable or disable .strict() by argument,"For the staging environment, I want to provide additional protocol validation with `strict` parsing, but it can break something on production, so I see the next solution
`.strict(process.env.NODE_ENV === 'development')`
and it gives
* `.strict()` â€” strict mode enabled
* `.strict(true)` â€” strict mode enabled
* `.strict(false)` â€” strict mode disabled

Is it hard to implement?",,
1368727739,1399,Feature Request: Less strict enum / oneOf,"Right now `z.enum` only works when you have a constant/static array of strings:

```ts
const FishEnum = z.enum([""Salmon"", ""Tuna"", ""Trout""]);
type FishEnum = z.infer<typeof FishEnum>;
```

But this doesn't work for dynamic arrays:

```ts
declare const fish: string[];
const Fish = z.enum(fish);
// ts-error: Argument of type 'string[]' is not assignable to parameter of type '[string, ...string[]]'.
```

It also doesn't work for arrays of other primitive types:

```ts
const months = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] as const;
const Month = z.enum(months);
// ts-error: Argument of type 'readonly [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]' is not assignable to parameter of type '[string, ...string[]]'.
```

It's possible to solve this with `refine`:

```ts
const Fish = z.string().refine((value) => fish.includes(value));
const Month = z.number().refine((value): value is typeof months[number] => months.includes(value));
```

However other libraries like Yup provide a convenient `oneOf` method for these cases:

```ts
const Fish = yup.string().oneOf(fish);
const Month = yup.number().oneOf(months);
const Mixed = yup.mixed().oneOf(['foo', 42, true]);
```

Is there any appetite to add a less strict version of `enum` / `oneOf` to Zod?",,
1367765113,1397,Strange Error with AngularV9 and Ionic,"I get the following errors with zod@3.17.3 and the latest Zod release when compiling a Ionic project which uses AngularV9. downgrading to zod@1.11 fixes it

`[ng] ERROR in node_modules/zod/lib/helpers/enumUtil.d.ts:4:10 - error TS2456: Type alias 'UnionToTuple' circularly references itself.
[ng] 4     type UnionToTuple<T, Tuple extends unknown[] = []> = [T] extends [never] ? Tuple : UnionToTuple<Exclude<T, GetUnionLast<T>>, [GetUnionLast<T>, ...Tuple]>;
[ng]            ~~~~~~~~~~~~
[ng] node_modules/zod/lib/helpers/enumUtil.d.ts:4:88 - error TS2315: Type 'UnionToTuple' is not generic.
[ng] 4     type UnionToTuple<T, Tuple extends unknown[] = []> = [T] extends [never] ? Tuple : UnionToTuple<Exclude<T, GetUnionLast<T>>, [GetUnionLast<T>, ...Tuple]>;
[ng]                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[ng] node_modules/zod/lib/helpers/enumUtil.d.ts:4:148 - error TS2574: A rest element type must be an array type.
[ng] 4     type UnionToTuple<T, Tuple extends unknown[] = []> = [T] extends [never] ? Tuple : UnionToTuple<Exclude<T, GetUnionLast<T>>, [GetUnionLast<T>, ...Tuple]>;
[ng]
        ~~~~~~~~
[ng] node_modules/zod/lib/helpers/enumUtil.d.ts:6:59 - error TS2315: Type 'UnionToTuple' is not generic.
[ng] 6     export type UnionToTupleString<T> = CastToStringTuple<UnionToTuple<T>>;
[ng]                                                             ~~~~~~~~~~~~~~~
[ng] node_modules/zod/lib/helpers/partialUtil.d.ts:4:29 - error TS2589: Type instantiation is excessively deep and possibly infinite.
[ng] 4         [k in keyof Shape]: ZodOptional<DeepPartial<Shape[k]>>;
[ng]                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[ng] node_modules/zod/lib/types.d.ts:354:14 - error TS2456: Type alias 'deoptional' circularly references itself.
[ng] 354 declare type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U> ? deoptional<U> : T;
[ng]                  ~~~~~~~~~~
[ng] node_modules/zod/lib/types.d.ts:354:82 - error TS2315: Type 'deoptional' is not generic.
[ng] 354 declare type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U> ? deoptional<U> : T;
[ng]                                                                                      ~~~~~~~~~~~~~
[ng] node_modules/zod/lib/types.d.ts:400:25 - error TS2315: Type 'deoptional' is not generic.
[ng] 400         [k in keyof T]: deoptional<T[k]>;
[ng]                             ~~~~~~~~~~~~~~~~
[ng] node_modules/zod/lib/types.d.ts:463:145 - error TS1256: A rest element must be last in a tuple type.
[ng] 463 export declare type OutputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...OutputTypeOfTuple<T>, ...Rest[""_output""][]] : OutputTypeOfTuple<T>;
[ng]
       ~~~~~~~~~~~~~~~~~~~~~~~
[ng] node_modules/zod/lib/types.d.ts:467:144 - error TS1256: A rest element must be last in a tuple type.
[ng] 467 export declare type InputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...InputTypeOfTuple<T>, ...Rest[""_input""][]] : InputTypeOfTuple<T>;
[ng]
      ~~~~~~~~~~~~~~~~~~~~~~`",,
1367427392,1396,Zod wiht useFieldArray from react-hook-form,"Hi, I'm very newbie.

I would like to use zod validation and useFieldArray from react-hook-form.

```
const schema = z.object({
  items: z.object(
    {
       name: z.string().min(1, 'Required'),
       startAt: z.date(),
       endAt: z.date(),
    },
  ).array(),
).sueprRefine((val, ctx) => {
  ctx.addIssue({
    code: z.ZodIssueCode.custom,
    message: 'TEST ERROR MSG',
    path: ['items', 0, 'name']
  });
);
```
I made above validation schema.
When I got some validation error, how can I set the error message to the form using useFieldArray() ?
My form fields use MUI Controller.
",,
1367304243,1395,nonzero() like nonnegative() and nonpositive(),"I want to parse mongodb sort object like this
```js
{
  name: 1,
  age: 1
}
```
how can I ensure that the value is one of [-1, 1], I know, I can use it with different approaches like using `preprocess` or `transform` but they are not one-word solutions (**zod is preferable for**). If nonzero() is implemented, we can write this like this
```ts
const validator = z.object({
  age: z.number().min(-1).max(1).nonzero(),
});
```

This can also achieved with `in([...])` modifier
```ts
const validator = z.object({
  age: z.number().in([-1,1]),
});
```

The `in([...])` modifier can be found in many validators. `nonzero()` is also very useful()

",,
1366931572,1394,Feature: Conditional Validation Similar to yup.when(),"Similar to this Yup issue: https://github.com/jquense/yup/issues/176 and creating a new issue out of #61.

Many users of zod would like to do conditional requirement or validation of fields based on either fields passed as context to zod, or based off of the value of another schema property. This is common to do in form validations.

The closed issue #61 addresses how to do conditional validation with `superRefine`. This works well enough in small cases, but many folks have large complex schemas and we would like to _keep_ the existing validation on an object i.e. not have to make the entire object partial in order for conditional requirement to work.

This issue stems from the reaction to my comment https://github.com/colinhacks/zod/issues/61#issuecomment-1171958123

Pasting from the comment as my case is the same:
I have large schema that needs to require one or another field. A nested partial Zod object with `superRefine` works for this.

What I want to be able to do however, is to do conditional requirement on 1 or 2 fields without making the entire object partial and while having access to all of the fields in the object.

Ex:
I have a required enum that has two values: ""ValueA"" and ""ValueB""

Upon ""ValueA"" then someOtherFieldA is required. Upon ""ValueB"" then someOtherFieldB is required.

There are also other required fields within the schema that should remain required without explicitly checking them in something like `superRefine`.

The reason I chose zod over yup was TypeScript support, but in yup's beta versions TS support has improved a lot. Not having a functionality like this is a big blocker for me wanting to keep using zod. Thanks!

",,
1365237632,1392,Branded object types loose `z.ZodObject` functionalities,"When branding an object all the `z.ZodObject` functionalities are lost, is that the expected behavior or is there something that can be fixed in the types when using `z.brand()`?

This happens on the latest version `3.19.0`.

Here's a minimal reproduction:
```ts
export const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  age: z.number().int().positive().min(18).max(99),
  email: z.string().email(),
}).brand<'User'>();

const age = UserSchema.shape.age.parse(28) // Cannot read properties of undefined (reading 'age')

export const UserDomain = UserSchema.strict() // UserSchema.strict() is not a function
  .merge( // UserSchema.merge() is not a function
    z.strictObject({
      id: UserId,
    })
  );
```",,
1365230704,1391,Feature Request: Parse on output schemas,"### Summary

TL;DR - I'd love to be able to take the output of a zod pipeline (esp. including `.transform()`) and have the ability to call `.parse()` on it.

Or to think about it a slightly different way, I'd like something like `z.infer()`, except a real function I can call `.parse()` on instead of just a type utility.

For me, this is going to be most useful when reading previously parsed JSON data back from a JSON column in the database.

### Use Case

I'm using zod to parse data I receive from an api, transform it, and then store it in a db using prisma.

On the way in, I can use a schema like this, no problem:

`z.object({...}.transform({...}`

The problem is reading that data from the db later. If I try to call schema.parse on it, it will fail because the data matches the _output_ schema as opposed to the _input_ schema.

I know about `z.infer()` - it does what I want, except it's only a type utility rather than a real schema I can call.  Because the data is a JSON column in the db, I'd really prefer to use schema.parse() instead of just typecasting so I can get the runtime safety and not just suppress the compiler errors.

The obvious workaround for now is to track the input and output schemas separately. But then I'm effectively duplicating code between the transform and output schema. Not the end of the world, but not ideal.

I think I'm basically asking to replicate the whole `z.input` / `z.output` / `z.infer` paradigm, except with real classes that essentially clone the output of the pipeline for parsing.

### Appreciation / Next Steps

Thank you for your consideration and the wonderful library!  I've been blown away by how useful everything is.

Also, I could perhaps take a crack on the implementation of this if y'all feel it's a good idea that's worth doing.",,
1365028842,1390,"Request: Introduce ZodTransformError type, to allow for transforms that fail","When attempting a transform, it's possible that the transform may fail. In this case, there is no value to return, so it's necessary to return a typecast dummy value. Returning a typecast dummy value violates Zod's type-safety. 

Allowing a transform function to throw a special error type, e.g. `ZodTransformError`, to signal a controlled transform failure, would make for nicer DX.

The error type would contain an array of issues, which would be added to the parse result, and the issues would be considered fatal.

The following serves as an example:

```ts
import { ZodTransformError } from ""zod"";

const user = z.string().transform(async (id) => {
  try {
    const user = await getUserById(id);
    return user;
  } catch (e) {
    throw new ZodTransformError([{
      code: ""custom"",
      message: ""User not found"",
    }]);
  }
});
```



See https://github.com/colinhacks/zod/pull/1389 for a potential implementation",,
1364847905,1388,Allow optional() typings to work also for non-optional but possibily undefined fields,"Hello everyone, Zod is awesome!

While working with Zod I ended up in a particular situation, I didn't find any other reference to this problem except [this StackOverflow question](https://stackoverflow.com/questions/71477015/specify-a-zod-schema-with-a-non-optional-but-possibly-undefined-field) with no useful answer.

I prepared a [Code Sandbox](https://codesandbox.io/s/admiring-sara-7k0f70?file=/src/index.ts:0-575) to show the issue.

```ts
interface IFoo1 {
  somefield: string | undefined;
}

const schema1a: ZodSchema<IFoo1> = z.object({
  somefield: z.string().optional()
});

const schema1b: ZodSchema<IFoo1> = z.object({
  somefield: z.union([z.string(), z.undefined()])
});
```
When I declare a Typescript interface (`IFoo1`) with a required field, which can be both of a certain type and `undefined` I would expect that Zod would be fine with declaring that field as `optional()`. That didn't work, also using a `union()` type didn't work.

Do you have any idea how to solve it? IMHO I would allow `optional()` to accept a type that is required but could be `undefined` since from JS perspective they should be the same, but I'd like to hear more from you!

Thank you!",,
1363650232,1387,"VSCode Intellisense shows raw structure instead of type name, resulting in very long popups","I have these following types and function in which I tested this with:

```ts
export const IRFIDTag = z.object({
    id: z.number(),
    epc: z.string(),
    location: z.string(),
    createdAt: z.instanceof<new () => Dayjs>(dayjs as any),
    relatedJob: z.lazy(() => z.optional(IProductionJob)), // imported from elsewhere
});
export type IRFIDTag = z.infer<typeof IRFIDTag>;

export const IRFIDTagLocation = z.object({
    location: z.string(),
    from: z.instanceof<new () => Dayjs>(dayjs as any),
    to: z.instanceof<new () => Dayjs>(dayjs as any).optional(),
});
export type IRFIDTagLocation = z.infer<typeof IRFIDTagLocation>;

export const IRFIDTagWithLocation = IRFIDTag.extend({
    locationRelationship: z.object({
        currentLocation: IRFIDTagLocation,
        previousLocations: IRFIDTagLocation.array(),
    }),
});
export type IRFIDTagWithLocation = z.infer<typeof IRFIDTagWithLocation>;

const output: IRFIDTag = getTag();
const res: IRFIDTagWithLocation = {
  ...output, // The following error happens when I comment this line, Missing id, epc, location, createdAt
  ...rest // abstracts actual implementation
}
```

When using these types and I encounter an error, the Intellisense popup is extremely long and hard to read. These are the outputs from the same error:
```
// Using Zod infer types
Type '{ locationRelationship: { currentLocation: { to?: Dayjs | undefined; location: string; from: Dayjs; }; previousLocations: { to?: Dayjs | undefined; location: string; from: Dayjs; }[]; }; relatedJob: { ...; } | undefined; }' is not assignable to type 'IRFIDTagWithLocation'.
  Type '{ locationRelationship: { currentLocation: { to?: Dayjs | undefined; location: string; from: Dayjs; }; previousLocations: { to?: Dayjs | undefined; location: string; from: Dayjs; }[]; }; relatedJob: { ...; } | undefined; }' is missing the following properties from type '{ relatedJob?: { name?: string | undefined; dueDate?: Dayjs | undefined; completedDate?: Dayjs | undefined; assignedTo?: string | undefined; assignedAt?: Dayjs | undefined; ... 4 more ...; isRFIDTracked: boolean; } | undefined; location: string; id: number; epc: string; createdAt: Dayjs; }': location, id, epc, createdAt ts(2322)

// Hardcoding types (i.e. creating types with the same key/pair types as the Zod object instead of z.infer)
Type '{ locationRelationship: { currentLocation: IRFIDTagLocation; previousLocations: IRFIDTagLocation[]; }; relatedJob: { name?: string | undefined; ... 8 more ...; isRFIDTracked: boolean; } | undefined; }' is not assignable to type 'IRFIDTagWithLocation'.
  Type '{ locationRelationship: { currentLocation: IRFIDTagLocation; previousLocations: IRFIDTagLocation[]; }; relatedJob: { name?: string | undefined; ... 8 more ...; isRFIDTracked: boolean; } | undefined; }' is missing the following properties from type 'IRFIDTag': id, epc, location, createdAt ts(2322)
```

Is there any way for Intellisense to recognize type names made with Zod infer?",,
1362872071,1384,discriminatedUnion with recursive type results in ts error,"I have a situation where I want to use a recursive type inside discriminated union type.

It results into this error:

```
 Argument of type '[ZodObject<{ type: ZodLiteral<""a"">; a: ZodString; }, ""strip"", ZodTypeAny, { type: ""a""; a: string; }, { type: ""a""
 ; a: string; }>, ZodObject<{ type: ZodLiteral<...>; b: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, ZodType<...>]' is n
 ot assignable to parameter of type '[ZodDiscriminatedUnionOption<""type"", Primitive>, ZodDiscriminatedUnionOption<""type"", Primitive
 >, ...ZodDiscriminatedUnionOption<...>[]]'.
   Type at position 2 in source is not compatible with type at position 2 in target.
     Type 'ZodType<Category, ZodTypeDef, Category>' is missing the following properties from type 'ZodObject<{ type: ZodLiteral<Pri
 mitive>; } & ZodRawShape, any, any, { [x: string]: any; }, { [x: string]: any; }>': _cached, _getCached, shape, strict, and 14 mor
 e.
```

There seems to be a conflict between `ZodType` and `ZodDiscriminatedUnionOption`. 

Here the example I used:

```ts
interface Category {
  type: ""c"";
  c: Category[];
}

// cast to z.ZodType<Category>
const category: z.ZodType<Category> = z.lazy(() =>
  z.object({
    type: z.literal(""c""),
    c: z.array(category),
  })
);

const item = z
  .discriminatedUnion(""type"", [
    z.object({ type: z.literal(""a""), a: z.string() }),
    z.object({ type: z.literal(""b""), b: z.string() }),
    category,
  ])
  .parse({ type: ""a"", a: ""abc"" });

```",,
1362324110,1382,Branded Types and .brand documentation is not reflected in table of contents,"As above, there is a Branded link in the TOC which doesn't go anywhere, and the .brand() method doesn't have an entry. I'm on mobile, so some of the terms may not be exact, but hopefully the meaning is clear!",,
1361649615,1381,Check if object has keys,"```
z.object({}).resign( ( val ) => {
 return Object.keys(val) === 0 ? false : return
} )
```
It doesn't work. 
",,
1361580171,1380,optional must be removed from object if undefined,"**Schema**
```ts
const insertable = z.object({
  name: z.string().trim().min(2),
  age: z.number(),
});

const updatable = insertable.partial();
```

**Request Body**
```ts
const body = {
  name: ""Vikas"",
  age: undefined,
};
```
Now when the body is parsed with updatable schema,
```ts
const update = updatable.parse(body); // => { name : ""Vikas"" }
```
 it must return 

```ts 
{ name: ""User"" } 
```
instead of  
```ts 
{
  name: ""Vikas"",
  age: undefined,
}
```",,
1361424008,1378,Schema with a `transform` results in an invalid intersection,"Given a schema like:

```ts
const workflowSchema = z.object({
      sequence: z.number(),
      state: z.nativeEnum(WorkflowState),
      in_bundle: z.boolean(),
      timestamp: z.string().transform(value => DateTime.fromISO(value)),  // Luxon Datetime
})
```

which is intersected with another schema to parse an object, e.g.:

```ts
const apiSchema = z.intersection(featureSchema, workflowSchema)
```

This is not built via `extends` because `featureSchema` is defined to be used directly from files as well as via the API.

Since upgrading Zod (from 3.2 to 3.18) this results in an invalid intersection. From the debugger I've shown that `timestamp` fails in `mergeValues`.

My workaround is to transform after merge, e.g.

```ts
const apiSchema = z.intersection(featureSchema, workflowSchemaNoTransform)
    .transform(value => ({ ...value, timestamp: DateTime.fromISO(value) }))
```

I don't know if there's a ""fix"" here. I get why it's failing. It would be good to get a more useful error message, rather than having to poke around in the debugger to realise why it fails.",,
1361051376,1376,Schema parse function accepts additional param for data validation,"Hi. Thank you for an awesome library.

I want to know if zod can give options to parse function of schema.
I want to make similar type and validation using zod for this F# example (https://github.com/swlaschin/DomainModelingMadeFunctional/blob/master/src/OrderTaking/Common.SimpleTypes.fs)

```F#
module OrderQuantity  =

    /// Return the value inside a OrderQuantity
    let value qty =
        match qty with
        | Unit uq ->
            uq |> UnitQuantity.value |> decimal
        | Kilogram kq ->
            kq |> KilogramQuantity.value

    /// Create a OrderQuantity from a productCode and quantity
    let create fieldName productCode quantity  =
        match productCode with
        | Widget _ ->
            UnitQuantity.create fieldName (int quantity) // convert float to int
            |> Result.map OrderQuantity.Unit             // lift to OrderQuantity type
        | Gizmo _ ->
            KilogramQuantity.create fieldName quantity
            |> Result.map OrderQuantity.Kilogram         // lift to OrderQuantity type
```

It needs additional param ""**productCode**"" for quantity validation for like this.

```TypeScript
export const UnitQuantity = z
  .number()
  .int()
  .min(1)
  .max(1000)
  .brand<""UnitQuantity"">();
export type UnitQuantity = z.infer<typeof UnitQuantity>;

export const KilogramQuantity = z
  .number()
  .min(0.05)
  .max(100)
  .brand<""KilogramQuantity"">();
export type KilogramQuantity = z.infer<typeof KilogramQuantity>;

export const OrderQuantity = z
  .union([UnitQuantity, KilogramQuantity]).refine((val, productCode) => {
    if (productCode.startsWidth('W')) {
      return UnitQuantity.safeParse(val).success;
    } else if (productCode.startsWidth('G')) {
      return KilogramQuantity.safeParse(val).success;
    } else {
      return false;
    }
  })
  
const validatedOrderQuantity = OrderQuantity.parse(10, 'Widget');
```
  
  I don't know how to make this work.
  Thank you. Any comment would be appreciated!",,
1360739815,1375,"Unable to do .partial and getting ""TypeError: Cannot read properties of undefined (reading 'partial')""","I'm using zod in my NextJS project, and when trying to a .partial on a schema I get the a ""TypeError: Cannot read properties of undefined (reading 'partial')""

Here is my setup.

Models.tsx

```
const TripSchema = z.object({
    id: z.string(),
    user_id: z.string(),
    name: z.string(),
})

type Trip = z.infer<typeof TripSchema>

export type { Trip, TripSchema }
```

I'm trying to validate the shape of form input (in a modal) as follows:

AddTripModal.tsx

```
import { useState } from 'react'
import { Button, Modal } from 'react-daisyui'
import { TripSchema } from './Models'

type ModalProps = {
    open: boolean
    onClose: () => void
}

const AddTripModal = (props: ModalProps) => {
    const [trip, setTrip] = useState({
        user_id: '',
        name: '',
    })

    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const { name, value } = e.target
        setTrip((prev) => {
            console.log(prev)
            return { ...prev, [name]: value }
        })
    }

    const handleSubmit = (e: React.ChangeEvent) => {
    
        e.preventDefault()

        console.log(trip)

        const optionalId = TripSchema.partial({
            id: true,
        })

        if (optionalId.safeParse(trip).success) {
            console.log('zod success')
        }
    }

    return (
        // jsx for form
    )
}

export default AddTripModal
```

In VSCode, it seems like eslint does not like my using TripSchema but does not give me any reason why:

![image](https://user-images.githubusercontent.com/9031145/188253770-7359172d-08a9-41ca-8c4d-8a58fb411a7a.png)

And when I visit the page and tap submit on my form, it does have an object with data from the form fields:

![image](https://user-images.githubusercontent.com/9031145/188253807-5e9a4f12-7350-4ea3-889a-0e998ac6ba9f.png)

But I get this error:

![image](https://user-images.githubusercontent.com/9031145/188253872-0f2c44c3-fb4f-4d28-aa9f-c412d897f4eb.png)

Any idea how to resolve this?


",,
1360179978,1374,Type inference problem with extending generic ZodObject,"First of all, thanks for the great library! ðŸ™

I have a small problem with inferencing the type of a generic ZodObject's shape.

#### Problem description

I have a CMS API that sends localizations of different entities in a certain format. Simplified example of an article entity:
```json
{
  ""title"": ""English title"",
  ""locale"": ""en"",
  ""localizations"": [
    {
      ""title"": ""French title"",
      ""locale"": ""fr""
    }
  ] 
}
```

This is the Zod-schema used for the articles:

```typescript
const Article = z.object({
  title: z.string(),
  locale: z.string(),
})
```

I wanted to make a helper function which takes a ZodObject as an input and extends it with localizations field:

```typescript
const withLocalizations = <T extends z.ZodObject<any>>(zodObject: T) => zodObject.extend({
  localizations: zodObject.array()
})
```

Then I would use it like so:

```typescript
const ArticleWithLocalizations = withLocalizations(Article)
```

Unfortunately, with this setup the TS compiler loses track of the original fields and thinks that `ArticleWithLocalizations` has only `localizations` field. Supposedly that's because of the any-type used in `withLocalizations`.

#### Partial solution

I found a solution by passing the shape to `withLocalizations` but I think this is quite verbose:

```typescript
const withLocalizations = <S extends z.ZodRawShape, T extends z.ZodObject<S>>(zodObject: T) => zodObject.extend({
  localizations: zodObject.array()
})

const Article = z.object({
  title: z.string(),
  locale: z.string(),
})

type ArticleType = typeof Article

const ArticleWithLocalizations = withLocalizations<ArticleType[""shape""], ArticleType>(Article)
```

#### Question
Is there a way to infer the type of the shape inside `withLocalizations` without passing it explicitly?


",,
1359901825,1373,"[question] How to ""deep"" parse schema that contains JSON string?","I'm using Zod to validate HTTP request that contains JSON data. Currently, I'm using a pattern like the one that follows (simplified, for readability):

```ts
const z = require('zod')
const payloadSchema = z.object({ name: z.string(), age: z.number().min(18) })
const requestSchema = z.object({ payload: z.string() })
// ...

const req = requestSchema.parse(request)
const raw = JSON.parse(req.payload)
const payload = payloadSchema.parse(raw)

console.log(payload.name) // << this is what I'm interested into
```

Would there be a more strait-forward way to _deep parse_ a shape that contains JSON string that I don't know of?

```ts
const z = require('zod')
const payloadSchema = z.object({ name: z.string(), age: z.number().min(18) })
const requestSchema = z.object({ payload: z.string().json(payloadSchema) })
// ...

const req = requestSchema.parse(request)
console.log(req.payload.name) // << this is what I'm interested into
```

-- _this question was also posted in [stackoverflow](https://stackoverflow.com/questions/73580183/how-to-deep-parse-schema-that-contains-json-string-using-zod/73580486#73580486)._",,
1359640913,1372,How to compare schemas?,"Looking for some help and guidance on comparing two Zod schemas. 
More specifically, I would like to assert whether a schema contains another schema. For example,
```
const u = z.object({ a: z.string(), b: z.number() })
const v =  z.object({ a: z:string() })
u.contains(v) // pseudo code, expect true
```

more details on my somewhat unusual use case. 
For example, with the following type definition
``` typescript
function a(): { x: string, y: string };
function b({ x: string }): void;
function c({ y: string }): void;
```

- functions a is compatible with b and c. because both b(a()) and c(a()) are valid. 
- while b and c are not compatible with each other, doing a(b('')) will result in a type error. 

Typescript works well in handling this if how the functions are combined is predetermined at compile time. However, in my use case,  how the functions are chained together is determined at runtime. 

So I thought maybe I can leverage Zod to define the function's interfaces and use that to the compatibility at runtime. 
``` typescript
const a = z.function().args().returns({ x: z.string(), y: z.string() });
const b = z.function().args({ x: z.string() });
const c = z.function().args({ y: z.string() });

// how do I do something like this? using chai expect as an example below
expect(a.returnTypes()).deep.includes(b.parameters()) // true
expect(a.returnTypes()).deep.includes(c.parameters()) // true
expect(b.returnTypes()).deep.includes(c.parameters()) // false
```
Well, this doesn't work. Running the following 
```typescript
expect(z.string()).deep.include(z.string());
```
gives
```
AssertionError: expected ZodString{ â€¦(24) } to have deep property 'spa' of [Function bound safeParseAsync], but got [Function bound safeParseAsync]
```
How should I go about comparing two Zod schemas? 
Any pointer is much appreciated. Thanks
",,
1359465889,1371,"Why do I get custom error messages ""sometimes""?","As you can see in the comparison below. The only difference being that the ""Required"" message is triggered when the error occurs, whereas the more verbose (custom) error message appears randomly, typically when I am working on the code.

<img width=""855"" alt=""Screenshot 2022-09-01 at 23 10 51"" src=""https://user-images.githubusercontent.com/27443324/188021787-1728a285-652b-4f17-b777-3eedc1b08540.png"">

<img width=""839"" alt=""Screenshot 2022-09-01 at 23 10 34"" src=""https://user-images.githubusercontent.com/27443324/188021792-a292d0b7-680d-413f-b58b-0e59a84e331a.png"">

It would be great if someone could help me figure out why this is happening? The code is fairly straightforward:

```
  mainImages: z
    .array(z.string())
    .min(1, { message: 'Please upload at least one image' }),
```",,
1359450739,1370,Feature request: `.deepStrict`,"Like `.deepPartial` is to `.partial` it would be beneficial to have a `.deepStrict` function that ensures every level in an object, array, or tuple hierarchy is `.strict`.

For example, this code does _not_ generate a ZodError:
```
const person = z
  .object({
    name: z.string(),
    meta: z.object({
      born: z.string(),
    }),
  })
  .strict();

person.parse({
  name: ""bob dylan"",
  meta: {
    born: ""a place"",
    extraKey: 61,
  },
});
```

With `.deepStrict` it would work like this:
```
const person = z
  .object({
    name: z.string(),
    meta: z.object({
      born: z.string(),
    }),
  })
  .deepStrict();

person.parse({
  name: ""bob dylan"",
  meta: {
    born: ""a place"",
    extraKey: 61,
  },
});
// => throws ZodError
```",,
1358017535,1369,Property 'brand' is missing in type ZodObject<{...}>,"Any idea as to what the problem might be? Example below. 
Zod 3.17.10
React 18.2.0
React-Native: 0.66.1

Property 'brand' is missing in type 'ZodEnum<[""Adventurous"", ""Affectionate"", ""Calm"", ""Carefree"", ""Caring"", ""Cautious"", ""Cooperative"", ""Curious"", ""Disciplined"", ""Easy-Going"", ""Energetic"", ""Free-flowing"", ""Intense"", ... 16 more ..., ""Trusting""]>' but required in type 'ZodEnum<[string, ...string[]]>'.",,
1357183210,1368,"Ability to ""name"" an enum","Consider this Zod-to-Nexus function:

```ts
export const enumType = <
  S extends
    | z.ZodNativeEnum<any>
    | z.ZodEnum<[string, ...string[]]>
    | z.ZodUnion<[z.ZodLiteral<string>, ...z.ZodLiteral<string>[]]>
>(
  schema: S,
  config?: { name: string; case?: 'camel' | 'snake' }
) => {
  const name = config?.name ?? schema._def.typeName
  const enumifyThis = enumify(config?.case ?? 'snake')
  const members =
    'options' in schema._def
      ? // union case
        schema._def.options.map((_) => _._def.value).map(enumifyThis)
      : // enum case
      Array.isArray(schema._def.values)
      ? schema._def.values.map(enumifyThis)
      : values(schema._def.values)
          .map((_) => String(_))
          .map(enumifyThis)
  return Nexus.enumType({
    name,
    members,
  })
}
```


When using it today it is not possible to capture the enum name so we get code like this:

```ts
const ExternalErrorDatabaseKind = z.enum([
   'IntrospectionFailure',
   'NotEmpty',
   'PushSchemaFailure',
   'SeedFailure',
])

NexusZod.enumType(ExternalErrorDatabaseKindEnum, {
   name: 'ExternalErrorDatabaseKind',
})
```

What I wish we could do is just:

```ts
NexusZod.enumType(ExternalErrorDatabaseKindEnum)
```

Which would I guess be powered by a new Zod method on enums like this:

```ts
const ExternalErrorDatabaseKind = z.enum([
   'IntrospectionFailure',
   'NotEmpty',
   'PushSchemaFailure',
   'SeedFailure',
]).name(`ExternalErrorDatabaseKind`)
```

Or maybe unify name and description under the concept of ""metadata"":


```ts
const ExternalErrorDatabaseKind = z.enum([
   'IntrospectionFailure',
   'NotEmpty',
   'PushSchemaFailure',
   'SeedFailure',
]).metadata({ name: `ExternalErrorDatabaseKind`, description: 'foobar' })
```",,
1356741230,1367,Strip unknown types in a discriminated union when parsing,"## Summary
Is it possible for a discriminated union to optionally ignore unknown values when parsing?

## Detail
Let say I have the following models:

```ts
export const BaseProviderResponseModel = z.object({
    type: z.string(),
    name: z.string(),
});

export const LocalProviderResponseModel = BaseProviderResponseModel.extend({
    type: z.literal(""local""),
});

export const OAuthProviderResponseModel = BaseProviderResponseModel.extend({
    type: z.literal(""oauth""),
    url: z.string().url(),
});

export const ProviderResponseModel = z.discriminatedUnion(""type"", [
    LocalProviderResponseModel,
    OAuthProviderResponseModel,
]);
```

When parsing a response using `ProviderResponseModel` I'm expecting to receive either a `type=""local""` or `type=""oauth""` and this works fine.

At some point in the future the data I parse may present other types I do not yet know about but I would like for them to just be stripped rather than throwing an error about an unknown discriminator value.

Am I missing an obvious way to do this?",,
1356480463,1366,pass context to default function ,"a schema like

```
z.object({
   somearg: z.someschema()
   otherarg:z.schema().default((context)=>({
        arg: context.parent.data.somearg.somneprop
   }))
})
```

would be a nice addition 
(depending on how its parsed i can see that this might be somewhat interesting if the field order is changed but i think thats something the developer should keep in mind - long term it might be a good idea to do all the other validating first before invoking the defaults ðŸ¤”)",,
1356446373,1365,ZodError in preprocess should wrap with path,"having a schema definition like :

```
 z.object({
	port: z.preprocess(
		(a) => parseInt(z.string().parse(a), 10),
		z.number().positive()
	),
})
```
if the preprocessor throws an exception (for example if the value is undefined) the error looks like this:
```
ZodError: [
  {
    ""code"": ""invalid_type"",
    ""expected"": ""string"",
    ""received"": ""undefined"",
    ""path"": [],
    ""message"": ""Required""
  }
]
```
with no indication which property the error originated from 
generally i think all errors thrown in `preprocess` should be wrapped and their field added to the path
",,
1354689510,1362,"Using `z.function(z.tuple([...]), ...).implement()` form results in TS2345 in TypeScript 4.8",zod was listed in microsoft/TypeScript#50060 with several issues. I've actually encountered the issue listed for [src/tests/function.test.ts#L115](https://github.com/colinhacks/zod/blob/master/src/__tests__/function.test.ts#L115) in the zod tests.,,
1353253174,1359,Module parse failed error from Zod enum. ,"Update - figured out this is a problem with symlink/babel and not Zod

I'm getting this error, I believe from this zod enum. At the very least the error goes away if I changes the options prop on Autocomplete. Any idea what's causing this? Let me know if there's any other info needed.

Zod: 3.18.0
Material UI: 5.10.2
React: 18.2.0

```
export const countries = z.enum([
  ""United States"",
  ""Canada"",
  ""Afghanistan"",
  ""Albania"",
  ""Algeria"",
  ""American Samoa"",
  ... every other country
])
export type Countries = z.infer<typeof countries>

<Autocomplete 
options={[schema.countries.options]}
renderInput={(params) => (<></>)
/>
```
`Module parse failed: Unexpected token (9:7)
File was processed with these loaders:
 * ./node_modules/@pmmmwh/react-refresh-webpack-plugin/loader/index.js
 * ./node_modules/source-map-loader/dist/cjs.js
You may need an additional loader to handle the result of these loaders.`",,
1350835413,1356,special case: union types with omit and extended schema throws TS error,"We have the following case:

a base type:

![image](https://user-images.githubusercontent.com/827205/186662736-d5c13df1-355f-45e2-b33e-c9c0a07c7d24.png)

multiple extended types, one of them omits the `background_variant` field:

![image](https://user-images.githubusercontent.com/827205/186662838-d242d7d9-781d-42e0-8cab-f67bb038f265.png)

one union type for all of them:

![image](https://user-images.githubusercontent.com/827205/186663054-f5f62660-4654-4d3f-a30c-a454b728d871.png)

usage of some fields:

![image](https://user-images.githubusercontent.com/827205/186663267-e7cc0a03-e083-45ff-ba47-a58ec6851911.png)

Which results in this error:

```
error TS2339: Property 'background_variant' does not exist on type '{ type: ESuluContentBlockTypes.TEXT; settings: { hidden: boolean; schedules_enabled: boolean; schedules: ({ type: ESuluSettingsScheduleTypes.FIXED; start: string; end: string; } | { ...; })[]; } | {} | string[]; background_variant: ESuluContentBlockBackgroundVariants | null; title: string; description: string; } | ....'.
```

What is the correct approach to resolve this?",,
1348426933,1354,Is there a way to serialize and restore a simple schema?,"Hello! I wanted to try using one schema for parsing incoming data on the server and validating form fields. But at the same time, I would like to leave the schema description on the server side and not take this code into a separate package for reuse on the client.",,
1348162179,1353,Recursive type does not have same types after transforms,"I must be doing something wrong or I'm thinking of a solution in a wrong way.

I have this schema and type

```ts
function transformInvalidArrayValues<T>(
  value: (string | T)[],
): T[] {
  return value.filter((val): val is T => !!val && isReferenced(val));
}

function isReferenced<T>(ref: string | T): ref is T {
  return typeof ref !== 'string';
}

const CountryTargetableSchema = z.object({
  countries: z
    .array(z.union([z.string(), CountrySchema]))
    .transform(transformInvalidArrayValues),
});

type CountryTargetable = z.infer<
  typeof CountryTargetableSchema
>;
```

The CountryTargetable type is, as expected, now an array of valid objects that respect the CountrySchema (not relevant since it's just other fields).

But now, I need to define a recursive type that extends this structure.

```ts
interface Node extends CountryTargetable {
  testing: string;
}

export const NodeSchema: z.ZodType<Node> = z.lazy(() =>
  CountryTargetableSchema.extend({
    testing: z.string()
  })
);
```

but this is giving a Type error:

```
The types of '_input.countries' are incompatible between these types.
Type '(string | { uid: string; title: string; locale: string; country_code: string; })[]' is not assignable to type '{ uid: string; title: string; locale: string; country_code: string; }[]'
```

seemingly ignoring the transforms that were performed by the schema.

I have a feeling I might be doing something wrong or thinking about things wrong or confusing something.

Does anyone have any idea what might be the issue here? ",,
1346531288,1350,Is it possible to custom validate the allowed keys when. using .passthrough or .strip?,"I first want to congratulate you to a very well designed and implemented library!

I'm currently evaluating the use of zod in my application and have a small problem when having to parse an object that can contain optional keys. I'm using .passthrough to allow the keys to stay in the object but would like to custom validate the keys or at least make sure that the key names and types are valid. The .catchall only allows to specify a type of all optional keys but I would require to custom validate each optional key.

```typescript
import {z} from 'zod';

// mandatory user information
const user = z.object({
    id: z.number(),
    name: z.string(),
});

// additional keys like:
// string: key in the format /^add_\d{3}_s$/
// number: key in the format /^add_\d{3}_n$/ 

add_001_s: z.string()
add_002_s: z.string()
add_003_n: z.number()
add_004_n: z.number()
```",,
1340868784,1341,Unparse/serialize,"It would be nice to use zod schemas to serialize data, effectively doing the inverse of parse method.

All transforms would have to be reversed and optionally fields with default values should be omitted.

One potential problem is that transforms are not bidirectional so that would have to be added first.",,
1340865011,1340,Support passthrough on z.record,"Although zod support `passthrough` automatically on `z.instanceof`, and with explicit use of of the `passthrough` method on `z.object`; there seems to be no way to replicate this functionality with `z.record`. When writing a class decorator for Vue, I ran info this problem where parsing the existing property options for correctness resulted in a different object that the one on the component options. This prevented attaching new property options correctly.",,
1338509949,1333,Can not merge a record type into an object type,"Hi ðŸ‘‹ 
I want to rebuild the following types from ts type to zod type:
```typescript
type myType = {
  ""204"": never
  [t: string]: Record<string, {
    foo: string,
    bar: number
  }>,
} 
```
When I write the zod types like this, it shows me an error that `Argument of type 'ZodRecord<ZodString, ZodRecord<ZodString, ZodObject<{ foo: ZodString; bar: ZodNumber; }, ""strip"", ZodTypeAny, { foo: string; bar: number; }, { foo: string; bar: number; }>>>' is not assignable to parameter of type 'AnyZodObject'.`:
```typescript
const myTypeZod = z.object({
  '204': z.never(),
}).merge(
  z.record(
    z.record(
      z.object({
        foo: z.string(),
        bar: z.number(),
      }),
    ),
  ),
)
```
How can I merge a record type with `key: string` into an object type?",,
1338319188,1332,`z.instanceof` does not accept abstract classes,"In #1065, `z.instanceof` rejects classes with a private constructor. This can be resolved by using `z.custom`, but this syntax isn't ideal and repeats itself between the type param and the right hand side of `instanceof` operator.

A similar issue appears when using an abstract class, is there anything that could be done about that?
```ts
abstract class foo {
  constructor() {}
}

z.instanceof(foo);
// Argument of type 'typeof foo' is not assignable to parameter of type 'new (...args: any[]) => any'.
//  Cannot assign an abstract constructor type to a non-abstract constructor type. ts(2345)
```
This can be worked around using the above, but typescript does allow for parameter type `abstract new (...args: any[]) => any`, which could be used either in place of or in union to the existing parameter type on `z.instanceof`

Failing that, a class is just a different syntax for defining a function, and classes can be passed to parameter type `Function`. This allows for incorrect usage by passing a normal, non-class function, but I expect most users of Zod to understand the difference on the basis of a) they're competent enough to be using TypeScript and b) they're using Zod, a schema-base parser/validator.
```ts
// this has no issues with very strict TS compiler options
function parse(x: Function, y: unknown) {
  return y instanceof x;
}

// this solves the abstract issue, and prevents passing incorrect subtypes of `Function`

/** this union is not necessary and will work with only the abstract variant. The union is to be more verbose */
type MaybeAbstractClass = (abstract new (...args: any[]) => any) | (new (...args: any[]) => any);

function parse(x: MaybeAbstractClass, y: unknown) {
  return y instanceof x;
}
```",,
1336354033,1331,"Creating a custom type for number, strings, etc","We use numbers all over our codebase to represent numbers, dollar value, percentages, etc. Ideally, we'd like to keep the zod type along with a typescript type that represents that type. 

Here's an example:

```ts
type DollarValue = number;

const dollarValueSchema = z.number();
```

Ideally, when using `z.infer<typeof dollarValueSchema>` we get `DollarValue` type, instead of `number`. 

Thoughts? ",,
1335032607,1327,z.string().url() validates url without a top-level domain.,"z.string.url() validates ""https://google""",,
1334954938,1326,Readme.md typo.,"In the Readme.md it says for the documentation of keyof property.
### `.keyof`

Use `.key` to create a `ZodEnum` schema from the keys of an object schema.

```ts
const keySchema = Dog.keyof();
keySchema; // ZodEnum<[""name"", ""age""]>
```

there a type in Use `.key` it's actually .keyof method not .key.

And A salam alaykoum.",,
1334860777,1325,"`.keyof()` relies on key order, resulting in unsound `.options` tuple type","Saw this [awesome trick](https://github.com/colinhacks/zod/pull/1216/files#diff-44137e14e4c38858d2925367bcf2455388e24146f88934724da11d2f9ecaa7d2) by @ecyrbe transforming object keys into string tuple ordered by source declaration, but beware [TS treats key order differently than JS engines](https://2ality.com/2015/10/property-traversal-order-es6.html#traversing-the-own-keys-of-an-object):

```ts
z.object({ a: z.string(), '1': z.string() }).keyof().options()
// TS says it's ['a', '1']
// JS runtime it's ['1', 'a']
```

I believe `.options` is public API for enums, therefore this typing is unsound.
A simple solution that comes to mind is having an `UnorderedZodEnum` like

```ts
type UnorderedZodEnum<T extends [string, ...string[]]> = Omit<z.ZodEnum<T>, 'options'> & { options: Set<T> }
```

Or just downgrade the keyof to return `ZodSet` instead of `ZodEnum`.

A * mostly * non breaking change could be something like:

```ts
type UnorderedZodEnum<T> = Omit<ZodEnum<T>, 'options'> & { options: Repeat<typeof T[number], T['length']> }

type Repeat<N extends number, T, Acc extends T[] = []> = N extends Acc['length']
  ? Acc
  : Repeat<N, T, [T, ...Acc]>
```

Will still be breaking change in use-cases relying on contravariance or assignability, but those are exactly the cases that would be unsound in current version, eg:

```ts
const Enum = z.object({ a: z.string(), b: z.string() }).keyof()

// user relying on ordering of current API
const first: 'a' = Enum.options[0]
// Type '""a"" | ""b""' is not assignable to type '""a""'.

// needs to be cast instead
const first = Enum.options[0] as 'a'
```

A more non-breaking solution would be to try mimicking JS engines, beware of typescript `keyof` though, it seems to sometimes result in desired order (i really didn't get the rule on that), but only with object literals, not when the object comes from a generic param. Seems the safer would be to force the engine ordering with something like:

```ts
type ObjectKeys<T> = [
  ...Sort<enumUtil.UnionToTupleString<IntString<keyof T>>>, 
  ...enumUtil.UnionToTupleString<Exclude<keyof T, IntString<keyof T>>>
]
```

But to implement a 'Sort' for that would need some more possibly unsound tricks",,
1333118374,1322,[Bug] Type inference does not work as expected when using catchall,"Using zod's type inference (schema first approach) I get typescript errors when using catchall.

Example:

```typescript
import z from 'zod';

const zschema = z
  .object({
    'main': z.string()
  })
  .catchall(z.number().optional());

const result = zschema.safeParse({
  'main': 'foo',
  'catch': 1
});

type Test = z.infer<typeof zschema>;
const foo: Test = {
  'main': 'foo',
  'a': 1
}
```

This example shows the expected behaviour for `safeParse` (which correctly validates the object), but it results in a typescript error when trying to instantiate an object using the infered type `Test`.

Expected behaviour:

`type Test` should resolve to something like:
```typescript
{
  main: string,
  [x: string]?: number
}
```

However it produces the following error given the example above:
```typescript
const foo: {
    [x: string]: number | undefined;
    main: string;
}
'foo' is declared but its value is never read.ts(6133)
Type '{ main: string; a: number; }' is not assignable to type '{ [x: string]: number | undefined; main: string; }'.
  Property ''main'' is incompatible with index signature.
    Type 'string' is not assignable to type 'number'.ts(2322)
```",,
1330975209,1320,Requesting `ctx` in preprocess transformer,"May I ask you to add `ctx` parameter to the preprocess transformer, so it would be possible to add issues?

> Perhaps you should be able to add issues inside `preprocess` similar to `superRefine`. 

_Originally posted by @colinhacks in https://github.com/colinhacks/zod/issues/696#issuecomment-941148842_


",,
1330163218,1317,How to create zod schema from existing value?,"I have a such object:
```ts
const obj = {
  typeName: 'hmmm :)',
  attributes: {
    owner: '',
    country: {
      guid: 'it is a string',
      typeName: 'country',
      uniqueAttributes: {
        iso3_code: 'ddd',
        qualifiedName: 'ccc',
        iso2_code: 'aaa',
      },
    },
    qualifiedName: 'Hello, how are you',
    organization_id: '8113',
    name: 'Lorem',
    description:
      'Lorem ipsum',
  },
  guid: 'eferferferfwefwerfw',
  status: 'ACTIVE',
  displayText: 'regergergrgtergt',
  classificationNames: [],
  meaningNames: [],
  meanings: [],
  isIncomplete: false,
  labels: [],
}
```

Is there a tool to create zod schema type for this object instead of manually doing it?",,
1330054611,1316,support coercion for non primitives,"Would you be open to a PR, providing built-in implementation for processors, performing coercion to most common types? (numbers, string, booleans, arrays)? 

This is how type coercion looks like right now:
```ts
        const preprocessor = (value) => {
            switch (typeof value) {
                case 'bigint':
                case 'boolean':
                case 'number':
                    return value.toString();

                case 'object':
                    if (value == null) {
                        return value;
                    }
                    if (value instanceof Date) {
                        return value.toISOString();
                    }
                    return value; // could not coerce, return the original and face the consequences during validation

                case 'string':
                    return value.trim();

                case 'undefined':
                    return value;

                default:
                    return value; // could not coerce, return the original and face the consequences during validation
            }
        }

        const CREATE_USER_SCHEMA = z.object({
            age: z.preprocess(preprocessor, z.string().max(15))
        })

        const result = CREATE_USER_SCHEMA.parse({
            age: 44
        });

        expect(result).toEqual({
            age: '44'
        })
```

This is pretty verbose and requires plenty of boilerplate every time.

This is a proposed API:
```ts
        const CREATE_USER_SCHEMA = z.object({
            age: z.string().max(3).coerce()
        })

        const result = CREATE_USER_SCHEMA.parse({
            age: 44
        });

        expect(result).toEqual({
            age: '44'
        })
```

Resolution of a specific preprocessor would be based on ZodType `typeName`, and throw an error if no preprocessor is implemented for a given type.",,
1329209631,1311,Add Slonik to the ecosystem,"Slonik now implements runtime query result checks using zod:

https://github.com/gajus/slonik/tree/gajus/add-zod-validation-backwards-compatible#runtime-validation-and-static-type-inference",,
1328332628,1309,[Feature Request] Catch errors thrown in transform,"README says that `transform` should not throw errors. This makes it less convenient to use for two reasons:
1. If the code can throw errors, we need to ensure that they are caught and transformed to `ctx.addIssue` calls with `fatal: true`
2. There is often no meaningful value to return in case the error happens, so for zod to infer the output type correctly, some hacks are needed

For example, I wrote this utility helper in my applicaiton to handle this problem:
```
export const zodCatch =
  <Input, Result>(fn: (input: Input) => Result) =>
  (input: Input, ctx: RefinementCtx) => {
    try {
      return fn(input);
    } catch (error) {
      if (error instanceof Error) {
        ctx.addIssue({
          fatal: true,
          code: ZodIssueCode.custom,
          message: error.message,
          params: {
            ...error,
            name: error.name,
          },
        });
      } else {
        ctx.addIssue({
          fatal: true,
          code: ZodIssueCode.custom,
          message: String(error),
        });
      }

      // Hack for zod to infer type correctly
      // this value won't be used because we added fatal issues to ctx
      return undefined as any as Result;
    }
  };
```

I use it like this:
```
const schema = z.string().transform( zodCatch((v) => JSON.parse(v)) );
const parsed = schema.parse(""invalid json"");
```

Although this helper solves the problem for me, it would be nice if something like this could be included in zod itself. If catching all errors is too much (it would likely be a breaking change), maybe it can only catch instances of a specific error class. That would still be beneficial because it would eliminate the need for a return type hack.
",,
1328312382,1308,Incorrect Input type when using `refine` with a type guard,"When using `refine` with a type guard, the Input type gets changed to `RefinedOutput` type. I do not expect this to be the desired behavior, because this breaks the Input type when used with transforms. See example:


```
import { z } from 'zod';

const schema = z.string().transform(v => 5 as number | undefined /* Imagine some lookup here */);

type input = z.input<typeof schema>;
//   ^ string

type output = z.output<typeof schema>;
//   ^ number | undefined

const refined = schema.refine((v): v is Exclude<typeof v, undefined> => v !== undefined);

type input2 = z.input<typeof refined>;
//   ^ number <-- wrong, should be string

type output2 = z.output<typeof refined>;
//   ^ number
```
[Link to CodeSandbox](https://codesandbox.io/s/zod-refine-type-issue-kg7mlh?file=/src/index.ts)

The potential cause is that the corresponding `refine` type definition returns `ZodEffect` with `RefinedOutput` instead of `Input`.
https://github.com/colinhacks/zod/blob/master/src/types.ts#L272

",,
1328000947,1307,How would I extract first property type from zod object?,"Here is what I got:

```ts
import {
  z,
  type ZodTypeAny,
} from 'zod';

const foo = z.object({
  name: z.string(),
});

const bar = <T extends ZodTypeAny>(shape: T) /* ??? */ => {
  return null as any;
};

const baz = bar(foo);

console.log(baz);
```

I need `baz` to be first/any property value of `foo`, i.e. in this case it should be `string`.

How would I extract first property type from zod object?",,
1327882696,1306,How to check if subject is ZodObject?,"At the moment I am doing:

```ts
const foo = z.object({
  name: z.string(),
});

console.log(foo?._def?.typeName === 'ZodObject');
```

Though this relies on accessing an internal property.

For context, it is needed to make https://github.com/gajus/slonik/issues/364 work.",,
1326315581,1304,Allow default values for empty strings,"I'm trying to assign [a default value when string is empty](https://codesandbox.io/s/typescript-playground-export-forked-s0g6ip?file=/index.ts) without any luck. 

```ts
import { z } from ""zod"";

const stringWithDefault = z.string().optional().default(""tuna"")

const result = stringWithDefault.parse(""""); // => Should be ""tuna"" instead is """"
//      ^ ?

console.log(result);
```

How could I achieve this?

```ts
const result = stringWithDefault.parse(undefined) // => returns ""tuna""; 
const result = stringWithDefault.parse("""") // => returns """"; 
```

Basically I want  both cases to use the default value.",,
1325463823,1302,Zod claims that types are incompatible: required is missing,"For some reason even a simple schema doesn't work for me:

```ts

import { z } from 'zod'

type Foo = {
  a: number
}
export const schemaFoo: z.ZodType<Foo> = z.object({ // ***
  a: z.number(),
})

```

In the ***-line I get an error:
```
Type 'ZodObject<{ a: ZodNumber; }, ""strip"", ZodTypeAny, { a?: number; }, { a?: number; }>' is not assignable to type 'ZodType<Foo, ZodTypeDef, Foo>'.
  Types of property '_type' are incompatible.
    Type '{ a?: number; }' is not assignable to type 'Foo'.
      Property 'a' is optional in type '{ a?: number; }' but required in type 'Foo'.ts(2322)
```",,
1325053504,1301,Friendly Error Messages,"Is there a way to get a generic string or array of strings that I can pass back to an end user? With `flatten` and `format` it looks like I'd need to iterate through properties and arrays to try to create a message, and even then it wouldn't be very friendly. Writing custom messages feels a little redundant, and wouldn't be as helpful about communicating which validation on a property actually failed. Thanks for your help!",,
1324634326,1300,Incorrect inferred type of unknown keys policy after object merge,"Hi, I found something. When merging two schema of objects with a different policy for unknown keys (one ""strict"" and the other ""strip""), the inferred type of the resulting schema is inconsistent with the runtime behavior.

```
// This one is ""strict""
const schemaA = z
    .object({
        a: z.string(),
    })
    .strict()

// This one is ""strip""
const schemaB = z
    .object({
        b: z.string(),
    })

// Merge them
// According to the docs, the policy from B overrides the one from A, so it should be a ""strip""
const mergedSchema = schemaA.merge(schemaB)

 // This doesn't throw an error : the schema is indeed ""strip'
mergedSchema.parse({
    a: 'xxxxx',
    b: 'xxxxxx',
    other: 'xxxxx',
})

// However the inferred type of the merge schema uses ""strict""
// This compiles, it should not
const strictSchema: z.ZodObject<any, 'strict'> = mergedSchema
// This doesn't compile, it should
const stripSchema: z.ZodObject<any, 'strip'> = mergedSchema
```",,
1324108360,1299,"fails to parse ""Proxy"" object","```
const WalletProvider = z.object({
    request: z.function(),
    on: z.function(),
});
```

Following object expected to parse accordingly to schema above..

![image](https://user-images.githubusercontent.com/4569866/182117174-d386a67b-8f6b-4c2d-a88c-39423e07c77f.png)

But fails with unexpected error..

![image](https://user-images.githubusercontent.com/4569866/182117325-a8ebcaf5-cf6b-4c5f-a1f3-ad5f344b7c95.png)

",,
1323331584,1298,Validating a multistep form is behaving differently than with yup,"Here's a multistep form using zod: https://codesandbox.io/s/pensive-ives-jzjwb3?file=/src/MultiStepForm.js
This is the same form using yup: https://codesandbox.io/s/unruffled-river-9fkxo?file=/src/MultiStepForm.js

The issue I have with zod is when submitting the form, only the current step's (step 3) data is available in the onSubmit call. Both examples are resolving using `xResolver(currentValidationSchema)` which only points to the validation for the current step, but I'm wondering why yup is returning the entire form while zod doesn't.",,
1321703791,1297,how can I fix this type error,"![image](https://user-images.githubusercontent.com/23290513/181674944-f54a89e5-4bdf-41fa-9c68-2a858594b70d.png)

```
export function parseClientData<T>(
  schema: z.ZodType<T>,
  input: z.input<z.ZodType<T>>
) {
  return schema.safeParse(input);
}

const Schema = z.object({
  a: z.string().transform((val) => JSON.parse(val) as { b: string })
});

parseClientData(Schema, { a: JSON.stringify({ b: ""1"" }) });
```",,
1321687744,1296,how can I validate the object after JSON.parse,"I want to validate val to be `z.object({ b: z.string() })`ï¼Œbut no method to re validateï¼Œwhy not add second argument to transform like .preprocess

```
const Schema = z.object({
  a: z.string().transform((val) => JSON.parse(val))
});

Schema.safeParse({
  a: JSON.stringify({ b: 'abc' })
})
```

butï¼ŒIf I can pass second argument to transformï¼Œit will be

```
const Schema = z.object({
  a: z.string().transform((val) => JSON.parse(val), z.object({ b: z.string() }))
});
```
",,
1319984073,1293,Add support to report invalid length,"So apparently this boils down to zod not supporting something like this. 

https://github.com/trpc/trpc/issues/2328

Would it be possible to add what's needed to get that kind of behavior ""In real time""?

Of course on the example I mention the length, but it could apply to any other condition.

Thanks in advance.",,
1318573759,1292,Addition of `.keyof()` breaks assignability for `ZodObjects`,"Hi there,

#1216 appears to break assignability of `ZodObjects` in a subtle way.  For example, the following worked before Zod 3.17.9, but fails in the latest Zod (3.17.10).  I'm on TypeScript version 4.7.4.

```ts
declare const superset: { foo: string } & z.ZodObject<{
  prop1: z.ZodString;
  prop2: z.ZodNumber;
}>; // The `{ foo: string }` intersection is necessary for this to fail for some reason.

const subset: z.ZodObject<{ prop1: z.ZodString }> = superset;
//    ^^^^^^ Error here
```

This produces the following type error:

```
Type '{ foo: string; } & ZodObject<{ prop1: ZodString; prop2: ZodNumber; }, ""strip"", ZodTypeAny, { prop1: string; prop2: number; }, { prop1: string; prop2: number; }>' is not assignable to type 'ZodObject<{ prop1: ZodString; }, ""strip"", ZodTypeAny, { prop1: string; }, { prop1: string; }>'.
  The types returned by 'keyof()._parse(...)' are incompatible between these types.
    Type 'ParseReturnType<""prop1"" | ""prop2"">' is not assignable to type 'ParseReturnType<""prop1"">'.
      Type 'OK<""prop1"" | ""prop2"">' is not assignable to type 'ParseReturnType<""prop1"">'.
        Type 'OK<""prop1"" | ""prop2"">' is not assignable to type 'OK<""prop1"">'.
          Type '""prop1"" | ""prop2""' is not assignable to type '""prop1""'.
            Type '""prop2""' is not assignable to type '""prop1""'.ts(2322)
```

The problem arises because `z.ZodEnum<[""prop1"", ""prop2""]>` is not assignable to `z.ZodEnum<[""prop1""]>`.  This makes sense!  However, I would argue that `superset` _should_ be assignable to `subset`, because that aligns with TypeScript's structural typing.  In particular, in TypeScript,
```ts
interface Superset {
  prop1: string;
  prop2: number;
}
```
is assignable to
```ts
interface Subset {
  prop1: string
}
```

As I mentioned in the comment, for some reason this error doesn't surface unless you intersect the `z.ZodObject` with a non-empty object type (i.e., `{ foo: string }` in the example above).  As far as I can tell, this is a TypeScript quirk.  I _think_ with the addition of `.keyof()`, TypeScript _should_ be raising an error even without that intersection present.  Maybe I'm missing something?

Not sure what the solution is here other than removing `.keyof()` I guess.  It could be replaced with `z.keyOf(object: z.ZodObject)`  or something else that doesn't change the `ZodObject` type?  Or you could decide that this problem doesn't matter!  But a project I'm working on does lots of fun stuff with Zod and we rely on `ZodObject` assignability working this way ðŸ¥².

Thanks for reading and for the fantastic library.

P.S. I feel like somehow the new [variance annotations](https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/#optional-variance-annotations-for-type-parameters) could be used to solve this but I'm not sure how.",,
1318559702,1291,`tuple` produces broken schema on bad input,"An easy typo to make with `tuple` is to pass the arguments without wrapping them in an array:

```
// correct:
const schema = z.tuple([z.number(), z.number()])

// incorrect:
const schema = z.tuple(z.number(), z.number())
```

Rather than throwing an error on construction, a schema is created which parses successfully to the empty array:

```
const schema = z.tuple(z.number(), z.number())
schema.parse([1,2]) // []
```

Admittedly, this is only a problem if type checking is not enabled. However, if supporting vanilla JS is design goal, `tuple` should probably perform some runtime validation of its inputs.",,
1316579615,1287,Feature request: add external params for custom refine and transform,"In my use case I would like to validate some fields of an object in front of an other dynamic object. I didn't found a way to do that with the current implementation . I think the best way to do that would be to add custom parameters to the parse functions that would be accessible by the callback of transform and refine functions (for exemple with a ctx property):

```ts
const foo = z.object({
  id: z.string(),
  data: z.unknown()
});

consr bar = z.object({
  fooRef: z.string().refine((data, ctx) => ctx.customParams?.include(data))
});

const a = z.parse({id: 'a', data: 'a data'});
const b = z.parse({id: 'b', data: 'b data'});

const ids = [a,b].map(obj => obj.id);

const obj1 = z.parse({fooRef: 'b'}, ids);  // successfully returns {ref: 'b'}
const obj2 = z.parse({fooRef: 'c'}, ids);  // throw a  parsing error
```

This exemple could be extended with transform to directly parse obj1 as {foo: {data: 'b data'}} for exemple.",,
1316205793,1286,How can I compare and validate two fields?,"There are two select tags that allow you to select integer values.
Both have the same list of items that can be selected

If the integer value of the item in the first select tag is less than the integer value of the item in the second select tag
If the integer value of the item in the second select tag is less than the integer value of the item in the first select tag, how do I make it a validation error?
How do I do this?

Or
When an item in the first select tag is selected
How do I make it so that the second select tag can only select integers after the first item?",,
1315876402,1284,strictObjects and unions,"Hey,
I'm trying to create a schema for an object that has a `code` property, a `path` property, or both.
But not none, and that no other key exists by combining 2 strict objects, and then doing a ""and / or"" mechanism as following:

```
import z from ""zod"";

const withCode = z.strictObject({code: z.string()});
const withPath = z.strictObject({path: z.string()});

const withCodeOrPath = withCode.or(withPath);
const withCodeAndPath = withCode.and(withPath);
const withCodeAndOrPath = withCodeAndPath.or(withCodeOrPath);

withCodeAndOrPath.parse({
  code: ""bob"",
  path: ""bob""
});
```

But this doesn't work, parsing fails with:
`Unrecognized key(s) in object: 'path'`

The TS version of this does seem to work, here's a sandbox link - https://codesandbox.io/s/blissful-fog-xcdyh5?file=/src/pure-types.ts

PS: I fixed it by making both properties optional, and then using a custom refinement.
`.refine((obj) => obj.code || obj.path)`

Is this a bug? expected behavior? 

Thanks in advance!


",,
1315747168,1282,variadic args function,"I am trying to define function of this shape:
```ts
return z
    .function()
    .args(...args , makeAPISchema(valueSchema))
    .returns(returns)
```

where makeAPISChema returns a z.object but it keeps throwing the following error:
`Variadic element at position 0 in source does not match element at position 0 in target.`

Is there a way to make this work?",,
1315248674,1278,New Feature - Variadic tuples with noUncheckedIndexedAccess,"Variadic tuples were introduced in Typescript 4.0, and they allow some pretty nifty tricks.
If the [--noUncheckedIndexedAccess](https://www.typescriptlang.org/tsconfig#noUncheckedIndexedAccess) is enabled, it's possible to differentiate arrays that are guaranteed to have at least one element from simple arrays, like so:

```
type Array1<T> = [T, ...T[]];

const a: Array1<string> = []; // this will show an error
const b: string[] = []; // no error here
```
<img width=""363"" alt=""example"" src=""https://user-images.githubusercontent.com/4076804/180491063-07e12dee-bcba-4852-a219-a1596c7c7077.png"">

and it also correctly types if we want to access some index:

<img width=""391"" alt=""example2"" src=""https://user-images.githubusercontent.com/4076804/180491067-dc6f336b-2f70-4c44-9133-7fc33b093a0c.png"">

I used this approach in a previous project, but had to define manually all the necessary type guards to check if a standard array has at least one element.

https://github.com/nicu-chiciuc/dependent-ts/blob/59f92dc243bfdc53494fd6e3dfd13efbef026829/src/index.ts#L82

I was wondering if this is something that would be of interest to somebody.

",,
1312990100,1277,.strip and .partial not available methods on ZodDiscrimatedUnion schema,"I have a base generic equal to `z.ZodObject<{ [k: string]: any }>`.

Unfortunately the follwowing schema doesn't satisfy that requirement which seems like an error?

```typescript
export const schema = z
  .object({
    id: z.string().min(1),
  })
  .and(
    z.discriminatedUnion(""type"", [
      z.object({ type: z.literal(""A""), payload: z.object({a: z.string()}) }),
      z.object({ type: z.literal(""B""), payload: z.object({b: z.string()}) }),
    ])
  );
```

My base generic needs to be `z.ZodObject<{ [k: string]: any }>` which exposes `.strip` and `.partial` on the schema. A `z.discriminatedUnion` (nor `z.ZodIntersection`) schema does not which seems odd?

Shouldn't the following code be valid?

```typescript
// example 1 discriminated union
z.discriminatedUnion(""type"", [
      z.object({ type: z.literal(""A""), a: z.string() }),
      z.object({ type: z.literal(""B""), b: z.string() }),
  ]).partial()  // TS and runtime error

// example 2 intersection
z.object({
    a: z.string(),
  })
  .and(
    z.object({ b: z.string() })
  ).partial()  // TS and runtime error

// example 3 union
z.union([
    z.object({ a: z.string() }),
    z.object({ b: z.string() }),
  ]).partial()  // TS and runtime error
```",,
1311422574,1275,Please add TypeScript support for `.extend()` method in the z.Schema type,"I find it very useful to add my types for Zod schemas, so that if I change the type, TypeScript helps me in highlighting the errors in my broken schemas. But as soon as I assign any schema `z.Schema<MyType>`, I can no longer extend this schema.
Here's a detailed example:
1. Without `z.Schema<MyType>` specification:
```
const mySchema = z.object({ ... });
const anotherSchema = mySchema.extend({ ... });
```
Works just fine, but no highlights if I have my types mismatched with the schema.

2. With `z.Schema<MyType>` specification:
```
const mySchema: z.Schema<MyType> = z.object({ ... });
const anotherSchema = mySchema.extend({ ... });
```
Here, I have my type definitions connected to Zod schemas, but I can no longer safely extend from `mySchema` (by safely, I mean type-safety, if I put @ts-ignore, it works just as expected).

Please suggest a workaround if any exists or add a type support for `extend` method in Schema type definition. Thanks!",,
1310436686,1272,how to describe multiple string?,sometimesï¼ŒI have multiple comments for a key-valueï¼Œso I want to  use `.describe().describe()`ã€‚,,
1309656989,1271,how can I use .extend or .merge with .lazy(() => z.object({ ... })),"as you can seeï¼ŒZodType does not have extendï¼Œso how can I write the type for `FormData`

![image](https://user-images.githubusercontent.com/23290513/179780835-1de07aac-fe51-468e-853d-a4842a210604.png)

",,
1308924744,1270,'Invalid binding pattern' error when remapping object properties in transformer,"Using a spread operator in a transformer raises an error.

### Versions

* node v18.3.0
* zod v3.17.9
* typescript 4.7.4

### Repro

```ts
//  SymbolInfo.ts
import { z } from 'zod'

const Parser = z.object({
    business_description: z.string().min(1),
    country: z.string().min(1),
    currency_code: z.string().min(1),
    exchange: z.string().min(1),
    industry: z.string().min(1),
    isin: z.string().min(1),
    local_code: z.string().min(1),
    nsin: z.string().min(1),
    pro_name: z.string().min(1),
    sector: z.string().min(1),
    sedol: z.string().min(1),
    session_holidays: z.string()
      .refine((x) => /^(?:\d{8},?)*$/.test(x))
      .transform((x) => x.split(',')),
    short_description: z.string().min(1),
    web_site_url: z.string().min(1),
  })
  .transform(({
    business_description: description,
    currency_code: currency,
    pro_name: identifier,
    local_code: localCode,
    session_holidays: holidays,
    short_description: name,
    web_site_url: url,
    ...entries,
  }) => ({
    identifier,
    name,
    localCode,
    description,
    url,
    currency,
    holidays,
    ...entries,
  }))

export type SymbolInfo = z.infer<typeof Parser>
export const createSymbolInfo = (params: unknown): SymbolInfo => Parser.parse(params)
```

```json5
// tsconfig.json
{
  ""compilerOptions"": {
    ""esModuleInterop"": true,
    ""module"": ""esnext"",
    ""moduleResolution"": ""node"",
    ""target"": ""esnext"",
    ""strict"": true,
  },
}
```

### Error

```text
Error: Transform failed with 1 error:
file:///project/SymbolInfo.ts:29:14: ERROR: Invalid binding pattern
    at failureErrorWithLog (/project/node_modules/.pnpm/esbuild@0.14.48/node_modules/esbuild/lib/main.js:1605:15)
    at /project/node_modules/.pnpm/esbuild@0.14.48/node_modules/esbuild/lib/main.js:1394:29
    at /project/node_modules/.pnpm/esbuild@0.14.48/node_modules/esbuild/lib/main.js:666:9
    at handleIncomingPacket (/project/node_modules/.pnpm/esbuild@0.14.48/node_modules/esbuild/lib/main.js:763:9)
    at Socket.readFromStdout (/project/node_modules/.pnpm/esbuild@0.14.48/node_modules/esbuild/lib/main.js:632:7)
    at Socket.emit (node:events:527:28)
    at addChunk (node:internal/streams/readable:324:12)
    at readableAddChunk (node:internal/streams/readable:297:9)
    at Readable.push (node:internal/streams/readable:234:10)
    at Pipe.onStreamRead (node:internal/stream_base_commons:190:23) {
  errors: [
    {
      detail: undefined,
      id: '',
      location: {
        column: 14,
        file: 'file:///project/SymbolInfo.ts',
        length: 1,
        line: 29,
        lineText: '    ...entries,',
        namespace: '',
        suggestion: ''
      },
      notes: [],
      pluginName: '',
      text: 'Invalid binding pattern'
    }
  ],
  warnings: []
}
```",,
1308906473,1269,how can i transform class-validator + class-transfomer to zod?,"```
import {Type} from 'class-transfomer';
import {IsNumber} from 'class-validator';

class TestDto {
  @IsNumber()
  @Type(() => Number)
  a: number;
}
```

I can input { a: '123' } , and then output { a: 123 } with class-validatorï¼Œalthough the type of a does not matchï¼Œso how can I use zod to describe this case?",,
1308011448,1268,how can i use circular zod schema,"typescript:

```
export interface IndustryDTO {
  name: string;
  tagGroups: Array<TagGroupDTO>;
  id: number;
  subs: Array<IndustryDTO>;
}
```

zod schema

```
export const IndustryDTOZodSchema = z.object({
  name: z.string(),
  tagGroups: TagGroupDTOZodSchema.array(),
  id: z.number().int(),
  subs: IndustryDTOZodSchema.array()
});
```


but this will case `ReferenceError: Cannot access 'IndustryDTOZodSchema' before initialization`",,
1305742940,1264,Strict function args,"Zod right now always adds `.rest(z.unknown())` to any function initiation and makes it impossible to validate that a function does not get extra parameters it does not intend

![image](https://user-images.githubusercontent.com/696842/179184877-1fed7a4d-7b7d-462b-b644-a7dd1e438924.png)

Is this the desired behavior? One could call `z.ZodFunction.create()` directly but feels a bit strange.
",,
1305339221,1263,`discriminatedUnion` produces TS error when `.default` or `.preprocess` are applied,"[Playground link.](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgNwBQFAxhAHYDO8AYhBAMrUAWApiAIZwAvCgB0EAEYArHtRgAKBBThwYATzA8AXGIA2wGDyj9d8-Jjb4AlKOI9M-AK66F5y1YA0yuPx3JRTFDAdADm8p4UaFaUNPRMcABC-FCcvALCYpIycore6pp+ovqGxqb41I5MuNZeKiA8MFwkhYHBYRFRMbSM8EnIqXyCIv7EwAzUQSDB-IbEAKp0wPRm+Tz4HnAA2qwc3IMbSSl7AgC60bGMELo8RRBhfQMComDJDDyKPjpuEPjoVudAA)

Given this snippet:

```ts
import { z } from 'zod';

const FooSchema = z.object({
  type: z.literal('foo').default('foo'),
  a: z.string(),
});

const BarSchema = z.object({
  type: z.literal('custom'),
  method: z.string(),
});

const BazSchema = z.discriminatedUnion('type', [FooSchema, BarSchema]);
console.log(BazSchema.parse({ a: 'foo' }));
```

TypeScript produces this error:

```
$ tsc tmp.ts
tmp.ts:13:49 - error TS2322: Type 'ZodObject<{ type: ZodDefault<ZodLiteral<""foo"">>; a: ZodString; }, ""strip"", ZodTypeAny, { type?: ""foo""; a?: string; }, { type?: ""foo""; a?: string; }>' is not assignable to type 'ZodDiscriminatedUnionOption<""type"", Primitive>'.
  Type '{ type: z.ZodDefault<z.ZodLiteral<""foo"">>; a: z.ZodString; }' is not assignable to type '{ type: ZodLiteral<Primitive>; } & ZodRawShape'.
    Type '{ type: z.ZodDefault<z.ZodLiteral<""foo"">>; a: z.ZodString; }' is not assignable to type '{ type: ZodLiteral<Primitive>; }'.
      Types of property 'type' are incompatible.
        Property 'value' is missing in type 'ZodDefault<ZodLiteral<""foo"">>' but required in type 'ZodLiteral<Primitive>'.

13 const BazSchema = z.discriminatedUnion('type', [FooSchema, BarSchema]);
                                                   ~~~~~~~~~

  node_modules/zod/lib/types.d.ts:531:9
    531     get value(): T;
                ~~~~~
    'value' is declared here.


Found 1 error in tmp.ts:13
```

This code works at runtime however and Zod correctly parses the object:

```
{ type: 'foo', a: 'foo' }
```",,
1304821764,1262,Array of Objects,"How do I correctly create a schema for an array of objects? I tried doing this but @hookform/resolvers throws an error:

```
const schema = z.object({
  field: z.array(z.object({
    subfield1: z.string().min(1, ""Required""),
    subfield2: z.string().min(1, ""Required"")
  }))
})
```",,
1303419332,1258,Extending z with custom types,"I'm using [Day.js](https://day.js.org) extensively in my application. The way to check for dayjs type is to check instanceof dayjs (the function):
```js
import dayjs from ""dayjs"";
const date = dayjs();
console.log(date instanceof dayjs) // true
```

The param type of `z.instanceof` only accepts classes with constructors, but it works in runtime for checking instanceof dayjs. This means that I have to typecast dayjs as any every time I need it in instanceof:
```ts
const dateType = z.instanceof(dayjs as any);
```

Is there an option to extend `z` so that I can do something like `z.dayjs()`?",,
1302145509,1257,Incorrect validation with `optional` and `default` properties,"## The problem 

I noticed that when setting the `optional` property before the `default` the validation does not have the same behavior.
Look at the example below:

```tsx

const mySchema1 = z.object({
  name: z.string(),
  surname: z.string().min(1).max(120).optional().default("""")
});

const mySchema2 = z.object({
  name: z.string(),
  surname: z.string().min(1).max(120).default("""").optional()
});

const data = {
  name: ""Leo""
};

const result1 = mySchema1.safeParse(data);
/**
 * Result:
 * {
 *  ""success"": false,
 *  ""error"": {
 *    ""issues"": [
 *      {
 *        ""code"": ""too_small"",
 *        ""minimum"": 1,
 *        ""type"": ""string"",
 *        ""inclusive"": true,
 *        ""message"": ""String must contain at least 1 character(s)"",
 *        ""path"": [""surname""]
 *      }
 *    ],
 *    ""name"": ""ZodError""
 *  }
 * }
 */

const result2 = mySchema2.safeParse(data);
/**
 * Result:
 * { ""success"": true, ""data"": { ""name"": ""Leo"" } }
 */
```
I expected `result1` to have the same behavior as `result2`.

### Possible fix
Change type `default(def: util.noUndefined<Input>): ZodDefault<this>;` to also accept `undefined`

```tsx

const mySchema1 = z.object({
  name: z.string(),
  surname: z.string().min(1).max(120).optional().default(undefined)
});

```

### **Packages and versions:**
""zod"": 3.17.3
""typescript"": ""4.5.5""




",,
1294561321,1247,Functions with transform in returns/args,"Hello and first of all, thank you for this great library.  
I'm trying to validate a function with a schema with a `returns` that contains a `transform`. The problem occurs when the function schema is implemented : the return type is `Returns['_input']` instead of `Returns['_output']`. Here is a simple example :

```ts
const a = z.function().args(z.string()).returns(z.number().transform((v) => `${v}`));
const b = a.implement((e) => +e); // b is (e:string) => number but should be (e:string) => string
```
By investigating, I guess the problem comes from https://github.com/colinhacks/zod/blob/master/src/types.ts (lines 2884-2894) where the return types of `implement` and `strictImplement` are not accurate :
```ts
implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): F {
    const validatedFunc = this.parse(func);
    return validatedFunc as any;
}

strictImplement(func: InnerTypeOfFunction<Args, Returns>): InnerTypeOfFunction<Args, Returns> {
    const validatedFunc = this.parse(func);
    return validatedFunc as any;
}
```
I guess they should match the `OuterTypeOfFunction` defined in the same file at line 2752.
",,
1294532679,1246,Getter maxLength in ZodString has incorrect type (null),"**Snippet:**

```typescript
const s = z.string().max(10);
type L = typeof s.maxLength;
```

**Expected:**

```typescript
type L = number | null        // or ideally just number
```

**Actual:**

```typescript
type L = null
```

**Setup:**
- zod v3.17.3
- typescript v4.7.4

**Context:**

This is the current implementation of `maxLength`.

```typescript
  get maxLength() {
    let max: number | null = null;
    this._def.checks.map((ch) => {
      if (ch.kind === ""max"") {
        if (max === null || ch.value < max) {
          max = ch.value;
        }
      }
    });
    return max;        // typescript considers max to be of type null here
  }
```

The issue here is that Typescript ignores callbacks when it comes to type narrowing (assumes that they won't have any side effects). See https://github.com/microsoft/TypeScript/issues/35593 and https://github.com/microsoft/TypeScript/issues/9998. Since the only other operation on the variable `max` is its assignment to `null`, Typescript will narrow down its type to just `null`.

**Potential Fixes:**

- Add an explicit return type annotation of `number | null`.
- Replace `.map` with a for-of loop.",,
1294220346,1245,Schemas generated by refine do not have the omit method (or that is what typescript says),"Hello, first of all, thanks for Zod, it's fantastic.
According to typescript, the objects that have been refined do not have the omit method.
To reproduce you can try something as simple as this

```ts
const schema = z.object({ name: z.string(), age: z.number() }).refine(() => true);
const newSchema = schema.omit({ name: true }) // <- omit does not exist 
```
",,
1293361208,1243,Custom error map not working,"Hello,
I'm trying to customize the error messages using an error map but it doesn't seem to have any effect, the function gets executed, but the returned message doesn't come from the map.

Example:
```js
const customErrorMap = (issue, ctx) => {
  return { message: ""custom"" };
};

const email = z.string({ required_error: ""required"" }).email(""invalid"");

const res = email.safeParse(""email"", { errorMap: customErrorMap });
``` 

I would expect `res` to contain the `custom` error message, but in fact it returns:
<img width=""298"" alt=""Screenshot 2022-07-04 at 13 59 40"" src=""https://user-images.githubusercontent.com/23037261/177150474-61cd571c-4a59-4ff7-a3d8-b0e01561d74b.png"">

If I remove `.email(""invalid"")` it works, so seems like the chained validation has a higher priority than the error map which should not be the case.

Repro:
https://codesandbox.io/s/festive-gould-m7y3nk?file=/src/index.ts:22-297",,
1292307842,1240,how to express number string,our team handle i64 into stringï¼Œso how should we validate this number string type,,
1290946767,1239,Add documentation for `.lazy`,"This method is referenced twice in code-snippets in the README without explanation, and doesn't appear to be documented itself.",,
1289883408,1237,Feature request for reverse transform,"I love how the `.transform` function works and how it all makes working with external data so easy. In my example I'm loading and parsing an ini file and then transform it into usable JSON to work with in forms in my app. This is all great and smooth but the problem I encountered was when I wanted to save the modified data back into an ini file. What I had to do was basically double all my schemas, one for parsing data from the ini (`MatrixValueSchema`) and one for parsing my form values back to the shape of the ini file data (`RawMatrixValueSchema`).

Here is the [schema file](https://github.com/Haaxor1689/FightKnightEdit/blob/master/src/utils/types.ts#L13) for full context.

One solution that I think would work nicely, would be to add an optional reverse callback to the `.transform` helper and then a new `.reverseParse` function which would take a output value and return a input value.

I'm sure there are a bunch of more steps to think through for this to work, but I'd like to hear your opinion on usefulness of feature like this or some way to better solve this problem with current features.",,
1288520522,1234,Undefined description with default,"Example:
```typescript
import { z } from ""https://deno.land/x/zod/mod.ts"";

const schema1 = z.object({
    param: z.string({ description: 'description of the param' }),
});

const schema2 = z.object({
    param: z.string({ description: 'description of the param' }).default('value'),
});

console.log(schema1.shape.param.description);
console.log(schema2.shape.param.description);

// result:
description of the param
undefined
```
I expect description value in schema2.",,
1287111659,1232,ZodEffects not assignable to paremeter type ZodRawShape,"Trying to upgrade a codebase to use the latest version of Zod, but we have a lot of schemas that extend other schemes that have refinements on them. Now refinement outputs a ZodEffect, these all throw a type error. Is there a way around this?",,
1284885663,1230,How to make an optional property with a default value?,"Hello, first of all, thank for this awesome library, it is making wonders in my user-data interactions.
I want to define an schema for user input that has an optional field with a default value. However, it is being impossible for me to make the runtime behaviour match the type, maybe I'm getting something wrong.
What I want, is the field to be optional, and when not provided, or provided as undefined, use the default value. If I want to have this behaviour I can't have the field optional in the generated type, and if I manage to make it optional in the generated type, then it will not get a default value during runtime.

Let me explain it with code:

```ts
import { Timestamp } from 'firebase/firestore';
import { z } from 'zod';

export const someSchema = z.object({
  id: z.string(),
  timestamp: z.instanceof(Timestamp),
  type: z.enum(['fever', 'constipation']),
  notes: z.string().optional().default(''),
});

export const someInput = someSchema
  .omit({ id: true })
  .merge(
    z.object({
      timestamp: z
        .date()
        .optional()
        .default(() => new Date()),
    }),
  )
  .partial({
    notes: true,
  });

export const schemaArray = z.array(someSchema);

export type Schema = z.infer<typeof someSchema>;
export type SchemaInput = z.infer<typeof someInput>; // <- Here I expect timestamp to be optional, but it is required


function a({ type, timestamp, notes}: SchemaInput){
  someInput.parse({
  type, timestamp, notes
  })
}

a({type: 'fever'}) <- Error, timestamp is required

```",,
1284844633,1229,Export `RawCreateParams` and `processCreateParams` to allow custom type definitions?,"I'm attempting to build out a series of local `Zod` type definitions and following the pattern from [`types.ts`](https://github.com/colinhacks/zod/blob/master/src/types.ts)

However, I've hit a snag not being able to access some of the final elements, specifically `RawCreateParams` and `processCreateParams`.


### Example

```typescript
export enum ZodThirdPartyTypeKind {
  ZodSymbol = ""ZodSymbol""
}

type ZodSymbolCheck =
  | {
      kind: ""description""
      value: string
      message?: string
    }
  | {
      kind: ""prefix""
      value: string
      message?: string
    }

export interface ZodSymbolDef extends ZodTypeDef {
  checks: ZodSymbolCheck[]
  typeName: ""ZodSymbol""
}

export class ZodSymbol extends ZodType<symbol, ZodSymbolDef> {
  public _parse(input: ParseInput): ParseReturnType<any> {
    const parsedType = this._getType(input)
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input)
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      })
      return INVALID
    }

    const status = new ParseStatus()
    let ctx: undefined | ParseContext = undefined
    for (const check of this._def.checks) {
      switch (check.kind) {
        case ""description"":
          if (input.data.description !== check.value) {
            ctx = this._getOrReturnCtx(input, ctx)
            addIssueToContext(ctx, {
              code: ZodIssueCode.custom,
              message: check.message
            })
            status.dirty()
          }
          break
        case ""prefix"":
          if (input.data.description?.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx)
            addIssueToContext(ctx, {
              code: ZodIssueCode.custom,
              message: check.message
            })
            status.dirty()
          }
          break
        default:
          util.assertNever(check as never)
      }
    }

    return { status: status.value, value: input.data }
  }

  public static create = (
    params?: RawCreateParams // MISSING!
  ): ZodSymbol =>  
    new ZodSymbol({
      checks: [],
      typeName: ZodThirdPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)  // MISSING!
    })
}


export const symbolType = ZodSymbol.create

```",,
1284825386,1228,z.record(z.object) bug?,"Hello,

I've minimized my schema so that the basic configuration is seen.

**Schema:**
```Typescript
import * as z from 'zod';

const Schema = z.object({
    parameters: z.record(
        z.object({
            choices: z.object({values: z.array(z.string())}).optional(),
            question: z.string().optional(),
        })).optional(),
});

export default Schema;
```

**Usage:**
```Typescript
const parsedSchemaResult = Schema.safeParse({
            parameters: {
                whatever: {
                    unrecognizedField: [],
                },
            }
        });
        if (!parsedSchemaResult.success) {
            throw new ConfigError();
        }
```

I get `parsedSchemaResult.success === true`.

Is this a bug or misconfiguration?

**Zod**: ^3.16.1",,
1284763477,1227,New ZodDefaultOnMismatch class for providing a default value when there is a type mistmatch,"## Summary
A new class ZodDefaultOnMismatch which will replace the data with the default value when the provided value is a mismatch in type with the expected value. When data is undefined, ZodDefaultOnMismatch acts like ZodDefault.

```javascript
const deleteAllFiles = z.boolean().defaultOnMismatch(false).parse(""monkeys"")  // deleteAllFiles = false
```

Below, I layout two real world use cases. Whether or not this gets accepted, we will need this functionality, and I am hoping that we don't have to work off a forked version of zod.

Below, I also layout three implementations. All are tested and ready to be merged. I just need @colinhacks to tell me which is a sounder implementation, so I know which branch to make a pull request. Also, if the naming should be changed, I am up for that as well.

The implementation I suggest is the first one: https://github.com/seancrowe/zod/commit/40579cacf411f37a0458dd1abf85b8aba679fb81

So, if you don't feel like reading through all these implementations, the first one is the simplest and logical choice at the expense of JavaScript users requiring discipline.

## Use Case

### Use Case 1
Application is pulling data from a JSON file where both the data's type is not guaranteed to be correct or even defined. Our application wants to use zod to verify the parsed JSON, but we don't want to fail if there is a type mismatch, but instead default to a safe value.

### Use Case 2
Our application uses an FP technique of passing data around as objects. This data is passed to a function, the function will copy the data, modify the data, and potentially add more data. Due to JavaScript being dynamic typed and TypeScript not having sound typing, the types defined by TypeScript are not guaranteed 100% at compile time. This scenario means that as we pass these data objects around, we cannot be guaranteed 100% that the data object is exactly as we expect.

To defend against this, a type check must be made everytime. If there is a type mismatch, we don't want to cause an error, but instead default to a safe value with the correct type. Since these objects can be complex or contain extra data our current function does not care about, we need make sure the input and output is untouched accept for the specific properties we are interested in.

## ZodDefaultOnMismatch
Unfortunately, Zod does not have built way to support the two above use cases. Maybe it can be done with preprocess, but for our use case, that defeats the purpose of zod if every object property needs a handwritten type check anyway. 

Instead, all zod needs is something like ZodDefault but that will use the default value not only when there is undefined but when there is a mismatch in types. Thus ZodDefaultOnMismatch.

A new class ZodDefaultOnMismatch which will replace the data with the default value when the provided value is a mismatch in type with the expected value. When data is undefined, ZodDefaultOnMismatch acts like ZodDefault.

### Name
At first, I named this ZonDefaultAlways, but that implied it would always default to a value no matter what. ZodDefaultOnMismatch, while lengthy, is descriptive in what it does. However, I am not set on ZodDefaultOnMismatch. Maybe there is a better name?

## Implementation
After tinkering, there were three options:

- ðŸ‘ Assume the value of the defaultValue is the same as the expected value and compare types
- Go down the innerType branch until we get to the end, and then compare the last innerType (excepted) to the current type
- Allow the running as normal, and if there is an abort, run again with the default type

The last two implementations require going down the inner branch twice. 

## First defaultValue type Implementaion
This is my suggestive implementation.

This implementation makes the assumption that the value from _def.defaultValue() will be the same type as the expected value. This is a safe assumption if the user is using TypeScript. If the user is using JavaScript, then they can pass whatever they want into the defaultValue. In my mind this an acceptable risk, as there are other areas already in zod, where JavaScripts lack of compiler type checking can break the result.

You can find this implementation here:
https://github.com/seancrowe/zod/commit/40579cacf411f37a0458dd1abf85b8aba679fb81

(By the way, already made an improvement: https://github.com/colinhacks/zod/commit/354867bbebc437032f76750ac8a05e572cca8d00)

## Second innerType Implementation
This implementation will use the _def to get the final last type to be parsed, grab the type of that and compare it to the parsed type.

You can find this implementation here:
https://github.com/seancrowe/zod/commit/ee70583f9b18a86e4f25a05ad2b91e7f7745d215

This implementation had to solve two problems:

The first problem is that all the Zod classes do not share an interface that has innerType. Each class implements innerType separately. Since no common interface that means that either innerType is not always available or we would need to use a more generic ""any"" and hope innerType exists.

Actually, innerType is not always available. ZodEffect has a schema instead, which means you much go innerType -> schema -> innerType. This is one example, but if other Zod classes exist that use another naming convention, or future ones were added, we would end-up in the same scenario

The second problem is that the types are stored as Zod{type}, so ""ZodString"" or ""ZodNumber"" but our data type is stored as ""string"" or ""number"". This means that I would have to rely on the discipline of naming conventions to be able to compare ""ZodString"" to ""string"" or ""ZodNumber"" to ""number"".


## Third abort Implementation
This implementation utilizes the fact that mismatch types are aborted, to then go down the parse function again but with the default value.

You can find this implementation here:
https://github.com/seancrowe/zod/commit/1dd93075946436672771a25411a084a102f5da8e

This implementation feels less breaky at the expenses of having to carry around our defaultValue function in the ParseContext common. Meaning that defaultValue must not be readonly as it is set only after parsing begins.

The upside is that this will not break due to the problems listed above changing. For example, a new Zod class implemented that does not use innerType or schema, but something else altogether. 

The downside of requiring parsing to happen twice at the fist ZodDefaultOnMismatch. It goes down the tree once, gets the abort and then goes down the tree again but with the value from ZodDefaultOnMismatch. I have to do this, because I don't know the type of the inner most value.
",,
1284555184,1226,infer is not a function,"
![image](https://user-images.githubusercontent.com/4569866/175771246-d2229e67-a3fa-4494-8e72-86543b1f5d91.png)

![image](https://user-images.githubusercontent.com/4569866/175771235-1807a5bf-754c-4e9e-982b-fb8e7b2c56d0.png)

![image](https://user-images.githubusercontent.com/4569866/175771216-de0adedc-f849-45e1-a92e-cf3d603ac58b.png)
",,
1283933966,1223,"Request: Introduce a convert method, to allow for transforms that may fail","When attempting a transform, it's possible that the transform may fail. In this case, it's necessary to return a typecast dummy value.

I think having a 'convert' method on ZodType, which could return a success or failure value, would make for nicer DX.

The convert method would essentially combine a refine and transform, where the refinement failure would be fatal but the transform is necessary to determine the refinement.

The following serves as an example:

```ts
const IdToUser = z
  .string()
  .uuid()
  .convert(async (id) => {
    try {
      const user = await getUserById(id);
      return z.success(user);
    } catch (e) {
      return z.failure([
        {
          code: ""custom"",
          message: ""Unable to fetch user"",
        },
      ]);
    }
  });
```

See https://github.com/colinhacks/zod/pull/1224 for a potential implementation",,
1283379828,1221,'keyof typeof' js-object to zod-schema,"Hi,

we are slowly transitioning from a JavaScript code base to TypeScript. Due to the quantity of code and our inexperience with TypeScript, we have to live with both worlds for the foreseeable future.

We used simple js Objects as pseudo enums in the past:

**within a js file:** 

```
const pseudoEnum = {
  ELECTRIC: {someProp: true, anotherProp: ""xxx""},
  PNEUMATIC: {someProp: false, anotherProp: ""yyy""},
  HYDRAULIC: {someProp: true, anotherProp: ""zzz""},
}
```
This allows us to type stuff like this:

**within a ts file:**
```
type Application: keyof typeof pseudoEnum
```
Which nicely restricts possible values for elements of type Application:
![image](https://user-images.githubusercontent.com/1145346/175484336-aefb28bc-1b3e-4944-9f1d-d9d3e2ffa8cb.png)


How can I mimic this behavior in a zod schema?
I spent quite a while playing with z.enum and z.nativeEnum, but I don't get it to resolve properly.

_I'd prefer not to rewrite our pseudoEnums since so much of our js code base relies on it..._

Thanks in advance
Nice regards
Christian


---
My apologies if you think that this does not belonging here. Feel free to close it. :)",,
1283166548,1220,Property 'infer' does not exist,"![image](https://user-images.githubusercontent.com/4569866/175447934-01797006-914e-4efc-b06f-2330c737a2a2.png)
",,
1279850083,1218,How to adapt initial scheme for a response,"Hi! 

I wanna have the following data as input for the **request**:
```
{
  ""street"": ""Street A23""
   ...
}
```
and following data for the **response**:
```
{
  ""address"": {
    ""street"": ""Street A23"",
     ...
  }
}
```

**How do i adapt my scheme for both?**
```
z.object({
      street: z.string()
      ...
})
```
P.S. I need this for the openapi documentation.",,
1278224615,1217,Enums `invalid_type` issues have unexpected `expected` value,"When adding translations to my global errorMap function, I ran into an issue with the `enum` type.

```ts
const s = z.enum(['Red', 'Green', 'Blue']);
console.log(s.safeParse(null));
```
This produces a `ZodError` with the following issue:
```json
{
    ""expected"": ""'Red' | 'Green' | 'Blue'"",
    ""received"": ""undefined"",
    ""code"": ""invalid_type"",
    ""path"": [
        ""color""
    ]
}
```
The problem here, is that the `expected` value ends up as a string representation of the array provided. I assume the point is to make it look like the Typescript representation, but that's not any of the expected values in the `ZodInvalidTypeIssue.expected` type. This makes it kind of impossible to add a general translation for enum errors in the generic global error map function.

It would be much better if `expected` was hardcoded `""enum""`, and then the valid enum values instead came as a separate property. This would make it possible to translate all enum errors properly, and also give the ability to format the valid options however you want:
```ts
function zodErrorMap(...[issue, ctx]: Parameters<ZodErrorMap>): string {
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      switch (issue.expected) {
        case 'number':
          return 'must be a valid number';

        case 'integer':
          return 'cannot have decimals';

        case 'enum': // Currently not possible
          return `must be one of ${issue.valid.join(', ')}`

        case 'boolean':
          switch (issue.received) {
            case 'null':
            case 'undefined':
              return 'mÃ¥ fylles ut';
            default:
              return 'mÃ¥ vÃ¦re en boolsk verdi';
          }
      }
      break;
```",,
1277166517,1215,non-partial `record`?,"Hey, I notice that the type created by `z.record` is `Partial<Record>`, and I can't see a way to avoid the `Partial`. I don't want to use `z.object` because I have one enum of keys that I want to use across many record types, with different value types.

Maybe z.record isn't the one for this. In other words how can I create a schema for keys in one place, and re-use it for many object schemas?

For example:

```ts
const Languages = z.enum([""en"", ""fr""])

const Translations = z.record(Languages, z.string())
const hello = Translations.parse({ en: ""hello"", fr: ""bonjour"" })
const v = hello.en // string | undefined

const Numbers = z.record(Languages, z.array(z.string()))
const numbers = Numbers.parse({ fr: [""un"", ""deux""] }) // should fail without 'en' key",,
1277058126,1214,ZodFormattedError Does not work for union type,"I have an interface with a template property that can be either a number or an object. The typewriter does not correctly display the type for the formatted error

```ts
zod.object({
    template: zod
        .number()
        .or(zod.object({
            label: string().nullish(),
        }))
```

I want to get a formatted error type
```ts
ZodFormattedError<ZodInterface, string>
// Expected
// {_errors: string[]} |  {_errors: string[], label: {_errors: string[]}}

// Actual
// {_errors: string[]}
```

[Reproduction in playground](https://www.typescriptlang.org/play?ts=4.5.5#code/C4TwDgpgBAWg9gEwGJwE4FsCGxgQQUVVTQB4AVAGigFUoBeKAZ2FQEsA7AcwD56oBvALAAoKGKgB9CETSMAXDQDaAXQDcIgL5QAZFAAUZKBAAeudgkZRFmdiCoA6RzZArlUAPwCR4qwGkoHFAA1hAgcABmUGTK7grwyGhYOHiExKjkir7K3OrCWgqGJmYWUM4qHl6i4opBCuwArugARtLKcYgoGNi4BDLpZIoNza05mlAFRqYQ5pZwTQBWEADGwBVCVWKZAezBoRFRMe0JXcm9aRlZo3njUPXsQexwAO7sAJS5IiIA9ABUUCIAL0Q9jmixWenWPlw6DAABtsBAFECEN4fOJ7EMWqg9K9UWioCDsciQQtlsAIXj8eJ4S1YQpmGwuDj7CxWOhmQ1YbDWIwABY4iiUnwaV64vJin5fESgSCwRAASXYuFQ4UwS2gDEh4mhcIRdUaWKgAB9KlSoDSILDYkxWVxjVBObD7XcEBBwhw8LlhbkNJ9hDLoKk+PFOkkeqlSPFFcrVeqqAyODw-Us4OxmEY+PwtJhLKk-RAWRAYfDcO57BarfYpH1LF8vlASABaGjsEyQFZ4Ix9IA)

",,
1272010819,1208,Allow setting a label and pass it through to error map,"Don't remember the exact rule, but I believe there is a WCAG requirement that error messages should refer to the name of the field it's about. I.e. `Field is required` is less good than for example `""First name"" is required`.

Would be great if we could add a label to our schema, which would be used in the default error map, _and_ be made available in custom error map functions.

```ts
const mySchema = z.object({
  firstName: z.string({ label: 'First name' }),
  dateOfBirth: z.date({ label: 'Date of birth' }),
})
```

I see there's already a `description`, but it's not documented anywhere, so not sure what that is for. If it's actually for a label, then I guess this would be solved simply by exposing that `description` in the error map somehow. Maybe it could come as part of the `ErrorMapCtx` object?

<img src=""https://user-images.githubusercontent.com/142162/173804787-a9987eb7-946d-489b-b6b4-4d09679858ff.png"" alt=""screenshot"" width=""350""/>
",,
1271071948,1207,Jest fake timers don't work with Zod defaults,"When mocking dates in Jest, Zod does not use the mocked values when using a date in a default.

Example:
`updatedTimestamp: z.string().trim().regex(ISORegex).default(new Date().toISOString()),`

Testing:

`const mockTimestamp = '2022-05-24T03:56:38.795Z';`

`jest.useFakeTimers().setSystemTime(new Date(mockTimestamp));`
Or
`jest.spyOn(Date.prototype, 'toISOString').mockReturnValue(mockTimestamp);`

It does not use the provided date, and instead continues to use the current time.",,
1270709834,1206,"How can I allow `null` as input value of a schema, but not as a valid output?","I'm trying to use `zod` and `react-hook-form` together, and find it a bit difficult to deal setting `defaultValues` in a way that makes both `react-hook-form`, `typescript` _and_ the actual schema validation happy.

Say you have this schema:
```ts
const zodSchema = z.number().int().nonnegative()
type ZodValues = z.input<typeof zodSchema>
// number <-- want null to be allowed here
type ZodValid = z.output<typeof zodSchema>
// number
```
Here both `ZodValues` and `ZodValid` does not allow `null` as a value.

If I add `nullable`, we get this:
```ts
const zodSchema = z.number().int().nonnegative().nullable()
type ZodValues = z.input<typeof zodSchema>
// number | null
type ZodValid = z.output<typeof zodSchema>
// number | null // <-- don't want null to be allowed here
```

Using `yup@0.32.11` (latest now), it seems I'm able to do it like this, which is what I want:
```ts
const yupSchema = number().nullable(true).required().integer().min(0)
type YupValues = TypeOf<typeof yupSchema>
// number | null | undefined
type YupValid = Asserts<typeof yupSchema>
// number
```

Is there any way I can write this schema with `zod`, so that the _input_ allows `null`, while the _output_ does not?

The issue is that `react-hook-form` preferably wants non-undefined default values for the input, and for e.g. `number` and `Date` inputs I'd really prefer to use `null` as I do not want to pick a random number or date to use as the default.",,
1270305538,1205,"Issue with types? Using refine() with an array results in typescript linting error saying type is missing the message property. However, works in runtime. ","Hello, I am using zod as a resolver with react hook form. I have a schema setup as follows:

```typescript

const mySchema = z.object({
  // some other properties
  myArray: z.array({
    // some properties
  })
  .min(1)
  .max(10)
  .refine(
    (item) => {
      // some validation
    },
    {
      message: ""My error message""
    }
  )
});
```

When trying to access the error message like below, I get a linting error saying property 'message' does not exist on type. However during runtime there is no error and I can access the message properly.

```typescript
formState.errors.myArray.message
```

Any idea on how to resolve this?",,
1269975213,1204,"How to enable ""eager validation"" after first failed form submission?","Thank you so much for this amazing library.

I'm using Zod in a Mantine form on a Next.js app, and it's working well.

One possible UX improvement on my form would be for field validation to be ""eager"" (i.e. instant on every keyUp event) after the first time the visitor tries to submit a form with invalid values.

For example, I have this rule:

```
z
    .string()
    .max(64, { message: 'Maximum 64 characters' })
    .refine((acc) => acc === '' || mainnetRegex.test(acc), {
      message:
        'If you are providing a named NEAR mainnet account address (which is optional), it must be valid and end with `.near`. See https://docs.near.org/docs/concepts/account#account-id-rules for details.',
    })
    .optional()
```

If a visitor tries to submit the form and then sees that error, it would be ideal if the visitor could see the error message go away *immediately* whenever the field's value is edited such that it is valid.

How could I achieve this UX while using zod? Thanks!",,
1264877793,1196,Discriminated unions became incompatible with `zod.input`,"The issue is reproducible with Typescript v. 4.6+ and is very likely caused by its new feature called [Control Flow Analysis for Destructured Discriminated Unions](https://devblogs.microsoft.com/typescript/announcing-typescript-4-6/#control-flow-analysis-for-destructured-discriminated-unions).
[Here](https://codesandbox.io/s/festive-marco-0tv0uk?file=/index.ts) is a sandbox that reproduces the error. Run `yarn build` in the terminal tab.
Essentially, here's the compiler error that I get when trying to reference the result of `zod.input` that was applied to a discriminated union type constructed using `zod.union` (classic way):

<img width=""1231"" alt=""image"" src=""https://user-images.githubusercontent.com/32125472/172644267-0ed33e49-c9ce-4abb-859b-f76f35238d92.png"">

And nothing changes if I use the brand new `zod.discriminatedUnion`:

<img width=""1244"" alt=""image"" src=""https://user-images.githubusercontent.com/32125472/172646717-7b557fb5-e166-449c-8f22-c4357624f1d3.png"">

The issue is not reproducible in Typescript v. 4.5 and older.
",,
1264103236,1195,Zod 2?,"@colinhacks just read on your profile that you're working on Zod 2. Since I'm about to go all in with Zod on a bigger project it would be great if we could learn more about Zod 2, in particular if there'll be an upgrade path, if Zod 1 will be kept maintained and a rough ETA for Zod 2. Thanks.

Edit: Ok, I think your profile text is old and we are already past Zod __version__ 2, so I presume it's safe to go all in ðŸ™‚",,
1263699886,1194,Add the value received to the error message for a discriminated union's type,"I ran into a small problem with the error reporting that just meant I was having to chase a needle in a haystack. My situation: I am writing a zod definition to represent the data coming back from an api. It is an array of messages each with a type so a discriminated union is perfect.

The issue I ran into was that I had a large json file which was a dump of an api request and as I started defining the messages I would find I would be missing some types. These just became painful to find as I a. didn't know what they were called and b. ended up counting items in an array to find the right position based on the path in the z.parse error :(

In @alexxander [original code  comment](https://github.com/colinhacks/zod/issues/792#issuecomment-1023251415) in #792 the value was shown in the error message `Received ${val[discriminator]}` thus:

```javascript
ctx.addIssue({
    code: z.ZodIssueCode.custom,
    message: `Invalid discriminator value. Expected one of: ${validDiscriminatorValues.join(', ')}. Received ${val[discriminator]}.`,
    path: [discriminator],
});
```

[In the code that ended up being merged](https://github.com/colinhacks/zod/pull/899/files#diff-c54113cf61ec99691748a3890bfbeb00e10efb3f0a76f03a0fd9ec49072e410aR1960) it was done like this:

```javascript
if (!option) {
  addIssueToContext(ctx, {
    code: ZodIssueCode.invalid_union_discriminator,
    options: this.validDiscriminatorValues,
    path: [discriminator],
   // TODO Add received here?
  });
  return INVALID;
}
```

I'm happy to put up a PR for this (if anyone can see how to do this please feel free) - I suppose before I start on this journey into understanding the source code (which is surprisingly delightfully terse btw) I just wanted to sanity check 2 things:

1. Is this something that maintainers would be happy to have added to the codebase - ie maybe there is an opinion that error messages should nat have the value received in them.
2. Is this possible - ie can `addIssueToContext` have a `received: this.value` added to it? and if so is the value available in `this`at this point in the code

Thanks again for everyone contributing to this project - you make my life better

",,
1263415532,1193,Cannot read properties of undefined (reading '_parse'),"Hey, I've come across this issue in my project while composing schemas from imported zod objects/enums.Here is the code:

**CountryCode.ts**
```TS
import { z } from 'zod';

const countryCode = z.enum(['IE', 'GB']);

type CountryCode = z.infer<typeof countryCode>;

const countrySchema = z.object({
  alpha2: z.string(),
  alpha3: z.string(),
  code: countryCode,
  name: z.string(),
  region: z.string(),
  regionCode: z.number(),
  subRegion: z.string(),
  subRegionCode: z.number(),
});

type Country = z.infer<typeof countrySchema>;

export { countryCode, countrySchema };
export type { Country, CountryCode };
```
**CurrencyCode.ts**
```TS
import { z } from 'zod';

const currencyCode = z.enum(['EUR', 'GBP']);

type CurrencyCode = z.infer<typeof currencyCode>;

const currencySchema = z.object({
    code: currencyCode,
    name: z.string(),
    minorUnit: z.number(),
  });


  type Currency = z.infer<typeof currencySchema>;

export { currencyCode, currencySchema };    
export type { CurrencyCode, Currency };   
```

If i import the above like so:
**invitePerson.ts**
```TS
import { z } from 'zod';
import { countryCode, currencyCode } from '../../api';

const invitePersonSchema = z.object({
  startDate: z.date().optional(),
  firstName: z.string().min(1, 'First name is required'),
  lastName: z.string().min(1, 'Last name is required'),
  role: z.string().optional(),
  dateOfBirth: z.date().optional(),
  email: z.string().email('Email is required'),
  residentialAddress: z.object({
    addressLine1: z.string().optional(),
    addressLine2: z.string().optional(),
    addressLine3: z.string().optional(),
    city: z.string().optional(),
    countryCode: countryCode,
    postalCode: z.string().optional(),
  }),
  annualSalary: z
    .string()
    .min(1, 'Annual salary is required')
    .transform(value => parseInt(value, 10)),
  salaryCurrency: currencyCode,
  taxId: z.string().optional(),
});

type InvitePersonData = z.infer<typeof invitePersonSchema>;

export { invitePersonSchema };
export type { InvitePersonData };

```
I get the error in the title. However, if I define the enums directly in the `invitePersonSchema` and don't import, there is no error. I would have expected this to be allowed, so please forgive me if I am misusing the library in some way.

Note: this was already discussed here, but the last comment provides a reproducible example which I have copied below, just in case it helps: https://github.com/colinhacks/zod/issues/643 

> I ran into the same error message and found this issue. Now while my problem is likely a different another one, I thought sharing this might still help others ending up here.
> 
> Essentially what I was doing is exporting a schema from one file, using it in another one to compose another schema, and then importing that composed schema back into the first file. While there isn't a cyclic dependency per se, it causes the mentioned error at runtime.
> 
> See this CodeSandbox for an example: https://codesandbox.io/s/patient-butterfly-hsg3q?file=/src/index.ts The message isn't as descriptive as in my local (larger) project, but removing this exact kind of import solved it for me. (Maybe this is generally ""wrong"" in terms of my tsconfig or simply unsupported by zod and I don't know it, but I would intuitively expect it to work ðŸ™ˆ.)",,
1262617372,1192,Simple `ZodObject` inference from existing Interface?,"When needing to attempt to bind an existing Interface to `ZodObject`, there are a few issues with using the more simplistic `ZodSchema` to achieve this - namely losing all the object-specific options such as `schema.shape`.

As far as I know, there isn't really a way to neatly infer a `ZodObject` without needing to recapitulate the entire schema again within the definition, which is often not possible when the source type is external and the point of the binding is to notice if the shape of the schema differs from the source.

This is what I (very roughly) have worked out so far, so was wondering if 
a) there is any existing internals that might be better suited to this, and;
b) if there is any chance some more developed version of this inference type might be possible to include in the main package?

```typescript
/**
 * Simple example mapping to string version of each type, would need to be completed with all types
 */
export type GetRequiredType<T> = T extends string
  ? ""string""
  : T extends number
  ? ""number""
  : T extends boolean
  ? ""boolean""
  : never

/**
 * Append `Optional` to the key name for optional properties.
 */
export type GetType<T> = undefined extends T
  ? `${GetRequiredType<T>}Optional`
  : GetRequiredType<T>

/**
 * Simple example mapping / lookup of ""rough"" Zod types for each concrete type.
 */
export interface ZodTypes {
  string: ZodString | ZodEffects<ZodString, string, any>
  stringOptional: ZodOptional<ZodString | ZodEffects<ZodString, string, any>>
  number: ZodNumber | ZodEffects<ZodNumber, number, any>
  numberOptional: ZodOptional<ZodNumber | ZodEffects<ZodNumber, number, any>>
  boolean: ZodBoolean | ZodEffects<ZodBoolean, boolean, any>
  booleanOptional: ZodOptional<
    ZodBoolean | ZodEffects<ZodBoolean, boolean, any>
  >
}

/**
 * Cast the existing output interface as a ZodRawShape using the lookups defined above.
 */
export type ToZodRawObject<Output extends object> = {
  [Key in keyof Output]: ZodTypes[GetType<Output[Key]>]
}

/**
 * Case the existing output interface as a valid ZodObject.
 */
export type ToZodObject<Output extends object> = ZodObject<
  ToZodRawObject<Output>,
  ""strip"",
  ZodTypeAny,
  Output
>

```

## Passing Example

```typescript
export interface User {
  name?: string
  email: string
}

export const UserSchema: ToZodObject<User> = z.object({
  name: z.string().optional(), // Passes
  email: z.string().email() // Passes
})
```

## Failing Example

```typescript
export interface Product {
  name: string
  serial?: number
}

export const ProductSchema: ToZodObject<Product> = z.object({
  name: z.string().transform((value) => value.toUpperCase()), // Passes
  serial: z.number().refine((value) => value > 1000) // Fails! (must be optional)
})

```",,
1262205976,1191,.omit/.pick support for enums,"I have use-cases for `pick`/`omit` like https://github.com/colinhacks/zod#pickomit but for enums:

- https://github.com/colinhacks/zod#zod-enums
- https://github.com/colinhacks/zod#native-enums

Example currently:

```ts
export const DatasourceProvidersNormalizedSupportingMigration = z.nativeEnum(
  omit(Reflector.Schema.DatasourceProviderNormalized.enum, ['mongodb'])
)
```

Imagined example with better API:

```ts
export const DatasourceProvidersNormalizedSupportingMigration = Reflector.Schema.DatasourceProviderNormalized.omit('mongodb')
```",,
1261086065,1190,safeParse discriminated union doesn't have 'error' attribute,"```            
const parsedUser = userZ.safeParse(user.toObject())

if (!parsedUser.success) {
      console.error(parsedUser.error)
      return null
}
```

Gives me this error:

```
Property 'error' does not exist on type 'SafeParseReturnType<{ telegramId?: number; telegramHandle?: string; twitterId?: number; twitterHandle?: string; address?: string; ens?: string; telegramFirstName?: string; twitterUsername?: string; isMetabotEnabled?: boolean; }, { ...; }>'.
  Property 'error' does not exist on type 'SafeParseSuccess<{ telegramId?: number; telegramHandle?: string; twitterId?: number; twitterHandle?: string; address?: string; ens?: string; telegramFirstName?: string; twitterUsername?: string; isMetabotEnabled?: boolean; }>'.ts(2339)
```

when `success===true` it doesn't give an error when i try to access `data`. Example:

```
return parsedUser.success ? parsedUser.data : null
```",,
1261032658,1189,Data transformation with zod schema,"Hi, I'm investigating ways to automate data transformation.

Since zod's main purpose is to validate data using a schema, would there be interest in also transforming a source object into the result described by the schema?

Probably an example would help understanding the use case.

```// Source data coming from an API.
const source = {
  foo: 'baz',
  bar: ['bar', 'foo'],
  baz: {
    qux: 'bazqux'
  }
};
const schema = {
  foo: 'foo', // Simple Projection
  bazqux: 'baz.qux' // Grab a value from a deep path
};

morphism(schema, source);
//=> { foo: 'baz', bazqux: 'bazqux' }```



This is inspired by a package called morphism: https://github.com/nobrainr/morphism",,
1261001456,1188,Type numeric native enum is not assignable to type 'string',"I'd like to produce the following type:
```ts
export type ButtonItem = {
  type: ItemType.BUTTON
}
```

where `ItemType` is a native numeric enum

So I try this:
```ts
z.object({
    type: z.nativeEnum([ItemType.BUTTON]),
  })
```

But it says: `Type 'ItemType' is not assignable to type 'string'`

I'm not sure how to proceed here?",,
1260259726,1186,UUID parser is firing errors for valid UUIDs,"## Describe the bug

the UUID string validator doesn't work for UUIDs that have the third portion starting with a 0.

## To Reproduce

```js
const { z } = require('zod');
z.string().uuid().parse('30000000-0000-0000-0000-000000000000'); 
/*                                                            
    that will throw because of the first 0 at the third part of the UUID.
*/
```
",,
1255844188,1182,[Feature Request|Question]How to add a plain field to the schema type?,"For example, I want to add a reference between children and parent, but the 'parent' field is not inside the data object(json):
```typescript
type Child = {
    parent: Group,
    name: string,
}

type Group = {
    name: string,
    children: Child[]
}
```
The data is:
```typescript
[
    {
        name: 'group1',
        children: [
            { name: 'child1' },
            { name: 'child2' },
        ]
    }
]
```

So I build the schema:
```typescript
const ChildSchema = z.object({ name: z.string() });
const NodeSchema = z.object({ name: z.string(), children: z.array(ChildSchema) });

type Node = z.infer<typeof NodeSchema>;
type Child = z.infer<typeof ChildSchema> & { parent: Node }; // How to add this field?
```
",,
1254317565,1181,Type error with discriminatedUnion when using dynamic amount of objects,"For a project I am working on we are using zod to type check user provided input at runtime, we have ""sections"" which are defined in a manifest. I need to have a discriminatedUnion by am getting a type error when doing the following:

```ts
const section = z.discriminatedUnion('type', [
  ...Object.values(manifest.sections).map((section) => section.zod),
])
```

The above code does work, and what is weirder is that when accessing the items individually it works:

```ts
const zodObjects = Object.values(manifest.sections).map((section) => section.zod)

const section = z.discriminatedUnion('type', [
  zodObjects[0],
  zodObjects[1],
  zodObjects[2],
  // ...
])
```

At a guess it's because it doesn't know that it's a array with multiple items but am unsure the best way of fixing this",,
1254070466,1180,[Proposal] Allow to add arbitrary values to `ZodIssue`,"I'm trying to add the value that caused an error to the `ZodIssue`s returned by the `parse`-functions and as far as I can see the only way to do it is
- either misuse `errorMap` and put it into the `message`
- or post-process the `issues` array and do whatever after parsing it:

https://codesandbox.io/s/suspicious-minsky-s8mjgn?file=/src/index.ts

Proposal:

Allow `errorMap` (or a new method) to add arbitrary values to `ZodIssue` return by the `parse` functions.",,
1253399776,1179,cannot able to extract type form schema z.infer<myzodschema>,"version: 3.17.3

i'm unable to extract type from schema
```
//here is my code
const body:ZodSchema =z.object({
	username:z.string(),
	password:z.string()
})
type login = z.infer<typeof body>

//here it shows data as type of any and  therefore shows no autosuggestions
const data:login = {}


```
it was working fine yesterday i haven't change any code  is this version issue? i'm not sure if its updated,",,
1252120019,1177,Doubts about type inference when using picks,"Hello everyone, when calling the pick method of a `zodObject` in a function by passing in a reference, how to set the type of `T` to ensure the correct type of return valueï¼Ÿ

```typescript
function zodPickDemo<T extends ZodObject<ZodRawShape>>(src: T) {
  return src.pick({ id: true });
}

const dto = z.object({ id: z.string(), name: z.string() });
const picked = zodPickDemo(dto);
// In this case the type of picked is not the expected type
```

In the above code, the type expected to be obtained is a `zodObject` object type containing only the id, but what is obtained is a type such that:

```typescript
z.ZodObject<Pick<z.ZodRawShape, never>, ""strip"", z.ZodTypeAny, {}, {}>
```

Playground: [link](https://stackblitz.com/edit/vitejs-vite-iauawv?file=src%2Fmain.ts&terminal=dev)",,
1252105620,1176,Allow specific properties to be `.required`,"I have a mySchema with ~10 properties.

In my API, I use `mySchema.partial()` as all props are optional, BUT one.

I wish I could simply `mySchema.partial().required({ myRequired: true })`, as partial allows.

It would be a better solution than .partial({ 9 props }) or merging with the mySchema.shape.myRequired.",,
1251982190,1174,Don't let `invalid_type_error` replace the default `required_error`,"The default error when parsing `undefined` for a required value is ""Required"". When a value overrides its type error with `invalid_type_error`, that message also also overrides the default message for undefined values. I would expect that only `required_error` would override that message.

```
z.number().parse(undefined);
// Throws error with message ""Required""

z.number({ invalid_type_error: 'Wrong type!' }).parse(undefined);
// Throws error with message ""Wrong type!""
// Expected behavior: Throws error with message ""Required""
```",,
1250324288,1171,Discriminated union doesn't work with `transform`,"Possibly it is not bug. Any way to ""post""-define discriminator (define in `transform`)?

[Codesandbox example 1](https://codesandbox.io/s/typescript-playground-export-forked-y43ihh?file=/index.ts:0-410)
[Codesandbox example 2](https://codesandbox.io/s/typescript-playground-export-forked-gnlt25?file=/index.ts)

Example 1:

```ts
import z from ""zod"";

const schemaA = z
  .object({
    mo: z.number().optional(),
    aa: z.number()
  })
  .transform((content) => ({
    ...content,
    k: ""kindA"" as const
  }));

const schemaB = z
  .object({
    mi: z.number().optional(),
    aao: z.number()
  })
  .transform((content) => ({
    ...content,
    k: ""kindB"" as const
  }));

const schemaC = z.discriminatedUnion(""k"", [schemaA, schemaB]);
```

Example 2:

```ts
import z from ""zod"";

const schemaA = z.object({
  T: z.literal(""error""),
  c: z.number(),
  m: z.string()
});

const schemaB = z
  .object({
    T: z.literal(""ss""),
    mi: z.number().optional(),
    aao: z.number()
  })
  .transform((content) => ({
    ...content,
    someField: ""someValue"" as const
  }));

const schemaC = z.discriminatedUnion(""T"", [schemaA, schemaB]);
```

Error: The discriminator value could not be extracted from all the provided schemas
",,
1248568930,1169,Deep-nullable utility?,"Simple request: can a utility be added which does exactly what `deepPartial` does, but makes properties `nullable` instead of `optional`? For instance, `deepNullable()`, as a first stab.

I tried my hand at this myself, but admittedly the source for `deepPartial` is ... pretty tricky to follow ðŸ™‚ 

If there's a way to do this that I've missed, please steer me straight. Thanks!",,
1247601513,1166,Schema annotations,"Reading the README I have not found a way to define schemas with custom annotations

Currently I extend my JSON Schemas to annotate a property as ""sensitive"", so I know which fields have privacy concerns, like, it should not be appear in logs and/or it can be affected by user privacy laws.

I do not mean adding the ""sensitive"" property to a Schema property, but just store any random key-value combo. That will open the door to similar ideas. Since they are non standard, it can be safely ignored by tools depending on Zod and not increase the maintenance burden.",,
1246405429,1164,Failing a `.refine` check does not report error,"First of all thank you for a great library! ðŸ™ 

I ran into what I believe to be a bug while using this to build some programmatic input parsing and validation, where objects containing keys that do not match the schema need to be removed from an array. The details of how and why are probably uninteresting for this issue, though I can make a write-up if you would like.

The general structure of the schema is like this:

```typescript
const schema = z.object({
    foo: z.array(
        z.object({
            k1: z.string(),
            k2: z.number()
        })
    ).refine(
        (os) => os.filter((o) => o.k1 === ""bar"").length < 2,
        ""At most one k1 with value \""bar\"" allowed!""
    )
});
```

I want to parse an unknown input using this schema, and do two things:

1. Remove any entries of the array in `foo` that fail the schema
2. Merge any entries of the array in `foo` if the ""At most one k1 ..."" refinement failure occurs

If I have a value that fails just the refinement part of the schema, it shows the refinement error. However, once I have a value that fails both the inner `z.object` schema and the refinement, only the schema error for the `z.object` schema is reported. I would have expected it to report all errors in the first pass.

With this limitation, solving the problem becomes:

1. Run validation
2. Remove objects as required
3. Run validation with the new value (which I now know does not contain any of the issues reported in step 1)
4. Rinse and repeat (presumably just once)

The looping/recursion works, but it is not optimal.

To help debug this I have created a repo with a very small example of a schema and values that show the problem: https://github.com/mdiin/zod-parse-repro",,
1246003697,1163,Applications fail to build with tsc 4.3.5 and zod 3.17.2 due to invalid import in parseUtil.d.ts,"When I try to compile my typescript application with tsc to js, and depend on zod 3.17.2, I get a number of compile errors:

```
 tsc -p tsconfig.json
node_modules/zod/lib/helpers/parseUtil.d.ts:1:15 - error TS1005: ',' expected.
1 import { type IssueData, type ZodErrorMap, type ZodIssue } from ""../ZodError"";
                ~~~~~~~~~

node_modules/zod/lib/helpers/parseUtil.d.ts:1:31 - error TS1005: ',' expected.
1 import { type IssueData, type ZodErrorMap, type ZodIssue } from ""../ZodError"";
                                ~~~~~~~~~~~

node_modules/zod/lib/helpers/parseUtil.d.ts:1:49 - error TS1005: ',' expected.
1 import { type IssueData, type ZodErrorMap, type ZodIssue } from ""../ZodError"";
                                                  ~~~~~~~~

node_modules/zod/lib/helpers/parseUtil.d.ts:2:15 - error TS1005: ',' expected.
2 import { type ZodParsedType } from ""./util"";
                ~~~~~~~~~~~~~
```
This is with the following compiler options:
```
  ""compilerOptions"": {
    ""incremental"": true, 
    ""target"": ""ES2020"",
    ""module"": ""commonjs"",
    ""lib"": [""ES2020""],
    ""allowJs"": true,
    ""pretty"": true,
    ""declaration"": true,
    ""sourceMap"": true,
    ""removeComments"": true,
    ""strict"": true,
...
}

and 
```
tsc -V
Version 4.3.5
```.

Logging at the offending lines from `parseUtil.d.ts`:
```
import { type IssueData, type ZodErrorMap, type ZodIssue } from ""../ZodError"";
import { type ZodParsedType } from ""./util"";
```

I think those import statements should be:
```
import type { IssueData, ZodErrorMap, ZodIssue } from ""../ZodError"";
import type { ZodParsedType } from ""./util"";
```
Am I right? I would be happy to create a PR with the fix. ",,
1245187913,1161,Latest release's types not working?,"Excuse the horrible title, but I'm creating a PR over at trpc and some CI tool is telling me this:

```
$ next build
--
10:53:39.158 | info  - Loaded env from /vercel/path1/.env
10:53:39.404 | info  - Checking validity of types...
10:53:44.795 | Failed to compile.
10:53:44.795 | Â 
10:53:44.796 | ./node_modules/zod/lib/helpers/parseUtil.d.ts:1:15
10:53:44.796 | Type error: ',' expected.
10:53:44.796 | Â 
10:53:44.796 | > 1 \| import { type IssueData, type ZodErrorMap, type ZodIssue } from ""../ZodError"";
10:53:44.796 | \|               ^
10:53:44.797 | 2 \| import { type ZodParsedType } from ""./util"";
10:53:44.797 | 3 \| export declare const makeIssue: (params: {
10:53:44.797 | 4 \|     data: any;

```

I didn't have this error yesterday, so I'm assuming that this is relate to the latest release.
In fact, it looks like [this github actions job](https://github.com/colinhacks/zod/commit/44916fe7dee9413216ee0b24001cfbf835cda584#diff-cf85b3e0a8cdc5f1bfea0bff847e1d89dfbb182c744fd0bc95eae659117b70fd) is telling that there needs to be some fixes.",,
1244051396,1158,refine add original value | enhancement,"I am using the union of objects with different shapes. Sometimes users will fill just one ""image"" and ZOD removes this field automatically during parsing (union). I want to handle the state when the user needs to fill all images for all options, but I cannot do that. Can you add ""original data"" as the second parameter in refine function? Or the ability to get this data?

```js
  const textOption = z
    .object({
      text: optionTextSchema,
    })
    .array();

  const imageOption = z
    .object({
      image: optionImageSchema,
    })
    .array();

  const textAndImageOption = z
    .object({
      image: optionImageSchema,
      text: optionTextSchema,
    })
    .array();

  return z
    .union([
      textAndImageOption,
      textOption,
      imageOption,
    ]).refine((options: Object[]) => {
      const imageOptions = options.filter((option: any) => option.image);
      return imageOptions.length === 0 || imageOptions.length === options.length;
    }, ...);
```

Data example with just one image
```js
[{
  image: 'image.jpg',
  text: 'first option'
}, {
  text: 'second option',
}]
```

Refine will get these options which is correct but I am not able to know if there are any images:
```js
[{
  text: 'first option'
}, {
  text: 'second option',
}]
```
",,
1243219377,1156,New Feature - Negative Regex ,"Hi, first of all, really appreciate all the effort on this fantastic library.

I'd like to suggest what I think is a minor improvement...a negative regex test.

**Rationale**: It can be quite complex to write the inverse of a regex (negative look ahead etc) and would be much simpler to have the ability to negate the result of the match.

**Suggestion**: Rather than change the current API, I would suggest negex( regex, message) but entirely up to you.

Apologies if there is another idomatic way of achieving the same outcome.  

**Background**: I'm using tiptap as a Wysiwyg editor.  When it's input is empty, rather than `""""`, it returns `""<p></>""`.   I want to error if the regex **does not match** `/^<p><\/>$/`, rather than if it does.  Currently I preprocess the input to coerce `""<p></>""` to `""""`.
 ",,
1242860311,1155,How to use Enum to map between numbers and member names,"Hi I'm a beginner at TS, I'm trying to easily map between the number and status.

Here is a python example of what am I trying to achieve:

```python
from enum import Enum

class Status(Enum):
    GOOD = 1
    BAD = 2

response = {""status"": ""GOOD""}

print(Status.GOOD)  # Status.GOOD
print(Status.GOOD.value)  # 1
print(Status.GOOD.name)  # GOOD

good_status = Status[response['status']]

print(good_status == Status.GOOD)  # True

print(good_status.value)  # 1
```

When I try something similar with `zod` I get TS error: `Element implicitly has an 'any' type because index expression is not of type 'number'`


Please see attached CodeSandbox: https://codesandbox.io/s/typescript-playground-export-forked-sf66kp?file=/index.ts:1040-1428

```typescript
import { z } from ""zod"";

enum StatusEnum {
  GOOD,
  BAD
}

export const ASchema = () =>
  z.union([
    z.literal(StatusEnum[StatusEnum.GOOD]),
    z.literal(StatusEnum[StatusEnum.BAD])
  ]);

type A = z.infer<ReturnType<typeof ASchema>>;

export const BSchema = () =>
  z.enum([
    StatusEnum[StatusEnum.GOOD] as string,
    StatusEnum[StatusEnum.BAD] as string
  ]);

type B = z.infer<ReturnType<typeof BSchema>>;

export const AResponseSchema = () =>
  z.object({
    body: z.string().optional(),
    status: ASchema()
  });

type AResponse = z.infer<ReturnType<typeof AResponseSchema>>;

export const BResponseSchema = () =>
  z.object({
    body: z.string().optional(),
    status: ASchema()
  });

type BResponse = z.infer<ReturnType<typeof BResponseSchema>>;

const received = { status: ""GOOD"" } as const;

const x = AResponseSchema().parse(received);

const iWantThisToEvaluate = x.status === StatusEnum.BAD; // this is a problem

if (iWantThisToEvaluate) {
  console.log(""finally!"");
} else {
  console.log(""does not work"");
}

const works_number = StatusEnum[received.status];
const works_name = StatusEnum[StatusEnum[received.status]];
const notWorks_number = StatusEnum[x.status]; //Element implicitly has an 'any' type because index expression is not of type 'number'
const notWorks_name = StatusEnum[StatusEnum[x.status]]; // Element implicitly has an 'any' type because index expression is not of type 'number'

```

Thank you",,
1242438766,1154,Ability to add label to be shown in error instead of generic like: String must contain at least 3 character(s),"For example if I have this validation
```typescript
const schema = z.object({
   firstName: z.string().min(3).max(12),
   isActive: z.boolean(),
   role: z.enum(['Admin', 'User']),
});

const result = schema.safeParse({
   ""firstName"": '',
   ""isActive"": null,
   ""role"": ""min"",
});

console.log(JSON.stringify(result, null, 2));
```

```
{
  ""success"": false,
  ""error"": {
    ""issues"": [
      {
        ""code"": ""too_small"",
        ""minimum"": 3,
        ""type"": ""string"",
        ""inclusive"": true,
        ""message"": ""String must contain at least 3 character(s)"",
        ""path"": [
          ""firstName""
        ]
      },
      {
        ""code"": ""invalid_type"",
        ""expected"": ""boolean"",
        ""received"": ""null"",
        ""path"": [
          ""isActive""
        ],
        ""message"": ""Expected boolean, received null""
      },
      {
        ""received"": ""min"",
        ""code"": ""invalid_enum_value"",
        ""options"": [
          ""Admin"",
          ""User""
        ],
        ""path"": [
          ""role""
        ],
        ""message"": ""Invalid enum value. Expected 'Admin' | 'User', received 'min'""
      }
    ],
    ""name"": ""ZodError""
  }
}
```

Error message will be 

`firstName must contain at least 3 character(s)` instead of `String must contain at least 3 character(s)`

",,
1242177035,1153,How to use the `custom` validator?,"Documentation for the `custom` validator is missing. That's how I use it:

``` ts
const schema = object({
  number: number(),
  string: string(),
  myProp: custom((data) => {
    const isValid = isDataValid(data); // returns bool

    if (!isValid) {
      throw new ZodError([
        {
          message: 'My custom msg',
          code: ZodIssueCode.custom,
          path: ['myProp'],
        },
      ]);
    }

    return true;
  }),
});
```

But I'm not sure if it's right because if I do:

``` ts
try {
  schema.parse({});
} catch(e) {
  console.log(error);
}
``` 

Then the only validation error I'm getting is coming from the custom validator. I would expect 3 errors instead. So I'm guessing I'm doing something wrong.",,
1241450532,1151,Zod schema from OpenAPI/Swagger,"Is there a way to generate Zod schema from OpenAPI/Swagger definition? 
I could not find anything related (there are many tools for the other way), but I guess that validating/converting JSON from API would be a typical Zod use case.",,
1239179817,1147,Support merging ZodEffects (created from an object) into other objects,"I've created a ZodEffects schema as follows:

```
const myObjSchema = z.object({
    foo: z.string(),
    bar: z.string().optional(),
}).refine( input => {
    // allows bar to be optional only when foo is 'foo'
    if ( input.foo !== 'foo' && input.bar === undefined ) return false
    return true
});
```

Now I want to merge `myObjSchema` into another object, like so:

```
const composedSchema = z.object({
  baz: s.string()
}).merge(myObjSchema);
```

But I can't, because `merge` is expecting an `AnyZodObject` argument and not a `ZodEffects` argument.",,
1238706809,1145,Union of Enum values or object values,"Is there any way to create a union validation of enum values or object values?

I tried the code below but it doesn't work:
```ts
import {z} from 'zod';

const Fruits = {
  Apple: ""apple"",
  Banana: ""banana"",
} as const;

const FruitEnum = z.nativeEnum(Fruits);

type Fruit = z.infer<typeof FruitEnum>; // ""apple"" | ""banana""

const fruitValuesLiterals = Object.values(Fruits).map(value => z.literal(value)); // z.ZodLiteral<""apple"" | ""banana"">[]

const fruitUnion = z.union(fruitValuesLiterals); // ERROR: Argument of type 'ZodLiteral<""apple"" | ""banana"">[]' is not assignable to parameter of type 'readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
```

[TS playground code](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbwF4F84DMoRHA5EiAE1wG4AoMgYwgDsBneAMSgFdgY64BeRMuOAIJgwAGwCmALjgAiAIbDx0gDR84AIVk1NsqdIBG2rcrJpZnavRjkqtBnGZsYAURoscPJADotMYADcxFzcACgd2OgBKaxgATzAxe1Z2bjgvYBp0MSgAHlj4iHRExyCQAD4SOAB6Spl5UTFpOAAfGQMtIwoLO0xHADVZERYxOgAZdiyBzh4AeT0AKzFKGE8-AaG6UKSOCM8QeWDVwYSuUtTPEXGoAYO1sQioqpqvAC0iMZgJkWy5BQbm1sMsmkpQA2gBdTq2eA9dgAVRowFoKS8LARtGCMJg-SOo0ukwe1TgTgASsTpsSpAIoABzNxiGjwApwPIJXCvQjvT7fOqKf76QHA8G4ODATg0CDwMx0YDUrR6cTMiBwMCyK4gMQfKBwJksvBQMSyQi0EQxOAg9kAFTiYgENBiSjgluttvtcE87qd8Rd4LBuE8QA)",,
1238672147,1144,Union form Enum values,,,
1237717215,1142,Circular dependency detected,"I have Circular dependency checking in my project and when I include this library, I get this error:

<img width=""869"" alt=""Screen Shot 2022-05-16 at 5 00 17 PM"" src=""https://user-images.githubusercontent.com/444206/168681885-329ebcc5-f39f-491f-858a-8761fde05922.png"">

This makes my builds fails.",,
1237506510,1140,Using z.instanceof in z.union swallows invalid_union error,"Given a schema like `z.union([z.string(), z.instanceof(Date)])`, you would expect `parse(null)` to return an `invalid_union` error. Instead of that, `custom` is returned from the `z.instanceof`. The following test case demonstrates:

```typescript
import { z } from ""zod"";

describe(""zod"", () => {
  it.each([
    z.union([z.string(), z.number()]),
    z.union([z.string(), z.instanceof(Date)]),
  ])(""%#"", (schema) => {
    const result = schema.safeParse(null);
    const error = (result as z.SafeParseError<any>).error;
    expect(error).toMatchObject({
      issues: [{ code: z.ZodIssueCode.invalid_union }],
    });
  });
});
```

The input can be any invalid value. The argument to `instanceof` can be any constructor. Using zod `3.16.0`.",,
1236757969,1139,zod types with circular references can't be merged into other zod objects.,"Thanks for this repository ~
But I get confused when trying to merge a type with circular reference into other objects.
- zod: 3.16.0
- typescript: 4.6.4

I defined two types that depend on each other by the instruction in zod document like this:
```TypeScript
import { z } from ""zod"";

export interface IObj {
  name: string;
  items: IItem[];
}

export interface IItem {
  name: string;
  obj: IObj;
}

export const obj: () => z.ZodSchema<IObj> = () =>
  z.object({
    name: z.string(),
    items: z.array(item),
  });

export const item: z.ZodType<IItem> = z.object({
  name: z.string(),
  obj: obj(),
});
```
but when I try to merge the type 'item' into other zod objects, it shows the error: Argument of type 'ZodType<IItem, ZodTypeDef, IItem>' is not assignable to parameter of type 'AnyZodObject'.
```TypeScript
export const extItem = z
  .object({
    ext: z.string(),
  })
  .merge(item); // error

export type IExtItem = z.infer<typeof extItem>;
```
<img width=""584"" alt=""image"" src=""https://user-images.githubusercontent.com/47050572/168543769-bd7cd276-7ac8-4da2-b450-c9529fa588ad.png"">
how can I merge the type with circular reference into other zod objects?",,
1236296087,1138,Union of z.literal() numbers,"How would you go about doing this? 

```
const union = z.union(
    [1, 2, 3, 4, 5].map((val) => z.literal(val)),
)
-----------------------------------------------------
const arr = [1, 2, 3, 4, 5] as const
const union = z.union(
    arr.map((val) => z.literal(val)),
)
```

Neither works with the type system. 

```
Argument of type 'ZodLiteral<number>[]' is not assignable to 
parameter of type 'readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
Source provides no match for required element at position 0 in target.
------------------------------------------------------------------------------------
Argument of type 'ZodLiteral<0.166667 | 0.2 | 0.25>[]' is not assignable to 
parameter of type 'readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
Source provides no match for required element at position 0 in target.
```

I've tried using refine which works but gives me inferred type 'number' instead of 1 | 2 | 3 | 4 | 5.",,
1236145837,1136,Relationship between schema object fields,"Hello there!
I was exploring Zod with the intent of migrating from Joi. This looks awesome and makes me feel the schemas are more solid. I think it might be an excellent ally for my open-source library!

I observed how Joi owns a way to specify a relationship between schema object fields through the properties `when` ([doc](https://joi.dev/api/?v=17.6.0#anywhencondition-options)) and `with` ([doc](https://joi.dev/api/?v=17.6.0#objectwithkey-peers-options)).

So, I could write:

```js
Joi.object().keys({
	 ...,        
	 value: Joi
		.alternatives(z.string().allow(""""), z.number(), z.date().iso())
		.required(),
	numberStyle: Joi
		.string()
		.regex(
			/(aaaaa|bbbbbb|ccccccc|ddddddd)/,
		)
		.when(""value"", {
			is: Joi.number(),
			otherwise: Joi.string().forbidden(),
		}),
});
```

Which tells Joi to forbid `numberStyle` if `value` is a not a `number`, or

```js
Joi.object().keys({ ... }).with(""webServiceURL"", ""authenticationToken"");
```

Which enforces that two properties must appear at the same time for the schema to be valid.

So, is there a way to define a relationship between keys, if necessary with a condition?
I guess something could be done with `z.never()` but I can't figure it out right now.

A solution that comes to my mind might be to create a discriminated union of objects based on `value` for what concerns `when`.

I would do something like this:

```typescript
z.object<Field>({
	/** The rest of props... */
}).merge(
	z.discriminatedUnion(""value"", [
		z.object<Field>({
			value: z.string().or(isoDateString),
			numberStyle: z.never(),
		}),
		z.object({
			value: z.literal(z.number()),
			numberStyle: z
				.string()
				.regex(
					/(aaaaa|bbbbbb|ccccccc|dddddddd)/,
				)
				.optional(),
		}),
	]),
);
```

But, it seems that value must be literal, but in my case, it is a generic string or a generic number. So how can I achieve this? Would union still be okay?

For what concerns `what`, instead, I don't yet know how to create the relationship.

I guess the big issue here is that I'm attempting to migrate my Joi schemas 1-to-1 to Zod, but it probably requires a whole mindset change. ðŸ˜„

Thank you very much!",,
1235963630,1135,Every schema can be associated with an error map - how?,"Here: https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md#schema-bound-error-map

> The `overrideErrorMap` message is then passed as `ctx.defaultError` into any schema-bound error maps. Every schema can be associated with an error map.

> ```ts
> z.string({ errorMap: myErrorMap });
> 
> // this creates an error map under the hood
> z.string({
>   invalid_type_error: ""Invalid name"",
>   required_error: ""Name is required"",
> });
> ```

I don't quite understand how can I do that with an array or an object?

Particularly `z.object()` takes its shape from the arg, doesn't it? So there is basically no place to pass the above mentioned error map:

```ts
const myObj = z.object({
  prop1: ...
  prop2: ...
  required_error: ""Prop is required"",   // Where should I place this?
}) 
```

For example, how to customize the _required_ error message for the `bar.foos` property?:

```ts
const foo = z.object({
  name: z.string()
})

const bar = z.object({
  foos: foo.array()
})
```

",,
1232340352,1128,.pick doesn't typecheck keys and throws `Cannot read property '_parse' of undefined`,"I've run into this issue when using `.pick` that the keys are not typechecked that they're actual keys on the source object.

Here's a small example to reproduce this using 3.15.1:

```typescript
import { z } from 'zod';

const schema = z.object({
  a: z.string(),
  b: z.number(),
});

const pickedSchema = schema.pick({
  a: true,
  doesntExist: true,
});

pickedSchema.parse({
  a: 'value',
});
```

Results in:

```
/node_modules/.pnpm/zod@3.15.1/node_modules/zod/lib/types.js:1060
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                                    ^
TypeError: Cannot read property '_parse' of undefined
    at ZodObject._parse (/node_modules/.pnpm/zod@3.15.1/node_modules/zod/lib/types.js:1060:37)
    at ZodObject._parseSync (/node_modules/.pnpm/zod@3.15.1/node_modules/zod/lib/types.js:109:29)
    at ZodObject.safeParse (/node_modules/.pnpm/zod@3.15.1/node_modules/zod/lib/types.js:139:29)
    at ZodObject.parse (/node_modules/.pnpm/zod@3.15.1/node_modules/zod/lib/types.js:120:29)
    at Object.<anonymous> (/zodTest.ts:13:14)
    at Module._compile (internal/modules/cjs/loader.js:1085:14)
    at Module.m._compile (/node_modules/.pnpm/ts-node@10.7.0_3yjwidxeabsavpmncg7zl6hyk4/node_modules/ts-node/src/index.ts:1455:23)
    at Module._extensions..js (internal/modules/cjs/loader.js:1114:10)
    at Object.require.extensions.<computed> [as .ts] (/node_modules/.pnpm/ts-node@10.7.0_3yjwidxeabsavpmncg7zl6hyk4/node_modules/ts-node/src/index.ts:1458:12)
    at Module.load (internal/modules/cjs/loader.js:950:32)
```",,
1230084650,1124,Add deepPassthrough method,"Currently if you have an object schema that is multiple layers deep, calling ""passthrough"" on the top level object will only allow additional keys on that level.  I don't think this is a bug, as I can understand why you wouldn't want to automatically apply it to the whole object.  But I think having that functionality as an option would be nice.

The reason I think this is a good idea, is that in a situation where you want to allow extra keys on a nested object in certain conditions, but not in others (on the same schema) there is no elegant way that I have seen to do that. 

Say we have:
```javascript
const fooSchema = z.object({ bar: z.string() });
const rootSchema = z.object({ foo: fooSchema });
```

If given `condition_1` we want to passthrough the extra keys when we parse, but in `condition_2` we don't for whatever reason, we have to duplicate the schema a little as:

```javascript
const fooSchema = z.object({ bar: z.string() });
const rootSchemaNoPass = z.object({ foo: fooSchema });
const rootSchemaWithPass = z.object({ foo: fooSchema.passthrough() });

if (condition_1) {
    return rootSchemaWithPass.parse(data);
}

if (condition_2) {
    return rootSchemaNoPass.parse(data);
}
```

Obviously with such small code/schemas that doesn't look too bad, but in larger projects with bigger data definitions it can get pretty ugly I think.  I think it would be better to just be able to do:

```javascript
const fooSchema = z.object({ bar: z.string() });
const rootSchema = z.object({ foo: fooSchema });

if (condition_1) {
    return rootSchema.deepPassthrough().parse(data);
}

if (condition_2) {
  return rootSchema.parse(data);
}
```

That way you don't have to store the ""passthrough"" on the schemas themselves and can just chose to allow extra keys at time of parsing",,
1228779363,1121,Zod resolved type change for Opaque type between v3.14.4 -> v3.15.1,"I have the following code:

```typescript
type Opaque<Type, Token = unknown> = Type & { tag: Token }; 

enum FACE {
    QUEEN = 'QUEEN',
    KING = 'KING'
}

enum SUIT {
    HEARTS = 'HEARTS',
    DIAMONDS = 'DIAMONDS'
}

type FaceCard<Face extends FACE> = Opaque<`${ Face }_${ SUIT }`, 'FaceCard'>;

type Hand = z.output<
    z.ZodObject<{
        card : z.ZodType<FaceCard<FACE.QUEEN>, z.ZodTypeDef, string>,
    }>
>;
```

In `zod@3.14.4`, `Hand` resolved to:

```typescript
type Hand = {
    card: FaceCard<FACE.QUEEN>;
}
```

But now in `zoid@3.15.1`, `Hand` is resolving to:

```typescript
type Hand = {
    card: (FaceCard<FACE.QUEEN> | undefined) & FaceCard<FACE.QUEEN>;
}
```

Why did the second type get more complex here, when the first one is correct?

(By the way -- **incredible** library. Thank you for making this, seriously.)",,
1228714211,1120,Deno missing z.infer ?,"As a deno user I can't find z.infer.
Idk if I'm doing something wrong but if there is no z.infer implementation I would strongly suggest to add a Note in the docs.",,
1228694178,1119,Property 'strict' does not exist on type ZodObject,Seems like the readme is outdated for zod v3 as `strict` is now default on objects and `nonstrict` is an available method instead of `strict`?,,
1227054851,1118,enum of numbers,"This code fails:

```ts
import { z } from ""zod"";

const Multipliers = [1, 2, 3, 4] as const;

const schema = z.enum(Multipliers);
```

With error

```
No overload matches this call.
  Overload 1 of 2, '(values: readonly [string, ...string[]]): ZodEnum<[string, ...string[]]>', gave the following error.
    Argument of type '[1, 2, 3, 4, 5, 6]' is not assignable to parameter of type 'readonly [string, ...string[]]'.
      Type at position 0 in source is not compatible with type at position 0 in target.
        Type 'number' is not assignable to type 'string'.
  Overload 2 of 2, '(values: [string, ...string[]]): ZodEnum<[string, ...string[]]>', gave the following error.
    Argument of type '[1, 2, 3, 4, 5, 6]' is not assignable to parameter of type '[string, ...string[]]'.
      Type at position 0 in source is not compatible with type at position 0 in target.
        Type 'number' is not assignable to type 'string'.ts(2769)
```

Is there any reason why `z.enum` only expects `string`s?

https://codesandbox.io/s/zod-number-union-4pqezv",,
1225193295,1115,"Support for Go To Definition, Rename Symbol and other IDE features","Thanks for your amazing work on this library! I'm a big fan of the approach you have taken with Zod of defining a type's schema only once rather than duplicatively for each type and its parser. 

The one major downside I have found with using Zod for declaring types is that Visual Studio Code (and I assume the TypeScript language server more generally) does not seem to be able to connect usages of object properties back to their declaration in `z.object`. 

For example, consider the following code:

```TypeScript
const Example = z.object({ property: z.string() });

type Example = z.infer<typeof Example>;

const instance: Example = { property: ""value"" };
```

Using any language server action like Go To Definition, Find Usages or Rename Symbol on `Example[""property""]` does not work. This is a particular pain point for Rename Symbol, which is incredibly useful when working on a large code base.

I assume this is a limitation of the Typescript language server given the specific type-level programming that Zod is using. However, these features do appear to work with [io-ts](https://github.com/gcanti/io-ts) (a library that takes a similar approach), which makes me think it may be possible to implement Zod's type mappings in a way that preserves these IDE features, at least for some scenarios.

Is this a valuable goal to pursue, or have I misunderstood how most people are using Zod? 

Digging a little deeper, TypeScript does not appear to be able to connect the properties in an object to those same properties in its associated mapped type if the keys are changed.  This appears to be what is causing the IDE features to not work. For example, consider a simplified version of the return type of `objectType` in Zod:

```TypeScript
type optionalKeys<T extends object> = {
    [k in keyof T]: k;
}[keyof T];

type requiredKeys<T extends object> = {
    [k in keyof T]: undefined extends T[k] ? never : k;
}[keyof T];

export type addQuestionMarks<T extends object> = {
    [k in optionalKeys<T>]?: T[k];
} & {
    [k in requiredKeys<T>]: T[k];
};

export type mergeIntersections<T extends object> = { [K in keyof T]: T[K] };

type Example2 = { property: string; optionalProperty: string | undefined };

const instance2: mergeIntersections<addQuestionMarks<Example2>> = { property: """" };

// type Instance2 = {
//    property: string;
//    optionalProperty?: string | undefined;
// }
type Instance2 = typeof instance2;
```

This code is responsible for making schemas marked with `.optional()` optional (rather than just `undefined`) in the final object type. The `addQuestionMarks` type is transforming the keys in `T` using `optionalKeys` and `requiredKeys`. Due to these transformations of the keys of `T`, TypeScript can no longer connect the original type's keys to the mapped type's keys. As a result, using Go To Definition on `property` on the line starting with `const instance2` does not work. 

However, I believe we can get the same outcome in a way that preserves the IDE features:

```TypeScript
export type addQuestionMarksPreserve<T extends object> = {
    [k in keyof T]?: T[k];
} & {
    [k in requiredKeys<T>]: T[k];
};

type Example3 = { property: string; optionalProperty: string | undefined };

const instance3: mergeIntersections<addQuestionMarksPreserve<Example3>> = { property: """" };

// type Instance3 = {
//    property: string;
//    optionalProperty?: string | undefined;
// }
type Instance3 = typeof instance3;
```

All I have done is changed `[k in optionalKeys<T>]?: T[k];` to `[k in keyof T]?: T[k];`. Using Go To Definition and Rename Symbol on `property` on the line starting with `const instance3` now works as you would expect.
I believe this works because `{ [k in keyof T]?: T[k]; }` directly passes on the keys of `T` without transforming them. This allows TypeScript to connect the original type with the mapped type. We then rely on the fact that `{ a?: A | undefined } & { a: A }` merges to `{ a: A }`, giving us the original type mapping behaviour. 

What do you think? Is it worth seeing whether these sorts of changes can improve the IDE experience when using Zod?",,
1224581813,1114,Lost values on JSON.stringified formatted errors if schema contains array of objects,"Title is quite a mouthful, so an example will probably be helpful. :)

Given
```javascript
const schema = z.array(
  z.object({
    name: z.string()
  })
);
const result = schema.safeParse([{name: ""name""}, {}]);
```

results in
```javascript
result.error.format()
// {
//   '1': [ _errors: [], name: { _errors: [ 'Required' ] } ],
//   _errors: []
// }
```

but once piped through JSON.parse + JSON.stringify (which should pretty likely if used in common web environments)
```javascript
JSON.parse(JSON.stringify(result.error.format()))
// { '1': [], _errors: [] }
```

Basically all nested errors are lost on serialization.

The culprit are these lines: https://github.com/colinhacks/zod/blob/7296aae7d5062f60ca73d39adf71a2e62cc3d1d2/src/ZodError.ts#L213...L219
Removing the seperate type handling and unconditionally use `curr[el] = curr[el] || { _errors: [] };` should/would potentially fix the problem but slightly change the output format.

```javascript
result.error.format()
// {
//   '1': { _errors: [], name: { _errors: [ 'Required' ] } },
//   _errors: []
// }

JSON.parse(JSON.stringify(result.error.format()))
// {
//   '1': { _errors: [], name: { _errors: [ 'Required' ] } },
//   _errors: []
// }
```

Is the current behaviour intended or a bug? If you want I could open a pull request with the change and some tests.",,
1221809151,1110,Provide a way to extract implementation from function schema,"Given a function schema with an implementation, it would be nice to have a way to extract the implementation out, so that it can be directly invoked when the overhead of validation is not desirable and 

```ts
const doSomething = z
    .function()
    .args(z.string())
    .returns(z.promise(Something))
    .implement((id) => {
        // ...
    })

const doSomethingUnsafe = doSomething.implementation; // Same signature as doSomething
```

I understand that I can separately define and expose the function I am passing to `.implement` but then I need to annotate the types explicitly rather than having them inferred for me as is the case above. This also results in more boilerplate when the args/returns take in complex types that are defined inline. 
",,
1221274076,1108,[Request] bigints for z.literal,"I'm trying to create an enum validator who's values are bigints, and to validate if the data provided is one of those bigints, I use zod.

The README said to create an issue for support for bigints in z.literal",,
1220297404,1106,Can't set invalid_type_error for nativeEnum,"This doesn't seem to work:

```js
const schema = z.nativeEnum(Options, {
  invalid_type_error: 'Invalid option',
});
```

The default error message is always displayed.",,
1219030598,1105,Support TS 4.7 instantiation expressions,"TS 4.7.0 (currently in beta) will bring in ""Instantiation Expressions"" (see https://github.com/microsoft/TypeScript/pull/47607).

Essentially this means that you can write things like:
```ts
function foo<T>(val: T) {}
type Foo<T> = typeof foo<T>
// type Foo<T> = (val: T) => void
```

The application for Zod schemas is as detailed here (https://github.com/microsoft/TypeScript/issues/40542), in particular that we can now write such things as:
```ts
// the dateSchema param could be a schema for an ISO 8601 string or a Date object, or even some custom date-like type
const fooSchema = <T>(dateSchema: z.ZodSchema<T>) => z.object({
  name: z.string(),
  date: dateSchema
})
type Foo<T> = z.infer<ReturnType<(typeof fooSchema)<T>>>
// expected result: type Foo<T> = { name: string, date: T }
```

Unfortunately this does not ""Just Work"" by upgrading to TS 4.7.0-beta:

```ts
import { z } from ""zod"";

function genericFooSchema<T>(inner: z.Schema<T>) {
  return z.object({
    type: z.literal(""foo""),
    inner,
  });
}

type Foo<T> = z.infer<ReturnType<typeof genericFooSchema<T>>>;

function useAFoo<T>(foo: Foo<T>): string {
  switch (foo.type) {
    // Hovering over foo.type gives:
    // ```
    // (property) type: z.objectUtil.addQuestionMarks<{
    //     type: ""foo"";
    //     inner: T;
    // }>[""type""]
    // ```

    case ""foo"":
      return ""TS should infer that this switch is exhaustive"";
  }
}
```",,
1217473052,1103,enum of integers,"Would it be feasible to create an enum of integers?

TypeScript seems to accept unions of integers, being able to have also a schema would be great.

Very nice and useful library.",,
1217009145,1102,z.infer does not return correct types with Typescript conditionals,"Hi team, thank you for the library. 

I'm new to zod and I was looking for ways I could create conditional schemas (something similar to generics in typescript), but couldn't find anything out of the box, so I opted to create multiple objects that could be called conditionally. However, after creating a generic function that conditionally returns `z.infer<typeof DogSchema>`, I do not get the raw typed object.

```
const DogSchema = z.object({
  sound: z.string(),
});

```
`type DogSchemaTypes<T> = T extends AnimalEnum ? z.infer<typeof DogSchema> : string;`

```
const getAnimal = <T>(data: any): DogSchemaTypes<T> => {
    const parsedData = DogSchema.parse(data)
    return  parsedData
}

```
The implementation above throws the error on `parsedData`: 

`Type '{ sound: string; }' is not assignable to type 'DogSchemaTypes<T>'`

and if you inspect the return type of `parsedData`, I get this:

```
z.ZodObject<{
    sound: z.ZodString;
}, ""strip"", z.ZodTypeAny, {
    sound: z.ZodString;
}, {
    sound: z.ZodString;
}>
```

However, if: `type DogSchemaTypes<T> = z.infer<typeof DogSchema>`, It returns the proper object type. Is there a way to return the right type using typescript conditionals?

I have `""zod"": ""^3.14.4""`",,
1215087844,1101,Stricter types,"Hi! Thanks for the library.

I'd like to request a feature because currently it is missing so much.

The errors are barely typed, so for example when I return a custom error with a `path` that has absolutely no connection with the schema, ts does warn me.
```ts
const schema = z.object({
    smscode: z.string()
});

// after schema validation passes: 
const customValidationIssue = {
    code: ""custom"",
    path: [""password""], // this should be smscode, but TS accepts password currently.
    message: ""Wrong password"",
} as z.ZodIssue;
```

Because the `smscode` is z.string() only, I think it will not throw for example ZodTooBigIssue. But ZodTooBigIssue and other unreachable errors are parts of the ZodIssue type so it is misleading. 

I would like to see more generic types.


 ",,
1215066538,1100,Use of `RawCreateParams` for `preprocess` context,"Hey there ðŸ‘‹ðŸ» I'm coming in from `io-ts` and very happy to have found this project.

**TL;DR:** assuming I've set up some of my own-built schemas correctly, I can't seem to get custom errors out of a `preprocess`-based schema.

---

What I have is an own-rolled schema like the following, based on the `Dates` example from your docs:
```ts
export const dateString = (
  params?: RawCreateParams // <-- added params
) =>
  z.preprocess(
    (input: unknown) => {
      if (!(typeof input == 'string')) {
        return;
      }

      const date = new Date(input);

      if (isNaN(date.getTime())) {
        return;
      }
      return date;
    },
    z.date(),
    params
  );
```

Pretty basic stuff. The idea is to use it like so:

```ts
const someSchema = z.object({
  updated_at: dateString({
    invalid_type_error: ""Field `updated_at` had wrong type""
  })
})
```

Problem is whenever I do this, the custom error message doesn't seem to survive. I've tried all the fields under `RawCreateParams`, but still just get the default error object when parsing fails.

By contrast, doing this with a built-in schema works just fine:

```ts
const someSchema = z.object({
  someString: z.string({
    invalid_type_error: 'Custom error message here!',
  }),
});
```

So, what am I doing wrong? Or is this a bug with `preprocess`?",,
1211391872,1095,Any way to refine error messages when dealing with discriminated unions?,"Currently, a failed parse of a complex data structure with lots of unions basically ends up printing all the unions that failed to match. Typically we use discriminated unions like:
```
z.object({
  version: 1,
  payload: z.object({
    method: z.literal(""get""),
    someField: z.number(),
  }).or({
    method: z.literal(""put""),
    someOtherField: z.number(),
  })
}).or(z.intersection(z.object({
  version: 2
}, z.object({
  method: z.literal(""get""),
  field: z.string(),
}).or(z.object({
  method: z.literal(""put""),
  value: z.string(),
}))))
```
If this fails to parse, the parse error is basically every single union (& we have a lot) because as far as zod knows, it's just appending every union parse failure. Is there any way to mark certain fields as discriminants? e.g. If I try to parse `{ version: 3 }` it would just say something like `invalid value ""3"" for version`. If I try to parse `{ version: 2, method: ""abc"" }` it would say something like `invalid value ""abc"" for version=1.method` or something like that.

In our exact case, I'm getting about ~3kb of error messages and it's hard to find what actually is the problem.
",,
1211280339,1094,Add Custom Message To Enum,"First off, love this library seems to solve all my teams pain points! The one thing we can't figure out is adding a custom message to an enum type, something like the following:

```
z.enum(['apple', 'orange', 'banana'], {
  message: 'You must select an acceptable fruit',
});
```",,
1209993784,1092,Suggested feature: z.enumMap() ,"Given the updated change in 3.13.3, (#992), where the z.record function now correctly types as a `Partial<Record>` I wonder if it's possible to introduce some validation for exhaustively checking object keys against an enum (or even a union but haven't gone in depth there).

I have created a helper function to create such a schema but I feel it might be something to consider for the core library with a correct type?

The code:

```typescript
export const enumMap = <
  T extends [string, ...string[]],
  U extends z.ZodTypeAny,
>(
  enumeration: z.ZodEnum<T>,
  obj: U,
) => {
  const validateKeysInEnum = <I extends any>(
    record: Record<string, I>,
  ): record is Record<
    typeof enumeration.enum[keyof typeof enumeration.enum], // Yes this is ugly
    I
  > => Object.keys(record).every((key) => enumeration.safeParse(key).success)
  return z.record(obj).refine(validateKeysInEnum)
}

// produces a gnarly z.ZodEffects<> due to refinement?
const myEnumMap = enumMap(
  z.enum(['aaa', 'bbb', 'ccc', 'dddd']),
  z.object({ hhh: z.literal('a') }),
) 

// Zod does infer the type correctly:
// {
//   aaa: {
//     hhh: 'a'
//   }
//   bbb: {
//     hhh: 'a'
//   }
//   ccc: {
//     hhh: 'a'
//   }
//   ddd: {
//     hhh: 'a'
//   }
// }
export type MyEnumMap = z.infer<typeof x>
```

I am fairly new to using Zod and so there may be several reasons not to do this and I may be passing by good reasons to do this but I thought I should share. I don't believe the refinement will lead to easier composition with other schemas. Ideally I would be looking for a solution that can reconcile the current `z.record` behaviour which removes the `Partial` aspect ",,
1209703118,1091,"z.object() with validation: min, max and length","This feature would can be like joi has it:
 - min: https://joi.dev/api/?v=17.6.0#objectminlimit
 - max: https://joi.dev/api/?v=17.6.0#objectmaxlimit
 - length: https://joi.dev/api/?v=17.6.0#objectlengthlimit

If you give me green light then i would can do you a PR with this features.",,
1209638621,1090,Strip object values that fail member validation,"The [strip](https://github.com/colinhacks/zod#strip) method allows for invalid keys to get stripped, but would love an equivalent for invalid values to help make our site more robust.

I see the suggestions in [this similar issue](https://github.com/colinhacks/zod/issues/627), but the painful part with those is that every key that can possibly be invalid would need to have the transform applied; in a large schema with like 40 members, that's fairly annoying.

I guess one idea is that I can do something like (with a `mapValues()` helper we have):

```ts
const stripBadValuesSchema = z.object(mapValues({
  foo: z.string(),
  bar: z.number()
}, schema => schema.or(z.unknown().transform(() => undefined)));
```

but wondering if there's a more idiomatic way to do this. Thanks!",,
1208845987,1089,Request: ZodDate min and max,"I'm happy to give this a shot myself if you think it's worthwhile to add!

I get that this can currently be achieved with a refinement:

```js
z.date().refine((d) => d >= new Date(""2020-01-01"") && d <= new Date(""2030-01-01""))
```

... but it seems like a reasonable top-level concept to me:

```js
z.date().min(new Date(""2020-01-01"")).max(new Date(""2030-01-01""))
```",,
1205258216,1086,Generating on-the-fly zod validation objects for 3rd party libs,"I used yup for years in a totally half-assed way because it didn't have typescript support. I have since fallen absolutely in love with zod and I'm now validating nearly everything. And most of my type definitions are coming from `z.infer<typeof MyZodSchema>`.

However the only deficiency I have found is the ability to support validation for 3rd party types.

My best example of this is the Stripe library. Nowadays, Stripe actually provides a very robust set of types for their very many entities (customers, subscriptions, charges, payment methods, etc, it goes on and on).

You can use these types easily like this:
```
import {Stripe} from 'stripe';
const customer: Stripe.Customer = {
  // ... a bunch of properties here ...
};
```

But I would like to be able to validate these types as well. This is particularly useful when I have cached stripe objects in browser storage (or async storage for mobile) and I need to validate that they are not corrupted before consuming them.

I have seen some people create some codegen tools to go from typescript interface -> zod schema, but is there any way to do this in code on the fly? I'm working on stripe lib right now, but I can imagine doing this for many other libraries as well.

Thanks again for the great lib!!",,
1205226492,1085,Support for schemas that is an enum of the keys of an object?,"Essentially what I'm looking for would be something akin to this:

```typescript
const Inputs = Z.object({
  email: Z.string().email(),
  password: Z.string().min(8),
  username: Z.string().min(3),
  id: Z.string().uuid(),
  base: Z.unknown().optional(),
})
const InputFields: Z.ZodEnum<['email', 'password', 'username', 'id', 'base']> = Z.keyof(Inputs)
```

Is any form of the above currently possible, and if not, would anything bar its creation?",,
1202127283,1082,The inferred type of '...' cannot be named without a reference to '..node_modules/zod/lib'. This is likely not portable. A type annotation is necessary.,"I realize that this is most likely not a bug at zod but maybe it is!?

I have a package that exposes an API to firestore with zod validation. I'm using generics to determine the type of data returned based on the validation schema given.

But when I install the package and create my client I get a lot of errors like this

```
The inferred type of 'databaseClient' cannot be named without a reference to '../../firestore-zod/node_modules/zod/lib'. This is likely not portable. A type annotation is necessary.ts(2742)
```

I don't really understand the issue but I'm guessing it's related to using `z.infer<typeof validationSchema>`? Anyone able to help to get around it?",,
1198435893,1078,"When defining a function with a return type of `z.void()`, is it necessary to verify the return type of the function?","Please consider following example:

https://stackblitz.com/edit/typescript-m6zgjb

```ts
import * as z from 'zod';
import { expectType, TypeEqual } from 'ts-expect';
import { expect } from 'chai';

const src = [1, 2, 3];
const dst = [0];

const push = dst.push.bind(dst) as typeof dst.push;

const pushWithoutReturnValue = z
  .function(
    z.tuple([]).rest(z.number()),
    z.void() // should not throw Error
  )
  .implement(push);

// should be true
expectType<TypeEqual<typeof pushWithoutReturnValue, (...items: number[]) => void>>(true);
// @ts-expect-error: should not use the return value
const _: number = pushWithoutReturnValue(...src);
expect(dst).deep.eq([0, 1, 2, 3]);
```

1. When defining a function with a return type of `z.void()`, is it necessary to verify the return type of the function?
2. It seems that `pushWithValidation` will be inferred to `typeof push` instead of the type defined in `z.function`.

Are there any considerations about this?

Thanks.

---

References:
> ... Another way to say this is a contextual function type with a void return type (type vf = () => void), when implemented, can return _any other_ value, but it will be ignored. - https://www.typescriptlang.org/docs/handbook/2/functions.html#return-type-void
",,
1198098653,1077,Only validate if input is checked,"I have the following schema:
```
const schema = z.object({
    checks: z.object({
        enable: z.boolean(),
        max: z.number().min(1),
        every: z.number(),
    }),
});
```
If `enable` is true, then `max` and `every` should be validated, otherwise they should be omitted. Is this possible with Zod ? I tried tinkering with `refine()` but I could not get it to work.",,
1196478045,1075,Allow more types in discriminated unions,"It seems like `z.discriminatedUnion` currently has quite narrow requirements for what you can use it with. Here are some example use cases that seem sound to me (in the sense that the discriminator should still be able to uniquely determine the union member) but currently aren't allowed:

```typescript
const A = z.object({ type: z.literal('a') });
const B = z.object({ type: z.literal('b') });
const C = z.object({ type: z.literal('c') });
const D = z.object({ type: z.literal('d').optional() });
const E = z.object({ type: z.enum(['e', 'ee', 'eee']) });

const AorB = z.discriminatedUnion('type', [A, B]);

// using another discriminated union with the same discriminator as a union member
const AorBorC = z.discriminatedUnion('type', [AorB, C]);

// the discriminator is optional in one union member
const CorD = z.discriminatedUnion('type', [C, D]);

// the discriminator is an enum
const CorE = z.discriminatedUnion('type', [C, E]);
```

Any chance these cases can be supported? It would great if the requirement for discriminated union members could be widened to something like ""any type that has the discriminator as a field and the type of the discriminator is a subtype of `string | null | undefined` and is mutually exclusive between the discriminated union members"", but supporting at least the cases I mentioned above would still be much appreciated.",,
1195086636,1072,Feature request: set discriminator field,"I have two schemas that doesn't have common property (discriminator).
I have no chance to change input data, this is external data.

I know that I can handle it this way:

```ts
const swapInfoSchema = z.union([
  z.preprocess((content) => ({ ... content, type: 'byAmountIn'}), swapInfoByAmountIn)
  z.preprocess((content) => ({ ... content, type: 'byAmountOut'}), swapInfoByAmountOut)
]);
```

But `content` is unknown and a don't want set `any` type here.

Also I thought that I can do:

```ts
const swapInfoByAmountOut = swapInfoBase.extend({
  availableAmountOut: z.number(),
  availableAmountIn: z.null(),
  marketAmountOut: z.null(),
  marketAmountIn: z.number().nullable(),
}).transform((val) => ({
  ...val,
  type: 'byAmountOut' as const,
}));
```

But inferred type doesn't contain my ""type"" field. Any suggestions?",,
1194816566,1071,"Feature request: `z.string()` vs `z.string`, bracketless way of expressing validation","I wish zod was as simple as:
 
```
z.object({
  username: z.string,
  age: z.number,
})
```

[runtypes](https://github.com/pelotom/runtypes) and some other libs proved that brackets are not needed in declarations like that.
Honestly the need to add useless `()` in `z.string()` is what blocking me from starting using zod.

Any hope to fix that? Thanks!",,
1194478371,1069,Type inference on schema with passthrough(),"Hi,
Vscode infers this code:
```
const test=z.object({id:z.string()}).passthrough()
type Typetest=z.infer<typeof test>
```
to be
```
type Typetest ={
id:string
}
```
Is this correct? I was thinking about using this pattern to have a converter for ""id"", so I can transform the id objects before I ship my data (which is a document including id) off to the db driver. I was thinking that Typetest should display ""id"" and then some..
",,
1193525473,1068,`schema.safeParse(...).error.flatten()` return type and `z.inferFlattenedErrors<...>` don't match,"I'm trying to create a function that takes an object and a generic ZodObject schema and validates the object against the schema. But TypeScript complains that the error object from `schema.safeParse(...).error.flatten()` has a different type than `z.inferFlattenedErrors<...>`.

I've reduced my code to where the error is below:

```ts
import { z } from ""zod"";

type BaseSchema = z.ZodObject<Record<string, z.ZodTypeAny>>;

type Arg<Schema extends BaseSchema> = {
  fields: Record<string, string | null>;
  schema: Schema;
  onSuccess: (data: z.infer<Schema>) => Promise<Response>;
  onFailure: (data: z.inferFlattenedErrors<Schema>) => Promise<Response>;
};

export async function v<Schema extends BaseSchema>({
  fields,
  schema,
  onSuccess,
  onFailure
}: Arg<Schema>): Promise<Response> {
  const validation = schema.safeParse(fields);

  if (validation.success) {
    return await onSuccess(validation.data);
  } else {
    const error = validation.error.flatten();

    // This fails
    const response = await onFailure(error);

    // So I have to do this instead
    // const response = await onFailure(error as z.inferFlattenedErrors<Schema>);

    return response;
  }
}
```

[Demo](https://codesandbox.io/s/relaxed-turing-x55ycj?file=/src/index.ts).

The complaint is that the `.flatten()` error has this shape:

```
{
  formErrors: string[];
  fieldErrors: {
      [k: string]: string[];  // issue here
  };
}
```

while the `z.inferFlattenedErrors<...>` has this shape:

```
{
  formErrors: string[];
  fieldErrors: {
    [P in allKeys<TypeOf<Schema>>]?: string[] | undefined;  // issue here
  };
}
```

I found this in zod's source that looks related to my problem: the `fieldErrors` keys from the `.flatten()` error are typed as strings.

https://github.com/colinhacks/zod/blob/753f627504a6801d3637a33efab6ad87b216d4a6/src/ZodError.ts#L234-L247

Is this intentional or am I doing something wrong please? Thank you.",,
1192215328,1066,enum type inference loses refinement,"Using a zod enum in an object degenerates to generic string.
```ts
const MyEnumType = z.enum(['a', 'b']);
type MyEnum = z.infer<typeof MyEnumType>;
type MyObject = {foo: MyEnum};

function testFunc() {
  let x: MyObject = {foo: 'a'};
  const parsed = MyEnumType.safeParse('a');
  if (parsed.success) {
    let y = {foo: parsed.data};
    x = y; // Type '{ foo: string; }' is not assignable to type 'MyObject'.
  }
}
```

As a workaround, I can use `z.union([z.literal('a'), z.literal('b')])`, but the verbosity is inconvenient.",,
1190471548,1065,Cannot assign a 'private' constructor type to a 'public' constructor type,"I'd like to ensure that the `to` and `from` property are of the TransactionAmount class. The TransactionAmount class has it's own validation and I figure it can do the validation and creation before being passed in as props here. Is this the right way to do that?

```
export const transactionProps = z.object({
  id: z.string(),
  to: z.instanceof(TransactionAmount), // Argument of type 'typeof TransactionAmount' is not assignable to parameter of type 'new (...args: any[]) => any'. Cannot assign a 'private' constructor type to a 'public' constructor type.
  from: z.instanceof(TransactionAmount), // same.
});
```

```
export const transactionAmountProps = z.object({
  amount: z.string(),
  currency: z.string(),
});

export type TransactionAmountProps = z.infer<typeof transactionAmountProps>;

export class TransactionAmount {
  private constructor(private readonly props: TransactionAmountProps) {}

  get amount(): string {
    return this.props.amount;
  }

  get currency(): string {
    return this.props.currency;
  }

  public static create(props: TransactionAmountProps): Result<TransactionAmount, TransactionValidationError> {
    const validation = transactionAmountProps.safeParse(props);

    if (!validation.success) {
      return Err(new TransactionValidationError(JSON.stringify(validation.error.format())));
    }

    return Ok(new TransactionAmount(validation.data));
  }
}
```",,
1188456832,1064,"z.shape, infer and TypeScript","I have the following function, which generically validates a value of a poperty on an object, with zod:
```ts
import type { z } from 'zod';

const validateValue = <M extends z.ZodObject<z.ZodRawShape>, T extends keyof M[""shape""]>(
    model: M,
	field: T,
	value: z.infer<M[""shape""][T]>,
): z.infer<M[""shape""][T]> => model.shape[field].parse(value) as z.infer<M[""shape""][T]>;
```

This leads to multiple problems:

- TypeScript claims that the `model.shape[field]` object could possibly be undefined (I have all strict flags on), but this can't be true because the type of `field` is a generic key of `model[""shape""]`
- My ESLint configuration (`@typescript-eslint/no-unsafe-return`) complains that the return type of `.parse(value)` is `any`, but since it is explicitly assessed to be `z.infer<M[""shape""][T]>`, this must mean said type is `any`, which makes the function unusable for type safety.

Does anyone know what I can do to make this work fully type-safe, i.e. preventing calls with bad field/value parameters?",,
1187424744,1062,"Derivative schema usage, undocumented methods, and generic functions","Hey! in the last few days I became obsessed with zod after years of being driven crazy with working with ""soft"" interfaces from trash api. nevermind that, I have a proposal(?) and a question.

There are a few situations that I encountered with zod which I hit a dead end. 
The first is a generic wrapper. Lets say the data I'm working on has this repeated pattern:
```json
{
  ""data"": {
    ""id"":  ""1"",
    ""attributes"": {
      ""name"": ""zod"",
      ""author"": {
        ""id"": ""2"",
        ""attributes"" : {
          ""name"": ""colinhacks""
        }
      }
    }
  }
}
```
or, in other words
```ts
interface Payload<T> {
  data: {
    id: string
    attributes: T
  }
}
```
I'd wish to make generic helper or generic schema for these situation. With an important distinction. **I want the schema to transform (read strip) these boilerplate fields**. But TS breaks and won't let me ðŸ¤·ðŸ»â€â™‚ï¸ 
```ts
// this doesn't work
export const gqlPayload = <T extends object>(shape: T) =>
  z.object({
    data: z.object({
      id: z.string(),
      attributes: z.object(shape),
    }),
  }).transform(({data}) => ({id: data.id, ...data.attributes}))

// nor does this
export const gqlPayload = <T extends z.ZodTypeAny>(schema: T) =>
  z.object({
    data: z.object({
      id: z.string(),
      attributes: schema,
    }),
  }).transform(({data}) => ({id: data.id, ...data.attributes}))
```
very sad, next issue

---------------------

I also hit a wall when I wanted to continue working from an already-parsed object.
for example lets say I have a `Dragon` schema, and the schema makes a few transformations, and now I have a `startQuery` function, that should recieve that transformed `Dragon`, and extend/transform it again. but I could only set the input as the _untransformed_ `Dragon`. Which sucks eggs.

example:
```ts
const Wings = z.object({
  leftHp: z.number(),
  rightHp: z.number()
}).transform(({leftHp, rightHp}) => [leftHp, rightHp])

const Dragon = z.object({
  wings: Wings,
  legs: z.number(),
  eyes: z.enum(['red', 'blue'])
})


// requires a Dragon with array wings instead of object wings
const SlainDragon = Dragon.outputSchema.refine(/** check for less than 5 legs or something */).transform(value => ({...value, wings: [0,0]}))
type DragonToSlay = z.input<typeof SlainDragon>
// {
//   wings: [number, number];
//   legs: number;
//   eyes: ""red"" | ""blue"";
// }

function slayDragon(dragon:  Dragon) {
  try {
    const slainDragon = SlainDragon.parse(dragon)
    return slainDragon
  } catch (e) {
    throw new Error('you cannot hope to slay a beast with that many legs!')
  }
}
```
I know the example is a bit out there. The real-world example is just a bit more complicated. But basically it's getting an `Item` from somewhere, transforming it to be usable in my app, and in some other interaction take that transformed item and transform it more before sending it back. I could use 2 schemas, but then I'll have to make sure they are synced all the time. I just want the output of one schema to be the input of a different schema.. ðŸ˜¢ 

-----------------------

last but not least, whats up with all the undocumented stuff? `shape`, `innerShape()`, `describe`, tell me what they doooooooo why do I have to figure it out myselfffffff (no need for all the `_` prefixed ones, you can have your secrets ðŸ˜‰ )

I love zod, and sorry for the long issue. I'd open a PR instead, but I know nothing about the inner workings of zod, so I thought it'd approach you first",,
1186951698,1061,z.record returns partial type when using enum with a 2nd schema,"Love this library, and while I was updating a site to the latest version, I realized something had changed on `z.record`. I had been using `record`  with two schemas as described in the changelog, since I realized it was allowed and the readme documentation seemed behind on fancy functionality:

```
const schema = z.record(z.enum([""Tuna"", ""Trout""]), z.boolean());
type schema = z.infer<typeof schema>; // Record<""Tuna"" | ""Trout"", boolean>
```

This was working fine until around v3.13.2. Now the result seems to be `Partial<Record<""Tuna"" | ""Trout"", boolean>>` ",,
1186890345,1060,Type error in monorepo with different Zod versions across packages,"TypeScript fails to resolve the correct types in a monorepo if different Zod versions are installed.

I created a minimum reproducible repo with our setup with Zod, React Hook Form, and its resolver; see https://github.com/bkiac/typescript-error-with-monorepo-zod-react-hook-form.

Upgrading all packages to the same `zod` version resolves the issue.",,
1186582531,1059,Remove husky git add deno from commit hooks?,"This is more of a contributor-QoL issue, but the auto-adding of anything in the `deno` directory is unfortunately quite a bit of an annoyance. For example, I'll have an additional tweaked benchmark to test out a PR, and I'll make sure not to include it in the commit. But then when I run git commit, `build:deno` gets run automatically and `deno` gets added to the commit.

Basically the system makes it quite difficult to work with any kinds of uncommitted files because all files get compiled to deno and auto-committed, and it's surprising because there's no explicit `git add` that adds files to `deno`. So, in many cases I end up discovering later on that a file snuck in by this method and having to force push and remove it from that commit.

I'm not sure the state of deno currently, whether it pulls directly from GitHub or not. Maybe there's either an option where it's recommended that people push deno updates, or maybe that happens on release, or something like that.",,
1184825272,1055,"Shorter way to validate boolean from string ""true"" / ""false"" / overwrite a schema","e.g. you call a rest-api endpoint with `//some/endpoint?isVisible=true`
The server receives a string `isVisible = 'true'`

How you validate it in a shorter way?

```
const isVisibleSchema = z.union([ z.literal('true'), z.literal('false') ]).optional().transform( (val) => val === 'true') // overkill

const humanReadableWouldBe = z.boolean().optional() // not work, cause it is a string
```

Is there a way to extend / overwrite z.boolean?",,
1182573315,1053,Configurable default settings,It would be nice to enforce a certain coding style with zod such as using `.strict()` by default for all objects or forcing the user to set `.min()` and `.max()` for all Numbers and Strings. Maybe introducing a config file could allow the user to tune those default settings.,,
1181304034,1049,ZodType<Output> does not get the correct output of a union with transformations.,"Given this code

```typescript
import { z } from 'zod';

const stringToNumber = z.string().transform((val) => val.length);

const Data = z.object({
  prop: z.union([z.number(), stringToNumber])
});

function Parse<Output>(type: z.ZodType<Output>, data: unknown): Output {
  return type.parse(data);
}

const directlyParsed = Data.parse({}); // { prop: number; }
const indirectlyParsed = Parse(Data, {}); // { prop: string | number; }
```

Extracting the output on `indirectlyParsed` returns `string | number` instead of the correct one which should be just `number`. Am I doing something wrong or is there a problem with ZodType here?",,
1179777907,1046,`.required()` doesn't remove optional flag from the result of `.nullish()`,"The (undocumented) function `.required` is not working properly for properties defined with `.nullish()`:

```js
const base = z.object({
  required: z.string(),
  nullable: z.string().nullable(),
  optional: z.string().optional(),
  nullableOptional: z.string().nullable().optional(),
  nullish: z.string().nullish(),
})

const req = base.required()
```

The resulting inferred type of `req` is:
```ts
{
    required: string;
    nullable: string | null;
    optional: string;
    nullableOptional: string | null;
    nullish?: string | null | undefined;
}
```

As you can see, all fields that were defined as `.optional()` have properly been made non-optional except for the one created using `.nullish()`

This seems to arise from the fact that `.nullish()` is defined to return a `ZodNullable<ZodOptional<T>>` and `.required` simply returns the outermost `ZodOptional` without doing any type recursion, and as such it cannot see the optional in that type.",,
1179612875,1045,"More expressive error messsage possible for ""Expected string, received string""","Thanks for zod, I love it!

[Example:](https://runkit.com/gregoor/zod-string-literal-error)
```js
const { z } = require(""zod"");
const Special = z.literal(""wat"");
console.log(Special.safeParse(""nah"").error.issues[0].message);
```
which outputs `Expected string, received string`

Wouldn't `Expected ""wat"", received ""nah""` be more preferable? I suppose there is some nuance and edge cases where this isn't feasible?

",,
1179460222,1044,Callback on function arguments throws error,"I've started using this package to automatically infer types for Typescript declarations and to ensure object schemas, however I've came across some issues when it comes to having callbacks on functions.

When declarating a function like this:
```js
function processAndCallback(num, string, callback) {
    // Process data...
    callback(err, ""some string"", 0)
}
```
And using a Zod Schema like:
```js
const schema = z.function()
  .args(
    z.number(),
    z.string(),	
    z.function()
        .args(
            z.instanceof(Error),
            z.string({
                invalid_type_error: ""Paramether must be a string value"",
            }),
            z.number({
                invalid_type_error: ""Paramether must be a numeric value"",
            })
        )
        .returns(z.void())
        .implement((err: Error, address: string, family: number) => {
            err;
            address;
            family;

            return;
        })
    )
    .returns(z.void())
    .implement((err, options, callback) => {
        err;
        options;
        callback;

        return;
    })
```

The following error is thrown:
```
Argument of type '[ZodNumber, ZodString, (err: Error, address: string, family: number) => void]' is not assignable to parameter of type '[] | [ZodTypeAny, ...ZodTypeAny[]]'.
  Type '[ZodNumber, ZodString, (err: Error, address: string, family: number) => void]' is not assignable to type '[ZodTypeAny, ...ZodTypeAny[]]'.
    Type at positions 1 through 2 in source is not compatible with type at position 1 in target.
      Type 'ZodString | ((err: Error, address: string, family: number) => void)' is not assignable to type 'ZodTypeAny'.
        Type '(err: Error, address: string, family: number) => void' is missing the following properties from type 'ZodType<any, any, any>': _type, _output, _input, _def, and 30 more.
```

What I pretend is generating names for the arguments of the callback on the callback function for Typescript Declarations.
The only way I found that could do it was using `z.function().implement()`. Is there another way?",,
1179359504,1043,"""errorMap"" are not working for me, ""defaultErrorMap"" takes precedence","## What?

Hi I'm trying to override [errorMap order as explained in ERROR_HANDLING.md](https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md#customizing-errors-with-zoderrormap)

I'm trying this:

``` javascript
import { customErrorMap } from ""./customError"";

  z.setErrorMap(customErrorMap);
async function parse () {
  const result = await schema.safeParseAsync(
    {
      field_one: ""Hello there"",
      field_two: file
    },
    { errorMap: customErrorMap }
  );
}

parse()
```

But I see this error which is [hitting here](https://github.com/colinhacks/zod/blob/master/deno/lib/ZodError.ts#L361)

## DEMO
I made a [CODESANBOX CODE](https://codesandbox.io/s/pensive-frost-txd20s?file=/src/index.ts:21-85) with reproducing the error and using `zod@3.14.2` (Latest version at March 24th)

I see you have [errors in place](https://github.com/colinhacks/zod/blob/master/src/__tests__/error.test.ts#L318-L350) and if you check my code sandbox I think I'm doing the same.

Any ideas of what could be happening?",,
1179006074,1042,Read received value in invalid_enum_value issue ,"In `issue.code === 'invalid_type'` I can access `issue.received`. 
In `issue.code === 'invalid_enum_value'` this property does not exist. 

Is there any way to understand what was received and why the validation failed?",,
1178131339,1041,Validation errors not cleared from fields after passing checks,"`zod 3.14.2`

When using `refine()` to, for example` compare passwords:
```js
const register_schema = z
  .object({
    email: z.string().min(3).email(),
    password: z.string().min(6).max(64),
    password_confirm: z.string(),
  })
  .refine((data) => data.password === data.password_confirm, {
    message: ""Passwords don't match"",
    path: ['password_confirm'],
  })
```
Errors from the associated field - `password` in this case - are not being cleared even if said field passes it's validation. Here's a simple validation function
```js
export const createValidator = () => {
  let errors = {}

  const validate = async <T>(values: FormInitialValues<T>) => {
    try {
      await register_schema.parseAsync(values)
      errors = {}
    } catch (err) {
      if (err instanceof ZodError) {
        const err_array = err.flatten().fieldErrors
        errors = { ...errors, ...err_array }
      }
    }
    return errors
  }

  return validate
}
```
It records validation results in the `errors` object. Elsewhere, I'm using the returned `errors` object to enable / disable submit button or display the error messages to to user.

This doesn't work as expected as errors from the `password` field (`min()`, for example) won't be removed from from the `errors` object until the `refine()` checks pass. Nor will errors from the `email` field until all validation check pass.

[Here's a working example on Codesandbox](https://codesandbox.io/s/flamboyant-ellis-227d69?file=/createForm.js) .",,
1177592571,1040,Any better workarounds for TS7056?,"I'm responsible for a project with pretty complex schemas. We're running into a lot of TS compile errors like this:

> error TS7056: The inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed.

The best workaround I've found is to annotate schema declarations with zod types ahead of time (rather than using `z.infer`):

```ts
export type ZBlockEntity = z.ZodUnion<
  [
    typeof paragraphPropsOrElement,
    typeof layoutPropsOrElement,
    ...
    typeof escapeElement
  ]
>
export const blockEntity: ZBlockEntity = z.union([
  paragraphPropsOrElement,
  layoutPropsOrElement,
  ...
  escapeElement,
])
```

TypeScript will declare the array of `typeof name` referentially with this explicit annotation, otherwise it repeats a literal of each schema in the union.

The example I gave was simple, but some schemas that are hitting TS7056 are very tricky to mint and maintain explicit type annotations for, and even if it's achievable it will greatly increase technical inertia for the features that hit that wall.

I'd like to find a way to compile schemas in a way that TypeScript can declare and reuse named types instead of it repeating the same literals so many times it breaks.

Is there a workable solution here, or have we hit a wall?",,
1177278566,1039,`.asJsonSchema` method,"Some places require to describe input and output as a JSON schema.

Would a feature that exports as JSON schema be welcome? 

```ts
z.object({
  a: z.string().optional(),
}).asJsonSchema();
```
would give
```js
{
  type: ""object"",
  properties: {
    a: { type: ""string"" },
  },
}
```",,
1175808890,1037,Getting Zod to Accept Undefined as a value,"Hi, Im working on a pretty Dynamic form with a few conditional statements. However, when I submit the form, I have all the unused variables as undefined (because they are not defined in the form since they were not used) I keep getting the following error: 
""unionErrors"": [
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""all"",
            ""path"": [
              ""recipientType""
            ],
            ""message"": ""Expected all, received undefined""
          }
        ],
        ""name"": ""ZodError""
      },
      
 It should be receiving undefined in this case because I did not click the All Value in my form. I was wondering if there was a way to either ignore the ZodError, or allow it to be undefined.",,
1174096039,1032,Allow configurable access to unknown keys and their values within `refine` and `superRefine`,"As outlined in https://github.com/colinhacks/zod/discussions/1029, I have an object like so:

```
{
  a: ""foo"",
  b: ""foo""
}
```

which I'm validating using a schema like this:

```
z.object({
  a: z.string()
}).refine((input) => {
  // I need to reference b here
});
```

I can access `b` if I call `passthrough()` before `refine()`, like this:

```
z.object({
  a: z.string()
})
.passthrough()
.refine((input) => {
  // I need to reference b here
});
```

but I don't want `b` to actually be passed through though. 

@scotttrinh suggested adding the b schema and using `refine` to do the check and then use `transform` to only return a.

@scotttrinh's solution works, but it seems more optimal if Zod would add an option to `RefineParams` (passed as a second argument to `refine`) that would could be configured to include unknown keys to be included in `input`.",,
1174095367,1031,Question: Will key order always be preserved?,"I want to preserve key order of my `parse`'d objects and want to make sure this library's intent is to always do that and won't change that.

From what it seems, it's currently doing that right now.  If it's prone to change in the future, I may want to add my own internal sorting somehow.

Thanks!  Sweet library btw.",,
1171584870,1019,Feature Proposal: Preprocessed string types,"I use Zod heavily for parsing environment variables and in each project need to reimplement transformer definitions to convert the raw env object (either from `process.env` or `dotenv`) to their intended types.

What would alleviate a bunch of pain in this use case is having built in `<number|boolean|bigint|null>String()`, for example:

```typescript
const isString = (value: unknown) : value is string => typeof value === ""string""

const booleanString = z.preprocess(
  (value) => (isString(value) ? value === ""true"" : value),
  z.boolean()
)

const numberString = z.preprocess(
  (value) => (isString(value) ? parseInt(value) : value),
  z.number()
)

const bigintString = z.preprocess(
  (value) => (isString(value) ? BigInt(value) : value),
  z.bigint()
)

const nullString = z.preprocess(
  (value) => (isString(value) && value === ""null"" ? null : value),
  z.null()
)
```

The ideal implementation would be for the `z` import to provide these like:

```typescript
import { z } from ""zod""

const EnvSchema = z.object({
  FOO_NUMBER: z.numberString().default(100),
  BAR_BOOL: z.booleanString().default(false)
  // etc...
})

```

Happy to do an MR if this is something that might be accepted? ",,
1169596014,1018,Documentation: More specific on use of validator.js,"I have an application using zod but I'd like to use some methods from a different library (validator.js) zod documentation says:

> Check out validator.js for a bunch of other useful string validation functions.

Not sure if that means this functions are implemented on zod, or I have to also install validator.js, in that other case how I can use both libraries together? cant find any example.

I got this answer from stackoverflow, is this the way you refer in your docs?

```
import { z } from ""zod"";
import isCreditCard  from ""validator/lib/isCreditCard"";

const userSchema = z.object({
  name: z.string(),
  creditCard: z.string().refine(isCreditCard, {
    message: 'Must be a valid credit card number'
  }),
})
```

Thanks!",,
1167637230,1016,A schema where property value is limited to another zod schema of any type,"Hi, first of all. Thanks for an awesome and intuitive library! I've been using it for multiple projects and bragging about it to other developers :D

I'm wondering if there is a way to declare a schema where a single property value is itself a `zod` schema. I'm trying to define some rules for a specific object type, but leave the ""value"" validation up to the object itself. Something like this:

```typescript
const FieldDefinition = z.object({
  title: z.string(),
  value: // type of any valid zod schema
})
type FieldDefinitionType = z.infer<typeof FieldDefinition>
```

Then in some other part of my program I want to be able to do something like this:

```typescript
const TextField: FieldDefinitionType = {
  title: ""Text field"",
  value: z.string().length(128)
}
```

Basically limiting the `value` property to only be another `zod` schema. How would I type that up in the `FieldDefinition` schema?

Edit: To be clear. The value should not be limited to `z.string()` or `z.number()`, any valid zod schema should be allowed.",,
1167440909,1015,Support multiple discriminated unions on same object,"First of all, thank you for Zod! I'm just starting to use it on a new project. I have a case come up quite frequently that I don't know how to resolve using current Zod functionality. I've asked a similar question [here](https://github.com/colinhacks/zod/discussions/1006) and haven't received a response, so I'm logging an issue considering functionality may need to be added to Zod.

I believe I want multiple discriminated unions on the same object. Here's some code that illustrates what I'm trying to accomplish:

```js
const schema = z.object({
    sku: z.string()
  }).merge(z.discriminatedUnion(""product"", [
    z.object({
      product: z.literal(""shoes""),
      price: z.number(),
      material: z.union([z.literal(""leather""), z.literal(""suede"")])
    }),
    z.object({
      product: z.literal(""shirt""),
      price: z.string()
    })
 ]).merge(z.discriminatedUnion(""color"", [
    z.object({
       color: z.literal(""red""),
       size: z.enum([""s"", ""m""])
    }),
    z.object({
      color: z.literal(""blue""),
      size: z.enum([""m"", ""l""])
    })
  ]);
```

In other words, the object will (1) always have a sku, (2) always have `product` and `price` (and sometime `material`), and (3) always have `color` and `size`.  The combinations would be restricted by the discriminated unions.

This doesn't work, though, because ZodDiscriminatedUnion doesn't have a merge property and ZodDiscriminatedUnion can't be merged into ZodObject.

I'm not particular about the implementation, so long as it's simple (it's a common use case) and preferably does not require `refine` or `superRefine` (though I'd still like to understand how solve it with `refine` or `superRefine` in the meantime). Thanks!",,
1167123541,1014,Feature Request: async preprocess,"Iâ€™m trying to parse some minecraft NBT data with zod. However, in order to do this, one key of the object (`item_bytes`) first needs to be converted from the binary NBT format to a JSON-like structure.

The best way to implement this in my opinion would be to use zodâ€™s `z.preprocess()`. Unfortunately, the library Iâ€™m using [`prismarine-nbt`](https://www.npmjs.com/package/prismarine-nbt) only exposes `parse` as an `async` function.

As far as I can tell, async preprocessing is not supported right now. I think it would be great if itâ€™s allowed as it would really simplify parsing with `async` libraries.

Iâ€™d suggest either `z.preprocess(async () => { /* ... */ }, z.any())` or `z.preprocessAsync(async () => { /* ... */ }, z.any())` as I think either would be reasonable from an API standpoint.",,
1166042240,1010,Unnecessary Documentation: screencasts.md,"**ISSUE**: Unnecessary Documentation in zod/docs. Documentation ( [screencasts.md](https://github.com/colinhacks/zod/blob/master/docs/screencasts.md)) contains random strings making no sense of its purpose.

**PROPOSED**: Removal of screencasts.md documentation from the repository.
",,
1166038909,1009,Unnecessary Documentation: _navbar.md,"**ISSUE**: Unnecessary Documentation in zod/docs. All links inside the documentation ( [_navbar.md](https://github.com/colinhacks/zod/blob/master/docs/_navbar.md)) have expired or lead to 404 not found page leaving it useless and occupy free space.

**PROPOSED**: Removal of _navbar.md documentation from the repository.
",,
1166037460,1008,Unnecessary Documentation: _coverpage.md,"**ISSUE**: Unnecessary Documentation in zod/docs. All links inside the documentation ( [_coverpage.md](https://github.com/colinhacks/zod/blob/master/docs/_coverpage.md)) have expired or lead to 404 not found page leaving it useless and occupy free space.

**PROPOSED**: Removal of _coverpage.md documentation from the repository.
",,
1165142789,1007,404 on https://zod.js.org/ ,"https://zod.js.org/
<img width=""603"" alt=""Screenshot 2022-03-10 at 12 10 30"" src=""https://user-images.githubusercontent.com/1926464/157658999-710cf44e-d9e7-43ee-93b7-a2a12fbd9345.png"">
",,
1164340316,1004,Validate Keys,"It would be nice to validate keys just like it is possible to validate values. Currently I am using this code
```js
export const counter = z
  .object({})
  .catchall(
    z.object({
      true: z.number().positive().max(process.env.MAX_NUM_IN_COUNTER),
      false: z.number().positive().max(process.env.MAX_NUM_IN_COUNTER),
    })
  )
  .strict();
```

In this code the key could be anything. I will store the resulting parsed object in a database as is. In order to stop users from exploiting this, I would like to make sure that the key is at most x characters long. I think this is currently not possible, but would be a nice feature. Awesome library though, I'm absolutely loving it.",,
1161734179,1001,New `refine` behaviour issues with `z.custom` (and `z.instanceof`),"Because `z.custom` returns a `ZodType<T>`. successive refinements believe to operate on a `T` when they're actually receiving the untouched input instead.

### Example
```ts
import { z } from 'zod';

class Foo {
  isValid(): boolean {
    return true;
  }
}

const FooSchema = z.instanceof(Foo)
  .refine((val) => {
    // `val` is typed as `Foo` because `z.instanceof(Foo)` is a `ZodType<Foo>`
    // but we will be operating on the raw input instead causing a runtime error.
    return val.isValid();  
  });

FooSchema.parse(undefined); // TypeError: cannot read properties of undefined (reading 'isValid')
```

### Possible Solution
I think a viable non-breaking solution would be to have `z.custom` rely on `superRefine` instead of `refine` and create an issue with `fatal: true` when the validation fails.",,
1160435741,998,[question] Option to string be one of the strings in an array,"Hi! 

First of all, thanks for this amazing library. Second, is there a way to define something like `z.string().oneOf([""banana"", ""apple""])`?",,
1160347893,996,Confusing docs for .parse,"Bit confused by the docs for [parse](https://github.com/colinhacks/zod/tree/70615e6a4e05adafe7e471f4706e90f8ee798292#parse):

> Given any Zod schema, you can call its `.parse` method to check `data` is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown.
> > IMPORTANT: In Zod 2 and Zod 1.11+, the value returned by `.parse` is a _deep clone_ of the variable you passed in. This was also the case in zod@1.4 and earlier.

OK, but what does it return now? I would have assumed a deep clone. I looked in the changelog but it just says ""Parsing no longer returns deep clone"".",,
1158246425,995,Property does not exist on type '{ [k in keyof addQuestionMarks]...',"Hi, I'm not sure if this is a bug or if TypeScript just needs some more guidance but I'm having an issue with a generic function for generating schemas. Specifically the return type of the .parse() method

```typescript
import { z } from ""zod"";

export const createSchema = <T extends z.ZodTypeAny>(schema: T) => {
  return z.object({
    foo: schema,
    bar: z.string()
  });
};

export const createHandler = <T extends z.ZodTypeAny>(
  schema: T,
  data: unknown
): void => {
  const eventSchema = createSchema(schema)
  const result = eventSchema.parse({foo: data, bar: 'baz'})
  console.log(result.foo) // Error!
  console.log(result.bar) // No error
};

createHandler(z.string(), 'hello');
createHandler(z.number(), 123);
```

The error that I'm getting on the `console.log(result.foo)` says:

>Property 'foo' does not exist on type '{ [k_1 in keyof addQuestionMarks<{ foo: T[""_output""]; bar: string; }>]: addQuestionMarks<{ foo: T[""_output""]; bar: string; }>[k_1]; }'.ts(2339)

Here is a CodeSandbox with the same code as above.

https://codesandbox.io/s/nervous-banach-vkf8d5?file=/src/index.ts",,
1157260924,993,Type Inference : Named Types with nested schemas in objects,"Hey everyone!
I've recently discovered Zod and this is quite a marvel! Congrats @colinhacks and every contributor for the awesome work !

I've got an ""issue"" that can be quite annoying when dealing with complex objects, let me explain with this short example : 

```typescript
const foo = z.object({
    name: z.string(),
    birthdate: z.date()
})
type Foo = z.infer<typeof foo>

const bar = z.object({
    property: z.string(),
    foo
})
type Bar = z.infer<typeof bar>
```

Here i defined two schemas, a practical example would be : Foo is a Person, and Bar is an Order or something, it doesn't matter.
When I infer the type of Bar, I would like the final output to look like this : 

```typescript
type Bar = {
    property: string;
    foo: Foo;
}
```

Of course right now, this is impossible, I've searched the docs and tried a few things, but unfortunately nothing worked.

**What the inferred type looks like (no surprise here)**
```typescript
type Bar = {
    property: string;
    foo: {
        name: string;
        birthdate: Date;
    };
}
```

**What i've tried so far, without any luck**
```typescript
const bar = z.object({
    property: z.string(),
    foo: foo as z.ZodSchema<Foo>
})
```

```typescript
const bar = z.object({
    property: z.string(),
    foo: foo.transform((arg): Foo => { return arg })
})
```

**My terrible workaround**
```typescript
type Bar = { property: string, foo: Foo }
```

**Why I consider it important**
With large DB infrastructures, having understandable and clear typings is essential, while Zod allows me to really enforce typing, I would really like to have a clear type hinting from VSCode when using z.infer<T>. The workaround is fine but it's static.

Have anyone figured out how to achieve such behavior ?

Cheers!
Julien",,
1157005910,992,Typing for record became too loose after addition of Partial,"This issue is related to: https://github.com/colinhacks/zod/issues/751

After updating zod version from v3.12.0 to v3.13.3 we started to receive the following TS error: `error TS2322: Type 'Partial<Record<string, string>>' is not assignable to type 'Record<string, string>'.
  'string' index signatures are incompatible.
    Type 'string | undefined' is not assignable to type 'string'.
      Type 'undefined' is not assignable to type 'string'.
`

We are using zod `record` with string keys and values. I think that returning Partial for string records is a bug, because we are sure, that all keys that record has are checked by zod and contain non-`undefined` value, but TS says that they can contain `undefined` that forces us to do extra checks in the later code to convince TS that all values are strings.

I've created a repo with simple reproduction to illustrate such use case better:
https://github.com/hsarokina-ita/zod-partial-record
`safeParse` returned `success: false` for object with `undefined` values, this means that zod checked for it to be defined. But at the same time I can assign record with undefined value to typing returned by parser.",,
1156289198,991,string + email + nullish fails when empty string,"```ts
const emailSchema = z.string().email().nullish();

emailSchema.parse("""")
```

fails with invalid email. This should not be the case due to `nullish` no? ",,
1155792295,990,.deepPartial() broke type-checking of arrays of objects,"When using `.deepPartial() `in order to proagate` .partial()` to all nested objects,  the type validation of array of objects is broken.
The type checking is executed correctly using` .partial()` directly on the object.


```
object({
// ....    
questions: object({
        question_id: string(),
        response: string()
    }).array().optional()
}).deepPartial()
```

This broke the array internal type validation, allowing the parse of `[{}]`, `[{""fff"": ""fff""}]` and similar. 
The general array type validation seems to work correctly.",,
1155661788,989,How do I map an array of values into discriminated union options,"### Discussed in https://github.com/colinhacks/zod/discussions/985

<div type='discussions-op-text'>

<sup>Originally posted by **Aaronius** February 28, 2022</sup>
I'd like to be able to map an array of string values into discriminated union options and use them with `z.discriminatedUnion`. Here's what I'm trying to do:

```ts
const validationSchema = z.discriminatedUnion(""taxClassification"", Object.values(TaxClassification).map(taxClassification => {
  return z
    .object({
      taxClassification: z.literal(taxClassification),
      exemptPayeeCode:
        taxClassificationExemptPayeeCodeSchemaMap[taxClassification],
      exemptFatcaCode:
        taxClassificationExemptFatcaCodeSchemaMap[taxClassification],
    })
});
```

I can't though because ""Source provides no match for required element at position 0 in target."" 

I would typically try to type my mapped array as `[ZodDiscriminatedUnionOption, ZodDiscriminatedUnionOption, ...ZodDiscriminatedUnionOption[]` before passing it into z.discriminatedUnion, but Zod doesn't seem to expose the `ZodDiscriminatedUnionOption` type. Is there a better way?</div>",,
1155249685,986,Zod 3.12.0 doesn't bind the scope anymore,"This code used to work prior to 3.12.0, but it doesn't now:

```js
const z = require(""zod"");

const run = z.object({ a: z.number() }).safeParse;

console.log(run({ a: 1 }));
```

```bash
$ node run.js
/user/node_modules/zod/lib/types.js:184
            schemaErrorMap: this._def.errorMap,
                                 ^

TypeError: Cannot read property '_def' of undefined
    at ZodType.safeParse (/user/node_modules/zod/lib/types.js:184:34)
    at Object.<anonymous> (/user/test.js:5:13)
```",,
1154440650,981,Complex ZodObject type causes infer error,"I was able to isolate the bug with `infer` and `ZodObject` described in this issue: microsoft/TypeScript#48059

That requiredKeys (https://github.com/colinhacks/zod/blob/v3.12.0/src/types.ts#L1306) adds complexity to the type causes `infer` error:

> Type 'U' does not satisfy the constraint 'ZodRawShape'.(2344)

Reproduction ([playground](https://www.typescriptlang.org/play?ts=3.9.7#code/C4TwDgpgBAyglgWzAGzgMxAHgCoD4oC8UA3gNoDSEI240cAdlANZUD2aU2AugFycVUakLgF8A3AFgAUNNCQorMMDit6AQ2SUQAZxxQIAD2AR6AE20KARgCsIAY2D4ixaVDdRSTKA2ZsO3PgBXMwg0BghTfSMTc34mLigAfmYoPnoIADcIACdJKRFPP04uPOkAegAqWVoobIgAR0C4OtMtXWwo4zMLVht7R0ISVw8vHxYQdmKgkLD0yMMu2OxPBOT0rOzU5jyC8cnuPIqy6Wr5OsbmiLa9BZievocnKABRAztkQNMITD3-ABoFEoVOpNFR2rhcKUpIYwKxssAoHJoGpTKYAIqBCDaZSqACyamyTHanTuVlsj0GLik7hG3kYihxIOueC4iT4y3iOygADIhtT3J46bUGk0WszcLw4iVpOITlIkVAAFqsUwAJTUAHcYAALNTyZzDNyePjY7IMADmkuVpiE3zU9BAkJlUIYxmyaDUdmg1ttmAA8oFgGBA-gqW4APpIvgBoOBnZy6SunIer1KlV+h7ATDDDq3bpptWanV6iB-YYx4MIojwJCoDDZ-luMM02k+BnAjTi1nslZ5GkiHl8lutxjnUVXME4CU9zmGqAiYa4aT4POxH20f2Byuh4Z1FGqZAgKDh7S6yDs+MyeU1XEgDPkrN4Qa56L5633-qYBhoHJQACqS78skf4km+KrqlqZ4QHOwFzmkmQ5MM8EbHkQA)):

```ts
type Simplify<T> = {[KeyType in keyof T]: T[KeyType]};

type optionalKeys<T extends object> = {
    [k in keyof T]: undefined extends T[k] ? k : never;
}[keyof T];

type requiredKeys<T extends object> = Exclude<keyof T, optionalKeys<T>>;

export type addQuestionMarks<T extends object> = {
    [k in optionalKeys<T>]?: T[k];
} & {
    [k in requiredKeys<T>]: T[k];
};

type ZodRawShape = {
    [k: string]: ZodType<any>;
};

interface ZodType<Output> {
  _type: Output;
}

interface ZodObject<
  T extends ZodRawShape,
  Output = Simplify<
    {
      [k in optionalKeys<T>]?: T[k];
    } & {
      [k in requiredKeys<T>]: T[k];
    }
  >
> extends ZodType<Output> {
  readonly _shape: T;
}

type MyObject<T> = T extends ZodObject<infer U>
  ? U extends ZodRawShape
    ? U
    : never
  : never;
```

After changing requiredKeys to more simplified implementation similar to optionalKeys, the error disappears:

```ts
type requiredKeys<T extends object> = {
  [k in keyof T]: undefined extends T[k] ? never : k;
}[keyof T];
```

Versions to reproduce:

TypeScript v3.9.x (3.9.7) or higher
zod v3.1.2",,
1154393791,980,"Value or undefined is not the same as an optional, and should not be a required property either","### Discussed in https://github.com/colinhacks/zod/discussions/971

<div type='discussions-op-text'>

<sup>Originally posted by **emanuel-lundman** February  7, 2022</sup>
```typescript
type A = {
    b: string | undefined
}
```

is not the same as:

```typescript
type A = {
    b?: string | undefined
}
```

The first requires undefined to be set, and can't just be left out.

Zod though both seem to infer:
```typescript
type A = {
    b: string | undefined
}
```

 to an optional when writing the schema first and then inferring a type. And when doing the other way around, writing a schema for the type, thinks it's required and only accepts the following:

```typescript
type A = {
    b: string | undefined
}

const a = z.ZodScheme<A> = z.object({
    b: z.string()
})
```

even though it should be `z.string().or(z.undefined())`
But writing is it should be results in error:
`Property 'b' is optional in type '{ b?: string | undefined; }' but required in type 'A'`

Am I missing something?</div>",,
1149989659,970,Enums should support an omit method,"Example of what has to be done right now:

<!-- <img width=""624"" alt=""CleanShot 2022-02-24 at 22 05 16@2x"" src=""https://user-images.githubusercontent.com/284476/155646051-b8250501-6855-4da1-8c7c-d8fafaa3159f.png""> -->
```ts
const a = z.nativeEnum( { a: 1, b: 2 } as const )
const b = z.nativeEnum( Remeda.omit( a._def.values, [ 'a' ] ) )

b._def.values.b // works
b._def.values.a
//            ^
// Property 'a' does not exist on type 'Omit<{ readonly a: 1; readonly b: 2; }, ""a"">'.
```


I'm not sure how to do it with zod enums actually.

This issue would be asking for native and zod enums though to support an omit method.",,
1149368710,965,skypack error on v3.12.0,"I tried importing the most recent version of skypack and received an error:
```
[Package Error] ""zod@v3.12.0"" could not be built. 
[1/5] Verifying package is validâ€¦
[2/5] Installing dependencies from npmâ€¦
No matching version found for zod@3.12.0.
```

Reproduce:
Go to https://www.skypack.dev/view/zod and click ""Open in Codepen"" and view the console logs

version 3.11.6 works as expected with Skypack via `import * as zod from 'https://cdn.skypack.dev/zod@3.11.6'`, so not sure if something changed in 3.12.0",,
1149248759,964,`union` and `discriminatedUnion` do not work well together with `inferFlattenedErrors` ,"Given the code
```ts
const SomeData = z.discriminatedUnion(""kind"", [
    z.object({
        kind: z.literal(""with-number""),
        num: z.number()
    }),
    z.object({
        kind: z.literal(""with-string""),
        str: z.string()
    })
]);

type ErrorType = z.inferFlattenedErrors<typeof SomeData>;

const err: ErrorType = {
    formErrors: [],
    fieldErrors: {
        num: [""Could not parse number""]
    }
}
```
Typescript complains because the only field in `ErrorType.fieldErrors` is `kind`. Similar happens when `union` is used instead of `discriminatedUnion`. I would have expected the ErrorType to contain the union of the potential errors (as optional properties), not the intersection, as that is what the errors returned will contain.

Tested with Zod version 3.12.0 with typescript 4.5.5.",,
1147656424,959,Catch all errors for nested schemas and only return singular error,"```ts
z.object({
    type: z.literal(ConveyancePartType.TEXT_AREA),
    label: z.string(),
    options: z
        .object({
            max_length: z.number().optional(),
            min_length: z.number().optional()
        })
        .optional()
});
```

When parsing this object, is there a way to capture all of the errors for a certain schema, and return them as a singular error. For example, for the options property, if there is an error with max_length, or hypothetically any of the other properties on that object, I want to return a singular error that says ""invalid options"" regardless of what the actual error may be.

Any ideas?

Thanks!


",,
1142431463,946,Cannot read property '_parse' of undefined,"Hi, I have a Zod object like this

```ts
const zodObj = z.object( { id: string } )
```
then I extend it by
```ts
const extendObj = zodObj.pick( { wrongKey: true, id: true } )
```
when I run 
```ts
extendObj.parse( { id: ""xxx"" } )
```
I will get error

```
TypeError: Cannot read property '_parse' of undefined
    at s._parse (file:///E:/Job/test/node_modules/zod/lib/index.mjs:1:32502)
    at s.e._parseSync (file:///E:/Job/test/node_modules/zod/lib/index.mjs:1:13917)
    at s.e.safeParse (file:///E:/Job/test/node_modules/zod/lib/index.mjs:1:14474)
    at s.e.parse (file:///E:/Job/test/node_modules/zod/lib/index.mjs:1:14128)
    at Array.eval (webpack-internal:///(api)/./src/pages/api/test.ts:14:104)    
    at loop (file:///E:/Job/test/node_modules/next-connect/dist/index.js:79:47)
    at next (file:///E:/Job/test/node_modules/next-connect/dist/index.js:81:25)
    at AsyncFunction.handle (file:///E:/Job/test/node_modules/next-connect/dist/index.js:83:5)
    at nc (file:///E:/Job/test/node_modules/next-connect/dist/index.js:21:8)
    at Object.apiResolver (E:\Job\test\node_modules\next\dist\server\api-utils\node.js:182:15)
```
This can be fixed by remote `wrongKey` but I think you can fix this to avoid error ",,
1141901894,944,Support for function contracts,"The runtypes library has support for [function contracts](https://github.com/pelotom/runtypes#function-contracts).

Would it be desirable to have similar feature in zod as well ? Where function arguments and return types could be specified through zod types and the returned function will validate them at runtime. ",,
1140761502,942,"[Help/Question] Function with optional parameters, ZodError: ""too_small""","Perhaps I'm misunderstanding how this works, but I have made the following function:

```ts
const formatCurrency = z
  .function()
  .args(
    z.number(),
    z.string().optional(),
    z.string().optional(),
  )
  .returns(z.string())
  .implement((value: number, currency: string = 'CAD', locale: string = 'en-CA'): string => {
    return new Intl.NumberFormat(locale, {
      style: 'currency',
      currency,
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }).format(value);
  });
```

It works when I call `formatCurrency` with three arguments, but if I call it with only the `value` arguments I am presented with this error:

```json
ZodError: [
  {
    ""code"": ""invalid_arguments"",
    ""argumentsError"": {
      ""issues"": [
        {
          ""code"": ""too_small"",
          ""minimum"": 3,
          ""inclusive"": true,
          ""type"": ""array"",
          ""path"": [],
          ""message"": ""Should have at least 3 items""
        }
      ],
      ""name"": ""ZodError""
    },
    ""path"": [],
    ""message"": ""Invalid function arguments""
  }
]
```

What is the correct way to handle optional arguments?",,
1138584210,937,Breaking change in 3.9.0 can cause undefined `this` errors,"I've just upgraded from an early 3.x to 3.11.6 and spent a fair while debugging this, so I'm raising it to help others in the same situation. It may be helpful to revert or document the change too.

---

Commit d47eadc in 3.9.0 changed `() => {}` arrow functions to `function() {}` methods. With arrow functions `this` is bound lexically and will always point to the containing class, but with methods the value of `this` changes with how you call it. This breaks any direct call of a zod method which refers to `this` internally.

Using `parse` as an example which internally calls `this.safeParse`, the following code works as expected before 3.9.0, and throws `Cannot read property 'safeParse' of undefined` after 3.9.0.

```ts
const parse = isAsync ? myZodSchema.parseAsync : myZodSchema.parse
const result = await parse(values)
```

To fix it, you must avoid reassigning `parse` and instead call it directly from your schema.

```ts
const result  = await (isAsync ? myZodSchema.asyncParse(values) : myZodSchema.parse(values))
```",,
1136706391,935,[Proposal] Pass `description` to `ZodError` constructor.,"After minification / bundling it's not always feasible to access a source map for tracing errors, making it hard to diagnose specific ZodError causes in an app with many Zod schemas. 

It would be handy for the `ZodError` context to include the `description` property (or possibly a new `name` property) of the schema that triggered it by passing this info to the constructor.

## Example

### ZodError

https://github.com/colinhacks/zod/blob/12dcdf5169c809e1d3804ed3c2f2fcbf72ee6e54/src/ZodError.ts#L140

```typescript

export class ZodError<T = any> extends Error {
  // ...
  constructor(description: string, issues: ZodIssue[]) {  // Add description to constructor here...
    super();
    // ...
    this.name = ""ZodError"";
    this.description = description;
    this.issues = issues;
  }
}

```
### handleResult()
https://github.com/colinhacks/zod/blob/12dcdf5169c809e1d3804ed3c2f2fcbf72ee6e54/src/types.ts#L89

```typescript
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.issues.length) {
      throw new Error(`Validation failed on ${ ctx.description } but no issues detected.`); // Add description to generic error here...
    }
    const error = new ZodError(ctx.description, ctx.issues); // Add description to constructor here...
    return { success: false, error };
  }
```



If the schema provided it's `description` to the `ZodError` constructor, it would make it a lot easier to trace issues in these cases where a source map is not available, or even more gracefully in logging with something like:


```typescript
import { EOL } from ""node:os""
const logZodError = ({ name, description, issues }: ZodError) => {
  const message: string = [
    `Encountered a ${ name } error while parsing ${ description }`,
     issues.map(
          ({ message, path }: ZodIssue): string =>
            `[${ path.join(` â€º `) }]:  ${ message }`
        ).join(EOL)
  ].join(EOL)
  console.error(message)

}

```",,
1128888424,925,z.object().passthrough() not working with objects like Buffer,"Thanks for Zod!

Perhaps I am using this incorrectly, or missed something in the docs. I wanted to use a zod schema to parse an object containing a field that points to a `Buffer` , more generally an object that implements `Reader` (`Buffer` does), but that detail isn't important for this. I didn't expect native support for `Buffer`, so I figured I could use `z.object({ ... }).passthrough()`, checking for the methods on `Buffer` I cared about, but then passing through the whole object to keep the internals working.

What seems to happen is that I get back an object that has the `bytes()` function, but the rest of the fields _do not_ passthrough. So fundamentally, it seems that `passthrough()` isn't working for this case, unless i'm using it incorrectly.

Here is a reproduction using Deno:

```js
import * as z from ""https://cdn.skypack.dev/zod@^3"";
import { Buffer } from ""https://deno.land/std@0.125.0/io/buffer.ts"";

const FooSchema = z.object({
  bar: z.string(),
  // stream is a Buffer, but passthrough all fields
  stream: z.object({
    bytes: z.function(),
  }).passthrough(),
});

const throws = FooSchema.parse({
  bar: ""fizz"",
  stream: new Buffer(new Uint8Array(4).buffer),
});

console.log(""typeof Buffer: "", typeof new Buffer(new Uint8Array(4).buffer));

// this throws because another method has been stripped that bytes() uses internally
console.log(""throws.stream.bytes(): "", throws.stream.bytes());
```",,
1128771404,924,Discriminated Unions are available?,"I see a reference to [Discriminated Unions](https://github.com/colinhacks/zod#discriminated-unions) in the documentation, but in the latest version of zod, `3.11.6`, I can't access them, is there going to be a release soon to get this feature?",,
1128051725,923,Type Error when recursive types with default,"```
type NodeType = {
    id: string;
    parent?: NodeType;
};

export const NodeTypeSchema: z.ZodSchema<NodeType> = z.lazy(() =>
    z.object({
        id: z.string().default(''),
        parent: NodeTypeSchema.optional()
    })
);
```

typescript 4.5.5 error:

Type 'ZodLazy<ZodObject<{ id: ZodDefault<ZodString>; parent: ZodOptional<ZodType<NodeType, ZodTypeDef, NodeType>>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'ZodType<NodeType, ZodTypeDef, NodeType>'.
  The types of '_input.id' are incompatible between these types.
    Type 'string | undefined' is not assignable to type 'string'.
      Type 'undefined' is not assignable to type 'string'",,
1127572782,922,Validate object against schema without cloning,"Is there a way to validate an object against a schema without cloning it and returning a different object?

It would be much less computationally/memory intensive just to do the checking and not go through the process of cloning it and stripping out extra fields, which could be useful in many cases.",,
1127309051,921,Confusing terms - parse vs validate,"I'm still trying to wrap my head around [this article](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/) that points out that parsing is superior to validating. 

Yet, zod coins itself as a validation library, and as far as I can judge, it is one.
> Zod is a [...] validation library.

Yet you have chosen to name the method to validate `.parse`, `.safeParse` or `parseAsync`.
If zod were a parser, it could help me to transform data e.g. retrieved by a REST API to be in acceptable shape for a database.

Would it make sense to add an alias for `.parse` named `validate` to make usage more intuitive, without including a breaking change?
This is literally the first thing I intuitively tried after defining my first validation schema.

Otherwise, I am curious how you came to the conclusion of how to name the method :)
",,
1126662785,920,"Value or undefined is not the same as an optional, and should not be a required property either","```typescript
type A = {
    b: string | undefined
}
```

is not the same as:

```typescript
type A = {
    b?: string | undefined
}
```

The first requires undefined to be set, and can't just be left out.

Zod though both seem to infer:
```typescript
type A = {
    b: string | undefined
}
```

 to an optional when writing the schema first and then inferring a type. And when doing the other way around, writing a schema for the type, thinks it's required and only accepts the following:

```typescript
type A = {
    b: string | undefined
}

const a = z.ZodScheme<A> = z.object({
    b: z.string()
})
```

even though it should be `z.string().or(z.undefined())`
But writing is it should be results in error:
`Property 'b' is optional in type '{ b?: string | undefined; }' but required in type 'A'`

Am I missing something?",,
1126351678,917,Branded helper,"Instead of:

```ts
type Age = Branded<number, ""Age"">;

const Age = z
  .number()
  .min(0)
  .max(100)
  .refine((a: number): a is Age => true);
```

Zod can provide a simple helper:

```ts
const Age = z
  .number()
  .min(0)
  .max(100)
  .brand('Age');
```

What do you think? 

---

This line:

```ts
.refine((a: number): a is Branded<number, ""Age""> => true)
```

to this line:

```ts
.brand(""Age"").
```

I suppose it's a tiny change but would improve DX a lot.

---

Or something like that?

```ts
const brand =
  <B extends string>(brand: B) =>
  <T extends string | number>(a: T): a is Branded<T, typeof brand> =>
    true;

.refine(brand(""Age""))
```

---

OK, this is what I reiterated. Still, I suppose it should be part of the official Zod API. 

```ts
export type Branded<T extends string | number, B extends string> = T & {
  readonly __brand: B;
};

export const branded =
  <B extends string, T extends string | number>(
    brand: B,
    predicate?: Predicate<T>
  ) =>
  (a: T): a is Branded<T, typeof brand> =>
    predicate ? predicate(a) : true;
```",,
1125229044,916,Cannot raise issue with custom code and global error map,"Using `z.setErrorMap` a custom error map can be registered, but the default error map is called before this one and throws an error if the code is not one of the default error codes.

[ZodError.ts](https://github.com/colinhacks/zod/blob/master/src/ZodError.ts)
```js
switch (issue.code) {
    // ...
    default:
      message = _ctx.defaultError;
      util.assertNever(issue); // <--
```

```stacktrace
Error
    at Object.assertNever (node_modules\zod\lib\helpers\util.js:18:15)
    at defaultErrorMap (node_modules\zod\lib\ZodError.js:291:25)
    at makeIssue (node_modules\zod\lib\helpers\parseUtil.js:174:28)
    at addIssueToContext (node_modules\zod\lib\helpers\parseUtil.js:189:39)
    at Object.addIssue (node_modules\zod\lib\types.js:2310:55)
    at Object.notWhiteSpace [as refinement] (out\server.js:5871:13) | <= Custom super refinement here
    at executeRefinement_1 (node_modules\zod\lib\types.js:2326:37)
    at ZodEffects._parse (node_modules\zod\lib\types.js:2346:17)
    at ZodObject._parse (node_modules\zod\lib\types.js:1158:41)
    at ZodObject._parse (node_modules\zod\lib\types.js:1158:41)
```",,
1124927831,913,parse strings,"In the spirit of [parse, don't validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/), I'd like Zod to return a number for `z.number().parse(""42"")` instead of throwing an error. I'd like the same for booleans, arrays, objects, basically anything that has a well adopted string representation via JSON as well as widely accepted formats like ISO date strings.

I want to be able to use Zod for parsing, not validating, incoming requests from a client and I want my server to be conservative in what it sends back to the client but be liberal in what it accepts ([robustness principle](https://en.m.wikipedia.org/wiki/Robustness_principle)).",,
1124219982,909,Help users with choosing this library,"Zod is a really useful library in case of fetching data from external source! âœ¨

I think we could do some things that would help users to choose the best library for their case. My suggestions are:
1. move comparison section upper in readme's hierarchy, since it's more important 
1. simplify comparison section and turn it into table, [got](https://github.com/sindresorhus/got#comparison) is a good example
1. create issues in other data validation libraries and ask to also provide comparison section in theirs READMEs
1. add sample use cases, e.g. scraping websites; using external APIs

Please let me know what are your thoughts on that! ðŸ˜Š",,
1122573789,905,`z.infer` creates object types with optional keys,"When creating an object like,

```ts
  const Schema = z.object({
    email: z.string()
  })

  type Schema = z.infer<typeof Schema>
```

The created type is,

```ts
  type Schema = {
    email?: string
  }
```

But according to the documentation the keys should be required.",,
1121457323,904,"Namespace '""./zod/lib/index""' has no exported member 'inferFlattenedErrors'","First of all, awesome work on this library!

According to [the docs](https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md#type-safety-with-safeparse), I can use `inferFlattenedErrors` to improve the type safety of errors. However, it seems like it's not being exported from the package, because I get this error:

```
Namespace '""./zod/lib/index""' has no exported member 'inferFlattenedErrors'.
````

To be sure, I copy/pasted code from the [test files](https://github.com/colinhacks/zod/blob/cc8ad1981ba580d1250520fde8878073d4b7d40a/src/__tests__/all-errors.test.ts),  but I get the same error. Is the code somehow not included in the build, or am I doing something wrong?

",,
1120173433,903,Add name field to ZodTypeDef,"I've run into a situation where adding a `name` field to `ZodTypeDef` would be very helpful. I have a library that builds OpenAPI specs based on schemas and am having to deal with stack overflows when supporting lazy schemas. I have mostly got around this by tracking visited lazy schemas and creating References on the second time around, the key parts look like this

```ts
const visitedLazies = new Set<string>();
function createSchema(
  obj: ReferenceType | Reference<any>,
  components: OpenAPIV3.ComponentsObject,
  keyName?: string,
): OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | undefined {
  let schemaObject: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | undefined;

  const def = obj._def;
  if ('typeName' in def) {
    switch (def.typeName) {
      ...
      case z.ZodFirstPartyTypeKind.ZodLazy:
        if (!keyName) { // handle top level lazy schema ie not within an object. should perhaps throw here instead
          schemaObject = createSchema(def.getter(), components);
        } else if (visitedLazies.has(keyName)) {
          schemaObject = { $ref: `#/components/schemas/${keyName}` };
        } else {
          visitedLazies.add(keyName);
          schemaObject = createSchema(def.getter(), components);
          if (schemaObject) {
            components.schemas![keyName] = schemaObject;
          }
        }
        break;
      ...
  }
  return schemaObject;
```

The problem here is that `keyName` is the name of the key in an object that contains the lazy. If the schema is `z.object({ hello: SomeLazySchema })` then `keyName = hello`. This is a poor choice because a) the key name is not always the friendliest name to give an OpenAPI component and b) it forces you to make all keys with lazy schemas unique, or you will overwrite them.

I could write a custom zod type that has a name field on it and force lazy schemas to use it. But I'm wondering if this is would be a welcome addition to Zod itself? It's somewhat similar to adding the description to the schema like https://github.com/colinhacks/zod/commit/e2389b0312fb1b280a90d4bd1f10d099178aec9a.

I'm happy to do the work but wanted to make sure I'm not wasting my time before I do.",,
1118800849,901,Object validation custom message,"Hi! I'm trying to rewrite yup validator to zod and have an issue with custom object message.

I have a dropdown that by default has value of `null` and when an item is selected the value is for example`{label: 1, value : 1}`. Using yup I validated only for the object not to be null and outputted message of 'please select X value'.

So the yup validator looks like this - I don't care about particular object properties since they're hardcoded, I only care about the object not being null.

```
const schema = yup.object().shape({
  companyType: yup
    .object()
    .required('Please select X value')
    .typeError('Please select X value'),
```


When, on the other hand, I use zod the schema looks like this - I define the properties even though I don't care about them, and there is no way of defining custom error message. When selectField is `null` the message is `Expected object, received null` and I have no idea whether it is modifiable or how.

```
const zodSchema = z.object({
  selectField: z.object({
    value: z.string(),
    label: z.string(),
  }),
```

I would like to do something like this
```
const zodSchema = z.object({
  selectField: z.object({
    value: z.string(),
    label: z.string(),
  }).nonNullable('Please select X value'),
```

Any tips? :)",,
1118351795,897,optional().default() getter doesn't allow returning undefined,"Given the following snippet:

```ts
import { z } from ""zod"";

const checkIfOnPath = (executableName: string) => false;

const parsed = z.string()
  .nonempty()
  .optional()
  .default(() => [""a"", ""b"", ""c""].find(checkIfOnPath))
  .parse(undefined);
```

I get this error:

```
No overload matches this call.
  Overload 1 of 2, '(def: string): ZodDefault<ZodOptional<ZodString>>', gave the following error.
    Argument of type '() => string | undefined' is not assignable to parameter of type 'string'.
  Overload 2 of 2, '(def: () => string): ZodDefault<ZodOptional<ZodString>>', gave the following error.
    Type 'string | undefined' is not assignable to type 'string'.
      Type 'undefined' is not assignable to type 'string'.(2769)
```

[(TS Playground link.)](https://tsplay.dev/WP7Rkm)

My expectation is that `.default()` with a function on `ZodOptional<ZodString>` should be able to return `string | undefined`, but it only accepts a function that returns `string`.

Further, at runtime this works just fine -- if the default getter returns `undefined`, `.parse()` doesn't throw, and its return value is `undefined` as I expect.",,
1118280770,896,How to model nominal types,"I've got a simple nominal type:
```typescript
export type Id = string & { readonly """": unique symbol };
export interface Hero {
  id: Id;
  name: string;
}
```
How can I create a schema for `Hero`? I tried `ts-to-zod`, but it doesn't seem to be able to handle the case. Is there any way to model this on zod?  (Note: I don't need to use ts-to-zod, I can write the schema manually as long as I know how to do it.)
Thanks.",,
1118193719,895,`.pick()` mask allowing non-present props when present props are defined,"### Example
```typescript

// Original schema
const FooSchema = z.object({
  foo: z.string(),
  bar: z.string()
})


const CorrectlyFailingSchema = FooSchema.pick({
  notARealProperty: true // This causes TypeScript error as expected.
})


const IncorrectlyPassingSchema = FooSchema.pick({
  foo: true,
  notARealProperty: true // Once an existing property is added to the mask, any non-defined props can pass as well.
})

```

This became an issue today where after passing through a bundler (esbuild), a non-descriptive error started throwing on `e.t._parse`: 
```
TypeError: Cannot read properties of undefined
```

The issue occurred because I had removed a property `""title""` from the original schema, but not from the `pick()` mask, so `title._parse()` was throwing as `title` was now undefined.",,
1117644345,894,Add `discriminatedUnion` schema type,"Our current implementation naively goes through and tests each member in a union and reports back all errors. This is both noisy and slower for cases where the union is a discriminated union.

Adding this issue to discuss how best to tackle adding a new schema type for discriminated unions.

## Some technical challenges

### Async?

How do we support an `async` version of the schema?

### Requiring schemas to be objects with the discriminate as a key

I _think_ there should be a way to do this, but I think it needs to be absolutely type-level constrained that you can't add a schema to the union that wouldn't contain the discriminant, so it needs to exclude non-objects and objects who's `shape` does not include the discriminant.",,
1116824340,891,Zod is calling addIssueToContext when no error is happening,"I noticed since 3.10 (new parsing engine) that we call `addIssueToContext` whenever we use an enum with union. See:

3.11:
![image](https://user-images.githubusercontent.com/3749095/151457293-6a382aff-9cfc-46e6-8050-681c067ed1b2.png)

3.9:
![image](https://user-images.githubusercontent.com/3749095/151457362-254fb234-084d-4644-8ad2-8a67208dd0a6.png)

After digging further, I noticed it's coming from here: https://github.com/colinhacks/zod/blob/cc8ad1981ba580d1250520fde8878073d4b7d40a/src/types.ts#L2820-L2826

Seems like the union is mapping through all the items and still calling error in the new parsing engine, whereas that wasn't the case before. 

Fix is to downgrade to 3.9 unfortunately. ",,
1116371805,890,Fields depending on other fields,"Bit of a complex one and might be a job for a layer on top of Zod but I couldn't find a similar issue so figured I'd open one.

I have a data structure that has a couple of fields that are required only if another field is set to some value.

```ts
z.object({
  entity: z.enum([""individual"", ""business""]),

  firstName: z.string(),
  lastName: z.string(),

  companyName: z.string(),
  companyNumber: z.string(),
});
```

If `entity` is `individual` then the company name and number are not required at all, but if `entity` is `business` then they are required.

What's the best way to go about this? I was thinking refine but there's no access to the object within this function, another method I could think of was something akin to a tagged type union:

```ts
type GeneralFields = { firstName: string; lastName: string }

type IndividualFields = { entity: ""individual"" } & GeneralFields 

type BusinessFields = { entity: ""business"" } & {
  companyName: string;
  companyNumber: string;
}

type Fields = IndividualFields | BusinessFields;
```

Is this possible to express with Zod?

Thanks for such a great library!",,
1116169805,889,inferrence for transformed sub schema fails when going through generics,"Let me preface this with that this might just be me having made some bad generics. But it seemed to work before I changed all my string based ISO-8601 dates to be `transform`-ed to `Date`.

Full repro repo here: https://github.com/karl-run/zod-repro

## Details

When you have a zod type that transforms a string to a date, for example like this:

```ts
export const LocalDateSchema = z
  .string()
  .refine((date) => isValid(parseISO(date)), { message: ""Invalid date string"" })
  .transform((date) => parseISO(date));
```

The resulting type here would be `Date` because that is what the transform-function returns, which is correct.

Given this example type, with it's corresponding (generated from GraphQL schema type):

```ts
  const SchemaWithDate = z.object({
    a: z.string(),
    date: LocalDateSchema,
    c: z.string(),
  });
  
  interface CompatibleGraphQLSchemaWithDate {
    a: string;
    date: Date;
    c: string;
  }
```

Parsing like this give you the expected result:

```ts
  const workingResult = SchemaWithDate.safeParse({});
  if (workingResult.success) {
      const reAssign: CompatibleGraphQLSchemaWithDate = workingResult.data
  }
```

So far so good. But I had this function that infers the type from the schema, so I could have one fetch function that passes inn path and schema, and parses and infers correctly (simplified for repro):

```ts
async function genericFetcher<SchemaType>({
  path,
  schema,
}: {
  path: string;
  schema: ZodType<SchemaType>;
}): Promise<SchemaType> {
  const response = await fakeFetch(path);
  const responseJson = await response.json();
  const result = schema.safeParse(responseJson);
  if (result.success) {
    return result.data;
  }

  throw new Error(`Unable to parse response`);
}
```

Now if we parse using this function, we get some strange behaviour:
```ts
  const doesNotWork: CompatibleGraphQLSchemaWithDate = await genericFetcher({
    path: ""/foo"",
    schema: SchemaWithDate,
  });
```

Gives us the following error on `schema`:

```
error TS2322: Type 'ZodObject<{ a: ZodString; date: ZodEffects<ZodEffects<ZodString, string, string>, Date, string>; c: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'ZodType<{ a: string; date: Date; c: string; }, ZodTypeDef, { a: string; date: Date; c: string; }>'.
  The types of '_input.date' are incompatible between these types.
    Type 'string' is not assignable to type 'Date'.

45     schema: SchemaWithDate,
       ~~~~~~

  index.ts:54:3
    54   schema: ZodType<SchemaType>;
         ~~~~~~
    The expected type comes from property 'schema' which is declared here on type '{ path: string; schema: ZodType<{ a: string; date: Date; c: string; }, ZodTypeDef, { a: string; date: Date; c: string; }>; }'
```

Implying that the transformed `date` value is still viewed as `string`. :thinking: 

Again, full repro here if anyone would like to play around with it: https://github.com/karl-run/zod-repro",,
1115508868,888,Identify which zod function schema failed,"We have a case where a function calls multiple zod function schemas. Problem is, if one of them errors, we don't have an idea which one. Example:

```ts
const fn1 = z.function().args(z.number()).returns(z.number).implement(() => 'oops');
const fn2 = z.function().args(z.number()).returns(z.number).implement(() => 2);
const fn3 = z.function().args(z.number()).returns(z.number).implement(() => 3);

const myFunction = () => {
fn1(1); // this is erroring!
fn1(2);
fn1(3);
}
```


Error:
```
[ { ""code"": ""invalid_return_type"", ""returnTypeError"": { ""issues"": [ { ""code"": ""invalid_type"", ""expected"": ""object"", ""received"": ""undefined"", ""path"": [], ""message"": ""Required"" } ], ""name"": ""ZodError"" }, ""path"": [], ""message"": ""Invalid function return type"" } ]
: Required
ZodError: [ { ""code"": ""invalid_return_type"", ""returnTypeError"": { ""issues"": [ { ""code"": ""invalid_type"", ""expected"": ""number"", ""received"": ""string"", ""path"": [], ""message"": ""Required"" } ], ""name"": ""ZodError"" }, ""path"": [], ""message"": ""Invalid function return type"" } ] 
```",,
1115020153,886,Adding a default to a value converts its cast type to optional,"This works all right:

```ts
type Potato = {
  kiwi: string,
}

const potatoSchema : ZodSchema<Potato> = z.object({
  kiwi: z.string(),
});
```

But now I would like to add an additional value as a ""fallback"" in case a value for`kiwi` is missing. 

```ts 
// [typescript]
// Type 'ZodObject<{ kiwi: ZodDefault<ZodString>; }, ""strip"", ZodTypeAny, { kiwi: string; }, { kiwi?: string | undefined; }>' is not // assignable to type 'ZodType<Potato, ZodTypeDef, Potato>'.
//   The types of '_input.kiwi' are incompatible between these types.
//    Type 'string | undefined' is not assignable to type 'string'.
//      Type 'undefined' is not assignable to type 'string'
const potatoSchemaBroken : ZodSchema<Potato> = z.object({
  kiwi: z.string().default(""kiwi""),
});
```
`Z.infer` does deduce the correct type

```ts
type InferedPotato = z.infer<typeof potatoSchemaBroken>;
// Infers type correct,
// type InferedPotato = {
//     kiwi: string;
// }
```
From reading the docs, I expect that the type you get from ` : ZodSchema<Potato>` to match the type from  `z.infer<typeof potatoSchemaBroken>`. Am i missing something?


Thank you for your time! ðŸ˜„ 
",,
1114046647,885,No way to validate NaN,"- `z.number()` does not accept NaN (arguably correct behaviour)
- `z.union([z.number(), z.literal(NaN)])` does not accept NaN (presumably because under the hood `.literal` uses `===`)

I saw somebody in #512 mention `z.nan()` but this does not seem to exist (yet?)

My current workaround:
```ts
export const numberWithNaN = z.custom<number>(
    (val) => typeof val === 'number',
    (val) => ({ message: `Expected number (including NaN), received ${inspect(val)}` }),
);
```

Proposal: add `z.nan()`, or make `z.literal` use `Object.is` for equality under the hood.",,
1114033455,884,Type Error when used any() and ZodSchema,"## What

I wrote some code like below

```typescript
type A = {
  foo: any;
};

function AParser(): z.ZodSchema<A> {
  return z.object({
    foo: z.any()
  });
}
```

## Actual

```
Type 'ZodObject<{ foo: ZodAny; }, ""strip"", ZodTypeAny, { foo?: any; }, { foo?: any; }>' is not assignable to type 'ZodType<A, ZodTypeDef, A>'.
  Types of property '_type' are incompatible.
    Type '{ foo?: any; }' is not assignable to type 'A'.
      Property 'foo' is optional in type '{ foo?: any; }' but required in type 'A'.
```

## Expected

compilable (no type error)

I understand this is not compilable if I wrote like below

```typescript
type A = {
  foo: any;
};

function AParser(): z.ZodSchema<A> {
  return z.object({
    foo: z.any().optional()
  });
}
```

## Reproduce

https://codesandbox.io/s/zod-example-forked-8qnnq?file=/src/index.ts",,
1113451012,882,Discriminated unions execute parsing in all union sub-objects,"I'm not sure if this works as designed or not - I would expect a different behaviour though.
Consider the following [snippet](https://codesandbox.io/s/holy-violet-funks?file=/src/index.ts):
```ts
import * as zod from ""zod"";

const schema = zod.union([
  zod.object({
    flag: zod.literal(true),
    value: zod.string().min(1),
  }),
  zod.object({
    flag: zod.literal(false),
  }),
]);

console.log(
  schema.safeParse({
    flag: false,
    get value(): string {
      throw Error(`Should it get here?`);
    }
  })
);
```

This code throws an exception when executed. The model is valid if I remove the exception. However, the first part of the union shouldn't be run when the discriminator is `false`, should it?",,
1112965786,880,z.date documentation needed,"### Discussed in https://github.com/colinhacks/zod/discussions/879

<div type='discussions-op-text'>

<sup>Originally posted by **blocka** January 24, 2022</sup>
Very surprised that I could not find anything on this.

If I have a date schema `const schema = z.date()`  and I pass it a date string `schema.parse('2022-01-12T00:00:00.000Z')`
I would expect to get back a JS Date object. Instead I get an exception that I've passed a string instead of a date. ...</div>

There really should be some documentation in the README about how z.date works.",,
1112182514,878,Schema with either `strip()` or `passthrough()` throwing on unrecognized keys.,"Interestingly I have just started getting a weird scenario where `z.object({}).strip()` and `z.object({}).passthrough()` are both throwing errors on any unexpected keys.

This is causing a massive error stack when I try to parse `process.env` with the message:

```
""Expected never, received string""
```

```typescript

// A handful of similar passthrough schemas...
const RedisEnvSchema = z
  .object({
    REDIS_HOST: z.string().default(""queue.undetect.io""),
    REDIS_PORT: t.numberString().default(6379),
    REDIS_PASSWORD: z.string().optional()
  })
  .passthrough()

// Final strip schema...
export const EnvSchema = z.object({
  NODE_ENV: z.enum([""development"", ""test"", ""production""])
})
.merge(RedisEnvSchema)
.strip()


// Parse function...
export const parse = <Output, Input = Output>(
  packageName: string,
  schema: ZodSchema<Output, ZodObjectDef, Input>,
  defaultValues: Partial<Output> = {}
): Output => {
  try {
    return schema.parse({ ...defaultValues, ...process.env })
  } catch (error) {
    throw new EnvSchemaParseError(packageName, error)
  }
}


```",,
1108374917,871,"'constructor' key is ignored with strict(), passthrough()","This code doesn't throw:
```typescript
const person = z
  .object({
    name: z.string(),
  })
  .strict();

person.parse({
  name: ""bob dylan"",
  constructor: 61,
});
```

With other names, it throws. It is expected to throw with any property name.

It is also not being passed through (`.passthrough()`), so it's hard to prove that the library code actually receives such a property. But I think it does, since this is working:

```typescript
console.log(
  JSON.stringify({
    name: ""bob dylan"",
    constructor: 61,
  })
);

// outputs {""name"":""bob dylan"",""constructor"":61}
```",,
1108371215,870,class as argument for function schema,"Hello,

I was wondering how I can get my TS class as a argument to a function without having to recreate the class in zod.

```ts
class Something {
   public id: number
}

// Error
z.function().args(Something)
```

The actual argument will be a instance of Something

Thanks!",,
1108313995,869,Support composable schema with refinements,"Hi, 

Thanks for the work on this library, it's great and I'm looking to bring it into our development tool chain. I had a quick question about using `refine`. I'd like to compose validation together, preferably through spreading (in or order help TS). For example:

```ts
const dateRange =  z.object({
        min: z.date(),
        max: z.date()
    })
    // Useful validation that I'd like to keep alongside the schema definition
    // so whenever I use ""dateRange"" this validation will always be included
    .refine(({ min, max }) => min < max);

// Compose up one schema
const params = def.object({
    id: z.string(),
    ...dateRange // or ...dateRange.shape etc.
});

// Compose up another schema
const params2 = def.object({
    name: z.string(),
    ...dateRange.shape
});
```

I understand that refine returns `ZodEffect` which[ doesn't have the shape property](https://github.com/colinhacks/zod/issues/830#issuecomment-998850309), although I don't quite understand how refine potentially alters input / output, I thought it was additional validation only?

Perhaps `.merge` offers an alternative route. However using TypeScript I was unable to use `.merge` to enforce the required keys (see [this approach](https://github.com/colinhacks/zod/issues/858#issuecomment-1016632896) to how I'm enforcing types). 

I just wondered if there were any other suggestions I could try?

Thanks in advance",,
1107895809,866,Wrong error when using a union with strict objects,"I have two object types with one key each (with different names), and I want to parse an object and verify that it has one and only one of those keys. To do that, I created a union schema with two strict objects:

```ts
z.union([
  z.object({ a: z.number() }).strict(),
  z.object({ b: z.number() }).strict()
])
```

If I parse `{ a: 1 }` or `{ b: 1 }` it validates successfully as expected, and if I parse `{ c: 1 }` it gives an `invalid_union` error with the issue from both union elements in `unionErrors` as expected.

However if I parse `{ a: 1, b: 1 }` I don't get an `invalid_union` error. I instead get an `unrecognized_keys` error, i.e. the same error you would get if you parsed this directly with `z.object({ a: z.number() }).strict()`. I also see that in other to change this error message, I have to add an `errorMap` to the object schema, rather than the union schema. Since none of the object schemas match the input, I would expect to get an `invalid_union` here as well.

This makes it hard to get a useful error message for this use case.

It seems like what's happening is that when checking if any of the union schemas is valid, it doesn't consider them to be strict, then selects the first since it matches when it's not strict, and then applies strict afterwards?",,
1107482648,865,Minified ESM file produces giant messages on error,"![image](https://user-images.githubusercontent.com/55749227/150037898-a00d7f9f-6b84-4f0e-acea-42f96585f291.png)

Node gives me this massive error when something goes wrong, with Zod, taking away from the actual error itself. I tried using sourcemaps but that doesn't work either. I'm not sure why index.mjs is minified, can we remove the uglifying step from Rollup?
",,
1106494513,861,ZodSchema not strictly parsing union types,"I was trying to infer a ZodType from a well-defined typescript type:  e.g.

```ts
type Temp = {
 a?: string | null;
}
```

The following ZodType definition is considered as a valid ZodSchema type.

```ts
const guard: ZodSchema<Temp> = z.object({
 a: z.string();
})
```

What I am expected is it should throw an error like `ZodString` type is not assignable to `ZodOptional<ZodNullable<ZodString>>`

only 

```ts
const guard: ZodSchema<Temp> = z.object({
 a: z.string().nullable().optional();
})
```
Is strictly allowed.

Wondering whether this is by design or not?

Thanks~
",,
1105132805,859,[feature request] Add a refinement for precision-safe integers,"In order to encourage good practices on data integrity I believe that there should be a built-in refinement of `z.number().int().safe()` that makes a check of `Number.isSafeInteger()`. This way we would have an easy mean to check if the integer precision is not lost. 

This is especially important in cases where identifiers for data structures happen to be passed as `number` which sometimes takes place in data returned from JSON APIs.",,
1104986186,858,ZodObject not inferred when using ZodSchema,"I'm trying to extend a `ZodObject` schema which is bound to an existing interface with `ZodSchema`, however the schema is detected as `ZodType` which does not have the `extend()` method.

Is there some way to specify that the `ZodSchema` is specifically a `ZodObject`?

```typescript

const ActiveServiceModel: ZodSchema<ActiveService> = z.object({
  service_id: z.string(),
  team_id: z.string().uuid()
})

// This fails:
const ExtendedActiveServiceModel = ActiveServiceModel.extend({
  bar: z.string()
})

```

### Error Detail

```
TS2339: Property 'extend' does not exist on type 'ZodType '.
(ActiveServiceModel: z.ZodType<ActiveService, z.ZodTypeDef, ActiveService>)
```",,
1104904759,857,Object returning all properties as optional,"### Example Code

```typescript
export interface ActiveService {
  service_id: string
  team_id: string
}

export const ActiveServiceModel: ZodSchema<ActiveService> = z.object({
  service_id: z.string(),
  team_id: z.string().uuid()
})
```

### Error details

```
TS2322: Type 'ZodObject<{ service_id: ZodString; team_id: ZodString; }, ""strip"", ZodTypeAny, { service_id?: string; team_id?: string; }, { service_id?: string; team_id?: string; }>' is not assignable to type 'ZodType<ActiveService, ZodTypeDef, ActiveService>'. Â Â 

Types of property '_type' are incompatible. Â Â Â Â 

Type '{ service_id?: string; team_id?: string; }' is not assignable to type 'ActiveService'. Â Â Â Â Â Â 

Property ''team_id'' is optional in type '{ service_id?: string; team_id?: string; }' but required in type 'ActiveService'.

```

The same issue occurs when using `z.lazy(() => `.

It seems as though the for some reason the type inferred from `z.object()` assumes all optional properties. Is the the expected behaviour or is there change to the definition I need to make?



Additionally, it doesn't appear that `.shape` is available when binding a Zod Schema to an existing interface?
The following code works fine when not setting the type on the schema but begins to error when explicitly setting `ZodSchema<Foo>` 
```typescript
export const activeServiceColumns = Object.keys(
  ActiveServiceModel.shape
)

```

```
TS2339: Property 'shape' does not exist on type 'ZodType '.
```",,
1104693687,855,Helper type to infer errors from flattened `safeParse` error result.,"When using `flatten()` on error the result from `safeParse()`, it doesn't currently return type-safe `fieldErrors`, as it is typed with index signatures.

The idea is to provide an additional helper type similar to `z.infer`, but which provides a type-safe flattened error result type.

My current solution looks like this:

```ts
type inferSafeParseErrors<T extends z.ZodType<any, any, any>, U = string> = {
  formErrors: U[];
  fieldErrors: {
    [P in keyof z.infer<T>]?: U[];
  };
};
```

The name of the type is subject to change.

A use case for this is when doing form validation, where you want to have type safety and autocompletion around error types from validated fields. [See an example of this with form validation in Remix](https://gist.github.com/fnky/7fe414b402baf5c9ba8f7ddecfdd263e).",,
1102540422,854,UUID regex only validate Variant 1 UUIDs,"Hey everyone,

When I tried to use the UUID function to validate this UUID: **b3ce60f8-e8b9-40f5-1150-172ede56ff74** it returns invalid UUID, but it's a validate UUID. After digging into the source code, I found the reason.

Here is the regex we are currently using (v3.11.6) for validate uuid: 
``` javascript
const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
```
However the fourth part of the regex **[89ab][a-f0-9]{3}** only validate for Variant 1 UUIDs. 
[The definition of variant from Wikipedia](https://en.wikipedia.org/wiki/Universally_unique_identifier)

Not sure why the code limits the valid UUID to Variant 1 type?


",,
1102040680,853,Q: Partially execute a parse action,"So using vee-validate with zod for form validation brought up a thing with how zod is used in that context. So lets take a z.object({}) with some validation rules for fields. Since there is only .parse or .safeParse and so on for the whole object, this is always applied when the form validates no matter if all those values have been changed.
This brought up a problem with legacy data that might be not valid but also not changeable.
So my question is, is it possible to define a z.object({}) but then only parse certain elements of it like z.object({a, b}).parse(data, ['a']) something like that, so instead of form validation, field validation would be possible if there was a way to partially executing a schema.
One obstacle would remain though, handling refines that have a reference to a field that is not selected have to be handled too.",,
1100955590,852,Possible to extend or merge across a union? ,"Is it possible to extend or merge across a zod union? 

The use case I have here is that I have a polymorphic type which I store in a JSON field in my DB where I want to:
(a) represent the input I get which does not have an id on it
(b) represent what I get from the database, which now has an id on it

I've provided an example below - I tried a few other attempts without any luck. Please let me know if there's a way to do this - thank you!

```
// example:

const TestThing1 = z.object({
  type: z.literal('thing1'),
  // ... other properties not shared 
});
const TestThing2 = z.object({
  type: z.literal('thing2'),
  // ... other properties not shared 
});
const TestThing3 = z.object({
  type: z.literal('thing3'),
  // ... other properties not shared 
});

const ThingInput = z.union([TestThing1, TestThing2, TestThing3]);

const BaseThing = z.object({
  id: z.string().uuid(),
});
// I want to do something like this, but I get an error (see below)
const Thing = z.union([TestThing1, TestThing2, TestThing3].map(BaseThing.merge));

// Error 
Argument of type 'ZodObject<extendShape<{ id: ZodString; }, { type: ZodLiteral<""thing1"">; } | { type: ZodLiteral<""thing2"">; } | { type: ZodLiteral<""thing3"">; }>, ""strip"", ZodTypeAny, { ...; }, { ...; }>[]' is not assignable to parameter of type '[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
  Source provides no match for required element at position 0 in target.ts(2345)
```
",,
1099725583,850,Provide value to lazy callback,"Hey, first of all, thanks for Zod!

I'd like to access the value being validated inside a `lazy` callback, like this:

```ts
z.lazy((value) => {
  if (value) { 
    return z.object({
       ...
    })
  }
  return z.object({
    ...
  })
});
```

I can't use a zod union because there isn't a good way to use unions with Formik (https://github.com/robertLichtnow/zod-formik-adapter/issues/2).

This functionality would be similar to Yup's `lazy`: https://github.com/jquense/yup#lazyvalue-any--schema-lazy

Thanks!",,
1097172493,849,Parse in Date Object but  zod _.date() gives error,"I created a schema to validate a Date object
```
import {date, object} from ""zod""

const createFigureSchema = object({
  bornDate: date({
    required_error: `bornDate is required`,
  }).nullable(),
)};
```
However, when I make a POST request with request body below:
```
const createFigurePayload = {
  bornDate: new Date(""1925-07-11""),
}
```
It gives an error: `Expected Date, given string`

I tried to confirm the type of `bornDate` with `console.log(createFigurePayload.bornDate instanceof Date);`. It returns `true`. 

Need someone's help to explain why `_.date()` gives error despite parsing Date object!",,
1097107307,848,Ordered chaining for `.default()` values,"Hi, is it possible to have an ordered default value chain on a field with zod?

For now, I have only tried doing it this way, but it doesn't seem to work:
```ts
import env from ""env-var""

const schema = z.object({
    port: z.number()
        .default(env.get(""PORT"").asPortNumber()!)
        .default(env.get(""CONFIG.PORT"").asPortNumber()!)
        .default(4444)
})
```

Basically what I want to do here, is to assign 3 default values in an ordered way. So for example, if the `PORT` variable is `undefined | null` zod will try to default to `CONFIG.PORT`, if that's `undefined | null` too, the value default to `4444`.
```
[original field = undefined] --Try defaults--> undefined -> undefined -> 4444 (default)
```

If there's no default value at the end of the chain and the value from the previous matcher is `undefined | null` zod would throw an error.
```
[original field = undefined] --Try defaults--> undefined -> undefined -> ERROR (no default values)
```

Can this be achieved with zod?

Thanks!",,
1095465528,846,Help Needed: Hard time understanding Discriminated Union,"I'm having a hard time understanding how discriminated union work.

I have this schema bellow and I have a couple of conditions:
One is for the `workStatus` this is required. The user has 3 options, ""Full Time"", ""Contract"" and ""Both""
Now based on what the user selects we must display the appropriate fields
=> User selects ""Full Time"" then we need to request for `fullTimeCompensation` and `contractCompensation` should be undefined
=> User selects 'Contract"" then we need to request for 'contractCompensation` and `fullTimeCompensation` should be undefined
=> User selects 'Both"" then we need to request for `fullTimeCompensation` and 'contractCompensation`

The other condition is `workLocationType`, this is a required field and the user has two options, either ""Remote"" or ""Flexible""
If the user selects ""Flexible"" we need to as for field `acceptableTravelTime`, if user selects ""Remote"" then `acceptableTravelTime` should be undefined.

This is how I've defined my schemas

```ts  
  const workStatusEnumSchema = z.nativeEnum(Work_Status_Types_Enum, {
    errorMap: () => ({ message: formValidationMessages.format('fieldRequired') }),
  })
  const workLocationEnumSchema = z.nativeEnum(Work_Location_Types_Enum, {
    errorMap: (issue, _ctx) => {
      console.warn('issue', issue)
      console.warn('context', _ctx)
      return { message: formValidationMessages.format('fieldRequired') }
    },
  })
  const workVacationEnumSchema = z.nativeEnum(Work_Vacation_Durations_Enum, {
    errorMap: () => ({ message: formValidationMessages.format('fieldRequired') }),
  })
  const baseSchema = z.object({
    workStatus: workStatusEnumSchema,
    workLocationType: workLocationEnumSchema,
    vacationDuration: workVacationEnumSchema,
    address: z.string(),
    latitude: z.number(),
    longitude: z.number(),
    drivingToWork: z.boolean(),
    occasionallyTravelOffice: z.boolean(),
    relocateForWork: z.boolean(),
    visaSponsorShip: z.array(visaSponsorshipSchema),
    spokenLanguages: z.array(optionSchema),
  })

  const fullTimeSchema = baseSchema.extend({
    workStatus: z.literal(Work_Status_Types_Enum.FullTime),
    fullTimeCompensation: z.string({
      required_error: formValidationMessages.format('fieldRequired'),
    }),
    contractCompensation: z.undefined(),
  })

  const contractSchema = baseSchema.extend({
    workStatus: z.literal(Work_Status_Types_Enum.Contract),
    contractCompensation: z.string({
      required_error: formValidationMessages.format('fieldRequired'),
    }),
    fullTimeCompensation: z.undefined(),
  })

  const fullTimeContractSchema = baseSchema.extend({
    workStatus: z.literal(Work_Status_Types_Enum.FullTimeOrContract),
    contractCompensation: z.string({
      required_error: formValidationMessages.format('fieldRequired'),
    }),
    fullTimeCompensation: z.string({
      required_error: formValidationMessages.format('fieldRequired'),
    }),
  })

  const workStatusSchema = z.union([fullTimeSchema, contractSchema, fullTimeContractSchema])

  const flexibleSchema = baseSchema.extend({
    workLocationType: z.literal(Work_Location_Types_Enum.Flexible),
    acceptableTravelTime: z.string({
      required_error: formValidationMessages.format('fieldRequired'),
    }),
  })

  const remoteSchema = baseSchema.extend({
    workLocationType: z.literal(Work_Location_Types_Enum.Remote),
    acceptableTravelTime: z.undefined(),
  })

  const workLocationSchema = z.union([flexibleSchema, remoteSchema])

  const schema = z.union([baseSchema, workLocationSchema, workStatusSchema])

  type FormData = z.infer<typeof schema>
```

```ts
const methods = useForm<FormData>({
    mode: 'onBlur',
    reValidateMode: 'onBlur',
    defaultValues: {
      vacationDuration: '' as Work_Vacation_Durations_Enum,
      workLocationType: '' as Work_Location_Types_Enum,
      workStatus: '' as Work_Status_Types_Enum,
      address: '',
      drivingToWork: false,
      occasionallyTravelOffice: false,
      relocateForWork: false,
      visaSponsorShip: [],
      spokenLanguages: [
        buildSpokenLanguageOption(router.locale as string, spokenLanguagesMessages),
      ],
    },
    resolver: zodResolver(schema),
  })
```

At this point I have no errors in the schema nor in the default values.
However, in my `onSubmit` function which is defined as follow:
```ts
const onSubmit = async ({
    vacationDuration,
    workLocationType,
    workStatus,
    fullTimeCompensation,
    contractCompensation,
    acceptableTravelTime,
    address,
    latitude,
    longitude,
    drivingToWork,
    relocateForWork,
    visaSponsorShip,
    occasionallyTravelOffice,
    spokenLanguages,
  }: FormData): Promise<void> => {
    ...
}
```
But this clearly doesn't work. If a user selects 'Full Time"" then I get an error ""Expeted 'CONTRACT', received 'FULL_TIME'"", and in `fullTimeCompensation` if the user enters a value he get's an error ""Expected undefined, received 'string'"". Same thing if the user selects 'CONTRACT' and same behaviour for `workLocationType` if user selects something else other than ""REMOTE"" he will get the same error.

I'm not sure how  to create the schema for my use case :(

Any help would be greatly appreciated.",,
1093764878,844,CommonJS vs ESModules deployment issues : uglification,"# Remove uglification for `index.mjs`

## Problem

If we look into the `zod` dist in `node_modules` after installation, the files `node_modules/zod/index.js` and `node_modules/zod/index.mjs` should be very similar.

The esm module, however, has been minified and uglified. This caused an issue with my plugin (which I was able to make a workaround). But more importantly, it seems that we should reserve uglification and tree-shaking to the final build of the app, not as a npm module. 

## Solution

Just do the same as the regular `index.js` and don't minify and uglify.

I think it is as easy as removing this line:
https://github.com/colinhacks/zod/blob/73a9a628e8e3f512908b5f2b4116a87197f43407/rollup.config.js#L20


",,
1091952173,843,How to represent a React Componenet in Zod?,"Essentially I'm defining some types and I have no clue how to tell Zod that I want something to be a ReactNode, Element, ReactChild, etc. Any idea on how to do this?

ex.

```
const higherOrderComponent = z.object({
      childComponent: ????,
})
type HigherOrderComponent = z.infer<typeof higherOrderComponent>
```",,
1091666368,842,Missing documentation for `.required()`,"It seems like `.required()` is not documented but implemented, see https://github.com/colinhacks/zod/blob/db8adf289925321068e9d05210951569a18c3fe1/deno/lib/__tests__/partials.test.ts#L144",,
1085298269,834,DateType should be able to parse from other types,"Zod's DateType is fairly limited, it expects an existing Date object. This is most often not how they are sent over the internet, and therefore I believe that it should be able to parse inputs such as ISO timestamps, etc., which can usually be fed into the Date constructor.
Regarding UNIX epoch timestamps, I also believe that the user should have the choice of setting whether it is milliseconds or seconds, as the JS standard differs from the standards of other apps, which can have seconds as units.

I'd be fine implementing this myself, just would like to hear opinions on this.",,
1083837294,831,Mapping readonly array to Zod union  ,"Hi and thanks for Zod. It's been a joy to use. 

Being able to use the following would be even nicer, but it fails for a variety of hard-to-fix reasons...

```typescript
const items = [""a"",""b"",""c""] as const;
const unionSchema = z.union((items.map((item) => z.literal(item)));
```

I often use an `as const` array or object to simultaneously define types (guiding the compiler) AND sequences (used at runtime). 

For example in the toy case below, the `PRIORITIES` list defines the type of a `Priority` string, and can also be iterated to construct a dropdown menu for example. This is a common emerging pattern in typescript codebases. It can ensure that variants are defined once, and that none are missed in mapped types either at compile-time or runtime.

Defining a zod schema from an `as const` array hits a dead end for me. Perhaps it's impossible. Perhaps I am missing how to do this properly. If it's this hard, some kind of utility type could be needed.

# Problems

There are an interlocking set of problems...
* Zod not accepting `Readonly` definitions meaning the use of `as const` causes arguments to be rejected.
* the required arity of a union (at least two) meaning arrays of unknown length are not accepted - normally resolved by using readonly arrays with a known length
* a [weakness of typescript](https://github.com/microsoft/TypeScript/issues/44309), which can't keep the tuple nature when using e.g. map() 

# Solution: Utility Function

If a utility function was provided, I imagine overloaded signatures as follows...

```typescript
type ZodLiteralTuple<T extends readonly Primitive[]> = {
  readonly [K in keyof T]: ZodLiteral<T[K]>;
};

function createUnionSchema<T extends readonly []>(values: T): ZodNever;
function createUnionSchema<T extends readonly [Primitive]>(
  values: T
): ZodLiteral<T[0]>;
function createUnionSchema<
  T extends readonly [Primitive, Primitive, ...Primitive[]]
>(values: T): z.ZodUnion<ZodLiteralTuple<T>>;
```

Here, ZodLiteralTuple is a type to use as a type assertion after `Array.map`. It preserves tuple arity and projects each concrete literal found in T into a corresponding ZodUnionOptions datastructure. 

![image](https://user-images.githubusercontent.com/159819/146686024-e853dbc6-be11-4426-8f1b-6577b4ec9fcf.png)

## CASES 

* `createUnionSchema([])` should resolve to `z.never()`
* `createUnionSchema([""single""])` should return `z.literal(""single"")`
* `createUnionSchema([""first"",""second""])` should return `z.union([z.literal(""first""), z.literal(""second"")])`
* `createUnionSchema([""first"",""second"",""third""])` should return `z.union([z.literal(""first""), z.literal(""second""), , z.literal(""third"")])`

# Solution: Adding Readonly

Allowing the Readonly signature for arrays passed into all Zod functions would address one element of the issue. I can raise this as a PR.

# Reference Example

The toy example below is based on an experimental todo example. Here, keys for an index are a tuple,: task priority first, task due date second. Endpoint arguments will eventually need to validate the keys passed when paging the index, so we would like to have a schema for priority (a union of priorities), and compose it with a schema for date.

Each attempt hits some limitation, shown as a compiler error.

# FIRST ATTEMPT - DERIVE FROM as const TUPLE OF STRINGS

Here, because of a weakness preserving tuple nature, PRIORITY_SCHEMAS has an unknown length, so fails the union arity check.

```typescript
import { z } from ""zod"";

type Priority = typeof PRIORITIES[number];

const PRIORITIES = [""urgent"", ""soon"", ""normal"", ""backlog"", ""wishlist""] as const;

const DATE_SCHEMA = z.number();

/** Compiler error due to arity:
Argument of type 'ZodLiteral<""urgent"" | ""soon"" | ""normal"" | ""backlog"" | ""wishlist"">[]' is not assignable to parameter of type '[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
*/
const PRIORITY_SCHEMAS = z.union(PRIORITIES.map((priority) => z.literal(priority)))

const KEY_SCHEMA = z.tuple([PRIORITY_SCHEMAS, DATE_SCHEMA])
```

# SECOND ATTEMPT - DERIVE FROM  TUPLE OF SCHEMAS

Here, because of `z.union()` only accepting writeable arrays, it rejects a tuple defined with as const (`as const` ensures its length is known).

```typescript
import { z } from ""zod"";

type Priority = typeof PRIORITIES[number];

const PRIORITY_SCHEMAS = [
  z.literal(""urgent""),
  z.literal(""soon""),
  z.literal(""normal""),
  z.literal(""backlog""),
  z.literal(""wishlist""),
] as const;

const PRIORITIES = PRIORITY_SCHEMAS.map((schema) => schema.value);

const DATE_SCHEMA = z.number();

/** Compiler error:  The type 'readonly [ZodLiteral<""urgent"">, ZodLiteral<""soon"">, ZodLiteral<""normal"">, ZodLiteral<""backlog"">, ZodLiteral<""wishlist"">]' is 'readonly' and cannot be assigned to the mutable type '[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]' */
const PRIORITY_SCHEMA = z.union(PRIORITY_SCHEMAS);

const KEY_SCHEMA = z.tuple([PRIORITY_SCHEMA, DATE_SCHEMA]);
```

",,
1083747428,830,object.shape is undefined when a default is specificed,"Hello there. I have been messing around with zod and think it's quite useful. However, I have found that when using the default (and possibly other sub-methods on an object the shape property is lost.
Take this example;
```js
const object = z.object({
    test: z.string().default(""Hello World""),
});

const objectWithDefault = z.object({
    test: z.string().default(""Hello World""),
}).default({});

// Returns the the test object
console.log(object.shape.test);

// Shape is undefined and errors
console.log(objectWithDefault.shape.test);
```
The second one should behave much like the first. However, it does not.",,
1081997732,829,Missing `.exclude()` with functionality of `Exclude<>` in TS,"Hey, first of all thanks so much for the package!

As the title suggests I'm searching for a way to replicate the `Exclude<Type, ExcludedUnion>` functionality provided by TS ([docs](https://www.typescriptlang.org/docs/handbook/utility-types.html#excludetype-excludedunion)) using `zod`. I searched for ""exclude"" in issues and prs, but didn't find a single mention of this utility type (outside of internals), therefore I'm opening this issue.

My use case involves unions of many smaller action types, e.g.:
`type Actions = { type: ""added"", ... } |Â { type: ""removed"", ... } | { type: ""changed"", ... } |Â ... ;`
(or rather an equivalent `const Actions = z.union([ ... ]);` on which I'm using `z.infer`)

I need to retroactively exclude only a few specific actions from the main `Actions` type.

Using only TS, I can add a discriminator key such as `notA: true` to those few actions and then define:
`type ActionsOnlyA = Exclude<Actions, Actions & { notA: true }>;`

Using zod, I have to add a discriminator such as `isA: true` to a lot more actions to then use:
`const ActionsOnlyA = Actions.and(z.object({ isA: z.literal(true) }));`
(I still favor this over passing additional schemas for `ActionsOnlyA` from the definitions up to the root of the project due to the amount of code.)

Maybe I'm also missing an obvious way on how to get this behavior using the existing functionality... Any advice or comment is highly appreciated :)
",,
1081977076,828,Failed to parse source map,"Using zod: 3.11.6

We are having warning in `index.mjs`
```
WARNING in ./node_modules/zod/lib/index.mjs
Module Warning (from ./node_modules/source-map-loader/dist/cjs.js):
Failed to parse source map from 'C:\repos\Git\WorkZone\WZ-Teams\Source\tabs\node_modules\zod\src\types.ts' file: Error: ENOENT: no such file or directory, open 'C:\repos\Git\WorkZone\WZ-Teams\Source\tabs\node_modules\zod\src\types.ts'
```

apparently the referenced `src\types.ts` is not shipped with package, leading to such error.",,
1081062828,826,extending a z.object with a refinement,"I'm upgrading my zod 2 code to zod 3.

I have something like this

```
const form = z.object({}).refine(....)
```

where I use that refine to validate field X based on Y, etc.

in some other places in code, I take that z.object and add fields to it (base z.object represents a standard form, while custom forms sometimes require custom validation), so I had something like `return form.extend(....)`

However, once I add refine to the z.object, `extend` is no longer available (according to TS)

I scanned the migration guide, and didn't see anything mentioning this.",,
1075582116,820,Which is the correct way to structure a zod scheme to represent a form?,"Hi there,

maybe I'm using Zod in the incorrect way but I have two questions:

1) I need to represent a scheme where a field is a string and it's `required`. Required means that it's not null, not undefined, and must be at least 1 character length. As far as I see I need to declare the field with both `required_error` and `min(1)` to make it work because the default value of that field is `undefined` (that default value comes from backend)

```
const schema = z
        .object({
          name: z
            .string({
              required_error: ""The name field is required"",
            })
            .min(1, ""The name field is required""),
        })
```

Is there a way to express that with only 1 rule?

2) The second problem is that I would like to use the scheme to validate fields in the scheme without filtering others. It seems that Zod (when used with `react-hook-form`) removes fields that are not included inside the schema validation.

How can I do that?

",,
1073793219,817,Using union on array containing spreaded arrays,"Hello,
I'm trying to use z.union together with multiple arrays that would let's say come from different files.

Below is the example of my code, variable names are just for the purpose of the example.

```ts
import { z } from 'zod';

const array1 = [
  z.object({
    type: z.literal('TEST_1'),
  }),
];

const array2 = [
  z.object({
    type: z.literal('SOME_OTHER_ACTION'),
    payload: z.object({
      myNumber: z.number(),
    })
  }),
  z.object({
    type: z.literal('NOTHING'),
    payload: z.object({
      otherNumber: z.number(),
    })
  }),
  z.object({
    type: z.literal('HELLO'),
    payload: z.object({
      firstNumber: z.number(),
      secondNumber: z.number(),
    })
  }),
];

/*
  The below results in error (replaced ZodObject with ...):
  Argument of type '...' is not assignable to parameter of type '[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.
  Property '0' is optional in type '...' but required in type '[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]'.ts(2345)
*/
const wsMessagesParser = z.union([
  ...array1,
  ...array2,
]);
```

I guess this is to force users to provide at least 2 ZodTypeAny.
So for example doing something like this fixes the error mentioned above (or just anything that matches ZodTypeAny):
```ts
const wsMessagesParser = z.union([
  z.object({
    type: z.literal('DUMMY_1'),
  }),
  z.object({
    type: z.literal('DUMMY_2'),
  }),
  ...basicActionsPartial,
  ...inGameActionsPartial,
]);
```

Does anyone maybe have some proper way around this without the need of requiring those 2 dummies?",,
1073665428,815,Add input to the errors,"Given this example:

```ts
 {
    ""code"": ""not_multiple_of"",
    ""multipleOf"": 0.001,
    ""message"": ""Should be multiple of 0.001"",
    ""path"": [
      33,
      ""shepherdMgaFee""
    ]
  },
  {
    ""code"": ""not_multiple_of"",
    ""multipleOf"": 0.001,
    ""message"": ""Should be multiple of 0.001"",
    ""path"": [
      33,
      ""brokerCommission""
    ]
  },
```

It's very difficult to identify what the input was that caused this to error. Ideally, the errors would include the input that caused this to fail. For example:

```ts
 {
    ""code"": ""not_multiple_of"",
    ""multipleOf"": 0.001,
    ""message"": ""Should be multiple of 0.001"",
    ""path"": [
      33,
      ""shepherdMgaFee""
    ],
    ""input"": 1
  },
```",,
1073107324,814,Add file type,"Hi, as stated in contributing documentation, Im creating this issue to propose implementing ""ZodFile"" type. 

I have already implemented this in my project (I had to overwrite some types etc), and I could make PR with this.
In my current implementation, I have checks for size(min/max) and mime type, I'm open to suggestions to add something more.",,
1072351866,813,How to use `zod` in a clean architecture setup?,"Hi @colinhacks - great lib!

I would love to use this in our project but right now I am not clear on best to structure the code so that the entities do not end up directly depending on `zod`.

Ideally the core entities should not depend on anything, here since they are defined using a zod object that seems impossible?

Thanks again!",,
1071246457,812,Documentation for Custom Method,"I noticed that a `z.custom` method exists and works in schema validation. I also could not find any documentation on this feature, despite that it was personally very useful for me. 

I'd love to contribute (please note this would be my first open-source contribution)",,
1070264330,810,mergeArray in parseUtils can crash if array has empty elements,"Repro with Zod 3.11.6:-
```
import { z } from ""zod"";

console.log(""Checking schema"");
const ZSchema = z.object({
  nos: z.number().nullable().array().optional().nullable()
});

const nos = [];
nos[1] = 10;
const res = ZSchema.safeParse({
  nos
});
```

Error:-
```
TypeError: Cannot read properties of undefined (reading 'status')
    at Function.ParseStatus.mergeArray (https://yb77t.csb.app/node_modules/zod/lib/helpers/parseUtil.js:221:23)

    at ZodArray._parse (https://yb77t.csb.app/node_modules/zod/lib/types.js:1046:40)

    at ZodOptional._parse (https://yb77t.csb.app/node_modules/zod/lib/types.js:2418:36)

    at ZodNullable._parse (https://yb77t.csb.app/node_modules/zod/lib/types.js:2443:36)

    at ZodObject._parse (https://yb77t.csb.app/node_modules/zod/lib/types.js:1158:41)

    at ZodObject.ZodType._parseSync (https://yb77t.csb.app/node_modules/zod/lib/types.js:161:27)

    at ZodObject.ZodType.safeParse (https://yb77t.csb.app/node_modules/zod/lib/types.js:190:27)

    at $csb$eval (https://yb77t.csb.app/src/index.ts:15:19)

    at H (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:99995)

    at K.evaluate (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:112619)

    at ge.evaluateTranspiledModule (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:122966)

    at c (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:112234)

    at loadResources (https://yb77t.csb.app/index.html:3:2)

    at $csb$eval (https://yb77t.csb.app/index.html:9:3)

    at H (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:99995)

    at K.evaluate (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:112619)

    at ge.evaluateTranspiledModule (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:122966)

    at ge.evaluateModule (https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:122465)

    at https://codesandbox.io/static/js/sandbox.7e0c76a0e.js:1:314166

    at c (https://codesandbox.io/static/js/vendors~app~embed~sandbox~sandbox-startup.bcc15d438.chunk.js:1:3629)

    at Generator._invoke (https://codesandbox.io/static/js/vendors~app~embed~sandbox~sandbox-startup.bcc15d438.chunk.js:1:3382)

    at Generator.forEach.t.<computed> [as next] (https://codesandbox.io/static/js/vendors~app~embed~sandbox~sandbox-startup.bcc15d438.chunk.js:1:3986)

    at r (https://codesandbox.io/static/js/vendors~app~embed~sandbox~sandbox-startup.bcc15d438.chunk.js:1:206)

    at u (https://codesandbox.io/static/js/vendors~app~embed~sandbox~sandbox-startup.bcc15d438.chunk.js:1:417)
```


mergeArray in parseUtils:-
![image](https://user-images.githubusercontent.com/54072321/144555986-f9dede2c-d6ed-4e99-88c3-5073d5d9081a.png)

Code sandbox screenshot:-
![image](https://user-images.githubusercontent.com/54072321/144559110-a9b3c82a-7f34-47ca-8562-a05bc44af5d3.png)
",,
1070000025,808,Point-free `.parse` not possible since v3.9.0 â€“ a feature or a bug?,"Hi! 

Zod is an awesome project. And for a while I had code looking like this when parsing data from API endpoints:

```ts
import { z } from ""zod"";

type User = z.infer<typeof User>;
const User = z.object({
  name: z.string()
});

function getUser(): Promise<User> {
  return getUserFromApi().then(User.parse);
}

getUser()
  .then(
    // Use User
  )
  .catch(
    // Handle parsing error
  );
```

This is just a simplified example, but the idea is that `User.parse` is called by `.then` to parse whatever data is coming from the Promise. If `User.parse` throws an error, the whole thing results in a rejected Promise. Nice and simple and without the need to write `.then(user => User.parse(user))`.

However, since the release of v3.9.0, `.parse` cannot be used in a point-free way. An error is thrown inside Zod:

```
TypeError: Cannot read properties of undefined (reading 'safeParse')
```

Now, I want to ask if this behaviour is intentional or if it's a bug?

Disclaimers:
- I know that many people discourage point-free programming in JavaScript. It can be problematic, as the error above demonstrates, but I still happen to use the technique when I find that it simplifies my code.
- It's absolutely fine with me if this is not considered a bug. It's a small thing, and I'll keep using Zod even if I can't use `.parse` in a point-free way. I just wanted to make sure that I reported my findings.

I created a CodeSandbox that shows running code in v3.8.2, but if you change the version to v3.9.0 under ""Dependencies"", the example breaks: https://codesandbox.io/s/point-free-zod-parse-473q1?file=/src/index.ts

<img width=""303"" alt=""Screen Shot 2021-12-02 at 22 23 08"" src=""https://user-images.githubusercontent.com/4602382/144505233-0c0597bb-adaf-4e3b-af32-7cbb07df2c26.png"">

Finally, thank you for Zod. It's truly awesome ðŸ™ ",,
1069740622,807,Optional field specific validations,"Im generating schema from api data in runtime for validating in Formik.
Is there any possibility to add for egzample **max** to z.number only if it is not null on my config object?
I have no idea how to achive this.

My config object interface

```ts
interface ISurveyQuestion {
    questionId: number;
    title: string;
    subtitle: string | null;
    placeholder: string | null;
    description: string | null;
    imgUrl: string | null;
    hint: string | null;
    unit: string | null;
    inputType: ""number"" | ""checkbox"" | ""radio"" | ""select"" | ""date"";
    min: number | null;
    max: number | null;
    options: [ISurveyOption] | null;
}
```",,
1069179727,806,Make .parse an assertion function ,"```ts
const Post = z.object({slug: z.string()})

const thing = JSON.parse('{""slug"": ""hi""}')
// thing is any
Post.parse(thing)
// thing is {slug: string}
```

I realize that I could do `const thing = Post.parse(JSON.parse(...))` or make a second variable, but I don't really want to do that. My use case is in Remix.

Here's what I have to do now:

```ts
const data = LoaderData.parse(useLoaderData())
```

But some people are freaked out when they see me passing a hook call in an arguments list. So I'd prefer to be able to do this:

```ts
const data = useLoaderData()
LoaderData.parse(data)
```

But currently that leaves data as `any`.",,
1068488507,805,Missing `types` field to `exports` in package.json,"`exports` field in package.json should look like this:
```JSON
""exports"": {
    ""."": {
      ""require"": ""./lib/index.js"",
      ""import"": ""./lib/index.mjs"",
      ""types"": ""./lib/index.d.ts""
    },
    ""./package.json"": ""./package.json""
  }
```
Otherwise TypeScript (v4.6.0-dev.20211201) errors: `Could not find a declaration file for module 'zod'. 'REDACTED/node_modules/zod/lib/index.mjs' implicitly has an 'any' type.`. Apparently, TS ignores the root `types` field.

Could this be fixed?",,
1068412850,804,Consider adding `lenient()` option for string inputs,"I was in the process of migrating my existing [`yup`](https://github.com/jquense/yup) schemas to `zod` and found that the main sticking point is handling the parsing/validation of request path and query string parameters. Since they are typically considered raw strings and the parsing is left to the application level, `zod` doesn't really provide a great DX in these scenarios. Specially when compared to how `yup` does it out-of-the-box.

```js
// My existing `yup` schema
const schema = yup.object({ params: yup.object({ id: yup.number().required() }) })

// GET /user/42
// req -> { params: { id: '42' } }
schema.validateSync(req) // { params: { id: 42 } } -> Passes 
```

```js
// `zod` equivalent
const schema = z.object({ params: z.object({ id: z.number() }) })

// GET /user/42
// req -> { params: { id: '42' } }

schema.parse(req) // -> Fails

/*
Uncaught:
[
  {
    ""code"": ""invalid_type"",
    ""expected"": ""number"",
    ""received"": ""string"",
    ""path"": [
      ""params"",
      ""id""
    ],
    ""message"": ""Expected number, received string""
  }
]
*/
```

Which leads me to write custom `preprocess()` validators, along with custom error messages, for each expected type, every time. Here's an example for validating numerical strings.

```js
const DEFAULT_ZOD_NUMERICAL_PARAMS = Object.freeze({
  errorMap: (issue, _ctx) => {
    const message =
      issue.code === z.ZodIssueCode.invalid_type
        ? `Expected ${issue.expected}, received ${issue.received === 'string' ? `'${_ctx.data}'` : issue.received}`
        : _ctx.defaultError

    return { message }
  },
})

function numerical(params) {
  return z.preprocess(value => {
    const num = isNilOrEmpty(value) ? NaN : Number(value)
    return Number.isNaN(num) ? value : num
  }, z.number(params ?? DEFAULT_ZOD_NUMERICAL_PARAMS))
}

export default numerical
```

I know this has been [discussed before](https://github.com/colinhacks/zod/discussions/330#discussioncomment-656126), but having something close to a `.lenient()` parsing option, allowing for values to be internally coerced would be great.

```js
z.lenient(z.number()).parse('42') 
// 42
```

IMHO, this is such a common scenario when dealing with serialized data, that it only makes sense for a library such as this to support it without extra hassle. In addition, while the `.preprocess()` method above works, it **transfers the responsibility of the parsing to the user**,  which is arguably the main use case of `zod`. ",,
1067656754,802,Safe Parse on a ZodFunction,"Is there a way to do safeParse with a ZodFunction? I would like to avoid throwing errors

``` ts
const unknownData = 'foo' // could be from user input, or api, or somewhere else
const doSomethingSchema = z.function()
    .args( z.literal( 'hello' ) )
    .returns( z.literal( 'hello world' ) )

const doSomething = doSomethingSchema.implement( x => `${x} world` )
doSomething( 'hello' ) // => 'hello world' // works
doSomething( unknownData ) // throws error

// maybe something like this
const safeDoSomething = doSomethingSchema.safeImplement( x => `${x} world` )
safeDoSomething( 'hello' ) // => SafeParseSuccess // works
safeDoSomething( unknownData ) // => SafeParseError // doesn't throw error
```",,
1066309337,798,partial() doesn't work,"I use `userUpdateSchema` to make all fields optional and pass undefined `password` field but keep getting `Should be at least 3 characters` for `password` field. The schemas are bellow:


```typescript
export const userLoginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(3).max(20), // I send undefined for this field
});

export const userRegisterSchema = userLoginSchema.extend({
  name: z.string().min(3).max(15),
  username: z.string().min(3).max(15),
});

export const userUpdateSchema = userRegisterSchema
  .extend({
    avatar: isBrowser() ? z.instanceof(FileList) : z.any(),
  })
  .omit({ email: true })
  .partial(); // make all fields optional

...

const Settings: React.FC<Props> = ({ user }) => {

  const { register, handleSubmit, formState, watch, getValues } = useForm({
    resolver: zodResolver(userUpdateSchema), // use this schema
    defaultValues: {
      username: user.username,
      name: user.name,
      avatar: user.image,
      password: undefined, // like this, just submit initial values
    },
  });
```",,
1066138046,797,Object properties are all optional by default,"`import * as Zod from ""zod"";`

`const Dog = Zod.object({`
`name: Zod.string(),`
`age: Zod.number(),`
`});`
`type Dog = Zod.infer<typeof Dog>;`


Copied this code straight from the docs. The type of ""Dog"" is { name?: string, age?: number }. In the docs it says it should be { name: string, age: number }",,
1064747523,792,What is a good strategy to get a nice (nicer) error for invalid discriminated unions,"First of all: thanks for creating `zod` it is an awesome library.

Consider the following schema (contrived examples of course), and test. When you run this the error message is really long and hard for humans to grok. Note the schema has a discriminated union (the field `type` on each object is the discriminating field):

```typescript
import { z } from ""zod"";

const typeA = z.object({
    type: z.literal(""A""),
    prop1: z.string() 
})

const typeB = z.object({
    type: z.literal(""B""),
    prop2: z.string() 
})

const typeC = z.object({
    type: z.literal(""C""),
    prop3: z.string() 
})

const typeD = z.object({
    type: z.literal(""D""),
    prop4: z.string() 
})

const schema = z.object({ mytypes: z.union([typeA, typeB, typeC, typeD]).array() });

schema.parse({
    mytypes: [ 
        { type: ""A"", prop1: ""foo"" },
        { type: ""D"", bar: ""BAR"" } // misses prop4
    ]
});

```

<details>
  <summary>The long and hard to read error message</summary>
  
```
ZodError: [
  {
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""A"",
            ""received"": ""D"",
            ""path"": [
              ""mytypes"",
              1,
              ""type""
            ],
            ""message"": ""Expected A, received D""
          },
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""mytypes"",
              1,
              ""prop1""
            ],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""B"",
            ""received"": ""D"",
            ""path"": [
              ""mytypes"",
              1,
              ""type""
            ],
            ""message"": ""Expected B, received D""
          },
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""mytypes"",
              1,
              ""prop2""
            ],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""C"",
            ""received"": ""D"",
            ""path"": [
              ""mytypes"",
              1,
              ""type""
            ],
            ""message"": ""Expected C, received D""
          },
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""mytypes"",
              1,
              ""prop3""
            ],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""mytypes"",
              1,
              ""prop4""
            ],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      }
    ],
    ""path"": [
      ""mytypes"",
      1
    ],
    ""message"": ""Invalid input""
  }
]
    at new ZodError (/private/tmp/zodtest/node_modules/zod/src/ZodError.ts:140:5)
    at handleResult (/private/tmp/zodtest/node_modules/zod/src/types.ts:72:19)
    at ZodObject.ZodType.safeParse (/private/tmp/zodtest/node_modules/zod/src/types.ts:184:12)
    at ZodObject.ZodType.parse (/private/tmp/zodtest/node_modules/zod/src/types.ts:162:25)
    at Object.<anonymous> (/private/tmp/zodtest/index.ts:25:8)
    at Module._compile (node:internal/modules/cjs/loader:1101:14)
    at Module.m._compile (/private/tmp/zodtest/node_modules/ts-node/src/index.ts:1371:23)
    at Module._extensions..js (node:internal/modules/cjs/loader:1153:10)
    at Object.require.extensions.<computed> [as .ts] (/private/tmp/zodtest/node_modules/ts-node/src/index.ts:1374:12)
    at Module.load (node:internal/modules/cjs/loader:981:32) {
  issues: [
    {
      code: 'invalid_union',
      unionErrors: [Array],
      path: [Array],
      message: 'Invalid input'
    }
  ],
  format: [Function (anonymous)],
  addIssue: [Function (anonymous)],
  addIssues: [Function (anonymous)],
  flatten: [Function (anonymous)]
}
```
</details>

I've read [ERROR_HANDLING.md](https://github.com/colinhacks/zod/blob/master/ERROR_HANDLING.md) but I still struggle how to actually make a more proper error message (whithout a whole lot of ugly coding).

The error that I want to see is in the error message but hidden in the forest of other messages:

```
...
{
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""mytypes"",
              1,
              ""prop4""
            ],
            ""message"": ""Required""
 }
...
```

What is the best strategy to handle this? Any tips/pointer appreciated.

I'm on Zod 3.11.6. My actual use case, a CLI app that parses a DSL yaml, has even more possible types in the union, so the error message is really long and hard to read.",,
1064325574,791,How to configure the z.date() method?,"I'd like to define different messages shown when this field is empty and when the value is incorrect, however, the documentation doesn't mention that this is possible, nor have any attempts of mine worked.

Is it possible to configure the `.date()` method, and if so, how?",,
1064180886,790,inconsistent behavior with default and optional,"when default is used together with optional some things are allowed others not e.g:

```ts
declare function findConfig(): string | undefined;

string().optional().default(() => findConfig()) // is not allowed only ""string"" but..

declare function findConfigAsync(): Promise<string | undefined>;
string().promise().optional().default(() => findConfigAsync()) // is allowed because is wrapped into a ""Promise""
```

currently i have 3 scenarios
user provide the config
user doesn't provide the config, so i search and found one
user doesn't provide the config, so i search but i didn't find any

so even when i provide a default value this value could be undefined too (currently my workaround is using null)
```ts
declare function findConfig(): string | undefined;

string().nullable().default(() => findConfig() ?? null) // i can't change findConfig signature
```

i think default signature should allow undefined if the type allow it too",,
1064171199,789,add a repo to ecosystem,"I created a repository with zod, could be possible add it to the ecosystem section or any other place?

Repository:
https://github.com/mdbetancourt/soly

Npm:
https://www.npmjs.com/package/soly",,
1063702300,788,Schema only validating `.refine` when `object` passes.,"I'm using zod together with [react-hook-form](https://github.com/react-hook-form/react-hook-form) to create a user signup form. The schema is as follows: 
I am unsure as to whether this issue goes in [react-hook-form/resolvers](https://github.com/react-hook-form/resolvers) or here, so I am asking for support in both repos.


```
const schema = z
.object({
  name: z.string().nonempty('message'),
  email: z.string().nonempty('message').email('message'),
  password: edukPassword({ nonEmpty: 'message' }),
  confirmPassword: z.string(),
  cellphone: brazilianCellphoneNumber().nonempty('message'),
  privacyTermsAccepted: z.literal(true, {invalid_type_error: 'message',}),
})
.refine(({ password, confirmPassword }) => password === confirmPassword, {
  message: 'Passwords must match',
  path: ['confirmPassword'],
})

export const registerFormResolver = zodResolver(registerFormSchema)
```

The problem is, I am only getting an error on `.refine` when `.object` has passed. This results in the user not knowing they have entered an incorrect password confirmation until **after** they filled out the whole form.

Have I incorrectly built the schema for this useCase, or is the resolver incorrectly returning me formErrors?",,
1063365974,787,ZodObject with explicit type has an optional value can not be infered correctly after `omit` haven been called in Typescript.,"## Situation
When I define a custom ZodObjectType with explicit type, I found that this object can't not be infered correctly after `omit` haven been called in Typescript.

## Sample
```ts
import { z, ZodObject, ZodType } from ""zod"";

export type Guard<T extends Record<string, unknown>> = ZodObject<
  {
    [key in keyof T]: ZodType<T[key]>;
  }
>;

type User = {
    id: string,
    username: string,
    detail: string,
}

function testUser() {
    const userGuard: Guard<User> = z.object({
        id: z.string(),
        username: z.string(),
        detail: z.string(),
    });

    const omitUserGuard = userGuard.omit({ id: true, detail: true });

    console.log(""Omit UserGuard Shape:"")
    console.log(omitUserGuard.shape);
    console.log(""----------------"")
    console.log()
    console.log()

    console.log(""Username from Omit UserGuard:"")
    const { username } = omitUserGuard.parse({ username: 'Alex' });
    console.log(username)
    console.log(""-----------------------"")
}

type UserWithOptionalDetail = {
    id: string,
    username: string,
    detail?: string,
}

function testUserWithOptionalDetailGuard() {
    const userWithOptionalDetailGuard: Guard<UserWithOptionalDetail> = z.object({
        id: z.string(),
        username: z.string(),
        detail: z.string().optional()
    });

    const omitUserGuardWithOptionalDetail = userWithOptionalDetailGuard.omit({ id: true, detail: true })

    console.log(""Omit UserWithOptionalDetailGuard Shape:"")
    console.log(omitUserGuardWithOptionalDetail.shape)
    console.log(""---------------------------------------"");
    
    console.log()
    console.log()

    // this line of code will cause a problem: Property 'username' does not exist on type '{}'.
    const { username } = omitUserGuardWithOptionalDetail.parse({ username: 'Alex' })

    console.log(""Username from Omit UserWithOptionalDetailGuard:"")
    console.log(username)
    console.log(""-----------------------------------------"")
}

testUser()

console.log()
console.log()

testUserWithOptionalDetailGuard()
```
Both guards of the `User` and `UserWithOptionalDetail` type are correctly in console. but we can not build the typescript successfully.
![image](https://user-images.githubusercontent.com/10806653/143418511-0afe50fa-423c-4d09-aec8-490269fffe31.png)

Error message:
![image](https://user-images.githubusercontent.com/10806653/143417940-01228259-b9dd-4357-aa91-71e69ab3748e.png)

## Sample Code
you can reproduce the error by the source code below:
[typescript-playground.zip](https://github.com/colinhacks/zod/files/7601890/typescript-playground.zip)
```bash
npm i
sh ./run.sh
```

",,
1063295672,786,How to programmatically define the schema?,"Defining schema in a functional way is a very nice approach when the form model is known `z.string().max(...)`
However, I have a dynamic model, meaning my form can be of any type, and I need to validate it appropriately.
This means that I need to define the type and all the modifiers dynamically.

This doesn't look practical to me.
```ts
z[type][modifier1][modifier2]....
```

What other ways are there to achieve this requirement?",,
1062953827,785,Guarantee on self-compatibility within minor versions?,"This issue is a bit nebulous; my apologies that I don't have anything specifically actionable to list here. Feel free to close if this sort of commentary is not welcome.

When a library exports zod schemas, sometimes the consumers of those libraries will extend those schemas in various ways. For example, consider the following:

```
import { z } as ""zod"";
import { DocumentSchema } from ""library"";

const CreateDocument = z.object({ data: DocumentSchema, publishNow: z.boolean() });
```

In this scenario, what version of zod is safe for the consumer to import? Naively, we would think that something that matches the same minor version would be sufficient--that is, if the library has zod `^3.11.2` then the consumer can as well. However, this is not the case. Consider that when library was published, `3.11.2` was the latest published version of zod. But today, `^3.11.2` resolves to `3.11.6`, and this code fails to compile (because `DocumentSchema` is missing properties `describe` and `description`).

There are a few solutions here.

1. Zod guarantees that the `.d.ts` files never change without a corresponding change in minor version. I think this is best, because it most closely matches semver. There may be additional considerations beyond the `.d.ts` files as well, I'm not totally sure.
2. Any package exporting a zod schema must provide a corresponding `peerDependencies` for zod. This is suboptimal, because consumers of the library who only want to use the schema (not extend it) are now required to manually list zod as a dependency.
3. Any package exporting a zod schema needs to pin a precise zod version and document that consumers extending the zod schema must use the identical zod version. This is suboptimal because it requires these consumers to read the documentation ahead of time, lest they encounter strange errors when they do the natural `yarn add zod` and attempt to use it.
4. ~~export zod from the library.~~ This is a non-solution because it requires that the library is the ""one true zod"", which means it doesn't play nicely with other libraries.

Apologies again for not having anything more substantial. Hopefully this issue sparks some useful discussion that can lead to a working solution.",,
1061950950,782,schema.safeParse doesn't seem to have the appropriate signature.,"`zod`: `v3.11.6`
`TypeScript`: `v4.4.4`

I'm using `zod` to validate the body of my request. I expect to receive an email in the body.

Looking at the docs, I've created this:
```ts
const emailSchema = z.object({
      email: z.string().email(),
    })

    const result = emailSchema.safeParse({ email })
    if (!result.success) {
      res.status(400).json({ error: result.error.issues[0].message })
      return
    }
```

And according with the signature of `safeParse`, 
```ts
export declare type SafeParseSuccess<Output> = {
    success: true;
    data: Output;
};
export declare type SafeParseError<Input> = {
    success: false;
    error: ZodError<Input>;
};
export declare type SafeParseReturnType<Input, Output> = SafeParseSuccess<Output> | SafeParseError<Input>;
```
So it either returns a `SafeParseSuccess<Output>` if it validates successfully or `SafeParseError<Input>` if it fails.

However, when I try to return the message in the response, TypeScript get's mad, even though it returns the message
![image](https://user-images.githubusercontent.com/8176422/143164701-99aaffab-0476-4a2c-bb51-7941d5c5ec27.png)

I'm not sure what `safeParse` is supposed to to return. 

Any clarifications would be appreciated.",,
1061566213,781,"Required is not the default, or it is not behaving as I expect it to","The documentation states that all fields are required by default, however, that is not the case.

```ts
const validationSchema = z.object({
    name: z.string(),
  });
```

When tested, this schema performs the type check, but not the content check, which would be expected in order to validate if the required field is filled or not.
This results in success, although the value is an empty string: `console.log(validationSchema.safeParse({ name: '' }));`
",,
1061561547,780,"Doc: The ""required"" property on z.string() doesn't exist, it should be the ""required_error""","In the String documentation, there is this piece of code, however, these properties don't exist on the type for the string().
https://github.com/colinhacks/zod#strings
```ts
const name = z.string({
  required: ""Name is required"",
  invalid: ""Invalid name"",
});
```
The `required_error` and the `invalid_type_error` do exist, though.",,
1060117897,775,ZodObject.merge: pick & omit Mask only infers added properties,"Zod: 3.11.6 (issue same also in 3.9.8 from which I'v updated)

```ts
const A = z.object({
  b: z.boolean(),
  x: z.number()
})
const B = A.merge(
  z.object({
    y: z.number()
  })
)

// resulting type correctly inferred: {b: boolean; x: number; y: number}
type C = z.TypeOf<typeof C>
const C = B.omit({}) // Mask only infers ""y""

// resulting type correctly inferred: {b: boolean; x: number; y: number}
type D = z.TypeOf<typeof D>
const D = B.pick({}) // Mask only infers ""y""

type E = z.TypeOf<typeof E>
// resulting type correctly inferred: {b: boolean}
const E = B.pick({b: true}) // Mask only infers ""y""

type F = z.TypeOf<typeof F>
// resulting type correctly inferred: {x: number; y: number}
const F = B.omit({b: true}) // Mask only infers ""y""
```

There is no type error passing the `right` properties from `ZodObject` that was the merge source.

Might be an issue with the order of instantiation of generics. The result is correctly mapped over the props and fails when wrong properties are passed to mask.

I'd rate this minor issue though, since it kind of works, just worser completion in IDE.",,
1059176904,774,Optional key,"I'm working on a Zod schema for [Node package exports](https://nodejs.org/api/packages.html). Part of it looks like this:

```ts
export const ExportsCoreConditional = z.object({
  import: z.string().optional(),
  require: z.string().optional(),
  node: z.string().optional(),
  default: z.string().optional(),
})
```

The problem here is that the resulting type is e.g. `import?: string|undefined`. The actually correct type is `import?: string`. This is because a user will never be able to write `import: undefined` in their package.json file, since that is not valid JSON.",,
1058883258,772,Intersection with date field,"When schema with date field is used in intersection, parse fail with 
```json
{
          ""code"": ""invalid_intersection_types"",
          ""path"": [],
          ""message"": ""Intersection results could not be merged""
}
```

example:
```javascript
it('intersection with date', () => {
    const schema = z.object({
      date: z.date(),
    });

    const result = schema.and(schema).safeParse({
      date: new Date(),
    });

    expect(result.success).toBe(true);
});
```",,
1056297065,769,Documentation request: Why is `strict: true` required?,"I'd love more details here, because `strict` mode is actually just a collection of a bunch of other flags. If you can point me to the relevant parts of the code base I'd be happy to submit a PR for the README :)",,
1054346134,765,[Express.Request] Trying to type a req.locals field,"Hi! How are you?

I am trying to type an express `request.locals` field without success by the moment. I can see the types when I hover on the element but Typescript is complaining me.
Here in the images you can see the typing is correct (or I think so), but the VS Code is complaining.

`// request.locals.project seems to be ok`

![image](https://user-images.githubusercontent.com/45211582/141880853-06e93658-1371-4c3c-9f55-4b9219dc4c44.png)

But TS is complaining:

![image](https://user-images.githubusercontent.com/45211582/141880893-e9ac7d20-07e7-4491-b8f3-f0acdd726645.png)

Here is an exact copy of my code at this moment
```javascript
import express, { Request, Response } from 'express';
import { ParamsDictionary } from 'express-serve-static-core';
import { z, ZodType, ZodTypeDef } from 'zod';

const router = express.Router();

export type TypedRequestLocals<TLocals extends ZodType<any, ZodTypeDef, any>> = Request<
	ParamsDictionary,
	any,
	any,
	any,
	z.infer<TLocals>
>;

const projectData = z.object({
	id: z.string(),
	name: z.string(),
	days: z.number().min(1),
});
const base = z.object({
	locals: z.object({ project: projectData }),
});

router.route('/base').get(async (request: TypedRequestLocals<typeof base>, response: Response) => {
	const { project } = request.locals;

	return response.json({ project });
});
```

What my main goal is? To be able to type a `request.locals` object where I will store data related to the request.

Any clue? Thank you!",,
1054335791,764,`description` not presented in the `ProcessedCreateParams`,"According to the type sig, I'm expecting to retrieve my description set in the `RawCreateParams` previously.

```typescript
import { z } from 'zod'

const foo = z.string({ description: 'Foo' })
console.log(foo.description) // undefined in console
```

Then I check the code and find out that the processing function seems to [have no way passing the description data out](
https://github.com/colinhacks/zod/blob/72fa277a34970e542565c6d5630e7f451ff1e343/src/types.ts?_pjax=%23js-repo-pjax-container%3Afirst-of-type%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%3Afirst-of-type%2C%20%5Bdata-pjax-container%5D%3Afirst-of-type#L86-L103).

Is this a bug or I just miss something? Since I'm not really familiar with the codebase, just want to be sure before a PR.
",,
1052782972,762,zod object schemas being treated as partial,"The following example is using zod@3.11.6

```js
import { z } from 'zod'

const schema = z.object({
  type: z.string()
})

const foo = schema.parse(12)
```

This might be a bug with vscode (Version: 1.62.2), but when I hover over `foo`, it shows me that `foo.type` is optional:
<img width=""622"" alt=""Screen Shot 2021-11-13 at 14 42 31"" src=""https://user-images.githubusercontent.com/1906967/141659975-12d6ff98-e0f6-4524-9099-4b5a533c3838.png"">

The typescript cli (running `tsc`) doesn't complain about anything. So it's probably just something with vscode itself, but I wondered if maybe you might have some insight as to why that might happen so I can open the appropriate issue on their repo.
 ",,
1052278224,761,Make field optional if some other field is selected,"I have form and I'm using `react-hook-form` to validate the form. The validation mode is 'onBlur` meaning that every time a field loses focus we validate the field.

I'm trying to validate a schema where I have a `endDate` and this endDate can be optional if field `currentlyWorkingHere` is selected, otherwise it needs to be a valid date and needs to be greater than `startDate`

I've searched other issues and found this one: https://github.com/colinhacks/zod/issues/333 but it does not work with me

if I try to use 
```
endDate: z
      .date({
        invalid_type_error: 'Provide a valid end date',
        required_error: 'Provide a End date',
      })
      .optional()
      .refine((endDate) => endDate.getTime() <= Date.now(), {
        message:
          'End date cannot be in the future. Use the checkbox below if you still work at this position.',
      }),
```
Then as soon as the validation kicks (whenever a field loses focus) in I get this error
![image](https://user-images.githubusercontent.com/8176422/141515493-d3258677-f06f-49ec-b535-0731d8cbbe8b.png)

I'm assuming we cannot do a refinement on an optional field.

So I have to check whether or not `currentlyWorkingHere` is selected. If so, then `endDate` becomes optional, otherwise we need to check if `endDate` is greater than `startDate` and not greater than today. 

This is my schema:

```
const schema = z
  .object({
    companyName: z.string().nonempty({ message: 'Required field' }),
    focusArea: z.string().nonempty({ message: 'Required field' }),
    startDate: z.date({
      invalid_type_error: 'Provide a valid start date',
      required_error: 'Provide a Start date',
    }),
    endDate: z
      .date({
        invalid_type_error: 'Provide a valid end date',
        required_error: 'Provide a End date',
      })
      .refine((endDate) => endDate.getTime() <= Date.now(), {
        message:
          'End date cannot be in the future. Use the checkbox below if you still work at this position.',
      }),
    currentlyWorkingHere: z.boolean().optional(),
    technologies: z.array(z.string()).optional(),
    averageTeamSize: z.string().optional(),
    responsibilitiesSplit: z.number(),
    methodologies: z.array(z.string()).optional(),
    projectAspects: z.array(z.string()).optional(),
    teamLeadOf: z.string().optional(),
    coachOf: z.string().optional(),
    presentationAudience: z.string().optional(),
    presentations: z.string().optional(),
  })
  .refine(
    ({ startDate, endDate, currentlyWorkingHere }) =>
      !currentlyWorkingHere ? endDate.getTime() > startDate.getTime() : true,
    {
      message: 'End date must be posterior to Start date',
    }
  )
```
And the actual problem is that if I don't add a `endDate` and check `currentlyWorkingHere` and submit the form, then I get an error `Provide a valid end date` which is defined in the
```
.date({
        invalid_type_error: 'Provide a valid end date',
        required_error: 'Provide a End date',
      })
```

How can this be solved?

Thank you
",,
1051530975,759,"Conflict between .optional, .default and TypeScript types","My use case is where I'd like to input an empty object and have it filled with default values via `.default` - but when I have the code below:

```ts
import { z } from 'zod'

const schema = z.object({
  name: z.array(z.string()).default([])
})

type SchemaType = z.infer<typeof schema>

const input: SchemaType = {}  // TypeScript error here
const output = schema.parse(input)
console.log(output)
```
there is a typescript error:
```
Property 'name' is missing in type '{}' but required in type '{ name: string[]; }'.ts(2741)
```

So I added `.optional()` like so:

```ts
const schema = z.object({
  name: z.array(z.string()).default([]).optional()
})
```
but the output is the empty object and it seemingly ignores `.default`:
```
{}
```

How would I be able to accomplish my goal of assigning types of the input, while having the `.default` work as I intend it to? It works if I remove `:SchemaType` but I'd really prefer to have types assigned",,
1050016264,757,All properties are NOT required by default on inferred type,"I am following the README, at this point

https://github.com/colinhacks/zod#objects

an example is provided stating that ""all properties are required by default"", but when inspecting the inferred types I see that all properties are **optional** instead.

Minimal reproducible example (zod v 3.11.6)
https://stackblitz.com/edit/react-ts-eihrxu

Hover on line 18 on `DogType`

I can see the inferred type as:

```
type DogType = {
    name?: string;
    age?: number;
}
```
when instead, accordingly to the doc should be:

```
type DogType = {
    name: string;
    age: number;
}
```

Questions:

- Is the document correct/updated?
- How to make sure the properties are not inferred as optional? If you would provide a working sample I would appreciate it

Thanks for your time and great work on zod!
",,
1047591749,755,How to validate an enum inside a schema,"I'm using zod alongside react-hook-form and I need to validate when the user submits the form that the data matches my schema.

I have a plugin to generate GraphQL types, queries and mutation and it generates this enum
```
export enum Audience_Range_Enum {
  ElevenTwenty = 'ELEVEN_TWENTY',
  FiftyOneOneHundred = 'FIFTY_ONE_ONE_HUNDRED',
  None = 'NONE',
  OneHundredOnePlus = 'ONE_HUNDRED_ONE_PLUS',
  OneTen = 'ONE_TEN',
  TwentyOneFifty = 'TWENTY_ONE_FIFTY'
}
```
And when the user selects an option this is what he'll be passing. 

So I have this schema
```
const schema = z
  .object({
    teamLeadOf: z.string().optional(),
    coachOf: z.string().optional(),
  })
```

And instead of using `z.string()` I'd need to check if it's a value of `Audience_Range_Enum`. How can I check this in the schema? Is it possible?

I've checked the doc and the only examples with `z.enum()` or `z.nativeEnum()` are used outside of the schema.

Thank you",,
1047495636,754,Customizing array validation messages,"Currently, `.array()` schema does not receives any arguments. It would be nice if it could accept `RawCreateParams` so we can customize their error messages. For example,

```ts
const schema = z.array(
  {
    required_error: 'This is required',
    invalid_type_error: 'This must be an array',
  },
);
```",,
1046894705,753,How to reference another key,"Hi,

I'm in the process of replacing Joi with zod and I'd like to know how I could solve this issue. I need to check if the endDate is either after the start date or before the current date. Something like this => `endDate` > `startDate` && `endDate` <= `new Date()`

This is what I have right now in Joi.

I'd like to know if there's a way in zod to reference a key

```
const schema = Joi.object({
  companyName: Joi.string().required().messages({
    'string.empty': 'Required field',
    'any.empty': 'Required field',
  }),
  focusArea: Joi.string().required().messages({
    'string.empty': 'Required field',
    'any.empty': 'Required field',
  }),
  startDate: Joi.date().timestamp().required().messages({
    'date.invalid': 'a valid date',
    'date.empty': 'Required field',
    'any.empty': 'Required field',
  }),
  endDate: Joi.date().timestamp().min(Joi.ref('startDate')).max(new Date()).required().messages({
    'date.empty': 'Required field',
    'any.empty': 'Required field',
  }),
})
```

Thank you",,
1046317045,751,Record types should be partial,"I love that in v3.9 we can now specify the type of the record key using enums or literals.

But the inferred `Record` type now needs to be wrapped in `Partial`, otherwise typescript forces us to specify every key, which is inconsistent with how the Zod parser interprets the same schema.

For example, suppose we create a schema that allows us to map states to temperatures:

```ts
const Weather = z.object({
    temperatures: z.record(z.enum(['VT', 'NH', 'CA', 'AZ']), z.enum(['warm', 'cold']))
});
```

If we map a couple of states, it parses fine. This parses without throwing:

```ts
Weather.parse({ temperatures: {VT: 'cold', CA: 'warm'} });
```

But if we try to use the inferred type with the same object, typescript is not happy:

```ts
type Weather = z.infer<typeof Weather>;
const weather: Weather = { temperatures: {VT: 'cold', CA: 'warm'} };
```

This gives us this error:

```ts
Type '{ VT: ""cold""; CA: ""warm""; }' is missing the following properties from type
'Record<""VT"" | ""NH"" | ""CA"" | ""AZ"", ""warm"" | ""cold"">': NH, AZ
types.d.ts(639, 124)
```

It wants us to specify all the states in the enum, which is not intuitive or useful, and is inconsistent with the Zod parser.",,
1046245666,750,Expose partial and other object methods when used inside of lazy,"When using lazy for an object:
```ts
z.lazy(() => z.object({a: z.number() }) );
```

Expected to have `.partial` and other object schema methods exposed. 

Possible alternative is to unfurl the schema, so having some method that'd return the schema within the lazy function


```ts
const schema = z.lazy(() => z.object({a: z.number() }) );
schema.unfurl()  // z.object({a: z.number() })
```",,
1046108555,749,`.strict()` behaves in unexpected ways when intersected,"For example, I would expect this to work
```ts
const schema = z.intersection(
    z.object({a: z.string()}).strict(),
    z.object({b: z.string()}).strict(),
);

const result = schema.safeParse({a: 'asdf', b: 'asdf'});
```

But instead I get parse errors
```ts
""message"": ""Unrecognized key(s) in object: 'b'""
""message"": ""Unrecognized key(s) in object: 'a'""
```


My full use case is to get this schema to work. Maybe there's a way I can restructure it to get my desired schema (with `strict`)?
```ts
    const schema = z.intersection(
        z.strictObject({a: z.string()}),
        z.union([
            z.strictObject({
                kind: z.literal('dog'),
                b: z.string(),
            }),
            z.strictObject({
                kind: z.literal('cat'),
                c: z.string(),
            }),
        ]),
    );
```",,
1044591539,748,String to number with further chaining,"Thank you for great library, could you suggest how to solve next use-case:

I want to validate query parameters like `?limit=1`, so I want to transform string to number, filter if it's NaN, then use `.gte(1)` and `.lte(100)`.

Is this possible with `zod`?

I've seen this issue, but still this isn't clean: https://github.com/colinhacks/zod/issues/42

I tried to monkey-patch number implementation, but all properties are { configurable: false, writable: false }",,
1043599033,746,Recommended practice for literal error messages?,"At the moment, I'm using 
`terms: z.boolean().refine(value => value, 'You must accept terms and conditions.'),`
Since, as I understand, custom error messages are not yet supported for `z.literal(true)`
Is this the recommended practice or is there another, more practical way?",,
1043147298,744,Missing documentation for ZodArray .element,There seem to be no documentation for the `.element` property of `ZodArray` that selects the schema for its elements.,,
1041085597,741,bug: wrong inferred types when combining transform and refine,"# Description

The inferred types in `.refine()` callback match the inferred return type of previous `transform` (`Date`) but during runtime the raw untransformed value is passed to the `refine` callback

## Example 1:

```ts
const zoddate = () => z
        .string()
        .transform((s) => parseISO(s));
        .refine((d) => d.toString() !== 'Invalid Date', { // `d` has the inferred type `Date`, but is actually the raw string during runtime
            message: 'invalid date',
        })
```
## Workaround 1:

```ts
const zoddate = () => z
        .string()
        .refine((d) => parseISO(d).toString() !== 'Invalid Date', {
            message: 'Invalid date',
        })
        .transform((s) => parseISO(s));
```

## Example 2
```ts
export const QuerySchema = z
    .object({
        date_start: zoddate(),
        date_end: zoddate(),
    })
    .refine(({ date_start, date_end }) => {
        const start = startOfDay(date_start); // runtime error: `startOfDay` only accepts `Date` but during runtime the type is `string`
        const end = startOfDay(date_end); // runtime error: `startOfDay` only accepts `Date` but during runtime the type is `string`
        return isAfter(end, start);
    }, 'date_end must be after date_start')
```

## Workaround 2
```ts
export const QuerySchema = z
    .object({
        date_start: zoddate(),
        date_end: zoddate(),
    })
    .refine(({ date_start, date_end }) => {
        // workaround by typecasting as any
        const start = startOfDay(parseISO(date_start as any));
        const end = startOfDay(parseISO(date_end as any));
        return isAfter(end, start);
    }, 'date_end must be after date_start')
```

# Versions
zod ^3.10.0
typescript ^4.4.3
",,
1040438777,740,"z.set should have ""nonempty"" method, just like z.array",The title says it all,,
1039602313,739,Array of objects with some of them literals,"How are you? I'm thinking about the following validation with zod and I have no clue on how to do it (or if it's possible with zod).
I want an array of objects, all with the same shape of course with some of them with literal props, I need these always present in the array.

Example:
I need always in the array the objects those with name required1 and required2, and then other objects optionals following the same shape.

```javascript
[
    {
      name: z.literal('required1'),
      otherprop: z.number()
    },
    {
      name: z.literal('required2'),
      otherprop: z.number()
    },
    // I want to include one or more of the following too.
    {
      name: z.string(),
      otherprop: z.number()
    },
]
```

This other example will throw because required2 is missing
```javascript
[
    {
      name: z.literal('required1'),
      otherprop: z.number()
    },
    // I want to include one or more of the following too.
    {
      name: z.string(),
      otherprop: z.number()
    },
]
```

Any clue?

Thanks.",,
1038415176,738,No exported member 'ParseParamsNoData',"Hi,

Currently I use Zod with React Hook Form as validation schema. However when building code for production usage, I got this error:

**tsc && vite build

node_modules/@hookform/resolvers/zod/dist/types.d.ts:3:100 - error TS2694: Namespace '""/home/node_modules/zod/lib/external""' has no exported member 'ParseParamsNoData'.

export declare type Resolver = <T extends z.Schema<any, any>>(schema: T, schemaOptions?: Partial<z.ParseParamsNoData>, factoryOptions?: {

Found 1 error.**


Zod version is 3.11.6
React-hook-form 7.17.2
@hookform/resolvers 2.8.2",,
1037969830,737,ISO Timestamp,"I'm dealing with some data coming over the wire that includes date time info:

```ts
created_at: '2021-10-28T00:06:29.647Z',
updated_at: '2021-10-28T00:07:05.489Z',
```
Would it make sense for `zod` to have a `z.string().timestamp()` kind of validator for this?

Also would it make sense for `zod` to parse those strings into dates? Could/Should transformers do that I guess?
",,
1037967234,736,add jsdoc,"<img width=""849"" alt=""CleanShot 2021-10-27 at 20 24 03@2x"" src=""https://user-images.githubusercontent.com/284476/139165862-422ab562-2594-41e9-959a-ecc0a7e71726.png"">

In the above it would be nice to know more about what `email` is. I think it means that it will validate for a valid email. However there is also `isEmail`. Generally JSDoc would be great for docs.

Also, if you rely on https://paka.dev/npm/zod for your docs then you'll get to re-use your JSDoc for your website doc. Full disclaimer I am the co-creator of Paka.

-- edit: Oh looks like docs extraction for Zod on Paka is broken, I'll look into that. For a working example you can check out https://paka.dev/npm/nexus.",,
1037109200,734,Successive `refine` behave differently since 3.10.3,"Hello,

Since 3.10.3, all successive `refine` are being called, even when they return false.
For instance:
```javascript
import { z } from ""zod"";

const schema = z
  .string()
  .refine((value) => {
    console.log(""refine1 value"", value);
    return false;
  })
  .refine((value) => {
    console.log(""refine2 value"", value);
    return true;
  })
  .refine((value) => {
    console.log(""refine3 value"", value);
    return true;
  });

console.log(schema.safeParse(""a"").success);
```

was displaying in 3.9.8:
```
refine1 value a
false
```

but since 3.10.3 is displaying:
```
refine1 value a
refine2 value a
refine3 value a
false
```",,
1037056999,733,Tool using Zod check it out,https://github.com/miketamis/mimus-ts,,
1035868785,731,safeParseAsync error type is not generic,"Apologies if this has been discussed before, I wasn't able to find any existing issues.

In the definition for `safeParse`, the error type is `ZodError<Input>`, whereas for `safeParseAsync`, the type is `ZodError`. Is there any reason that prevents it from returning the same type that `safeParse` does?

```typescript
safeParse: (data: unknown, params?: Partial<ParseParamsNoData>) => {
    success: true;
    data: Output;
} | {
    success: false;
    error: ZodError<Input>;
};
safeParseAsync: (x: unknown, params?: Partial<ParseParamsNoData>) => Promise<{
    success: true;
    data: Output;
} | {
    success: false;
    error: ZodError;
}>;
```",,
1035449960,729,"An optional field that becomes required if a ""type"" field matches it's value","Thank you so much for building a fantastic library, @colinhacks. I'm a huge fan!

I have a schema that looks like this:

```js
ActivitySchema = z.object({
  amount: z.number(),
  type: z.enum[""deposit"", ""withdrawal""],
  deposit: z.object({ ... }).optional(),
  withdrawal: z.object({ ... }).optional(),
})
```

I'd like the `deposit` key to become required if `type == deposit` , and for the `withdrawal` key to become required if `type == withdrawal`. 

I hoped `.refine` might do the trick, but it doesn't work as I expected â€” both keys become required to parse successfully:

```js
ActivitySchema = z.object({
  amount: z.number(),
  type: z.enum([""deposit"", ""withdrawal""]),
  deposit: z.object({}).refine((d) => d.type == ""deposit"" && (""deposit"" in d)),
  withdrawal: z.object({}).refine((d) => d.type == ""withdrawal"" && (""withdrawal"" in d)),
})
```",,
1034833098,728,Support for frozen/readonly,"I would like to have a way to declare an object with the following restrictions:
- All properties of the inferred type should be (recursively) `readonly`
- Parsing an object should (recursively) `freeze` it

```ts
import * as z from ""zod"";

export const Vector2 = z.frozenObject({
  x: z.number(),
  y: z.number(),
});

export type Vector2 = z.infer<typeof Vector2>;

const foo: Vector2 = { x: 1, y: 2 };

// the following should not be allowed by the compiler
foo.x = 42;

const bar = Vector2.parse('{ ""x"": 1, ""y"": 2 }');

// the following should not be allowed by the compiler and throw at runtime (because the object is frozen)
bar.x = 42;
```",,
1034446558,726,Wrong tagged version on github,"Github has https://github.com/colinhacks/zod/releases/tag/v3.11.3 tagged and npm has https://www.npmjs.com/package/zod/v/3.11.2 

Would be great if you could fix this.",,
1034183586,725,Strip array elements that don't pass validation ,"Is there a way to make array validation work similarly to object? That is stripping all elements that don't match validation criteria instead of throwing an error. Example:

```js
const numberArray = z.array(z.number());
numberArray.parse([1, ""2"", 3, false]); // [1, 3]
```
I realize this is different from object's strip() method, which would only strip unrecognized keys, but array is in essence an object with numbered keys, so we already allow ""all keys"", which make standard array validation work like object with strict(). Having an option to filter away invalid array values would be really convenient. ",,
1031542187,718,How to do t.Mixed and t.UnknownType from io-ts in Zod?,"Hi! I am migrating a codebase from io-ts to Zod (much better API!). I am having some trouble figuring out how to recreate this io-ts type signature in Zod:

```ts
const Request = {
  async make(
    returnType: t.Mixed | t.UnknownType,
    method: HttpMethod,
    ...
  )
  ...
}
```

I'm not sure which Zod methods to use. `z.any() | z.unknown()` seems to make TS really angry in a way that `t.Mixed` does not:

```
This expression is not callable.
  Type '{ make(returnType: any): any; }' has no call signatures.ts(2349)
```",,
1030398681,717,Zod 3.10.1 not returning default values when schema uses `refine`,"Hey,

I'm experiencing the following issue with Zod 3.10.1: the `parse` is not returning the default values when the schema uses `refine`.

Here's the code to reproduce the issue:

```js
const { deepEqual } = require('assert');
const { z } = require('zod');

const schema = z
  .object({
    a: z.string().default('foo'),
    b: z.number()
  })
  .refine(({ b }) => b > 0);

const result = schema.parse({ b: 1 });

deepEqual(result, { a: 'foo', b: 1 });
```",,
1030257341,716,`preprocess` result seems to not get passed to `refine` calls starting from the second one,"The issue is relevant for v 3.10.1

When I have a schema with `preprocess` configuration + two `refine`s, the first refine gets the processed model, whereas the second one receives the original one:
```ts
import * as zod from ""zod"";

const schema = zod
  .object({
    failureReasons: zod.preprocess(
      (val) => [val],
      zod.array(zod.object({ isDescriptionRequired: zod.boolean() }))
    )
  })
  .refine(({ failureReasons }) => {
    console.log(JSON.stringify(failureReasons));
    return failureReasons.length > 0;
  })
  .refine(({ failureReasons }) => {
    console.log(JSON.stringify(failureReasons));
    return failureReasons.some((reason) => reason.isDescriptionRequired);
  });

console.log(
  schema.safeParse({
    failureReasons: { isDescriptionRequired: false }
  })
);

// Output:
// [{""isDescriptionRequired"":false}] 
// {""isDescriptionRequired"":false} 
// Error in sandbox: 
// TypeError: failureReasons.some is not a function
```
If I remove the first `refine`, the error disappears.
[Sandbox](https://codesandbox.io/s/crazy-water-2iqkl?file=/src/index.ts)",,
1030255178,715,[BUG] Type instantiation is excessively deep and possibly infinite on latest TypeScript 4.5,"There is a new issue that appeared in TypeScript 4.5.0-dev.20211001 and exists until now.

To reproduce the error:

```bash
npm init -y
npm add zod
npm add -D typescript@next
echo 'import { z } from ""zod"";' > main.ts
echo '{""compilerOptions"":{""lib"":[""es2020""]},""include"":[""main.ts""]}' > tsconfig.json
npx tsc -p .
```

TypeScript output:

```
node_modules/zod/lib/helpers/partialUtil.d.ts:4:29 - error TS2589: Type instantiation is excessively deep and possibly infinite.

4         [k in keyof Shape]: ZodOptional<DeepPartial<Shape[k]>>;
                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Found 1 error.
```

It affects the latest Zod (3.10.1), and also any other 3.x version. The issue appeared in https://github.com/microsoft/TypeScript/pull/41821 (producing a memory error), and later a check was added in https://github.com/microsoft/TypeScript/pull/46326 to prevent the infinite loop and give a meaningful message.

This is the same issue as #689 except that now we have an error message.

Demo code: https://github.com/mmvsk/zod-issue-715",,
1029568789,714,Zod 3.10.x is broken on node 12,"Repro:

```bash
$ docker run -ti --rm --entrypoint sh node:12-slim -c ""npm i zod@3.10.1 && node -e \""require('zod').number().parse('5')\""""

...

/node_modules/zod/lib/types.js:82
            path: params?.path || [],
                         ^

SyntaxError: Unexpected token '.'
    at wrapSafe (internal/modules/cjs/loader.js:915:16)
    at Module._compile (internal/modules/cjs/loader.js:963:27)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1027:10)
    at Module.load (internal/modules/cjs/loader.js:863:32)
```",,
1029126471,713,`refine` acts inconsistently in 3.10,"Upon 3.10 the following [example](https://codesandbox.io/s/cold-cdn-d2sou?file=/src/index.ts) gives a false positive result:
```ts
const objectSchema = zod
  .object({
    length: zod.number(),
    size: zod.number()
  })
  .refine(({ length }) => length > 5, {
    path: [""length""],
    message: ""length greater than 5""
  })
  .refine(({ size }) => size > 7, {
    path: [""size""],
    message: ""size greater than 7""
  });

console.log(
  objectSchema.safeParse({
    length: 4,
    size: 8
  })
);          // { success: true, ...
```
The first `refine` (for `length`) is being ignored.",,
1027138160,709,Check value against another value in schema,"Maybe I missed it but is there a way to check the value of one property of the object against the value of another property of the same object? Like below,

```
const schema = z.object({
  lower: z.number(),
  upper: z.number()    // Check this value is greater than lower
})
```",,
1023508962,706,Infer'd Type's properties are optional,"Hi,

I am new to using this lib, so hopefully this is something simple that I have misunderstood. I am trying to extract an inferred type from an object, I am not declaring that any of the properties are optional, but the returned type suggests all the properties are optional (as if I was using the `Partial` utility).



![image](https://user-images.githubusercontent.com/8988409/136825402-916d8fa8-92a5-4b63-aefb-e61268cfbae3.png)
Above is what I see when I copy the example in the docs.

If it helps, my version of TS is `4.4.3` and my version of Zod is `3.9.8`
",,
1023378118,705,Unused dependency `cowsay` introduce a vulnerability in zod 3.10 beta,"Installing zod@beta introduce a moderate severity vulnerability due to a faulty version of `ansi-regex`, that was introduced with the (apparently) unused dependency on `cowsay`.

It was introduced in the following commit: `3a4bf8db56db49f15cbe83d8e5c2bbfa9544b8c6`.

To reproduce:

```bash
npm init -y
npm add zod@beta
npm audit
```

Grep'ing cowsay in the project source doesn't show any use of `cowsay`.",,
1023373911,704,Can't call .pick() on object().refine(),"In version 1.x I could have this schema:

```ts
const validator = z.object({ something: z.boolean() }).refine(v => !!v);

validator.pick({ something: true });
```

Using zod `3.9.8` I get `TypeError: validator.pick is not a function`. How can I achieve the same thing?",,
1022884148,703,Zod loose instanceof with react-hook-forms,"Hey,

Having the following zod schema

```tsx
const eventCreateWizardStep1Schema = z.object({
  name: z.string().min(3),
  themeAndCover: z.object({
    theme: z.nativeEnum(EventTheme),
    cover: z.instanceof(File),
  }),
```


Use like this in my react-hook-forms:

```tsx
 const { setFields, fields } = useEventCreateWizard();

  const { formState, control, watch, getValues } = useForm({
    resolver: zodResolver(eventCreateWizardStep1Schema),
    mode: ""all"",
    defaultValues: {
      name: fields.name,
      themeAndCover: {
        cover: fields.cover,
        theme: fields.theme,
      },
    },
  });
```


fields.cover is an instanceOf `File` 

After pass through useForm, getting following data:
![Ionic App - Google Chrome_2](https://user-images.githubusercontent.com/284379/136821150-bd45366a-ea46-4585-8217-8cdb7201dc42.jpg)

Making image broken with `URL.createObjectFromUrl` 

Thanks for help <3 

",,
1022710918,702,`ZodNumber.step` does not use the same logic as number input `step`,"This implementation fails with cases like the following:

`23.9 % 0.01 = 0.009999999999998082`

_(the client enters a price, that must have at max 2 decimal places, = step(0.01))_

https://stackoverflow.com/questions/7037926/javascript-how-to-tell-if-one-number-is-a-multiple-of-another

https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript

@StefanTerdell @colinhacks @scotttrinh 

For my case, it would be good a validation like max/minDecimals(), but maybe you can come up with better solutions.

_Originally posted by @SrBrahma in https://github.com/colinhacks/zod/issues/623#issuecomment-939585373_",,
1022077957,699,Incomplete ZodError with recursive types and regexps?,"I believe I am seeing unexpected ZodError behavior with recursive types that use regexps. It's also entirely possible I am misunderstanding as the error handling is fairly complex -- but at least I cannot explain how the version with the regexp cannot find the path to the error, and without the regexp can.

```ts

const dogSchema = z.object({
  type: z.literal('dog'),
  dogname: z.string()
});
const catSchema = z.object({
  type: z.literal('cat'),
  catname: z.string()
});
const birdSchema = z.object({
  type: z.string().regex(/bird/),        <------ Uses a regexp
  birdname: z.string()
});
const categorySchema = z.object({
  type: z.literal('category'),
  category: z.string(),
  animal: z.lazy(() => animalSchema)
})
const animalSchema = z.union([
  dogSchema,
  catSchema,
  birdSchema,
  categorySchema,
])
const masterSchema = z.object({
  animals: animalSchema,
})

const input = {
  animals: {
    type: 'category',
    category: 'pets',
    animal: {
      type: 'cat',
      // Missing catname.         <------ No catname! Input error.
    }
  }
}

const parseResult = masterSchema.safeParse(input);
if (!parseResult.success) {
  console.info(parseResult.error);
}
```

On running this, I receive the following. Zod cannot discriminate the unions (which is WAI), but it also seemingly cannot pin down where the error is. Notice no reference to `catname` below (in the nested context):

```json
ZodError: [
  {
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""dog"",
            ""received"": ""category"",
            ""path"": [
              ""animals"",
              ""type""
            ],
            ""message"": ""Expected dog, received category""
          },
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""animals"",
              ""dogname""
            ],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""cat"",
            ""received"": ""category"",
            ""path"": [
              ""animals"",
              ""type""
            ],
            ""message"": ""Expected cat, received category""
          },
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""animals"",
              ""catname"" <--- (not the nested catname)
            ],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""validation"": ""regex"",
            ""code"": ""invalid_string"",
            ""message"": ""Invalid"",
            ""path"": [
              ""animals"",
              ""type""
            ]
          },
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""animals"",
              ""birdname""
            ],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""validation"": ""regex"",
            ""code"": ""invalid_string"",
            ""message"": ""Invalid"",
            ""path"": [
              ""animals"",
              ""animal"",
              ""type""
            ]
          },
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""animals"",
              ""animal"",
              ""birdname""
            ],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      }
    ],
    ""path"": [
      ""animals""
    ],
    ""message"": ""Invalid input""
  }
]
```

If I change:

`type: z.string().regex(/bird/)` to `type: z.literal('bird')` I get:

```
ZodError: [
  {
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""dog"",
            ""received"": ""cat"",
            ""path"": [
              ""animals"",
              ""animal"",
              ""type""
            ],
            ""message"": ""Expected dog, received cat""
          },
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""animals"",
              ""animal"",
              ""dogname""
            ],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""animals"",
              ""animal"",
              ""catname"" <----------------------------------------------------- THIS IS WHAT I EXPECT
            ],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""bird"",
            ""received"": ""cat"",
            ""path"": [
              ""animals"",
              ""animal"",
              ""type""
            ],
            ""message"": ""Expected bird, received cat""
          },
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""animals"",
              ""animal"",
              ""birdname""
            ],
            ""message"": ""Required""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""category"",
            ""received"": ""cat"",
            ""path"": [
              ""animals"",
              ""animal"",
              ""type""
            ],
            ""message"": ""Expected category, received cat""
          },
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""animals"",
              ""animal"",
              ""category""
            ],
            ""message"": ""Required""
          },
          {
            ""code"": ""invalid_union"",
            ""unionErrors"": [
              {
                ""issues"": [
                  {
                    ""code"": ""invalid_type"",
                    ""expected"": ""object"",
                    ""received"": ""undefined"",
                    ""path"": [
                      ""animals"",
                      ""animal"",
                      ""animal""
                    ],
                    ""message"": ""Required""
                  }
                ],
                ""name"": ""ZodError""
              },
              {
                ""issues"": [
                  {
                    ""code"": ""invalid_type"",
                    ""expected"": ""object"",
                    ""received"": ""undefined"",
                    ""path"": [
                      ""animals"",
                      ""animal"",
                      ""animal""
                    ],
                    ""message"": ""Required""
                  }
                ],
                ""name"": ""ZodError""
              },
              {
                ""issues"": [
                  {
                    ""code"": ""invalid_type"",
                    ""expected"": ""object"",
                    ""received"": ""undefined"",
                    ""path"": [
                      ""animals"",
                      ""animal"",
                      ""animal""
                    ],
                    ""message"": ""Required""
                  }
                ],
                ""name"": ""ZodError""
              },
              {
                ""issues"": [
                  {
                    ""code"": ""invalid_type"",
                    ""expected"": ""object"",
                    ""received"": ""undefined"",
                    ""path"": [
                      ""animals"",
                      ""animal"",
                      ""animal""
                    ],
                    ""message"": ""Required""
                  }
                ],
                ""name"": ""ZodError""
              }
            ],
            ""path"": [
              ""animals"",
              ""animal"",
              ""animal""
            ],
            ""message"": ""Invalid input""
          }
        ],
        ""name"": ""ZodError""
      }
    ],
    ""path"": [
      ""animals"",
      ""animal""
    ],
    ""message"": ""Invalid input""
  }
]
```


",,
1021959762,698,Custom invalid type message on ZodUnion is being ignored,"Hi,

I'm using Zod version 3.9.8 and have the following setup:

```typescript
const NumberOrNonEmptyString = z.union( [
    z.number(),
    z.string().nonempty()
], {
    invalid_type_error: 'A custom message'
} );

NumberOrNonEmptyString.parse( true );
```

The expected behavior is that it would output ``A custom message`` as my custom error message. But instead it outputs ``Invalid input``. Thus my custom ``invalid_type_error`` is being ignored.
This is the full error object:

```json
ZodError: [
  {
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""number"",
            ""received"": ""boolean"",
            ""path"": [],
            ""message"": ""Expected number, received boolean""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""boolean"",
            ""path"": [],
            ""message"": ""Expected string, received boolean""
          }
        ],
        ""name"": ""ZodError""
      }
    ],
    ""path"": [],
    ""message"": ""Invalid input""
  }
]
```

```
    at new ZodError (node_modules\zod\src\ZodError.ts:141:5)
    at handleResult (node_modules\zod\src\types.ts:83:19)
    at ZodUnion.ZodType.safeParse (node_modules\zod\src\types.ts:182:12)
    at ZodUnion.ZodType.parse (node_modules\zod\src\types.ts:169:25)
```",,
1021781175,696,Throwing errors in preprocess,[Deleted for privacy reasons],,
1021123251,695,Are there more illustrative reasons to use this lib over io-ts besides the `partial` for optional properties?,"My colleague is looking at zod over io-ts because it looks ""simpler"", but are there other use cases where zod is clearly simpler than io-ts besides the `partial` for optional properties example mentioned in the README?

Since README says that ""The API of io-ts heavily inspired the design of Zod"", maybe io-ts comparison deserves a bit more description of why zod was created and how it does things better than io-ts?",,
1019904946,692,Get the list of keys from a schema,"Hello,
I would like to know if there is an ""official"" way of getting the list of keys from a schema.
Given this schema :
```
const schema = z.object({
	civility: z.string().nonempty(""Required field""),
	firstname: z.string().nonempty(""Required field""),
	lastname: z.string().nonempty(""Required field""),
});
```
I would like to retrieve this array :
```
[""civility"", ""firstname"", ""lastname""]
```

The final goal is to automatically `pick` a subset of the full User object to pass it as default values to a form.

Thank you",,
1018659760,691,Mutation testing,"It would be cool to increase test coverage for the project. But coverage by lines isn't a good metric. I suggest to use Stryker mutation testing framework to measure mutation coverage. More info here: https://stryker-mutator.io/docs/

If you are interested in this, I can setup stryker",,
1018412585,690,`.refine` is being short circuited since 3.9.6,"In our app we used to rely on the `.refine`s execution being chained, e.g.
```ts
const objectSchema = zod
  .object({
    length: zod.number(),
    size: zod.number(),
  })
  .refine(({ length }) => length > 5, { path: ['length'], message: ""length greater than 5"" })
  .refine(({ size }) => size > 7, { path: [""size""], message: ""size greater than 7"" });

console.log(
  objectSchema.and(objectSchema).safeParse({
    length: 4,
    size: 4,
  })
);
```
would yield two errors for both length and size. However, this behaviour is broken by 3.9.6.
Is there a way to execute all refines that are defined on the schema?
[Sandbox](https://codesandbox.io/s/tender-kare-xxyoz?file=/src/index.ts)",,
1016572277,689,Typescript 4.5 Beta infinite loop leading to JS heap out of memory,"An issue appeared with TypeScript 4.5.0-dev.20211001 that made tsc go into an infinite loop leading to an out-of-memory error.

tsconfig.json:

```json
{
  ""compilerOptions"": {
    ""target"": ""es2020"",
    ""module"": ""commonjs"",
    ""moduleResolution"": ""node"",
    ""lib"": [""es2020""]
  },
  ""exclude"": [""node_modules""],
  ""include"": [""run.ts""]
}
```

package.json:

```json
{
  ""type"": ""commonjs"",
  ""scripts"": {
    ""start"": ""tsc -p .""
  },
  ""dependencies"": {
    ""zod"": ""^3.9.8""
  },
  ""devDependencies"": {
    ""typescript"": ""^4.5.0-beta""
  }
```

when using `tsc` directly, the following import cause the issue:

```ts
import { z } from ""zod"";
```

when using ts-node instead of tsc, this is the minimum necessary code to cause the issue:

```ts
import { z } from ""zod"";

const schema: z.ZodSchema<string> = z.string();
```

Demo code in: https://github.com/mmvsk/bug-zod-typescript-4.5.0-oct-01

The same code works until TypeScript 4.5.0-dev.20210930, and the issue was probably introduced with the following TypeScript PR: https://github.com/microsoft/TypeScript/pull/41821",,
1014968232,688,Major refinements regressions in 3.9.x,"Refinements have regressed in 3.9.x
```ts
import { z } from 'zod';

z
  .string()
  .refine(() => false)
  .transform(() => {
    throw new Error(""this shouldn't happen"") // in 3.9.x this throws, in 3.8.x it doesn't reach this branch
  })
  .safeParse("""") 
  ```

3.9.x - throws:
https://codesandbox.io/s/angry-hawking-qqx2q?file=/src/index.ts
 
3.8.x - doesn't throw:
https://codesandbox.io/s/elastic-hooks-eglbu?file=/src/index.ts


  
  ",,
1014574175,687,Error params are being ignored for array schema,"[Repro sandbox](https://codesandbox.io/s/cocky-grass-wlcv0?file=/src/index.ts)

```typescript
import { z } from ""zod"";

const schema = z.array(z.string(), { errorMap: () => ({ message: ""No"" }) });

schema.parse(undefined);
```

returns:
```javascript
[
  {
    ""code"": ""invalid_type"",
    ""expected"": ""array"",
    ""received"": ""undefined"",
    ""path"": [],
    ""message"": ""Required""
  }
]
```

but in practice, it should return the custom message given in `errorMap`, like the rest of the schemas.",,
1014502633,686,Type guard for parse function,"Hello,

I was excited to use `zod` to validate my objects in typescript. I quickly ran into a problem.
parse function does return the correct type but not as type guarded.

https://github.com/colinhacks/zod/blob/9648f3f632280614e07da9621af6e1a8440d678c/src/types.ts#L168
For type guards to kick in, this line should be written like:
`parse(data: unknown, params?: Partial<ParseParamsNoData>): data is Output`

This becomes problem when I try to make if-statements to make sense of what exact type I'm currently dealing with:
![image](https://user-images.githubusercontent.com/14369871/135768751-0288031d-5614-4043-9d14-efd7d8a8f9a6.png)


Could this be possible change? Or are there some unseen outliers why this is not the case currently?

Type guards: https://www.typescriptlang.org/docs/handbook/advanced-types.html",,
1014139505,685,3.9.*: refine not working inside a union,"In 3.9.5, refines inside of unions are evaluated but the errors are not resolved. Working fine in 3.8.x

```typescript
    const validator = union([
        object({
            type: literal('x'),
            value: string()
        }).refine(
          ({value}) => value === 'test', // < This lambda is called, but validation does not fail.
          {
              message: 'Some value invalid',
              path: ['value']
          }
        ),
        object({
            type: literal('y'),
            otherValue: string()
        })
    ]);
    expect(validator.safeParse({type: 'y', otherValue: 'test'}).success).toBe(true) // < good
    expect(validator.safeParse({type: 'x', value: 'test'}).success).toBe(true) // < good
    expect(validator.safeParse({type: 'x', value: 'fail'}).success).toBe(false) // < will fail in 3.9, pass in 3.8
```",,
1014119393,684,z.object: properties are optional by default?,"When I use `z.object`, the fields within the object seem to be optional by default. I would expect the opposite. Is  this the expected behavior, or is there something I'm missing? It doesn't seem to be the behavior demonstrated in the [documentation](https://github.com/colinhacks/zod#objects).

os: windows
npm version: 7.24.1
node version: v14.16.0
typescript version: 4.4.3
zod version: 3.9.5

[repro repo](https://github.com/dmacthedestroyer/zod-fields-bug)

## Repro steps
```
npm init
npm install typescript zod
touch index.ts
```

`index.ts`:
```
import { z } from ""zod"";

const shape = z.object({
  foo: z.string(),
  bar: z.number(),
});

type Shape = z.infer<typeof shape>;
````

VS Code indicates that foo and bar are both optional:
```
type Shape = {
    foo?: string;
    bar?: number;
}
```

I'd expect them to be _not_ optional:
```
type Shape = {
    foo: string;
    bar: number;
}
```

Love the library, by the way -- you're a legend :)",,
1013725094,682,Missing documentation on function type,"Seeing a few things:
- `strictImplement`
- `validate`

Curious if there is any documentation on them. Thanks! ",,
1012608663,680,Is there a way to type-check for an instantiated Primitive's type?,"Hello, is there a way to check if instantiated Primitive type is that type.
new Number() === number
new String() === string

I've had no luck. Here are some of my test cases
```
import * as s from 'superstruct'

// Checking for an empty object. Output true. This is correct
s.is({}, s.object({}))

// Checking for and empty object. Output false. This is correct
s.is({ propertyName: ""propertyValue"" }, s.object({}))

//  Checking for an object. Output true. I would like this to be false.
s.is(new Number(43), s.object())

//  Checking for number. Output false. I would like this to be true.
s.is(new Number(43), s.number())
```
I know why it would do this. It's an instantiated Number that has prototype of object.


I have ways to find out that these ones are a typeof number.
I figured if zod would like to support for this kind of type-checking in any other way.
I'm fine if earlier examples stays that way, because one can argue that instantiated Primitive's type is an object.

I would like to see a function that sees through the instantiated Primitive prototype and compare the real value inside.
Example:
```
s.typeof(new Number(43), 'number') // true
or
s.typeof(new Number(43), s.number()) // true

s.typeof(new Number(43), 'object') // false
or
s.typeof(new Number(43), s.object()) // false
```",,
1011960292,679,Undocumented breaking change for `transformer` in 3.9.0,"In `3.9.0` there was a breaking change to the `.transformer` method. Previously, as is currently documented in the Zod2->Zod3 documentation `.transformer` takes a single argument, a Zod schema. `.transformer` now appears to expect 2-3 arguments and all tests relating to `.transformer` have been rewritten to avoid using the `.transformer` method (in many cases the previous test was left commented out). 

`transformer` is not a very well documented method and the project appears to be moving away from it, but nethertheless it is a documented method and 3.9.0 should have been 4.0.0 or the change to .transformer should be reverted.

I've been able to rewrite all of our current usages to work without it, but ideally this should have been communicated via semver.",,
1011850120,678,[PROPOSAL] Flavoured and branded types,"Yes, I know about https://github.com/colinhacks/zod/issues/3 but I couldn't find anything saying that you didn't want to support nominal types in Zod ðŸ˜„ 

# Type alias

A type alias is just a name given to an already existing type. These won't prevent assigning values between types.

```ts
// Those three types are all number underneath
type Age = number;
type DistanceInMeters = number;
type DistanceInMiles = number;

const age = 10;
const distanceInMeters = age;
const distanceInMiles = distanceInMeters;

// Those two types are all string underneath
type Name = string;
type DateISO8601 = string;

const name = ""Zod"";
const date = name;

// Easy to do with Zod
type TownName = z.string();
```

# Tag

A tag is a property in a type that is used to differentiate it from other types. They are used to create discriminated unions.

```ts
type Shape = {
  area: number;
} & ({ radius: number } | { length: number });

// distinguishing between a Circle and a Square is annoying

declare const shape: Shape;

if (""radius"" in shape) {
  console.log(""The radius is "" + shape.radius);
} else {
  console.log(""The length is "" + shape.length);
}

// and you can't use a switch or a Record to handle all the types of shapes
// which is why tags are useful

type Animal =
  | {
      tag: ""dog"";
      barkStrength: number;
    }
  | {
      tag: ""cat"";
      purrStrength: number;
    };

declare const animal: Animal;

switch (animal.tag) {
  case ""dog"":
    // you can use barkStrength here
  case ""cat"":
    // you can use purrStrength here
}

// Easy to do with Zod
const shapeSchema = z.union([
  z.object({
    tag: z.literal(""circle""),
    radius: z.number(),
  }),
  z.object({
    tag: z.literal(""square""),
    length: z.number(),
  }),
]);
```

# Flavoured types

Sometimes you don't want types to be interchangeable, such as `distanceInMeter` and `distanceInMiles`, so you could use flavoured type to prevent this. A flavoured type is a type with  tag to prevent mixing flavoured types between themselves

```ts
type DistanceInMeter = number & { readonly brand?: unique symbol };
type DistanceInMiles = number & { readonly brand?: unique symbol };
const distanceInMeter: DistanceInMeter = 10; // this works
const distanceInMiles: DistanceInMiles = distanceInMeter; // this won't compile
```

You can't do this with Zod, you have to create a type and have your Zod schema use this type

```ts
type Flavor<T,  FlavorT> = T & { _type?: FlavorT; };
type UUID = Flavor<string, 'UUID'>;
const uuid: z.Schema<UUID> = z.string().uuid() as any;
```

It would be easier just to be able to use Zod to do this

```ts
const uuidSchema  = z.string().uuid().flavour<""UUID"">();
type UUID = z.infer<typeof uuidSchema>;
const uuid: UUID = ""123e4567-e89b-12d3-a456-426614174000"";
```

The code shouldn't be too complex too

```ts
export interface ZodFlavourDef<T extends ZodTypeAny> extends ZodTypeDef {
  innerType: T;
  typeName: ""ZodFlavour"";
}

export type ZodFlavourType<
  B extends string,
  T extends ZodTypeAny = ZodTypeAny
> = ZodNominal<B, T>;

type ZodFlavourOutput<
  B extends string,
  T extends ZodTypeAny = ZodTypeAny
> = T[""_output""] & { readonly __flavour?: B };

export class ZodFlavour<
  B extends string,
  T extends ZodTypeAny = ZodTypeAny
> extends ZodType<ZodFlavourOutput<B, T>, ZodFlavourDef<T>, T[""_input""]> {
  _parse(
    ctx: ParseContext,
    data: any,
    parsedType: ZodParsedType
  ): ParseReturnType<T[""_output""]> {
    return this._def.innerType._parse(ctx, data, parsedType);
  }

  unwrap() {
    return this._def.innerType;
  }

  static create = <B extends string, T extends ZodTypeAny = ZodTypeAny>(
    type: T,
    params?: RawCreateParams
  ): ZodFlavour<B, T> => {
    return new ZodFlavour({
      innerType: type,
      typeName: ""ZodFlavour"",
      ...processCreateParams(params),
    }) as any;
  };
}
```

# Branded types

These are the same as flavoured types but they don't accept primitive and have to be build using `parse` for example

```ts
const uuidSchema  = z.string().uuid().brand<""UUID"">();
type UUID = z.infer<typeof uuidSchema>;
const uuid: UUID = ""123e4567-e89b-12d3-a456-426614174000""; // won't compile
const uuid2: UUID = uuidSchema.parse(""123e4567-e89b-12d3-a456-426614174000"");
```

It would be the same code as above except for the `?`

```ts
type ZodBrandOutput<
  B extends string,
  T extends ZodTypeAny = ZodTypeAny
> = T[""_output""] & { readonly __brand: B };
```",,
1011568992,677,Add .describe() for annotating types with descriptions,"Originally came up here https://twitter.com/JasonKuhrt/status/1443331235598700544

Idea is that it would be great to be able to add descriptions to schema types so that it can be passed off to other destinations.

Example:

```ts
const foo = z.object({
  bar: z.string().description(`about bar`)
}).description(`about foo`)
```",,
1010469285,674,[meta] Deno releases are always behind NPM,"Hello there! I can't help but notice that the [Deno releases of this project](https://deno.land/x/zod@v3.9.0) are always behind those of NPM. For instance, as of writing, the Deno version is at `v3.9.0` whereas NPM is already at `v3.9.4`. As far as I can tell, this is because `deno.land/x` only updates third-party modules whenever the source repository (i.e. in GitHub) publishes a new tag/release. Thus, as far as `deno.land/x` is concerned, `v3.9.0` is the [""latest release""](https://github.com/colinhacks/zod/releases). It would be great if each new patch version is also tagged so that `deno.land/x` triggers synchronization.",,
1010409473,673,[Question] using zod for hashed key (non static key),"Been searching for answers to no avail, so asking question here:

let's say we have the following definition in typescript:
```
type Food = {
  id: string,
  name: string,
  prince: int
}

type Order = {
  [orderId: string]: Food
}
```
// and order is passed in as array of object from `items`, so it's items: [...]
how can I write such validation (main problem is the `orderId` is a non-static key, the best I can come up with is:
```
items: z.array(
  z.object({
    ...
  })
)
```",,
1009591620,671,"ZodUnion gets parsed, despite being invalid","Hi!

Based on this simple example:

```typescript
const NumberOrNonEmptyString = z.union( [
    z.number(),
    z.string().nonempty()
] );

NumberOrNonEmptyString.parse( '' ); // Passes
```

It passes the ``.nonempty()`` check despite being passed an empty string.",,
1008528427,669,Alternating results when using `regex` inside an `object`,"Running the same schema `safeParse` method when a item is of type `regex` returns alternating results.

```ts
import { z } from 'zod'

const schema = z.object({
  number: z.string().regex(/^\d+$/g).nullish()
})

const data = {number: '123'}

console.log(
  schema.safeParse(data).success, // => true
  schema.safeParse(data).success, // => false
  schema.safeParse(data).success, // => true
  schema.safeParse(data).success, // => false
  schema.safeParse(data).success, // => true
  schema.safeParse(data).success, // => false
)
```",,
1007767408,668,Tuples in unions does not get validated since v3.9.1,"Following schema

```ts
const eventsSchema = z.union([
    z.object({
      eventName: z.literal('foo'),
      eventPayload: z.tuple([z.number().nonnegative(), z.number().nonnegative()])
    }).strict(),
    z.object({
      eventName: z.literal('bar'),
      eventPayload: z.string().email()
    }).strict()
]);
```

failed before `v3.9.1` with following data

```ts
const data = {
  ""eventName"": ""foo"",
  ""eventPayload"": [0, -60]
};
const parseResult = eventsSchema.safeParse(data);
// parseResult.success === true
```

but since `v3.9.1` `zod` does not validate the `-60` value anymore as `.nonnegative()`. Parsing is always successful whereas before `v3.9.1` it failed (which is the expected behaviour)",,
1007422600,665,Bug: TypeError: Cannot read property 'async' of undefined,"Zod v3.9.1.

Error and stack trace:
```
Exception has occurred: TypeError: Cannot read property 'async' of undefined

  at ZodEffects._parse (/mnt/runtime/node_modules/x/node_modules/y/node_modules/zod/src/types.ts:2777:31)
    at ZodObject._parse (/mnt/runtime/node_modules/zod/src/types.ts:1647:22)
    at ZodObject.ZodType._parseSync (/mnt/runtime/node_modules/zod/src/types.ts:148:25)
    at ZodIntersection._parse (/mnt/runtime/node_modules/x/node_modules/zod/src/types.ts:2115:25)
    at /mnt/runtime/node_modules/x/node_modules/zod/src/types.ts:1316:14
    at Array.forEach (<anonymous>)
    at ZodArray._parse (/mnt/runtime/node_modules/x/node_modules/zod/src/types.ts:1313:10)
    at ZodArray.ZodType._parseSync (/mnt/runtime/node_modules/x/node_modules/zod/src/types.ts:148:25)
    at ZodArray.ZodType.safeParse (/mnt/runtime/node_modules/x/node_modules/zod/src/types.ts:181:25)
    at ZodArray.ZodType.parse (/mnt/runtime/node_modules/x/node_modules/zod/src/types.ts:169:25)
 ```
 
 Offending line in source: https://github.com/colinhacks/zod/blob/master/src/types.ts#L3125.
 
 Modifying the compiled output in `lib` from
```
    ZodEffects.prototype._parse = function (ctx, data, parsedType) {
        var isSync = ctx.params.async === false;
```
to 
```
    ZodEffects.prototype._parse = function (ctx, data, parsedType) {
        var isSync = ctx.params?.async === false;
```
fixes the problem.
 
 Seems like just a small oversight somewhere. Anything immediately obvious?",,
1007384969,664,"ðŸ› - ""Partial does not accept parameters""","According to the README, `partial()` can accept an object specifying which fields are allowed:

```
// Example from README
const optionalEmail = user.partial({
  email: true,
});
/* 
{ 
  email?: string | undefined; 
  username: string
} 
*/
```

However, the same example generates an error in VS Code: `Expected 0 arguments, but got 1.`:

![image](https://user-images.githubusercontent.com/1846034/134809012-4a927a44-8060-4784-af8c-bec32e0d7795.png)

![image](https://user-images.githubusercontent.com/1846034/134809067-6f17628b-eedb-464c-b4dd-107786ab4870.png)


## Environment

```txt
""node_modules/zod"": {
      ""version"": ""3.8.2"",
      ""resolved"": ""https://registry.npmjs.org/zod/-/zod-3.8.2.tgz"",
      ""integrity"": ""sha512-kpwVRACazsOhELVt5h4R2pC2OndrqaBK4+z134TWOsnzn7n2uOYnSyvx0QAn410pl28CgVtkSi5ew7e/AgO0oA=="",
      ""dev"": true,
      ""funding"": {
        ""url"": ""https://github.com/sponsors/colinhacks""
      }
    }
```",,
1007186329,662,"Using Zod for a form, transforming recursive shape","On [stackoverflow](https://stackoverflow.com/questions/69329657/how-to-transform-a-recursive-generics-shape-typescript)


### I love the Zod parser but I may have gotten in over my head creating a form lib.

In the ideal end state, the input shape is transformed to create `{ fieldA: { value, onChange, errors } }`. It works for a single level, but it's not clear how to support arrays and nested objects.

# Can typescript transform recursive generics like this?

## Zod represents parsers like this:
```typescript
const schema = z
  .object({
    name: z.string().min(3, 'Too short.'),
    nested: z.object({
      name: z.string(),
    }),
    repeat: z.array(z.object({
      arrNest: z.string(),
    })),
  }).transform((v) => v.name);
```

## Then using type inference:
```typescript
const example = <Input extends { [v: string]: any }, Output extends unknown>(
  schema: z.ZodType<Output, any, Input>
) => {
  type Fields = {
    [P in keyof Input]: {
      value: Input[P];
    };
  };

  return ({} as unknown) as Fields;
};

export const typed = example(schema);
```

## Name has the desired type `{ value: string }` but repeat has:

[![VS Code infering type of repeat][1]][1]


  [1]: https://i.stack.imgur.com/caN4a.png

# Instead, I want to apply this recursively with Objects and Arrays

Then `types.repeat` would have type `{ arrNest: { value: string } }[]`


### Notes

The [zod object type](https://github.com/colinhacks/zod/blob/6c6c9691ec6d3266ca088e5a1cfb98cceef061bd/src/types.ts#L1447) is rather complicated..

but I am only concerned with the `Input`, represented as 
```typescript
export type ZodRawShape = { [k: string]: ZodTypeAny };
```

# Any thoughts on feasibility or direction welcomed!",,
1005776851,661,z.lazy in recursive types example turns all values unwantedly optional,"When copying your example from https://github.com/colinhacks/zod#recursive-types

```typescript
interface Category {
    name: string;
    subcategories: Category[];
}

// cast to z.ZodSchema<Category>
const Category: z.ZodSchema<Category> = z.lazy(() =>
    z.object({
        name: z.string(),
        subcategories: z.array(Category),
    })
);
```

it gives the strange error saying that at some point all values become optional which would violates the original interface:

```
TS2322: Type 'ZodLazy<ZodObject<{ name: ZodString; subcategories: ZodArray<ZodType<Category, ZodTypeDef, Category>, ""many"">; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'ZodType<Category, ZodTypeDef, Category>'. Â Â Types of property '_type' are incompatible. Â Â Â Â Type '{ name?: string; subcategories?: Category[]; }' is not assignable to type 'Category'. Â Â Â Â Â Â Property 'name' is optional in type '{ name?: string; subcategories?: Category[]; }' but required in type 'Category'.
```",,
1005084117,660,parameters for function schemas that have implement,"For function schemas that use the `implement()` method, I noticed the `parameters` cannot be extracted. Any workaround there other than splitting it into two:

```ts
const _myFunction = z
  .function()
  .args(z.string(), z.number()) // accepts an arbitrary number of arguments
  .returns(z.boolean());

_myFunction.parameters() // works

const myFunction = _myFunction.implement((x) => {
    return true
  });
```",,
1001358586,658,"Bug: ""Required"" Behavior Not Working ","### The Problem
It stands to reason that if I declare 
```js
const requiredSchemaA = schemaA.required();
```
 then
```js
requiredSchemaA.shape.someProp.isOptional() 
```
would be `false`. 

However, this is not necessarily the case. 



### Repro Steps 
Here is the playground.ts to reproduce
```js
const schemaA = z.object({
  someProp: z
    .string()
    .optional()
    .refine(() => true),
});

const requiredSchemaA = schemaA.required();

console.log(requiredSchemaA.shape.someProp.isOptional());
```


### Proposed Solution
Add a new type ```ZodRequired```. I realize a type like `ZodRequired<ZodOptional<ZodString>>` is a bit clumsy, but `ZodRequired` could successfully handle cases where ZodOptional is ""hidden"" by some other type (ie ZodEffects).  ",,
1001105862,656,'shape' or 'element' like property to introspect a 'record',"### Discussed in https://github.com/colinhacks/zod/discussions/655

Currently, there seems to be no public API to introspect a record? Something like `shape` for `object` or `element` for `array`?
For example I want to get `ZodString` from `schema` of `const schema = z.record(z.string())`

As a workaround one can access the type by `schema._def.valueType`, but a public API would be nice.
",,
998606322,654,z.enum for as const numbers?,"This works nicely:
```ts
const VALUES = [""Salmon"", ""Tuna"", ""Trout""] as const;
const FishEnum = z.enum(VALUES);
// 'Salmon' | 'Tuna' | 'Trout'

```

But this does not work:
```ts
const VALUES = [1, 2, 3] as const;
const OrderEnum = z.enum(VALUES);
// 1 | 2 | 3
```
This is due to the requirement of having an array of strings, although a union of numbers work. 

Thoughts? 


",,
998005289,653,Feature request: First class string trimming support?,"Edit: I've since changed my mind, but leaving open to allow discussion.

I suppose this feature request is also a question about how the maintainers view the library in terms of its usage in form validation.

A very common use case when dealing with user input in forms is you need to ignore/strip whitespace. `""  ""` or `""michael@example.com ""` isn't valid input in some cases, and using `.min(1)` or `.email()` respectively will get what might be seen by some as the wrong result. In those cases you want to parse or validate the input after stripping the whitespace, and also transform the input to strip it out altogether in the ouput.

This question was raised in https://github.com/colinhacks/zod/issues/614, and `preprocess` was suggeted. The solution using `preprocess` presumably goes a follows:


```ts
z.preprocess((arg) => typeof arg === ""string"" ? arg.trim() : arg, z.string().min(1)).parse("" ""); // throws
z.preprocess((arg) => typeof arg === ""string"" ? arg.trim() : arg, z.email()).parse(""michael@example.com ""); // ouput: ""michael@example.com""
```

Now this seems quite verbose and you are having to validate the `arg` value ahead of your processing step (kind of the purpose of zod in the first place - to validate that something is a string etc...), and other libraries such as `yup` have builtin trim methods that will transform the input ahead of validation as a builtin operation:

```ts
Yup.string().trim().min(1).validateSync("" "") // ValidationError ""this must be at least 1 characters""
```

My sense is `zod` wants there to be a strong seperation between transformation and parsing. Is there space for zod having better support for what appears to be a pretty common use case? Something along the lines of:


```ts
// transforms after checking that input is a string
z.string().trim().min(1).parse("" "") // throws
z.string().trim().email().parse(""michael@example.com "") // ouput: ""michael@example.com""

// or does not change output, and force you to add a transform if you want the parsed ouput to have whitespace stripped
z.string().trim().min(1).transform(str => str.trim()).parse("" "") // throws
z.string().trim().email().transform(str => str.trim()).parse(""michael@example.com "") // ouput: ""michael@example.com""
```

The latter case is still a little noisy and confusing, but at least I'm dealing with a string by this point instead of an `unknown` because it has already passed parsing as a string.

Does this fit into `zod`'s vision (I'm guessing that it might not)?",,
997999283,652,z.ZodType and z.ZodSchema do not seem to work as I expect,"Hi there!

I've discovered the lib recently and have a question that is probably silly.

I have an application that defines its domain with Typescript, which I want to be the single source of truth. This means I'm not interested in inferring static types from Zod, but the other way around. I want Zod to obey what Typescript dictates and want the TS compiler to let me know when any inconsistency arises. I assume the dual definition of types and parsers.

I've tried to achieve this with `z.ZodType<MyType>` and `z.ZodSchema<MyType>` with no success and I have not found a clue to follow from the readme of the project, which seems to be the only documentation available.

I've prepared a small dumb example that I hope will help you understand what I intend to do ([CodeSandbox here](https://codesandbox.io/s/zod-example-1oe9x?file=/src/index.ts)):

```typescript
import * as z from ""zod"";

type A = {
  foo: string;
  bar: string;
};

// This parser exactly matches interface A so we have no errors. So far so cool.
const AParser: z.ZodType<A> = z.object({
  foo: z.string(),
  bar: z.string()
});

///////////////////////////////////////////////////////////////

type B = {
  bar: string;
};

// Why I get no errors on a parser that does not match the type z.ZodType<B>?
const BParser: z.ZodType<B> = z.object({
  foo: z.string(),
  bar: z.string()
});
```

I have some experience with `io-ts`. Please find here a [CodeSandbox demonstrating the result I'd expect](https://codesandbox.io/s/io-ts-example-2rgc6?file=/src/index.ts).

Thx!!",,
997258339,649,Allow custom code in errorUtil,"Currently `ErrMessage` can be string or `{ message?: string; };` and this message goes into `errorMap` function. We could add possibility to pass typed ""code"" instead of message and inside errorMap we could check it to select message. By that applications could have one place to define all the message with type checking support and have translations along with it.

Here is the example of `errorUtil` file:
```
export declare namespace errorUtil {
    export interface Codes {
    }

    export interface CodeErrorProps {
    }

    export interface CodeError extends CodeErrorProps {
        code: keyof Codes;
    };

    type ErrMessage = CodeError | string | {
        message?: string;
    };

    const errToObj: (message?: ErrMessage | undefined) => {
        message?: string | undefined;
    };
    const toString: (message?: ErrMessage | undefined) => string | undefined;
}
```

Because they are interfaces we could have declaration merging and users can provide their own codes and operate with them in errorMap. 

This is just rough example to show the idea.",,
995478548,647,`z.function().default()` Sometimes Doesnâ€™t make Type Optional,"As mentioned in #646, I really like this library all-in-all and am trying to integrate it where I can right now. While writing some custom `zod` -> `vue props` converter, I encountered the following behavior that at least to me looks like a bug.

## Reproduce

All these tests pass successfully. However, I donâ€™t understand why that is. I think all `.toBe()`s should be `true`. However, 8 of them are somehow `false`. I only encountered this with `z.function`. The other types seem fine to me.

```ts
import { z } from 'zod'

describe('z.function().default() does not work with isOptional', () => {
	it('works with explicit optional', () => {
		const schema = z
			.function()
			.optional()
			.default(() => undefined)

		expect(schema.safeParse(undefined).success).toBe(true)
		expect(schema.isOptional()).toBe(true)
	})

	it('fails with z.function().default(() => undefined)', () => {
		const schema = z.function().default(() => undefined)

		expect(schema.safeParse(undefined).success).toBe(false) // should be true
		expect(schema.isOptional()).toBe(false) // should be true
	})

	it(""fails with z.function().default(() => 'anything')"", () => {
		const schema = z.function().default(() => 'anything')

		expect(schema.safeParse(undefined).success).toBe(false) // should be true
		expect(schema.isOptional()).toBe(false) // should be true
	})

	it('works with union hack with () => () => undefined', () => {
		const schema = z
			.union([z.function(), z.function()])
			.default(() => () => undefined)

		expect(schema.safeParse(undefined).success).toBe(true)
		expect(schema.isOptional()).toBe(true)
	})

	it('fails with union hack with () => undefined', () => {
		const schema = z
			.union([z.function(), z.function()])
			.default(() => undefined)

		expect(schema.safeParse(undefined).success).toBe(false) // should be true
		expect(schema.isOptional()).toBe(false) // should be true
	})

	it(""fails with union hack with () => 'anything'"", () => {
		const schema = z
			.union([z.function(), z.function()])
			.default(() => 'anything')

		expect(schema.safeParse(undefined).success).toBe(false) // should be true
		expect(schema.isOptional()).toBe(false) // should be true
	})

	it('works with z.number().default(1)', () => {
		const schema = z.number().default(1)

		expect(schema.safeParse(undefined).success).toBe(true)
		expect(schema.isOptional()).toBe(true)
	})

	it('works with z.object().default({})', () => {
		const schema = z.object({}).default({})

		expect(schema.safeParse(undefined).success).toBe(true)
		expect(schema.isOptional()).toBe(true)
	})
})
```

## Versions

**zod**: `3.8.2`
**TypeScript**: `4.3.5`",,
995182722,646,z.union.default Has Unexpected Type Error,"First of all, thanks for this excellent library. Iâ€™m currently tying too hard to integrate it everywhere I possibly can haha

I found a rather minor type issue. Not sure if Iâ€™m misusing it, but it seems to work as expected at run-time â€” just not at compile-time. When using `z.union`, using `.optional()` seems to not be possible, at least in this case that I encountered and simplified into an example. As far as I can tell, runtime seems to work as-expected after adding a `@ts-expect-error`.

## Reproduce

**Link**: [TS Playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQFApgHYCueA0sLcYhXF3AIIByASQCyPADJwAvAX7Cx+ADSduAMVEB5AOoBRAEqSCqzboUU0VAMYRaAZ3gAPfciUA6erWBWAFAG0lXZM4QAEYAVtTmMJ5IANasxABcKM4ANsAw1FAAhsme+JnuINn4AJTycMnUAObWiQEMIEEZnsXopX5JwWERUXCxbLUpaRnZuZjJEADuGSVlY5MZNUn1jVDNrYpcALrFLsTUmJn0yZFrEgB8cD19CQT5oEVlFdWJACytxZQUljbwAJ6OLjcHloPnaAU64UiMTiA1S6SyORYbGcMhEolK5SqizqjBWazQbW4HVCkKuMKScOGiLizkM2h0GLmUyg2OcyyaLQJGzg212+0Ox08pwuZP6cCRxBRgjRjyxr3eZCAA)

```ts
import { z } from ""zod"";

enum Kind {
    ANIMAL = ""ANIMAL"",
    FLOWER = ""FLOWER"",
}

const x = z
  .union([
    z.object({ kind: z.literal(""animal""), legs: z.number() }),
    z.object({ kind: z.literal(""flower""), flowers: z.number() }),
  ])
  .default(() => ({ kind: ""animal"", legs: 4 }));

const y = z
  .union([
    z.object({ kind: z.literal(Kind.ANIMAL), legs: z.number() }),
    z.object({ kind: z.literal(Kind.FLOWER), flowers: z.number() }),
  ])
  .default(() => ({ kind: Kind.ANIMAL, legs: 4 }));
```

### Expected Behavior

No type error is produced

### Actual Behavior

#### `x`

```
No overload matches this call.
  Overload 1 of 2, '(def: { kind: ""animal""; legs: number; } | { kind: ""flower""; flowers: number; }): ZodDefault<ZodUnion<[ZodObject<{ kind: ZodLiteral<""animal"">; legs: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, ZodObject<...>]>>', gave the following error.
    Argument of type '() => { kind: string; legs: number; }' is not assignable to parameter of type '{ kind: ""animal""; legs: number; } | { kind: ""flower""; flowers: number; }'.
      Type '() => { kind: string; legs: number; }' is missing the following properties from type '{ kind: ""flower""; flowers: number; }': kind, flowers
  Overload 2 of 2, '(def: () => { kind: ""animal""; legs: number; } | { kind: ""flower""; flowers: number; }): ZodDefault<ZodUnion<[ZodObject<{ kind: ZodLiteral<""animal"">; legs: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, ZodObject<...>]>>', gave the following error.
    Type 'string' is not assignable to type '""animal"" | ""flower""'.(2769)
```

#### `y`

```
No overload matches this call.
  Overload 1 of 2, '(def: { kind: Kind.ANIMAL; legs: number; } | { kind: Kind.FLOWER; flowers: number; }): ZodDefault<ZodUnion<[ZodObject<{ kind: ZodLiteral<Kind.ANIMAL>; legs: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, ZodObject<...>]>>', gave the following error.
    Argument of type '() => { kind: Kind; legs: number; }' is not assignable to parameter of type '{ kind: Kind.ANIMAL; legs: number; } | { kind: Kind.FLOWER; flowers: number; }'.
      Type '() => { kind: Kind; legs: number; }' is missing the following properties from type '{ kind: Kind.FLOWER; flowers: number; }': kind, flowers
  Overload 2 of 2, '(def: () => { kind: Kind.ANIMAL; legs: number; } | { kind: Kind.FLOWER; flowers: number; }): ZodDefault<ZodUnion<[ZodObject<{ kind: ZodLiteral<Kind.ANIMAL>; legs: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, ZodObject<...>]>>', gave the following error.
    Type '{ kind: Kind; legs: number; }' is not assignable to type '{ kind: Kind.ANIMAL; legs: number; } | { kind: Kind.FLOWER; flowers: number; }'.
      Type '{ kind: Kind; legs: number; }' is not assignable to type '{ kind: Kind.ANIMAL; legs: number; }'.
        Types of property 'kind' are incompatible.
          Type 'Kind' is not assignable to type 'Kind.ANIMAL'.(2769)
```

## Versions

**TypeScript**: `4.4.2`
**zod**: `3.8.2`",,
993833880,644,Reference other types in zod object,"Is it possible to reference another value in an object to, let's say, check if the start time is before the end time [like in yup](https://github.com/jquense/yup#yuprefpath-string-options--contextprefix-string--ref)?",,
993777603,643,es6 - Cannot read property '_parse' of undefined,"Hey all ! Thanks for the good work.

In my project, I am using `zod@3.8.1` and for some technical limitations I need to manipulate `z` objects into an es6 codebase. More specifically the `pick` operator.

So I have my object definition in TS package (built to es6) :

```typescript
export const Model = z.object({
  id: z.string().uuid(),
  name: z.string()
})
```

And in my es6 code I want to use a subset of this `Model`. Naively I do the following

```javascript
import { Model } from '@mystuff/models'

const ModelSubset = Model.pick({
  name: true
})
```

The inferred type of `ModelSubset` looks right. But on the runtime, when I do this : 

```javascript
const myValidModel = ModelSubset.parse({
  name: 'Kikoo'
})
```

`zod` throws me : 

```
TypeError: Cannot read property '_parse' of undefined
```

Redefining the object in the es6 package works though.. ðŸ¤” 

So, what am I missing ?

Thank you for reading and be well !",,
993070469,641,Best practices: Use schema validation along classes,"Hello,

This issue is not related to a Zod problem, but I'm sure people using the lib can help me <3

This is a simple Schema (we have to imagine it is more complex):

```
export const PersonSchema = z.object({
    id: z.string(),
    firstname: z.string(),
    lastname: z.string()
});

export type PersonType = z.infer<typeof PersonSchema>;
```

On server side, when I get a POST request, I can validate the payload using:

```
const newPerson = PersonSchema.parse(payload);
```

Great, my noSQL database will stay clean !

But now, I want to use this on client-side. So I use the same method.

```
const newPerson = PersonSchema.parse(payload);
```

My front get a Person object now, but to display it, I would like to use a class method like this for example:

```
newPerson.getFullName();
```

But newPerson is not a class instance...

So far, I found those solutions:

**Solution 1:**

Create a class Person:

```
class PersonClass implements PersonType {
    id: ZodString['_output'];
    lastname: ZodString['_output'];
    firstName: ZodString['_output'];

    constructor(newPerson: PersonType) {
        this.id = newPerson.contactEmail;
        this.lastname = newPerson.lastname;
        this.firstname = newPerson.firstname;
    }

    getFullName() {
        return this.firstname + "" ""  + this.lastname;
    }
```

OR

```
class PersonClass implements PersonType {
    id: z.infer<typeof PersonSchema.shape.name>;
    lastname: z.infer<typeof PersonSchema.shape.name>;
    firstName: z.infer<typeof PersonSchema.shape.name>;

    constructor(newPerson: PersonType) {
        this.id = newPerson.contactEmail;
        this.lastname = newPerson.lastname;
        this.firstname = newPerson.firstname;
    }
    
    getFullName() {
        return this.firstname + "" ""  + this.lastname;
    }
}
```

I found this on the same subject: 

https://github.com/colinhacks/zod/issues/38

But the more Person will have attributes, the more the class size is also growing. And I will have to parse my object, then to make an instance of the class...

**Solution 2:**

I don't use classes, and I create a getFullName() methods like this:

```
const getFullName = (person: PersonType) => {return person.firstname + "" "" + person.lastname;}
```

So my question is:

**How and when do you use Zod in your projects ?**

Only to validate payloads ? How to use methods on parsed objects?",,
992630702,639,"Email ""////@////.////"" is allowed","I'm not an expert but shouldnt this fail?

```js
var zod = require(""zod"")

zod.string().email().parse('///@///.///')

```

https://runkit.com/embed/jnfvsg1uveyr",,
990820323,638,Wrong type inference when using refine function,"Hi, first of all thanks for this great library.

Unfortunately something went wrong after version 3.1.0 with the refine function.

Here is the code snippet:
```
import { z } from ""zod"";

const schema = z.object({
  date: z.date().refine((d) => true, ""Invalid."")
});

type t = z.infer<typeof schema>;

const test: t = {}; //should be invalid
const test2: t = { date: """" }; //should be invalid

const test3: t = { date: new Date() }; //OK
```
Using version 3.1.0 the inferred type is ok:
```
type t = { date: Date }
```
but using later versions (3.2.0-3.8.2) the inferred type is:

```
type t = { date?: any }
```

https://codesandbox.io/s/zod-refine-issue-v203y?file=/src/index.ts

Can you fix it?
Is there any workaround for this bug?

Thanks,
Balazs",,
990038466,637,Nesting Schemas,"Is it possible to use zod schemas within other schemas? here a pseudocode.
```
const UserSchema = z.object({ username: z.string(), password: z.string()});

const LoginSchema = z.object({ usercredentials: UserSchema, accessToken: z.string()})
```",,
989768978,636,"Error ""Intersection results could not be merged"" on array fields in zod 3.8.2","Consider the following example:
```ts
const arraySchema = zod.object({
  attachments: zod.array(zod.object({}))
});

console.log(
  arraySchema.and(arraySchema).safeParse({
    attachments: []
  })
);
```
I would expect a successful output, but the result is a `ZodError`:
```ts
ZodError: [
  {
    ""code"": ""invalid_intersection_types"",
    ""path"": [],
    ""message"": ""Intersection results could not be merged""
  }
]
```
At the same time a very similar object schema is parsed successfully:
```ts
const objectSchema = zod.object({
  attachment: zod.object({})
});

console.log(
  objectSchema.and(objectSchema).safeParse({
    attachment: {}
  })
);
```
[Here](https://codesandbox.io/s/heuristic-khayyam-62tpo?file=/src/index.ts:719-871) is a sandbox with zod 3.
[Here](https://codesandbox.io/s/wonderful-smoke-6osu7?file=/src/index.ts) is a sandbox with zod 2 which gives success for both cases.",,
989083221,635,.optional() and --exactOptionalPropertyTypes,"Currently, .optional() behaves like:

```typescript
const user = z.object({
  username: z.string().optional(),
});
type C = z.infer<typeof C>; // { username?: string | undefined };
```

This results in a type mismatch when you're using --exactOptionalPropertyTypes in TypeScript 4.4 and expecting type ```C```  to match an interface definition like:

```typescript
interface User {
  username?: string;
}
```

.partial(), .partialBy(), .deepPartial() all have the same issue.

It would be nice to unbundle the optionality of the key from the union type with undefined for the value.

I suggest that these methods be changed to specify the optional absence of the key by default, and perhaps accept an option to restore the old behavior of adding ```.or(z.undefined())``` to the value schema(s). This would unfortunately be a breaking change, but it makes more sense than the current behavior, especially as more projects adopt --exactOptionalPropertyTypes.

",,
988392930,634,Request: passthrough as an option to parse rather than a property of the type,"Consider making passthrough a property of the parse operation rather than of the type.

If you have some zod types and want to parse some nested structure without stripping out unrecognized keys (analogous to the usual TS type-checking behavior on anything but literals), then currently, I believe you have to add `.passthrough()` to every type and construct a parallel family of types. Simply doing `.passthrough().parse()` on the top-most type doesn't seem to do it.

If you want some parse operations to strip and others to not, it's impossible without creating two parallel families of types.",,
987203392,630,TS assertion functions?,"Can zod be used as ts assertion functions?

```ts
function assertNumber(v: unknown): asserts v is number {
  if (typeof v !== 'number') throw new Error();
}

function needsNumber(x: number) { ... }

declare const x: unknown;
assertNumber(x);
needsNumber(x);  // OK
```",,
986932829,628,Migrating to zod 3 - ZodType(?) issue,"We've been using zod 2 with great success, but now I'm having an issue migrating to zod 3. Here's the piece of code representing the error:
```ts
import * as zod from 'zod';

const schema = zod.object({
  videoDate: zod.string(),
});

class Editor<
  S extends zod.ZodType<zod.TypeOf<typeof schema>> = typeof schema,
> {
  constructor(public schema: S) {}
}

const advancedSchema = zod.intersection(schema,
  zod.object({
    videoDuration: zod.number(),
  })
    .refine(val => val.videoDuration > 5),
);

export class AdvancedEditor extends Editor<typeof advancedSchema> {      // the error pops here
  constructor(schema: typeof advancedSchema) {
    super(schema);
  }
}
```

This was legitimate in [zod 2 ](https://codesandbox.io/s/gifted-lumiere-ur9k9?file=/src/index.ts), but turned out to be prohibited in [zod 3](https://codesandbox.io/s/eager-cdn-7kute?file=/src/index.ts) yielding the following error:
```
Type 'ZodIntersection<ZodObject<{ videoDate: ZodString; }, ""strip"", ZodTypeAny, { videoDate?: string; }, { videoDate?: string; }>, ZodEffects<ZodObject<{ videoDuration: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, { ...; }>>' does not satisfy the constraint 'ZodType<{ videoDate?: string; }, ZodTypeDef, { videoDate?: string; }>'.
  The types returned by '_parse(...)' are incompatible between these types.
    Type 'ParseReturnType<ZodObject<{ videoDate: ZodString; }, ""strip"", ZodTypeAny, { videoDate?: string; }, { videoDate?: string; }> & ZodEffects<ZodObject<{ videoDuration: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, { ...; }>>' is not assignable to type 'ParseReturnType<{ videoDate?: string; }>'.
      Type 'OK<ZodObject<{ videoDate: ZodString; }, ""strip"", ZodTypeAny, { videoDate?: string; }, { videoDate?: string; }> & ZodEffects<ZodObject<{ videoDuration: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, { ...; }>>' is not assignable to type 'ParseReturnType<{ videoDate?: string; }>'.
        Type 'OK<ZodObject<{ videoDate: ZodString; }, ""strip"", ZodTypeAny, { videoDate?: string; }, { videoDate?: string; }> & ZodEffects<ZodObject<{ videoDuration: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, { ...; }>>' is not assignable to type 'OK<{ videoDate?: string; }>'.
          Type 'ZodObject<{ videoDate: ZodString; }, ""strip"", ZodTypeAny, { videoDate?: string; }, { videoDate?: string; }> & ZodEffects<ZodObject<{ videoDuration: ZodNumber; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>, { ...; }>' has no properties in common with type '{ videoDate?: string; }'.ts(2344)
```
Can I follow the same approach now?",,
986479801,627,Ignore entry that does not respect a schema,"Hey there,

Is there a way to filter element of an array that does not match our schema? 

For example I have this schema:

```ts
enum BarType {
  Big = ""big"",
  Small = ""small"",
}

const schema = z.object({
  foo_id: z.string(),
  bars: z.array(
    z.object({
      id: z.string(),
      type: z.nativeEnum(BarType),
    }),
  ),
});
```

Is there a way to ignore in the `bars` entries all the type that are not valid `BarType` enum? 

Here a gist with a complete example: https://gist.github.com/armandabric/f88bf690ade47d292ef3cec11716d41f",,
985258373,626,Zod enums with any literals?,"Hi!

Is it possible to extend the functionality of zod enums to any literal, not just strings?

Examples of using:

```
z.enum([true, false, 'unknown'])
```

```
z.enum([400, 401, 404, 405, 500])
```",,
984866980,625,ZodSchema type issue,"I working on a typescript function which accepts zod schema and a model which will be validated. 

this is the schema which i will parse later in the code below

`export const postClient = z.object({
  max_budget: z.number().min(0),
  max_no_offer: z.number().min(0),
  expires_in: z.date(),
  discount: z.number().min(0),
  buy_quantity: z.number().min(0),
  get_quantity: z.number().min(0),
  expire_type: z.string().min(0),
  branches: z.array(zToObjectId),
  name: z.string(),
  type: z.string(),
  items: z.array(zToObjectId),
  name_ar: z.string(),
  items_options: z.array(zToObjectId).nullable(),
})`

I also created a type based on this schema
`export type OfferClientT = z.infer<typeof postClient>`


`export interface JSONValid<Model, Schema> {
  schema: ZodSchema<Schema>
  model: Model
}
`

`export function jsValidate<T = any, TT = any>({ data, console }: Args<JSONValid<T, T>>): Results<TT> {
  let bool: Boolean = false
  let report: ReportLog = { code: generateid(), message: """", err: null, valid: false, functionDetails: funcName() }
  let dataRt
  try {
    dataRt = data.schema.parse(data.model)
    bool = true
    report.valid = true
    report.message = ""Parsing zod schema was successful""
  } catch (err) {
    logging(err, console)
    report.message = ""Failed to validate the json schema using zod""
    report.err = err
    //TODO: send email with the err to me :>
  }
  return {
    bool: bool,
    data: dataRt,
    report,
  }
}`


`  const { bool, data, report } = jsValidate<OfferClientT, OfferClientT>({
    data: { model: req.body, schema: postClient },
    console: true,
  })
`

**The issue is here, whenever i try to add the zodschema into the schema key i get this error:**

Type 'ZodObject<{ max_budget: ZodNumber; max_no_offer: ZodNumber; expires_in: ZodDate; discount: ZodNumber; buy_quantity: ZodNumber; get_quantity: ZodNumber; ... 6 more ...; items_options: ZodNullable<...>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is missing the following properties from type 'ZodType<{ type?: string; max_budget?: number; max_no_offer?: number; expires_in?: Date; discount?: number; buy_quantity?: number; get_quantity?: number; expire_type?: string; branches?: (string | ObjectId)[]; name?: string; items?: (string | ObjectId)[]; name_ar?: string; items_options?: (string | ObjectId)[]; }, Zo...': _parseInternal, _parseInternalOptionalParams, _parseWithInvalidFallbackts(2739)
index.ts(22, 3): The expected type comes from property 'schema' which is declared here on type 'JSONValid<{ type?: string; max_budget?: number; max_no_offer?: number; expires_in?: Date; discount?: number; buy_quantity?: number; get_quantity?: number; expire_type?: string; branches?: (string | ObjectId)[]; name?: string; items?: (string | ObjectId)[]; name_ar?: string; items_options?: (string | ObjectId)[]; }, ...'

",,
983526891,622,import lazy schema from other file module cause ts 4023,"```
Exported variable '$ModelSchema' has or is using 
name 'IObjectPropertyDetails' from external module 
""~/packages/api/src/api/common/schema.schema"" 
but cannot be named.ts(4023)
```
If I split schemas and import other schema which contains lazy properties, ts cannot infer the property correctly. I have to declare using zodschema<X>, is there other way?",,
983007973,621,Add .partialBy or .makeOptional,"A common use case for objects is making some subset of its fields optional. Currently, the syntax for this is

```js

const mySchema = z.object({
    foo: z.string(),
    bar: z.number(),
    xyz: z.boolean()
})

const myNextSchema = mySchema.omit({
    foo: true,
    bar: true
}).augment({
    foo: mySchema.shape.foo,
    bar: mySchema.shape.bar
})

// {
//      foo?: string | undefined,
//      bar?: number | undefined,
//      xyz: boolean
// }

```

I propose a new method on ZodObject which would allow for doing something like
```js
const mySchema = z.object({
    foo: z.string(),
    bar: z.number(),
    xyz: z.boolean()
})

const myNextSchema = mySchema.partialBy({
    foo: true,
    bar: true
})
// {
//      foo?: string | undefined,
//      bar?: number | undefined,
//      xyz: boolean
// }
```",,
982860515,620,The refine() function for a boolean is causing compilation error,"I am coding a project with the following libraries:

    ""@hookform/resolvers"": ""^2.7.1"",
    ""@reduxjs/toolkit"": ""^1.6.1"",
    ""@testing-library/jest-dom"": ""^4.2.4"",
    ""@testing-library/react"": ""^9.5.0"",
    ""@testing-library/user-event"": ""^7.2.1"",
    ""@types/jest"": ""^24.9.1"",
    ""@types/node"": ""^12.20.16"",
    ""@types/react"": ""^16.14.11"",
    ""@types/react-dom"": ""^16.9.14"",
    ""@types/react-redux"": ""^7.1.18"",
    ""axios"": ""^0.21.1"",
    ""node-sass"": ""^6.0.1"",
    ""npm"": ""^7.20.0"",
    ""primeflex"": ""^2.0.0"",
    ""primeicons"": ""^4.1.0"",
    ""primereact"": ""^6.5.0"",
    ""react"": ""^17.0.2"",
    ""react-dom"": ""^17.0.2"",
    ""react-localization"": ""^1.0.17"",
    ""react-redux"": ""^7.2.4"",
    ""react-router-dom"": ""^5.2.0"",
    ""react-scripts"": ""^4.0.3"",
    ""react-transition-group"": ""^4.4.2"",
    ""typescript"": ""~4.1.5"",
    ""zod"": ""^3.8.1""

I defined a UserCreateDto to handle and validate the most basic data for a Create User form. I also created a customized errorMap.

user-create.dto.tsx:

```
import { z } from 'zod';
import Localize from '../../components/localize';
import errorMap from '../error.map';

z.setErrorMap(errorMap);

export const validationSchema = z
	.object({
		User: z.string().min(8, { message: Localize['Validation:UserName'] }),
		Email: z.string().email({ message: Localize['Validation:InvalidEmail'] }),
		Password: z.string().min(1, { message: Localize['Validation:Required'] }),
		confirm: z.string().min(1, { message: Localize['Validation:Required'] }),
		Birthday: z
			.date()
			.optional()
			.refine((data) => data !== undefined, {
				message: Localize['Validation:UndefinedDate'],
			}),
		Accept: z.boolean().refine((data) => data === true, { message: '' }),
	})
	.refine((data) => data.Password === data.confirm, {
		message: Localize['Validation:PassswordsNotMatching'],
		path: ['confirm'],
	});

type UserCreateDto = z.infer<typeof validationSchema>;

export default UserCreateDto;
```

error.map.tsx

```
import { z } from 'zod';
import Localize from '../components/localize';

const errorMap: z.ZodErrorMap = (issue, ctx) => {
	if (issue.code === z.ZodIssueCode.invalid_type) {
		if (issue.expected === 'string') {
			return { message: Localize['Validation:Required'] };
		}
		if (issue.expected === 'date') {
			return { message: Localize['Validation:Required'] };
		}
	}
	if (issue.code === z.ZodIssueCode.custom) {
		return { message: `less-than-${(issue.params || {}).minimum}` };
	}
	return { message: ctx.defaultError };
};

export default errorMap;
```

The error I get when I do either npm start or npm run build is this:

Failed to compile.

undefined
fork-ts-checker-webpack-plugin error in undefined(undefined,undefined):
Maximum call stack size exceeded  TSINTERNAL

The error disappears when I remove .refine((data) => data === true, { message: '' }) from the Accept boolean property in the validationSchema. I can also add it back to the validation after npm start completes the startup.
",,
982164153,619,zod/lib/external has no exported member 'infer',"I am having issues using `z.infer`. However, `z.TypeOf` (which looking at the types it appears `infer` is just an alias of `TypeOf`) is working.

```
const repaymentSchema = z.object({
  from: z.number(),
  to: z.number(),
  amount: z.string(),
});

export type Repayment = z.infer<typeof repaymentSchema>;
```

This results in the following error:
```
TSError: â¨¯ Unable to compile TypeScript
src/splitwise/client.ts (11,27): Namespace '""/Users/dmmulroy/repos/ynab-splitwise-sync/node_modules/zod/lib/external""' has no exported member 'infer'. (2694)
```

Switching to the following works fine:

```
export type Repayment = z.TypeOf<typeof repaymentSchema>;
```



In vscode, the editor accurately infers the type when using `z.infer` but at compilation time it fails.

![infer working](https://user-images.githubusercontent.com/2755722/131260538-c329682a-5e9c-4909-9a9c-fdc38e83b7fc.png)

Here is my `tsconfig.json`:

```
{
  ""extends"": ""@tsconfig/recommended/tsconfig.json"",
  ""compilerOptions"": {
    ""outDir"": ""./dist"",
    ""allowJs"": true,
    ""noErrorTruncation"": true,
    ""strictNullChecks"": true
  }
}
```



",,
982074408,616,Feature: Extend ZodObject with modified version of existing element,"Hello, is it possible to extend the original shape but check that the keys are taken from origin. 
For example i have such shape in module scope:
```
const SomeData = z.object({
  test: z.string(),
  test1: z.number(),
})
```

Add i would like to add more rules to this object (the API can be smth different)
```
function MyForm() {
  const t = useTransition()
  const FormValues = SomeData.deepMerge({ test1: z => z.min(10, { message: t.form.numCheck }) })
  const form = useForm({ resolver: zodResolver(FormValues) })

  return <>{/* do smth with form */}</>
}
```
And the TS will autocomplete the `test1` prop.

The case when it is needed is when you want to use the localization in i.e. React components because usually the translations are available in React context and not in global scope. Technically i can use the translation from some global object and use it when defining SomeData, but the issue will be is that when i change the language the error message will be the same because they are hardcoded and cannot react the translation change.",,
981821285,615,Can't properly type `z.lazy` with an object validator that transforms fields,"I'm trying to validate an object (with a recursive structure, but the issue is reproducible without it) which transforms fields into something that doesn't exactly match the given schema, and I have a hard time figuring out how to do it.

Here's an example:

```ts
const validator: ZodSchema<{ 
  foo: string 
}> = z.lazy(() => z.object({
  foo: z.number().transform((num) => num.toString()),
}));

/**
* The types of '_input.foo' are incompatible between these types.  
* Type 'number' is not assignable to type 'string'.
*/

```

So I assumed that I got it wrong, and figured that the type given to `ZodSchema` should match validation _before_ transformation, but that also doesn't seem to work.

```ts
const validator: ZodSchema<{ 
  foo: number // <-- CHANGED FROM STRING 
}> = z.lazy(() => z.object({
  foo: z.number().transform((num) => num.toString()),
}));

/**
* The types of '_input.foo' are incompatible between these types.  
* Type 'string' is not assignable to type 'number'. // <-- REVERSED ERROR
*/

```

Did I understand something wrong here? How should I do this properly?
Thank you!

------
Using
Zod 3.8.1
Typescript 4.4.2",,
981014703,614,how to trim string before do validation?,"the transform happens after validation, is there a way to do basic transform before validation?",,
980872216,613,Tuple Behavior: strip by default,"# Problem
Currently the behavior of Tuples is unintuitive when used for function arguments. 

## Without Zod
In javascript, something like what is below is entirely valid
```js
function maxLength5(str) {
    return str.length <=  5
}

const filteredList = ['apple', 'orange', 'pear', 'banana', 'strawberry'].filter(maxLength5)
```

## With Zod
This is a wonderfully powerful capability. However, if the `maxLength` function was wrapped with zod type checking, the above example would fail with error
```js
const maxLength5  = z.function()
    .args(z.string())
    .returns(z.boolean())
    .implement((str) => {
       return str.length <=  5
    })

const filteredList = ['apple', 'orange', 'pear', 'banana', 'strawberry'].filter(maxLength5)
```

### Error 
```js
ZodError: [
  {
    ""code"": ""invalid_arguments"",
    ""argumentsError"": {
      ""issues"": [
        {
          ""code"": ""too_big"",
          ""maximum"": 1,
          ""inclusive"": true,
          ""type"": ""array"",
          ""path"": [],
          ""message"": ""Should have at most 1 items""
        }
      ],
      ""name"": ""ZodError""
    },
    ""path"": [],
    ""message"": ""Invalid function arguments""
  }
]
```

# Proposal
The default behavior for function argument tuples should instead be something analogous to stripping keys on objects. Any extra elements in a tuple should be removed and validation should pass so that the above example works as expected.",,
979590272,609,objects value doesn't get set to `default` when property is optional,"Hey there!

Given the following schema
```typescript
const schema = z.object({
   type: z.optional(z.enum([""switch"", ""checkbox""]).default(""switch"")),
})
```
when providing an empty object (`{}`) to the `parse` function, the result will be an empty object, instead of (what I'd expect) 

```typescript
{
  type: 'switch'
}
```

Is there a workaround for that? Or is this even a bug or is it just a limitation by zod's code-structure?

Thanks in regards!",,
979508820,608,Feature: Formalize Zod Extensions ,"There is a growing ecosystem around extending zod in various ways. This is awesome! However, these extensions are often awkward to work with. The underlying problem is that they cannot attach data to a zod type. I understand not wanting a general ""metadata"" property on zod types because this is ripe for abuse. However, could Zod be made extensible in some first class way?

Syntactically I was envisioning something like 

```js

const productNameSchema = z.string().ext.setMockFn(() => faker.commerce.productName())
const myProductName = productNameSchema.ext.mock()  // returns product name

// or 

const foo = z.date().ext.toFormikSchema()

```

where ext is an object which extensions add to.

Note: for typescript support to work with this, we would have to wrap Zod type in some way which would allow passing in Extensions (export would then be zod with no extensions). 

To construct your extended Zod version, you could do something like

```js
export const z = MakeZod([zodMockingExt, zodFormikExt, ...])

```

My hope would be that this could provide a definite pattern for how to extend zod leading to more consistency, a wider community, and perhaps even interoperable extensions. ",,
977191398,605,Thank you!,"@colinhacks and other contributors, thank you for creating and maintaining this library! 

I came across this lib ~a month after it was here on Github and I instantly loved the interface - the elegant usage and the powerful functionality and TS integration. So much that I made the decision to start using it in a production project from v1, in a project that already had `yup` included.

It really shows that this project receives a lot of love - with all the improvements, tests, benchmarks, github actions and fixes.

Apologies for opening an Issue for this, feel free to close it whenever you like :)",,
977089582,604,Feature: String starts/ends with ,"I was writing a validator for a hex color code and thought that being able to check that it started with a `#` would be a nice addition.

E.g.: `z.string().length(7).startsWith('#')`",,
976693920,603,Incomplete error info with inner union,"Example:
```ts
import { z } from 'zod';

const a = z.object({
    letter: z.literal('a'),
});

const b = z.object({
    letter: z.literal('b'),
});

const c = z.object({
    letter: z.literal('c'),
});

const union = z.union([a, b, c]);

union.parse({
    letter: 'd',
});
```

I'll receive this error, where I can see possible issues for all union entries:
```ts
{
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""a"",
            ""received"": ""d"",
            ""path"": [
              ""letter""
            ],
            ""message"": ""Expected a, received d""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""b"",
            ""received"": ""d"",
            ""path"": [
              ""letter""
            ],
            ""message"": ""Expected b, received d""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""c"",
            ""received"": ""d"",
            ""path"": [
              ""letter""
            ],
            ""message"": ""Expected c, received d""
          }
        ],
        ""name"": ""ZodError""
      }
    ],
    ""path"": [],
    ""message"": ""Invalid input""
  }
  ```

But if I modify `c` slightly: 
```ts
const c = z.object({
    letter: z.literal('c').or(z.literal('C')),
});
```

I'll receive this error:
```ts
{
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""c"",
            ""received"": ""d"",
            ""path"": [
              ""letter""
            ],
            ""message"": ""Expected c, received d""
          }
        ],
        ""name"": ""ZodError""
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""C"",
            ""received"": ""d"",
            ""path"": [
              ""letter""
            ],
            ""message"": ""Expected C, received d""
          }
        ],
        ""name"": ""ZodError""
      }
    ],
    ""path"": [
      ""letter""
    ],
    ""message"": ""Invalid input""
  }
  ```
  
  As you can see, now issues provided only for `c`",,
976169332,601,object key constraint using enum,"Hi @colinhacks,

An awesome library. Thanks!

This is more of a question than a bug. I've to create an object, more like `z.object`. But I want to restrict the keys of that object based on an Enum. For instance,

```
const enum ReferenceEntity {
  TestA = ""testA"",
  TestB = ""testB""
}
```
Then in TS, I can define a  object like 
```
const obj = { [key in ReferenceEntity]: string }
```

How can I achieve this using `zod`? 

I've defined enum in `zod` using 
```
const ReferenceEntityZod = z.nativeEnum(ReferenceEntity);
```

How do I create `obj` now using `zod`?",,
976146079,600,"Error ""Intersections only support objects"" when using transformation and passthrough","Zod version 3.7.2.

Code sample to reproduce the issue

```typescript
const left = z.object({}).passthrough();
const right = z.object({
  id: z.string().transform((str) => parseInt(str))
});
const schema = z.intersection(left, right);
schema.parse({
  id: '123'
});
```

Throws an error
```
ZodError: [
  {
    ""code"": ""invalid_intersection_types"",
    ""path"": [],
    ""message"": ""Intersections only support objects""
  }
]
```

The error itself is not clear enough, since **I'm certainly intersecting objects**.

After debugging it on the source code I figured out that perhaps it happens because parsed type on the `left` is `{id: string}` and on the `right` is `{id: number}`.
So it considers the field `id` to have unmatched types. But the error does not have a reference to the field: `path` is empty.

At the same time `left` does not declare the type of `id` field, it just passes the unknown fields through, so I'd say it should have less ""priority"" in the intersection.

I'd like to request the improvement of the intersection algorithms.
Maybe it should intersect object shapes before parsing their field types?",,
975589174,598,operations to check subset and identity of types,"I find myself with the use case to check whether a Zod type is a subset of another Zod type, and also, to help implement it, whether a Zod type is identical to another Zod type. I saw in the code earlier versions of Zod had an `.is` operation that has been removed.

So given:

```typescript
const main = z.object({foo: z.string(), bar: z.string()});
const a = z.object({foo: z.string()});
const b = z.object({foo: z.number()});
const c = z.object({other: z.string()});
```

Then:

```
a.isSubset(main) // true, as foo is in main and the same type
b.isSubset(main) // false, as foo is not the same
c.isSubset(main) // false, as other is not present in main
```

This might get hairy with intersection types, though I'm not particularly concerned with this right now. Is anyone working on anything like this or is there a solution already?

",,
975127761,597,"No .partial(), .deepPartial(), .merge() and others after using .refine() on ZodObject","The `refine` method on a ZodObject instance returns a ZodEffects instance which lacks any of the object methods. It broke some code after migrating to v3.
I don't know the reasons behind this change, I guess it's to support chaining multiple `refine` and `transform` calls, but maybe there's a way to keep the original methods.
It should also benefit another schema types' methods.",,
972470885,595,Zod exception should include the input data,"Hello.

When I run validator on incorrect data I get `ZodError` that does not contain the original data, only Zod info about what went wrong and on what path etc.
I think it would be beneficial to have the original data also included in the ZodError, since it would make the debugging much easier. 

## My use case:

I am communicating with API that is not well documented. The APIs responses are big and complicated (union types) and the structure of the responses is not documented at all, so I have to guess little bit. When there is an exception, the Zod error itself does not have enough information for me to fix it. So I had to wrap the Zod library, and in cases when the validation does not pass, I log the original data, along with the ZodError.

So my line of thinking was that adding the original data into the ZodError could make the errors much easier to understand and it would remove the need for wrapping the Zod library for me and probably other people.

## Proposal

Add input data into the `ZodError`
",,
970798128,591,Omit/Pick from a lazy object,"Is there a way to Omit/Pick on a recursive/lazy object?

I want to be able to use something like this:
```ts
type Test = {
	someKey: boolean;
	children: Omit<Test, ""someKey"">;
};

const test: z.ZodSchema<Test> = z.lazy(() =>
	z.object({
		someKey: z.boolean(),
		children: test.omit({someKey: true}) // This method does not exist
	})
);
```
But this does not work because `omit` does not exist there.

I discovered a ""hidden"" `schema` property on `ZodLazy`, so I tried using:
```ts
// ...
		children: test.schema.omit({someKey: true})
```
But this doesn't really help as it gives me a `RangeError: Maximum call stack size exceeded` error.


After some searching I found an answer for why those methods are not implemented:
https://github.com/colinhacks/zod/issues/56#issuecomment-636633007

How should I achieve this? And is this even possible?",,
967547441,586,`refine` doesn't throw an error until `password` field validation passed,"Hey ðŸ‘‹ðŸ»

I'm playing with Zod 3 and I get different behavior between v1 and v3 about refine.

With V1, `refine` throw an error even if the `password` validation itself isn't satisfied.
ðŸ‘‰ðŸ» https://codesandbox.io/s/epic-dan-fvwtn

Whereas with the v3 the error isn't thrown until the `password` field is good.
ðŸ‘‰ðŸ» https://codesandbox.io/s/gracious-euler-e9jid

Is that new behavior normal?

",,
965635641,581,Factory function that takes any zod schema and returns parsed result with inferred type,"I'm trying to make a create validator factory function that basically formats valid or invalid parsed input according to a set interface. 

I can't figure out how to get the inferred type from any zod schema. Pretty sure it has to do with the `z.AnyZodObject` but don't know what to use in it's place:


```typescript

type ValidateResult<T> =
	| {
		isValid: true;
		validatedResult: T;
	  }
	| {
		isValid: false;
		errorType: string;
		message: string;
	  };

export const makeZodValidator = (schema: z.AnyZodObject) => {
	return (payload: {
		[key: string]: any;
	}): ValidateResult<z.infer<typeof schema>> => {
		try {
			const res = schema.parse(payload);  
			return {
				isValid: true,
				validatedResult: res,
			};
		} catch (error) {
			if (error instanceof z.ZodError) {
				return {
					isValid: false,
					errorType: 'Zod validation error',
					message: JSON.stringify(error.issues, null, 2),
				};
			}
		}
	};
};
```

I want `res` to be the inferred type of whatever schema I passed in but is any object instead:

<img width=""216"" alt=""image"" src=""https://user-images.githubusercontent.com/25183985/128953938-06a4756a-2f81-4d16-b933-1b26d208f9c1.png"">
",,
965596881,580,Custom message for z.enum?,"Whats the best way of achieving a custom message when using `z.enum(['string', 'literals'])`? I tried to work it out myself but had no luck; using the custom messages for the other validators has been amazing",,
965355223,579,Auto infer type?,"I just started checking this library out and I think it's a really nice utility. I noticed some possible unnecessary code where I will define ""schemas"" and export them, I also have to have a second `type` export. What I was hoping for was a way to chain an optional method that returns an _inferred_ `type` as well as the value object.

Here is my code:
![image](https://user-images.githubusercontent.com/5973579/128930561-eccc1bd9-dd52-4edd-b0c9-38476b774e77.png)

What I would like to do is something like this:
![image](https://user-images.githubusercontent.com/5973579/128930639-e1d3b956-0606-412c-8475-293962849a4f.png)
",,
963481353,577,Recursive type: Type instantiation is excessively deep and possibly infinite. ,"I'm running into a problem creating a parser for a fairly simple recursive type. The following errors with `Type instantiation is excessively deep and possibly infinite.  TS2589`:

```
type V = [V] | ""Null""

const V : z.ZodSchema<V> = z.lazy(() =>
  z.union([
    z.tuple([V]),
    z.literal(""Null"")
]))
```

However a loosely similar type works fine:

```
interface V {
  a: [V]
}

const V : z.ZodSchema<V> = z.lazy(() => 
  z.object({
    a: z.tuple([V])
  })
)
```

The use of the Tuple is significant, using an array works fine for both.

I'd be willing to work on a pr but I had a poke around and didn't get far in finding out what causes this, if you have any tips on what might be causing it I can take another look.",,
961183293,575,Catchall override shape properties on inferred typescript type,"Hi all!

With zod v3.5.1, running the following code throw a TS2322 typescript exception:

```typescript
import { z } from ""zod"";

const ZodEntity = z.object({
  name: z.string(),
}).catchall(z.number())

export type Entity = z.infer<typeof ZodEntity>;

const e01: Entity = {
  name: 'my_name'
}
```

Typescript error:
```
error TS2322: Type '{ name: string; }' is not assignable to type '{ [x: string]: number; name: string; }'.
  Property 'name' is incompatible with index signature.
    Type 'string' is not assignable to type 'number'.
```

I would expect the `catchall()` function to not alter the type definition for the property `name`. Is this a bug or am I doing things wrong ?

Thanks :)",,
959549226,572,Stack Trace in Async Zod Function,"Currently, async zod functions do not produce a useful stack trace when their validation fails. The trace generally contains only zod internals, looking something like this... 

```
Error: [
  {
    ""code"": ""invalid_arguments"",
    ""argumentsError"": {
      ""issues"": [
        {
          ""code"": ""too_small"",
          ""minimum"": 1,
          ""inclusive"": true,
          ""type"": ""array"",
          ""path"": [],
          ""message"": ""Should have at least 1 items""
        }
      ]
    },
    ""path"": [],
    ""message"": ""Invalid function arguments""
  }
]
    at new ZodError (/Users/USERNAME/PROJECT/node_modules/zod/lib/ZodError.js:75:28)
    at handleArgs (/Users/USERNAME/PROJECT/node_modules/zod/lib/types.js:1786:23)
    at ZodFunction.<anonymous> (/Users/USERNAME/PROJECT/node_modules/zod/lib/types.js:1817:49)
    at step (/Users/USERNAME/PROJECT/node_modules/zod/lib/types.js:59:23)
    at Object.next (/Users/USERNAME/PROJECT/node_modules/zod/lib/types.js:40:53)
    at fulfilled (/Users/USERNAME/PROJECT/node_modules/zod/lib/types.js:31:58)
```

Async function validation should be reworked slightly to produce a more usable stack trace",,
958009772,571,Property 'toJSON' is missing in type 'ZodObject<...>',"With the help of this comment (https://github.com/colinhacks/zod/issues/392#issuecomment-826227242) I wrote a little helper function that looks like this:

```typescript
export default function validateSchema<T extends z.ZodTypeAny>(
    schema: T,
    payload: unknown
): z.infer<typeof schema> {
    const validation = schema.safeParse(payload);
    if (validation.success) {
        return validation.data;
    } else {
        console.log(error);
        throw error;
    }
}
```

After months I updated my zod version and now TypeScript complains with the following error whenever I want to invoke the function, even though it used to work:

```
Argument of type 'ZodObject<{ createdAt: ZodString; lsi1: ZodOptional<ZodString>; pk: ZodString; sk: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to parameter of type 'ZodTypeAny'.
  Property 'toJSON' is missing in type 'ZodObject<{ createdAt: ZodString; lsi1: ZodOptional<ZodString>; pk: ZodString; sk: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' but required in type 'ZodType<any, any>'.ts(2345)

base.d.ts(72, 14): 'toJSON' is declared here.
```

This is how I call `validateSchema`:

```typescript
const schema = z.object({
    createdAt: z.string(),
    lsi1: z.string().optional(),
    pk: z.string(),
    sk: z.string(),
});

validateSchema(schema, { some: ""payload"" });
```

How can I update `validateSchema` to work as intended?",,
957579625,570,No option to define an error message for non-empty array,"I can define a non-empty string like this:

```ts
z.string().nonempty('This string should not be empty')
```

The same ``nonempty`` method exists for ``z.array()`` but it doesn't take an argument to define the error message.

I would like to do:

```ts
z.array().nonempty('This array should not be empty') // Right now throws ""Expected 0 arguments, but got 1""
```

but right now I'm forced to write it like this:

```ts
z.array().min(1, 'This array should not be empty')
```",,
957445697,569,Issues inside array are not included in error if array has an issue,"Given the following schema and the data to validate:

```ts
const schema = z.object({
  people: z
    .object({
      firstName: z.string(),
      lastName: z.string(),
    })
    .array()
    .min(2),
})

const result = schema.safeParse({
  people: [
    {
      firstName: 'Me',
    },
  ],
})
```

I was hoping `result.error.issues` would be:

```json 
[
  {
    ""code"": ""too_small"",
    ""minimum"": 2,
    ""type"": ""array"",
    ""inclusive"": true,
    ""message"": ""Should have at least 2 items"",
    ""path"": [
      ""people""
    ]
  },
  {
    ""code"": ""invalid_type"",
    ""expected"": ""string"",
    ""received"": ""undefined"",
    ""path"": [
      ""people"",
      0,
      ""lastName""
    ],
    ""message"": ""Required""
  }
]
```

The actual `result.error.issues` is:

```json 
[
  {
    ""code"": ""too_small"",
    ""minimum"": 2,
    ""type"": ""array"",
    ""inclusive"": true,
    ""message"": ""Should have at least 2 items"",
    ""path"": [
      ""people""
    ]
  }
]
```",,
957444464,568,How to get shape by string key?,"I'm trying to get the type of object's key:
```
for (const key in object.shape) {
    const field = object.shape[key]
}
```
But it produces the error `type 'string' can't be used to index type`. I saw the type of the shape was changed in the last version.
How to extract the shape for the specific string key in the current version?",,
957308205,567,Change z.Object by function,"Hello,
I'm trying to create a function to change a zod object dynamically and to use type infer after that:
```
export function changeSchema<T extends z.AnyZodObject>(schema: T) {
  schema.setKey('newKey', z.string());
  return schema;
}
const object = z.object({ key: z.string() });
const modifiedObject = changeSchema(object);
```
But the result not contains the added key `'newKey'`
Could you advise me on how to get it working?",,
956862445,566,Zod Template Literal Types,"TypeScript 4.1 introduced template literal types, so we could define types like: 

```ts
type DateString = `${number}-${number}-${number}`;
```

It would be very cool if Zod allowed us to infer literal types. I'm not sure extending the current `literal` for this purpose is the best approach, but perhaps a new `templateLiteral` method that might look like:

```ts
const dateString = z.templateLiteral(z.number(), z.literal('-'), z.number(), z.literal('-'), z.number());
```

The above isn't as clean as defining a template literal type in TypeScript, but Zod will need some way of understanding the literal sequence and I wonder if the above format would make sense for it.

Do you think supporting template literal type checks and inference using `z.infer` is something on the horizon? Thank you!",,
955315388,564,Ability to `flatMap` on errors,"Like with `flatten()`, would be nice to have a `flatMap<U>(mapper: (string) => U )` to transform issues as needed.

Motivation for this is around the idea of being able to differentiate between custom-defined errors versus warnings in a form. Being able to flatten the errors, whilst also supplying the error code, or other `ZodIssue` specific information is a nice stepping stone to allow for that.",,
954567809,561,Create union from array,"I have an array of some codes (just a numbers) and I want to validate that object field contains one of them.
For example:
```
const HTTP_SUCCESS = [200,201];
```

In superstruct I can use `enums` function to do this:
```
const response = type({
   code: enums(HTTP_SUCCESS),
})
```

I tried to do something like:
```
const response = z.object({
    code: z.union(HTTP_SUCCESS.map(z.literal))
})
```
But this doesn't work because result of the map is an array, while z.union requires a tuple.",,
954078253,559,Obtain defaults even on failed validation,"Is there a way to obtain the defaults objects even after validation failed:
I tried:
```
const schema = z.object({
  name: z.string(),
  age: z.number().default(3),
});
const schema2 = z.object({
  name: z.string(),
  age: z.number().default(3),
  arr: z
    .array(
      z.object({
        number: z.string(),
        type: z.string().default(""cell""),
      })
    )
    .nonempty()
    .default([{}] as any),
});

console.log(schema.deepPartial().default({}).parse(undefined));
// This is ok, returns { age: 3 }
console.log(schema2.deepPartial().default({}).parse(undefined));
// This is not ok, returns { age: 3 } but wanted { age: 3, arr: [{ type:'cell' }] }
```
Is there a way to actually safe parse so defaults get filled and then validate for real?",,
952733212,556,Zod not working when imported across packages,"We ran into an issue when upgrading from 3.2.0 to 3.5.1, that when we're importing Zod defined schemas across our package boundaries (which just means that Zod is installed multiple times, once in each package that uses it) Zod breaks and the validation doesn't actually run.

I've put together a small repo to reproduce this: https://github.com/krivachy/zod-object-bug

The setup is:
- There are two packages in the `packages/` directory
- packageA contains a validation: [zEmail](https://github.com/krivachy/zod-object-bug/blob/main/packages/packageA/src/emailValidation.ts)
- packageB contains a model that uses zEmail: [models.ts](https://github.com/krivachy/zod-object-bug/blob/main/packages/packageB/src/models.ts)
- test fails when it's imported, but passes when it's locally defined: [index.test.ts](https://github.com/krivachy/zod-object-bug/blob/main/packages/packageB/index.test.ts)
- The same version of Zod is installed in both [packageA](https://github.com/krivachy/zod-object-bug/blob/main/packages/packageA/package.json) and [packageB](https://github.com/krivachy/zod-object-bug/blob/main/packages/packageB/package.json)

If we install Zod once at a root package.json level it seems to work, but we'd like to have our packages define their own dependencies.

Other libraries work perfectly fine this way, so I'm a bit confused as to why Zod breaks with this setup? Any advice would be much appreciated, thanks!",,
952359209,555,Error message for primitives?,"Ideally, would like to return a string (or customize myself) instead of
```
[
      {
        \""code\"": \""invalid_type\"",
        \""expected\"": \""string\"",
        \""received\"": \""number\"",
        \""path\"": [],
        \""message\"": \""Expected string, received number\""
      }
    ]
```",,
952130604,554,min() together with optional(),"I would like to make a field optional, but if it is set, then it must be at least 8 chars long. I tried `z.string().min(8).optional()` (which seems to be typed valid in contrast to `z.string().optional().min(3)`). Unfortunately, it still requires the field to be set (with at least 8 chars) and the `optional` is ignored.

A possible workaround seems to be `z.string().min(8).max(100).or(z.string().max(0))`, but it looks quite ugly.

_Originally posted by @medihack in https://github.com/colinhacks/zod/discussions/553_",,
951161972,549,Unable to extend/merge schema when using `z.Schema<Type>` ,"Apologies if this is already been reported or is something that cannot be fixed, I wasn't able to find it in the issues.

Assume you have the below schema:
```ts
interface Person {
    firstName: string,
    middleName?: string,
    lastName?: string,
    age: number,
    email?: string   
}

interface Employee extends Person {
    employeeId: string,
    manager: string
}
```

If you wanted to construct the Employee Schema to extend the PersonSchema, you are unable to do so if you create your schema with the type `z.Schema<Person>` as the `.extend` method apparently does not exist on the type `z.Schema<Person>`.

[Example with `z.Schema` (TS Playground)](https://www.typescriptlang.org/play?target=99&jsx=0&module=1#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgNwBQFwAdjAKZSYCGAxvXAAqMDOENiCnGFZgUHjAByzEPQBccCVFoBzADRCRIYMWIAbetNkB+BUtUaRcPcwlH6pxTGU11m4cxXy4NAK4gAI0ZLEXoQZmA9R3NXEQo0KloGJjYOAFFwPQgAT3oOegAPBhpiHi5efkErMLAs3PoASWIzZwt3OHCaT0YWlxV4qlZ+CXLxfgBlVgALMOYFZAA6SZnwgB5uMZoAPjgAXhQFiACAK3pWGAAKBHbMMTsZb0WYlQuAShDhbV0De3mF57ehzAMGA-GYejeH2stikDz+APe7W6fz8gUYgO0NAuAAZEdVwpF4a1XIDZpFARBgaCuhDXvE6RQhjQRhlajk8stZn9OWtWXU8jt9hs+DQecwFoVisQru0avzGs0DgioZ1ulAiX03nB6UA)

[Example without `z.Schema` (TS Playground)](https://www.typescriptlang.org/play?target=99&jsx=0&module=1#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcDkyEAJvgNwBQFwAdjAKZSYCGAxvXAAqMDOENiCnGFZgUHjAByzEPQBccCVFoBzADRCRIYMWIAbetNkB+BUtUaRcPcwlH6pxTGU11m4cxXy4NAK4gAI0ZLEXoQZmA9R3NXEQo0KloGJjYOAFFwPQgAT3oOegAPBhpiHi5efkErMLAs3PoASWIzZwt3OHCaT0YWlxV4qlZ+CXLxfgBlVgALMOY4AF4UADoIAIArelYYAAoEdswxOxlvZCWYlW2AShDhbV0DewVT86uVsBhgfmY9K5vrWykxyeZ1arl+7W6wL8gUYr20NG2AAZru1ZpFgS9Lks0T8sRB3p8urj4pdBsN4Blajk8pMZuEFqM+DRabNsUV6CVdqjMtTGs1lpi-p1ulAMaCLpc4CSgA)",,
948019310,546,Easy way to check array for duplicates,"Hi!

I have a feature proposal.
Namely to quickly and easily reject a ZodArray containing duplicate values.
Right now I'm doing it this way:

```
something.array().refine( ( array ) => {

    for ( const arrayItem of array ) {
        
        if ( array.filter( ( item ) => item === arrayItem ).length > 1 ) {
            return false;
        }
    }
    
    return true;
} );
```

It would be nice to have a faster way of rejecting an array with duplicate values such as ``something.array().unique()``",,
946478163,542,Make a field optional if some field have some expected value,"Hi, 

I would like to have some zod rules (like an optional), only if an other field have certain values. 

```
const schema = z.object({
    type: ""full"",
    name: z.string()
})

```

Now, how can I make the `name` field optional if the type field has the value ""partial"" ? 

I read about the refine function in documentation, but the logic seems to have a callback predicate with the input in parameter. 
In my case, I would rather prefer to be able to use some important primitive of zod like optional (but I can imagine other use cases where I would need to test against certain literals, etc.)

Any ideas? 

",,
946124621,541,Intersection cannot be assigned to `Schema` type,"Since v3.3 it is not possible anymore to give an explicit type definition for schemas of intersection types.The following code fails to type check.

~~~typescript
import * as zod from ""zod""

interface Foo {
  foo: string;
}

const fooSchema = zod.object({
  foo: zod.string(),
});

interface Bar {
  bar: string;
}

const barSchema = zod.object({
  bar: zod.string(),
});

const interSchema: zod.Schema<Foo & Bar> = fooSchema.and(barSchema);
~~~

Typescript produces the following error
~~~plain
index.ts:19:14 - error TS2322: Type 'ZodIntersection<ZodObject<{ foo: ZodString; }, ""strip"", ZodTypeAny, { foo: string; }, { foo: string; }>, ZodObject<{ bar: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'ZodType<Foo & Bar, ZodTypeDef, Foo & Bar>'.
  The types returned by '_parse(...)' are incompatible between these types.
    Type 'ParseReturnType<ZodObject<{ foo: ZodString; }, ""strip"", ZodTypeAny, { foo: string; }, { foo: string; }> & ZodObject<{ bar: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'ParseReturnType<Foo & Bar>'.
      Type 'OK<ZodObject<{ foo: ZodString; }, ""strip"", ZodTypeAny, { foo: string; }, { foo: string; }> & ZodObject<{ bar: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'ParseReturnType<Foo & Bar>'.
        Type 'OK<ZodObject<{ foo: ZodString; }, ""strip"", ZodTypeAny, { foo: string; }, { foo: string; }> & ZodObject<{ bar: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'OK<Foo & Bar>'.
          Type 'ZodObject<{ foo: ZodString; }, ""strip"", ZodTypeAny, { foo: string; }, { foo: string; }> & ZodObject<{ bar: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' is not assignable to type 'Foo & Bar'.
            Property 'foo' is missing in type 'ZodObject<{ foo: ZodString; }, ""strip"", ZodTypeAny, { foo: string; }, { foo: string; }> & ZodObject<{ bar: ZodString; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>' but required in type 'Foo'.

19 const interSchema: zod.Schema<Foo & Bar> = fooSchema.and(barSchema);
                ~~~~~~~~~~~
~~~

A workaround is to use `.merge`.

~~~typescript
export const interSchema2: zod.Schema<Foo & Bar> = fooSchema.merge(barSchema);
~~~

However, this requires `fooSchema` to be an object and is not possible if `fooSchema` itself is annotated with `Schema<Foo>`.",,
944906390,540,"[Question]: Typing advice for `superRefine()` methods on an obj, when the method provided is separated from the schema definition","Hello, new to TS and zod. Is it common practice to keep all logic coupled within the definition?

I am used to extracting out anything lengthy as may be the case for when using `.superRefine()`, but in that case I'm not sure what the advised approach is for handling typing to keep TS happy?

These are the two approaches I'm aware of, but perhaps there's a better way?

**Anonymous function has implicit typing from inference?:**
```ts
const dogSchema = z.object({
  name: z.string(),
  neutered: z.boolean(),
}).superRefine(
  (zobj, ctx) => { ... }
)

type Dog = z.infer<typeof dogSchema>
```

**Redundantly define the type anyway? (or at least for the values of interest in zobj):**
```ts
// Required to duplicate type definition...?
type zDog = {
    name: string;
    neutered: boolean;
}
const refineDog = (zobj: zDog, ctx: z.RefinementCtx) => { ... }

const dogSchema = z.object({
  name: z.string(),
  neutered: z.boolean(),
}).superRefine(
  refineDog
)

type Dog = z.infer<typeof dogSchema>
```

**Infer the type, but splits the schema into two stages:**
```ts
const _dogSchema = z.object({
  name: z.string(),
  neutered: z.boolean(),
})

// Better approach for large schemas?
type zDogRefine = (
   zobj: z.infer<typeof _dogSchema>,
   ctx: z.RefinementCtx
) => void
const refineDog: zDogRefine = (zobj, ctx) => { ... }

// Re-declaration of schema because type needed to be inferred to satisfy method provided to superRefine()
const dogSchema = _dogSchema.superRefine(refineDog)

type Dog = z.infer<typeof dogSchema>
```",,
944871396,539,Optional without undefined union,"Sorry if this is an ignorant question but is it possible to create an object with an optional key without the `| undefined`?

i.e. this
```
type Foo = {
  bar?: string;
}
```

instead of the 
```
type Foo = {
  bar?: string | undefined;
}
```

You get when using `.optional()`.",,
944775740,538,Exclude Zod Internals From ZodError Stack Trace,"I just received a ZodError which reported to the console the following

```
Error: [
  {
    ""code"": ""invalid_arguments"",
    ""argumentsError"": {
      ""issues"": [
        {
          ""code"": ""too_small"",
          ""minimum"": 1,
          ""inclusive"": true,
          ""type"": ""array"",
          ""path"": [],
          ""message"": ""Should have at least 1 items""
        }
      ]
    },
    ""path"": [],
    ""message"": ""Invalid function arguments""
  }
]
    at new ZodError (/Users/USERNAME/PROJECT/node_modules/zod/lib/ZodError.js:75:28)
    at handleArgs (/Users/USERNAME/PROJECT/node_modules/zod/lib/types.js:1786:23)
    at ZodFunction.<anonymous> (/Users/USERNAME/PROJECT/node_modules/zod/lib/types.js:1817:49)
    at step (/Users/USERNAME/PROJECT/node_modules/zod/lib/types.js:59:23)
    at Object.next (/Users/USERNAME/Work/PROJECT/node_modules/zod/lib/types.js:40:53)
    at fulfilled (/Users/USERNAME/PROJECT/node_modules/zod/lib/types.js:31:58)

```

The trouble with an error message like this is that its stack trace is totally uninformative. The reported stack trace is entirely Zod internals with no indication where the problem is in the user code. We should consider filtering zod internals out of the errors stack trace to give the user a more helpful stack trace. ",,
944713708,537,Add .promise() to ZodType,"z.function() is remarkably useful for writing typesafe functions. Often these functions will be async, thus the return type will be a promise. Adding a .promise() method to the base class ZodType would enable syntax like 

```js
const getUsernameById z.function
    .args(number())
    .returns(z.string().promise())
    .implement(async id => {
        ...
        return username
    })
```

This would be a bit more ergonomic for the developer frequently writing async function definitions. ",,
941379330,533,"Inferred all object properties are optional, when use strict: true","zod version: ^3.5.1
ts version: ^4.3.5

I saw #121 #276 #289 #498

And I tried this code.

```json
{
  ""compilerOptions"": {
    ""target"": ""es5"",
    ""lib"": [""dom"", ""dom.iterable"", ""esnext""],
    ""allowJs"": true,
    ""skipLibCheck"": true,
    ""strict"": true, // <- changed
    ""strictNullChecks"": true, // <- added just in case
    ""forceConsistentCasingInFileNames"": true,
    ""noEmit"": true,
    ""esModuleInterop"": true,
    ""module"": ""esnext"",
    ""moduleResolution"": ""node"",
    ""resolveJsonModule"": true,
    ""isolatedModules"": true,
    ""jsx"": ""preserve""
  },
  ""include"": [""next-env.d.ts"", ""**/*.ts"", ""**/*.tsx""],
  ""exclude"": [""node_modules""]
}
```

```ts
const User = z.object({
  username: z.string(),
})

type UserType = z.infer<typeof User>
```

The result is here.

![Screen Shot 2021-07-11 at 14 42 40](https://user-images.githubusercontent.com/13712715/125184137-49505b80-e256-11eb-944f-3734c118cf18.png)

I expected

```ts
{username: string}
```

Is there some my mistake?",,
941208094,532,"Add a `minMax()`, `range()`, `between()`","When a value uses both `min()` and `max()` it can be desirable to unify the error message to express that range instead of separate messages (user may input a value that fails validation a 2nd time).

Is that a common enough validation to warrant it's own method, or is it advised to implement through a third-party utility lib ([validator.js had an `isBetween()` but removed it](https://github.com/validatorjs/validator.js/issues/330)), or as this is rather simple through a `refine()` with a custom error message?",,
940781525,530,How to document the inferred type,"My goal is to document to the user of our product the api.
When I provided the validation sceme of zod, my manager said it is not good, because it is not common.

To give the user the ts type is acceptable.
But the issue is how to generate the type.
When I hover on the inferred type in VScode, I see the end type result.
But how do I print it?

Thanks",,
940779877,529,How to document the inferred type,"My goal is to document to the user of our product the api.
When I provided the validation sceme of zod, my manager said it is not good, because it is not common.

To give the user the ts type is acceptable.
But the issue is how to generate the type.
When I hover on the inferred type in VScode, I see the end type result.
But how do I print it?

Thanks",,
940409940,528,"Zod 3 regression ""Cannot read property '_parse' of undefined""","I have been trying to get more information, but I cannot isolate this bug.

```
TypeError: Cannot read property '_parse' of undefined
    at ZodObject._parse (/Users/ellis.berner/src/chatbot/node_modules/zod/src/types.ts:1492:22)
    at ZodObject.ZodType._parseSync (/Users/ellis.berner/src/chatbot/node_modules/zod/src/types.ts:102:25)
    at ZodObject.ZodType.safeParse (/Users/ellis.berner/src/chatbot/node_modules/zod/src/types.ts:125:25)
    at ZodObject.ZodType.parse (/Users/ellis.berner/src/chatbot/node_modules/zod/src/types.ts:113:25)
    at Object.queryBotUserInformation (/Users/ellis.berner/src/internal/src/internal.ts:86:69)
```

It appears when trying to _import_ Zod Schema's only, if I copy the Schema definitions over to the same file, the issue is alleviated. It's completely bizarre. 

v3.5.0

My schema, where Token and UserInfo are simple objects, that if I bring into the same file, (not imported) everything works. 

```ts
export const MetaData = z.object({
  token: Token,
  userInfo: UserInfo,
  selectedAccountId: z.string().optional(),
  locale: z.string().optional(),
});
```

What the heck is going on?
",,
939134077,525,Zod 3 : Partial on ZodEffects,"Hello, thanks for the awesome lib !

I had some schemas which use `.partial()` chained after `.refine()` (for example to validate that an `end` attribute is in the future of a `start` attribute).

```ts
z.object({
    ...
    start: dateFromString,
    end: dateFromString,
  })
  .refine(
    obj => obj.end > obj.start,
    {
      message: ':end must be later than :start',
      path: ['end'],
    },
  )
  .partial() <-- Property 'partial' does not exist on type 'ZodEffects<ZodObject<...>>'
```


After upgrading to Zod 3 they are not working anymore because the partial method doesn't exist on the ZodEffects class.

I didn't read anything about that in the migration guide, how am I supposed to handle such schemas in the v3 ?",,
938093174,522,Add Type Discriminator to ZodType,"Occasionally, users want to map a zod type to some other value. This problem comes up in mocking, getting defaults, generating ui from zod types, etc. Whenever a user is mapping zod types, it is useful to have an accurate typescript type for the result. For this to be possible, it seems to me that the typescript types for each option in ZodFirstPartySchemaTypes should be non-overlapping. This avoids situations like the following...

```js
import { z } from 'zod';

type myType = z.ZodAny extends z.ZodNull ? true : false; // true

const myValue = z.any() instanceof z.ZodNull; // false
```

Here, I believe ZodAny is meant to be a distinct type from ZodNull, but it is inferred as extending ZodNull.

My proposed fix is adding a type discriminator to the _def of all ZodFirstPartySchemaTypes. Something like, ```{ typeName: ""ZodString"" }```",,
937902232,520,Breaking change to typedef of `_refinement` & `superRefine` in 3.3.0,"After upgrading from `3.2.0` to `3.3.4` I started getting Typescript compilation errors on my `_refinement`-calls.
The new behavior seems to have been introduced in `3.3.0`, and also affects the `superRefine` method.

The behavior can be seen in the example you have in the README for `superRefine`:
```
const Strings = z.array(z.string()).superRefine((val, ctx) => {
  if (val.length > 3) {
    ctx.addIssue({
      code: z.ZodIssueCode.too_big,
      maximum: 3,
      type: ""array"",
      inclusive: true,
      message: ""Too many items ðŸ˜¡"",
    });
  }

  if (val.length !== new Set(val).size) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `No duplicated allowed.`,
    });
  }
});
```
This yields the following Typescript error on the method passed in to `superRefine`/`_refinement`:
`Argument of type '(val: string[], ctx: RefinementCtx) => void' is not assignable to parameter of type '(arg: string[], ctx: RefinementCtx) => boolean | Promise<boolean>'.
  Type 'void' is not assignable to type 'boolean | Promise<boolean>'.ts(2345)`

I can't see that this is mentioned in any changelog/readme, so it might be an unintentional change?

FYI, my Typescript version is `4.3.5`.",,
937545838,519,`infer` incorrectly marks property as `required` for `any().optional()` after upgrading to v3.3.4,"After upgrading from v3.2.0 to v3.3.4, for an object like ->
```
const TestSchema = z.object({
  options: z
    .object({
      message: z.string().optional(),
      convertOption: z.string().optional(),
      displayOrder: z.any().optional(),
    })
    .optional(),
})
```
and
`z.infer<typeof TestSchema>` 
results in 
`{options?: {message?: string | undefined, convertOption?: string | undefined, displayOrder: any} | undefined}` 
instead of marking `displayOrder?: any`

Using `number` or `string` instead of `any` marks it as optional correctly.",,
936490355,518,`infer` adds `[x: string]: any;` to type even for strict objects,"```
import { ObjectId } from 'mongodb';
import * as z from 'zod';

export const TestSchema = z.strictObject({
    _id: z.instanceof(ObjectId),
    test: z.string().nonempty(),
});

export type Test = z.infer<typeof TestSchema>;
```
results in:

```
export type Test = {
    [x: string]: any;
    _id: ObjectId;
    test: string;
};
```

Which is problematic for MongoDB `insertOne` operations, as they cannot successfully make the `_id` optional. When I handcraft the type to

```
export type Test = {
    _id: ObjectId;
    test: string;
};
```

it works fine. But that means I would need to add thousands of lines of code to our project.

Any idea on how we can solve this?

It worked fine with Zod 2.

Edit: The problem gets introduces with 3.3.x. I downgraded tp 3.2.0 and it works fine now.",,
936468388,517,How to I get the value of a ZodLiteral?,"I have an example union like this:

```typescript
const example = z.union( [
    z.literal( 'A' ),
    z.literal( 'B' )
] );
```

What would be the correct way to get all the options as a string array like `('A' | 'B')[]`?

Some of my attempts include:
```typescript
const exampleOptions = example.options.map( ( literal ) => literal._def.value );
const exampleOptions = example.options.map( ( literal ) => literal._type );
const exampleOptions = example.options.map( ( literal ) => literal._input );
const exampleOptions = example.options.map( ( literal ) => literal._output );
```

Are any of my attempts valid or is there perhaps a better way? What are the differences between those methods?",,
936406653,515,There is no way to determine that an error thrown is a `ZodError`,"In Zod v1, to determine whether a thrown error is an error thrown by Zod, I did `if (error.constructor.name === 'ZodError') {...}`.

In Zod v3, this is not possible anymore (at least when importing the module using ESM), because you minimize the source code, and the name of the constructor becomes `""n""` ðŸ˜¬.

Would love it if there was a way to know if the error is a Zod error. As a suggestion, have the `code` values all start with a `ZOD_ERROR` prefix, or have an `isZodError` field in the error, or perhaps even ensure that the constructor name will still be `ZodError`.

Currently, I'm working around this by a heuristic: checking that the error has a `path` property that is an array. ðŸ˜±

BTW, kudos for adding ESM support! ðŸŽ‰",,
936309696,513,[Question]: Usage of exclamation marks for ZodType readonly fields,"First of all, thank you for this amazing package ðŸ™ 

I've been reading through your code and stumbled upon an unfamiliar syntax:

<img width=""466"" alt=""Screen Shot 2021-07-03 at 2 55 01 PM"" src=""https://user-images.githubusercontent.com/10621548/124364333-d79d5f80-dc0e-11eb-95d9-a6787c45ae97.png"">

What do the exclamation marks do? What is this syntax / token called?",,
935915291,512,Add `.finite()` for numbers? Or require numbers to be finite by default?,"Usually, when I want a number, I want it to be finite.

I'd like to be able to say something like `z.number().finite()` to represent numbers that can't be `Infinity` or `-Infinity`.

Or, even better in my opinion (but a breaking change), I'd prefer that the default number implementation disallow non-finite values, so that `z.number().parse(Infinity)` throws an error. I think it'd be consistent with rejecting `Number.NaN`, since Infinity is a number-like thing in javascript that's not really a number, and `NaN` is already disallowed.

Would you accept a PR to make either of these changes?",,
935366890,510,question: contextual transforms,"Hi, so I have to design a parser that changes some values based on other values passed in. This is best illustrated with an example:

```ts
import { z } from 'https://deno.land/x/zod@v3.2/mod.ts'

const Percentage = z
  .string()
  .regex(/\d+%/)
  // I want transform to use .size.width or size.height here
  .transform((str) => parseFloat(str.slice(0, -1)) / 100)

const Pixels = z.string().regex(/\d+px/).transform(str => parseFloat(str.slice(0, -2)))

const Canvas = z.object({
  size: z.object({ width: z.number(), height: z.number() }),
  points: z.array(
    z.object({
      x: z.union(Pixels, Percentage),
      y: z.union(Pixels, Percentage),
    })
  ),
})

const canvas_data = Canvas.parse({
  size: { width: 200, height: 100 },
  points: [
    { x: '100%', y: '0%' },
    { x: '90%', y: '0%' },
    { x: '80%', y: '0%' },
  ],
})

console.log(canvas_data)
```

so what zod outputs is this:
```js
{
  size: { width: 200, height: 100 },
  points: [ { x: 1, y: 0 }, { x: 0.9, y: 0 }, { x: 0.8, y: 0 } ]
}
```

but in reality, I need the x and y values to be based off of width & height. E.g. 
```js
[ { x: 1 * 200, y: 0 * 100 }, { x: 0.9 * 200, y: 0 * 100 }, { x: 0.8 * 200, y: 0 * 100} ]
```

the obvious answer is to tack on some custom parsing logic _after_ the zod parsing step. The issue though is that in the example above, I have a union, inputs can be `100px` or `100%`. So for a secondary parser to know that we are dealing with a percentage rather than a pixel, I would need to tack on type info to the zod parser step:

```js
const Percentage = z
  .string()
  .regex(/\d+%/)
  .transform((str) => {
    const value = parseFloat(str.slice(0, -1)) / 100
    return { type: 'percentage', value }
  })

...
const canvas_data = Canvas.parse(...)
const parsed_points = canvas_data.points.map(p => {
  let x = p.x.value
  let y = p.y.value
  if (x.type === 'percentage') x = x * canvas_data.width
  if (y.type === 'percentage') y = y * canvas_data.height
  return { x, y }
}
```


instead, I was wondering if there is a better option that I can build off of zod. Essentially it would be great if I could use the already evaluated parts of a zod result in the transform step:
```ts
const PercentageX = z
  .string()
  .regex(/\d+%/)
  .transform((str, partial_resul) => {
    const value = parseFloat(str.slice(0, -1)) / 100
    return value * partial_result.size.width
  })
```
is something like this possible with zod?",,
935356839,509,bug: .transform() incorrectly changes ZodSchema,"the following snippet fails with error below. Adding a `.transform` method to a zod schema will alter the input type, when it should be only be altering the output type. The output type seems to correctly be just `number`.

```ts
import { z } from 'https://deno.land/x/zod@v3.2/mod.ts'

const percentage_parser = z.string().regex(/\d+%/).transform(str => parseFloat(str.slice(0, -1)) / 100)

function get_percentage(input: z.infer<typeof percentage_parser>) {
  return percentage_parser.parse(input)
}

const result: number = get_percentage('100%')
```

```
error: TS2345 [ERROR]: Argument of type 'string' is not assignable to parameter of type 'number'.
const result: number = get_percentage('100%')
```

here is a screenshot showing the full zod type declaration:

![screenshot(653)](https://user-images.githubusercontent.com/6627147/124212019-27b7dd00-dabc-11eb-9ec9-7e604499f694.png)
",,
935181277,508,Merge behavior substitute in zod 3?,"## Problem

Since `merge` method receives the same behavior than `extend` in `zod 3` I'm having some problems by merging two objects with same property key using `.and` intersection method. Look the following example:

```typescript
const Animal = z.object({
  properties: z.object({
    is_animal: z.boolean()
  })
});
const Cat = z.object({
  properties: z.object({
    jumped: z.boolean()
  })
}).and(Animal);

const cat = Cat.parse({ properties: { is_animal: true, jumped: true } });
assert.isDefined(cat.properties.jumped); // is not defined, only is_animal is defined
```
There's a way to get the same behavior of old `merge` from `zod 2` in `zod 3` considering this scenario? Using `zod 2` and `merge` method, the `properties` field is merged with both sub-fields.

**Version:** 3.2.0

## Workaround

The workaround that I found basically is something like this (but don't appear to be the best solution in the case you have more than one field):

```typescript
const Cat = z.object({
  properties: z.object({
    jumped: z.boolean()
  }).merge(Animal.shape.properties)
});
```",,
933863186,507,Data representation of schema?,"Hey,

Given a Zod schema e.g.:

```ts
const a = z.object({
  foo: z.string(),
})
```

Is there a way to get a plain data representation of this?

I am trying to map a Zod schema to a GraphQL schema (specifically an input object type).",,
933737155,506,Combined refine/transform,"Hello,

I'm using `transform()` to base64-decode a value. I'm bumping up against this requirement from the docs:

> âš ï¸ Transformation functions must not throw. Make sure to use refinements before the transformer to make sure the input can be parsed by the transformer.

To satisfy this requirement, I am doing this:
```
const schema = string().refine(isBase64).transform(d => Buffer.from(d, 'base64'));

function isBase64(data: string): boolean {
  try {
    Buffer.from(data, 'base64');
  } catch {
    return false;
  }
  return true;
}
```

This implementation is a little silly since I am base64-decoding the object just to check whether I can base64-decode it.

Is there some way to memoize the `Buffer` object created in `refine` call, so that I don't have to double-decode?",,
931802222,505,Zod 3 `transform` breaking change,"In version 2 we utilised `zod.transform` method to transform an object into an array, and validated each array item. Using `zod.array` directly resulted in parse error 'Expected an array, received object'.

Background: in Ember Data `hasMany` relations are essentially objects, but semantically they represent collections: they treat themselves as array-like structures with implementation of `map`, `filter` and others, and capable of returning a true array via `toArray` method.

Version 2 code:
```typescript
interface SyncHasMany<T> {
  // ...
  toArray(): T[];
}

function hasMany<T extends zod.ZodTypeAny>(itemSchema: T): zod.ZodTransformer<zod.ZodUnknown, zod.ZodArray<T>> {
  return zod.unknown().transform(
    zod.array(itemSchema),
    // In case it is hasMany we should convert it to plain Array so Zod can digest it.
    rel => Array.isArray(rel) ? rel as zod.TypeOf<T>[] : (rel as SyncHasMany<zod.TypeOf<T>>).toArray(),
  );
}
```

But in ver. 3 this approach is no longer available. The question is how can I achieve the same result now? I want zod to validate a `hasMany` relation using `zod.array(itemSchema)` schema as if the content of this relation was a plain array. ",,
931177763,504,"When using unions, .parse will not match to the correct type","Please see the example here: https://github.com/markhughes/zod-bug-minimum-repro

You will notice our union here:
https://github.com/markhughes/zod-bug-minimum-repro/blob/main/src/model.ts#L100-L112

We use this in our validator:
https://github.com/markhughes/zod-bug-minimum-repro/blob/main/src/validators.ts#L5-L15

Here is an example with the `accountId` key which would only match `CakeAcruSchema`:

https://github.com/markhughes/zod-bug-minimum-repro/blob/main/src/index.ts#L5-L31

When we run this, it seems to strip it out and revert to the base format:

```
$ ts-node src/index.ts
Starting test...
cakes in:
[{""cake"":{""accountId"":""f8abcccc"",""firmId"":""483e0314"",""icon"":""Acru"",""mixerId"":""787521c1"",""name"":""Default Cake"",""cakeId"":""ea4ededc"",""cakeType"":""Acru""},""recipients"":[{""firstName"":""Mark"",""lastName"":""Hughes"",""email"":""m@rkhugh.es"",""accessType"":1}]}]

cakes parsed:
[{""cake"":{""cakeId"":""ea4ededc"",""mixerId"":""787521c1"",""cakeType"":""Acru"",""name"":""Default Cake"",""icon"":""Acru""},""recipients"":[{""firstName"":""Mark"",""lastName"":""Hughes"",""email"":""m@rkhugh.es"",""accessType"":1}]}]    
Done in 2.85s.
```

However, if we go back to our union:
https://github.com/markhughes/zod-bug-minimum-repro/blob/main/src/model.ts#L100-L112


And move `CakeAcruSchema` under `CakeApplesSchema` - it seems to parse properly.

What has happened here? ",,
929939331,503,Alternative to superstruct Describe,"In Superstruct the Describe utility returns a type representing a struct for a given valid value type. This allows you to ensure you're writing your struct definitions properly.

```
type User = {
  id: number
  name: string
}

const User: Describe<User> = object({
  id: string(), // This mistake will fail to pass type checking!
  name: string(),
})
```

Is there a way to do something like this in zod?",,
928777850,502,can Zod make each field of the schema optional?,"I am using Zod to validate JSON format before adding or partial updating one document into the database, so each case will require a schema.
For adding, all the files can be nonoptional, for partial updating, all the fields need to be optional by default, I've tried to use z.optionsl(ExistingObjectSchema), or ExistingObjectSchema).optional(), both can't work as I expect. is Zod support this feature?

`
const  ExistingObjectSchema = z
            .object({
                name: z.string(),
                age: z.number()
            })
`
how to make both name and age optional? do I have to define a new schema like this?
`const  optionalSchema = z
            .object({
                name: z.string().optional(),
                age: z.number().optional()
            })
`

Thanks a lot.",,
928670776,501,Support for number granularity,"I'm just starting to get familiar with the library and have to say I am impressed so far with the ease use and ability to customize. One thing we use a lot in our schema validation that seems to be missing is granularity. In other words something like z.number().int().min(5).max(30).granularity(5) would allow 5, 10, 15, 20, 25, and 30. Without built in support, I assume the best way to accomplish this would be with refine or superrefine? And I assume those can be tacked on to the end of the built in validations so I don't have to reinvent those validators. Thanks so much! ",,
925452061,498,All object properties are optional by default,"```ts
const User = z.object({
  username: z.string(),
})

type User = z.infer<typeof User>
```
Current result
```ts
type User = {
  username?: string
}
```

Expected  result
```ts
type User = {
  username: string
}
```",,
920991727,496,Cannot use `extend` across multiple files,"I have a `lib/model` directory that contains all of my data model defined with `zod`. I prefer to define one data model per file and then import those data models for re-use across files, like so:

```typescript
// lib/model/resource.ts
import { z } from 'zod';

export const Resource = z.object({
  created: z.date(),
  updated: z.date(),
});
```

And then I can import and re-use that `Resource` object as a base model:

```typescript
// lib/model/account.ts
import { z } from 'zod';
import { Resource } from 'lib/model/resource';

export const Account = Resource.extend({
  id: z.string(),
  name: z.string(),
  phone: z.string().regex(/^(\+\d{1,3})\d{10}$/),
  email: z.string().email(),
});
```

But whenever I try to do that â˜ï¸ (i.e. import and extend `Resource` in another file), I get the following TypeScript error in my IDE:

```
Property 'extend' does not exist on type 'typeof Resource'.
```

It's totally fine when I use `Resource.extend` in the same file that `Resource` is defined in (i.e. `lib/model/resource.ts`), but as soon as I try to use it outside of that file (e.g. in `lib/model/account.ts`), I get that â˜ï¸ TypeScript error. I'm guessing this is because `zod` makes the `typeof Resource` only contain the keys that I defined (which makes sense and is the desired behavior when importing and using the data model normally... unless I am defining another data model that extends it OFC... which is my problem here). Is there a way that I can split my definitions over multiple files and avoid this TypeScript error?",,
920962882,495,"""semantic error TS2589: Type instantiation is excessively deep and possibly infinite"" with Zod 3.2","For a simple type such as:-
```
export const ZCustomer = z.object({
	name: ZString()
});
```
where ZString is:-
`export const ZString = () => z.string().min(1)`

I am getting a typescript error:-
> semantic error TS2589: Type instantiation is excessively deep and possibly infinite

I am using typescript 4.3.2 with Zod 3.2.0 in a tsdx 0.14.1 setup. Not sure what's wrong here.",,
920595926,493,Unknown fields are optional,"This looks like a spec bug, tsc's `unknown` means ""I don't care what's there as long as there's something"". Meanwhile with Zod:

```tsc
const x = z.object({ a: z.unknown() });
// type T = {a?: unknown}
type T = z.infer<typeof x>;
```

Do you agree that this is a bug? Should we fix it in place, or surface a new combinator in order not to break backwards compatibility?",,
915016793,487,Add a custom context field to ParseParams,"I would like to add an extra field called something like userContext to ParseParams which is passed to all parse and later refine calls. The idea behind this is allowing to set something like a API client as context which could be used with refine. Small example:

```
interface UserService {
  checkUniqueEmail(mail: string): Promise<boolean>;
}

const uniqueEmail = z.string().superRefine(async (mail, ctx) => {
  const userService = ctx.userContext as UserService;
  return await userService.checkUniqueEmail(mail);
});
```",,
913634512,486,Allow defining a different key into the final destination object after parsing,"Right now **zod** is becoming more and more an integral part of all my projects, however, there's still a pretty common use case that doesn't have a direct mapping in **zod**, basically, allowing to validate a different schema than the output one. 

Most of the times, in TypeScript codebases, interfacing with an API involves firing a `fetch` request and validating the received data to make sure it corresponds to the shape we're defining in our types. Zod is really great for this due to it's practically 1:1 equivalence with TS typings. However, sometimes, the types we receive from the request don't correspond directly to the types we've defined in our codebase (legacy code, different naming schemas, etc.) and that forces us to having to create yet another layer after validation to do processing. 

So I was wondering, if it'd be possible and zod architecture would allow to define a way to ""collect"" keys from the input data and ""assign"" them to another key in the resulting data. 

For example, let's imagine we're building a front-end app using TypeScript (camel case naming) and we request data to our back-end in Rails (snake case naming). Without the functionality described above, we have two solutions (without counting the one that is leaving the naming as is for obvious reasons):

 - Validate the data and then transform the data, so our validators will refer to something that doesn't really exist in the app
 - Transform the data and then validate having to transform loosely typed data.

However, adding this functionality to zod, we could do it in just one single step and correctly coupling these two non-independent descriptions thus also providing clarity of intent. 

An idea:

```ts
const UserSchema = z.object({
  firstName: z.fromKey('first_name').string()
});
```

The code above will validate that `first_name` is present and is a string, while at the same time, producing a `firstName` key with the correctly validated data.",,
912928915,485,Reduce library size [Question] [Enhancement],"At first â€” thank you for this awesome project.

Recently I debug my bundle and recognise that zod is almost the same as react-dom library and it's 114kb non gziped code. I use latest version of zod 3.1.0.

Used named import of all zod, but also tried something like `import { string } from 'zod'` with the same result

```
import { z } from 'zod';

export const linkShema = z.object({
  title: z.string(),
  link: z.string(),
});

```

Is it possible to remove at least unused parts of code from my bundle, because 100+ kb it's a lot.

<img width=""702"" alt=""image"" src=""https://user-images.githubusercontent.com/1213198/120937581-f34c3d80-c716-11eb-990f-c51c14f7bdaa.png"">
",,
912042567,484,feature request: 'shape'-like method for array(),"You can get the shape of an object schema but I don't see a way to get the schema for `array` items? Maybe:

- `array.shape`
- `array.unpack` (to follow the typescript terminology)
- `array.item` or `array.each`

I suppose the same could be asked about `record()`, etc.?",,
909677928,482,Support for ISO dates ?,"Thanks for this amazing lib ðŸ™

I'd like to have support for ISO string dates:
```
const schema = z.string().date()
schema.parse(""2021-06-02T16:23:50.048Z"") // âœ… Ok
schema.parse(""2021-06-02T16:23:50.048+02:00"") // âœ… Ok
schema.parse(""Not a date"") // ðŸš« Throws
```

Is it under preparation ?",,
909050174,481,error throwing in custom json string validation,"I'm dealing with a case that json string inside json.  Below are the parsing code. 
And i'm using the zod v3 library.

```js
import * as z from 'zod';

class JsonStr<T extends z.ZodTypeAny> extends String {
  constructor (val: string, obj: T) {
    super(val)
    const valobj = JSON.parse(val)
    this.jsVal = obj.parse(valobj)
  }
  jsVal: ReturnType<T['parse']>
}

const jsonString = <T extends z.ZodTypeAny>(obj: T) => {
  return z.string().transform((val) => {
    return new JsonStr(val, obj);
  });
};

const USchema = z.object({
  type: z.literal(1),
  key1: z.string(),
  key2: jsonString(z.object({
    key2plus: z.string()
  })),
  // key2: number()
})
.or(
  z.object({
    type: z.literal(2),
    key1: z.string(),
    key2: z.string()
  })
)

const testData = [
  {
    type: 1,
    key1: 'key1',
    key2: JSON.stringify({
      key2plus: 'key2plus'
    })
  },
  {
    type: 2,
    key1: 'key1.1',
    key2: 'some random str'
  },
]

testData.forEach((v) => {
  const parsed = USchema.parse(v) // throws JSON.parse exception
  console.log(parsed)
})
```

**How to solve the error, many thanks!**

",,
907916963,480,"Parse only throws error for single field, if outer refine is present","Consider Following Code:
```ts
const User = z
  .object({
    email: z
      .string()
      .min(1, { message: 'Email is required.' })
      .email({ message: 'Email is invalid.' }),
    password: z.string().min(8, { message: 'Password must have minimum 8 characters.' }),
    confirmPassword: z.string().min(1, { message: 'Confirm password required.' }),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: ""Passwords don't match."",
    path: ['confirmPassword'], // path of error
  });

const parseResult = User2.parse({
  email: 'sds@',
  password: 'Ak111@202902',
  confirmPassword: 'Ak111@kj32l',
});

console.log({ parseResult });
```

Above code throws following error:
```js
[
  {
    ""validation"": ""email"",
    ""code"": ""invalid_string"",
    ""message"": ""Email is invalid."",
    ""path"": [
      ""email""
    ]
  }
]
```

**Expected Output:**
It should also return error for `Passwords don't match.`
Because of this issue all errors are not shown at once in `react-hook-form`.

**Versions**
Zod: 3.1.0
",,
907738751,479,Refine validations on object definitions don't get triggered until all fields in the object exist.,"_Applies to zod v3. I have not tried the same scenario on older versions._

I have two dates, `startDate` and `endDate` and I want to verify that the former is always earlier than the latter. I tried doing something like this:

```
z.object({
  name: z.string(),
  startDate: z.date(),
  endDate: z.date(),
})
.refine((data) => checkValidDates(data.startDate, data.endDate), 'Start date must be earlier than End date.')
```

The problem is that the `.refine()` function defined on the `object` type doesn't get triggered until the all fields in the object are defined. So, imagine you have a form and user entered both `startDate` and `endDate` first, but in a wrong order. At this point, the validations for these dates do not trigger because user has not entered `name`. Then, user goes ahead enters `name` and user now sees the validations for the dates kicking in. This is very awkward experience.

I can see that in this issue #61, the example adds a `.partial()` to get around this problem, but this really isn't a solution because all of these fields are required in my case. It'd be nice if the `.refine` function defined on each individual field had access to the current form values, but it has access to its own value only. Any ideas, or did I miss something?",,
906567440,476,"Migrating from zod 1 to zod 3, got `refine` stack depth error.","Hello! I updated zod from `^1.11.16` to `^3.1.0` and I get a stack depth error when using `refine`

```javascript
import * as z from ""zod"";
import zxcvbn from ""zxcvbn"";

const createUserSchema = z.object({
  firstName: z
    .string()
    .min(1, ""First Name is required"")
    .max(16, ""First Name is too long""),
  lastName: z
    .string()
    .min(1, ""Last Name is required"")
    .max(16, ""Last Name is too long""),
  email: z.string().email(""Must be a valid email""),
  password: z
    .string()
    .min(1, ""Must be a valid password"")
    .max(48, ""Password is too long"")
    .refine((password) => zxcvbn(password).score > 2, ""Password is weak""), // zxcvbn(string).score returns an integer from 0-4
  hearAboutUs: z
    .string()
    .regex(/^(none|ads|work|recommendation|other){1}$/, ""Invalid option"")
    .optional(),
});
```

```
error TS2321: Excessive stack depth comparing types 'ZodError<?>' and 'ZodError<?>'.

 14   password: z
                ~
 15     .string()
    ~~~~~~~~~~~~~
...
 17     .max(48, ""Password is too long"")
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 18     .refine((password) => zxcvbn(password).score > 2, ""Password is weak""),
```

Any help would be appreciated, thanks!

**EDIT**: The issue hasn't got anything to do with `refine` in fact, if I delete the `password` key, it still throws the same error. Perhaps PR #472 attempts to solve this, I'm using TS 4.2.4",,
906082444,475,"`nonNullable` method that disallows `null` and `undefined`, like typescript's `NonNullable`","It's great to see that `unwrap` now exists! Thanks for adding it,

I had trouble finding `unwrap`, and the name isn't intuitive to me. I worry I'll have trouble finding it again in the future, since I don't use zod very often.

What do you think of adding an alias for `unwrap` called `nonNullable`? It was the first thing that came to mind for me when I was searching for this feature since Typescript has a utility type called [`NonNullable`](https://www.typescriptlang.org/docs/handbook/utility-types.html#nonnullabletype).",,
903019213,473,zod doesn't work with typescript `4.3.2`,see #472 ,,
902584826,471,Generate new schema based on another.,"My situation is as follows, let's say I have schema like:

```javascript
const Base = z.object({
    userId: z.string(),
    teamId: z.string(),
    origins: z.array(z.string()).optional(),
    publishedVersionId: z.string().optional(),
    status: PublishedStatus,
    slug: z.string(),
    title: z.string(),
    goal: z.string(),
    etc.
```

I would like another schema based on `Base` where **all the properties are optional**, so basically I would like to end with:

```javascript
const BaseOptional = z.object({
    userId: z.string().optional(),
    teamId: z.string().optional(),
    origins: z.array(z.string()).optional(),
    publishedVersionId: z.string().optional(),
    status: PublishedStatus.optional(),
    slug: z.string().optional(),
    title: z.string().optional(),
    goal: z.string().optional(),
    etc.
```

Is something like this possible with maybe some introspection on `Base.shape` and `reduce`, not sure if this is doable, would love to see an example of something like this! ",,
900988680,467,Complex type coercion,"We have an issue where we are using Zod to apply strong typing practices to our API layer

Trouble we have is using complex object over GET, as everything becomes a string over the wire. 

Are we able to attempt deep object coercion with Zod? Something like:

```typescript
const schema = z.object({example: z.number()})

const data = {example: '100'}

const coersedData = scheme.coerce(data) // {example: 100}

const brokenData = {example: 'lemon'}

scheme.coerce(brokenData) // Error
```",,
900117852,466,Is there a kind of abortEarly option?,"Hello all.

I looked for it through the docs, issues and Google but found anything. Is there an `abortEarly` kind of option for Zod? If not, would it be a nice to have?",,
899910344,465,Schema extension - Migrate to Zod v3 from Zod v2,"Hello,

Like we talked in issue #464 I created a new issue for some help with migrating some schema class extensions from Zod v2 to Zod v3.

This code may be not in the ideal form, but it works correctly and was well-tested in development and by qa.

In summary:

- Extended ZodString:
  - Reimplemented the Zod native methods `regex`, `email` and `url` to ignore `undefined` or `null` values;
  - Added the methods `cpfCnpj`, `cep` e `telefoneCelular` to validate data in Brazilian formats;
- Extended ZodArray to add the method `unique`, to validate if the array contains only unique elements.
- Created `ErrorMap` and reexported the types.

I tried to remake this class following the patterns of Zod v3 types but it didn't work.

I suggest to add in docs a topic about schema extensions.

Thanks.

```javascript
/* eslint-disable no-useless-escape */
/* eslint-disable no-control-regex */
import * as z from ""zod"";
import validarCpfCnpj from ""./validar-cpf-cnpj"";

const emailRegex =
  /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
const urlRegex =
  /^(http:\/\/www\.|https:\/\/www\.|http:\/\/|https:\/\/)?[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(:[0-9]{1,5})?(\/.*)?$/i;

class CustomString extends z.ZodString {
  regex = (regexp, message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return regexp.test(data);
      },
      {
        code: z.ZodIssueCode.invalid_string,
        type: ""string"",
        validation: ""regex"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );

  email = (message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return emailRegex.test(data);
      },
      {
        code: z.ZodIssueCode.invalid_string,
        type: ""string"",
        validation: ""email"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );

  url = (message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return urlRegex.test(data);
      },
      {
        code: z.ZodIssueCode.invalid_string,
        type: ""string"",
        validation: ""url"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );

  cpfCnpj = (message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return validarCpfCnpj(data);
      },
      {
        code: z.ZodIssueCode.invalid_string,
        type: ""string"",
        validation: ""cpf_cnpj"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );

  cep = (message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return /^\d{8}$/.test(data);
      },
      {
        code: z.ZodIssueCode.invalid_string,
        type: ""string"",
        validation: ""cep"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );

  telefoneCelular = (message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return /^\d{10,11}$/.test(data);
      },
      {
        code: z.ZodIssueCode.invalid_string,
        type: ""string"",
        validation: ""telefone_celular"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );

  static create = () => {
    return new CustomString({
      t: z.ZodTypes.string,
      validation: {}
    });
  };
}

class NonEmptyCustomArray extends z.ZodArray {
  unique = (mapFn = (e) => e, message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return new Set(data.map(mapFn)).size === data.map(mapFn).length;
      },
      {
        code: z.ZodIssueCode.custom,
        type: ""array"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );
}

class CustomArray extends z.ZodArray {
  unique = (mapFn = (e) => e, message) =>
    this.refinement(
      (data) => {
        if (!data) {
          return true;
        }

        return new Set(data.map(mapFn)).size === data.map(mapFn).length;
      },
      {
        code: z.ZodIssueCode.custom,
        type: ""array"",
        ...(typeof message === ""string"" ? { message } : message)
      }
    );

  nonempty = () => {
    return new NonEmptyCustomArray({ ...this._def, nonempty: true });
  };

  static create = (schema) => {
    return new CustomArray({
      t: z.ZodTypes.array,
      type: schema,
      nonempty: false
    });
  };
}

export const string = () => CustomString.create();

export const number = z.number;

export const boolean = z.boolean;

export const object = z.object;

export const date = z.date;

export const union = z.union;

export const literal = z.literal;

export const record = z.record;

export const array = (schema) => CustomArray.create(schema);

export const enumeration = z.enum;

export const relation = () =>
  z.object({ id: z.union([z.number(), string()]) }).nonstrict();

export const errorMap = (error, ctx) => {
  if (error.message) return { message: error.message };

  switch (error.code) {
    case z.ZodIssueCode.invalid_type:
      if (error.received === ""undefined"") {
        return { message: ""Campo obrigatÃ³rio"" };
      }

      break;

    case z.ZodIssueCode.too_small:
      if (error.type === ""string"" && error.minimum === 1) {
        return { message: ""Campo obrigatÃ³rio"" };
      }

      break;

    case z.ZodIssueCode.nonempty_array_is_empty:
      return { message: ""Deve conter no mÃ­nimo um registro"" };

    case z.ZodIssueCode.too_big:
      return { message: `MÃ¡ximo de ${error.maximum} caracteres` };

    case z.ZodIssueCode.invalid_string:
      if (error.validation === ""regex"") {
        return { message: ""Regex invÃ¡lida"" };
      } else if (error.validation === ""email"") {
        return { message: ""E-mail invÃ¡lido"" };
      } else if (error.validation === ""url"") {
        return { message: ""Site invÃ¡lido"" };
      } else if (error.validation === ""cpf_cnpj"") {
        return { message: ""CPF/CNPJ invÃ¡lido"" };
      } else if (error.validation === ""cep"") {
        return { message: ""CEP invÃ¡lido"" };
      } else if (error.validation === ""telefone_celular"") {
        return { message: ""Telefone invÃ¡lido"" };
      }

      break;

    case ""custom"":
      return { message: ""NÃ£o pode conter elementos duplicados"" };
  }

  return { message: ctx.defaultError };
};

export const validateSchema = async (schema, input) =>
  schema.safeParseAsync(input, { errorMap });
```",,
899874439,464,New feature - custom methods,"Hello,

It would be nice if Zod accepted adding custom methods to the chain, like this:

```javascript
import { z } from ""zod"";

z.string().startingWithA().parse(""B""); // error
```

The custom method would be like a `refine` but in the chain of methods of schema.

The use case would be more intuitive schemas, instead of importing `zod` and custom `refine` functions, I just import my custom schemas with the custom methods.

I use this for string functions like `cpfCnpj` (an SSN in my country), `phone`, etc.

I'm using Zod v2 and I managed to do this extending the `ZodString` class, but in Zod v3 the `ZodString` code changed and I couldn't make it work anymore, so I'm stuck in Zod v2.

Also extending the class would leave the code more susceptible to changes in the parent classes, like from Zod v2 to Zod v3, so a native solution would be better.

Thanks.",,
899134839,463,feature: prepare,"What do you think about adding a new `.prepare()` method
- problem:
```typescript
const emailSchema = z.string().email()
emailSchema.parse("" aaa@bbb.ccc ""); // throws Error
```
but - if trimmed - it's a valid email, I can accept it.

- solution:
 ```typescript
const emailSchema = z.string().email().prepare(v => v.trim())
// and more concisely
const trimmed = v => v.trim()
z.string(trimmed).email()
```

You can add a parameter (without breaking change) and/or a new method (i.e. prepare), both accept a value that is of type `T` just like transform

this is only a toy-example there're a lot of real use case

[edit]
this solution is inspired to .transform() but act before the validation.",,
899101621,462,Fixed array of objects,"Hi, how are you?
I am looking for the ""correct"" way to do this validation with zod.
I have a property that contains always three objects with the following structure:
```javascript
{
    name: 'primary' | 'secondary' | 'tertiary',
    value: 'string with regex' // z.string().regex(regex)
}
```

The validation is because I **always** need those three objects in my array, and always one primary, one secondary and one tertiary.
Final result will always be:
```javascript
[
    {
        name: 'primary',
        value: 'string with regex'
    },
    {
        name: 'secondary',
        value: 'string with regex'
    },
    {
        name: 'tertiary',
        value: 'string with regex'
    },
]
```

How can I approach this with zod?
Thanks!",,
898777306,461,Literal and enum validation errors contain input data,"Normally `ZodError` does not contain the actual value that was invalid. IMHO this is good - errors are often logged, and there are many situations where you don't want to log the value - the value could be sensitive (credit card number, personally identifiable information, password/secret token of some kind), or it might be unsafe to log (might be several gigabytes, contain newlines, NUL bytes, ANSI terminal escape sequences, HTML, ... - some of which might cause problems when viewing logs later). 

However, for `z.literal` and `z.enum`, the message does contain the input data:

````
> z.literal('Foo').parse('Bar')
Uncaught ZodError: [
  {
    ""code"": ""invalid_type"",
    ""expected"": ""Foo"",
    ""received"": ""Bar"",
    ""path"": [],
    ""message"": ""Expected Foo, received Bar""
  }
]
<snip>

> z.enum(['Foo','Bar']).parse('Bad')
Uncaught ZodError: [
  {
    ""code"": ""invalid_enum_value"",
    ""options"": [
      ""Foo"",
      ""Bar""
    ],
    ""path"": [],
    ""message"": ""Invalid enum value. Expected 'Foo' | 'Bar', received 'Bad'""
  }
]
<snip>
```

I would suggest aligning these two with the other errors (it looks like these are the only two exceptions), so that logged error messages can never contain the invalid input data itself.
",,
897485999,458,Cannot compile using tsc with typescript 4.2.4 in 3.0.1,"Running TSC on project consuming zod 3.0.1 with typescript 4.2.4 gives the following error on the types.d.ts:
```
> tsc

node_modules/zod/lib/types.d.ts:305:185 - error TS2536: Type 'k_1' cannot be used to index type 'addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>'.

305     static create: <T_1 extends ZodRawShape>(shape: T_1) => ZodObject<T_1, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>[k_3]; }>;
    
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:305:355 - error TS2536: Type 'k_3' cannot be used to index type 'addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>'.

305     static create: <T_1 extends ZodRawShape>(shape: T_1) => ZodObject<T_1, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>[k_3]; }>;
    
                                                                                                                                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:306:192 - error TS2536: Type 'k_1' cannot be used to index type 'addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>'.

306     static strictCreate: <T_1 extends ZodRawShape>(shape: T_1) => ZodObject<T_1, ""strict"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>[k_3]; }>;
    
          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:306:362 - error TS2536: Type 'k_3' cannot be used to index type 'addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>'.

306     static strictCreate: <T_1 extends ZodRawShape>(shape: T_1) => ZodObject<T_1, ""strict"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>[k_3]; }>;
    
                                                                                                                                                                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:307:195 - error TS2536: Type 'k_1' cannot be used to index type 'addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>'.

307     static lazycreate: <T_1 extends ZodRawShape>(shape: () => T_1) => ZodObject<T_1, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>[k_3]; }>;
    
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:307:365 - error TS2536: Type 'k_3' cannot be used to index type 'addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>'.

307     static lazycreate: <T_1 extends ZodRawShape>(shape: () => T_1) => ZodObject<T_1, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][""_input""]; }>[k_3]; }>;
    
                                                                                                                                                                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:481:174 - error TS2536: Type 'k_1' cannot be used to index type 'addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>'.

481     object: <T extends ZodRawShape>(shape: () => T) => ZodObject<T, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>[k_3]; }>;
                                                                                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:481:336 - error TS2536: Type 'k_3' cannot be used to index type 'addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>'.

481     object: <T extends ZodRawShape>(shape: () => T) => ZodObject<T, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>[k_3]; }>;
    
                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:497:182 - error TS2536: Type 'k_1' cannot be used to index type 'addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>'.

497 declare const objectType: <T extends ZodRawShape>(shape: T) => ZodObject<T, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>]: 
objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>[k_3]; }>;
    
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:497:344 - error TS2536: Type 'k_3' cannot be used to index type 'addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>'.

497 declare const objectType: <T extends ZodRawShape>(shape: T) => ZodObject<T, ""strip"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>]: 
objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>[k_3]; }>;
    
                                                                                                                                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:498:189 - error TS2536: Type 'k_1' cannot be used to index type 'addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>'.

498 declare const strictObjectType: <T extends ZodRawShape>(shape: T) => ZodObject<T, ""strict"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>[k_3]; }>;
    
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:498:351 - error TS2536: Type 'k_3' cannot be used to index type 'addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>'.

498 declare const strictObjectType: <T extends ZodRawShape>(shape: T) => ZodObject<T, ""strict"", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][""_output""]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][""_input""]; }>[k_3]; }>;
    
                                                                                                                                                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Found 12 errors.
```",,
897033138,457,typescript doc comments?,"Hi, I am working on integrating zod into one of my current projects. In the past I have used a combination of declared typescript types and manual validation. Zod is obviously a lot nicer to use on the validation side, but there is one piece from declaring types that I cannot find a replacement for in zod. That is [doc comments](https://typedoc.org/guides/doccomments/)

E.g. if I have the following struct defined:
```ts
interface Media {
  /**
  * The location of the media file
  */
  filepath: string
}
```

what would the equivalent comment look like in zod? These are important for my project, which relies on deno's documentation generation for user docs (see here https://doc.deno.land/https/raw.githubusercontent.com/andykais/ffmpeg-templates/main/lib/template_input.ts#Template)",,
896010631,456,label schemas for error logging,"Hello, I have been looking for a way to somehow label my schemas such that when I log the ZodError, it includes information about what schema the validation failed. With schema, I mean to nonprimitive values like `object` or `record`
",,
895334247,454,.extend after .refine,"```ts
const timespan = z.object({
    start: z.date(),
    end: z.date()
}).refine(startIsBeforeEnd)

const annotatedTimespan = timespan.extend({
    something: z.string()
})
// ^ Fails with error TS2339: Property 'extend' does not exist on type ...
```

I guess this is to do with it being difficult to define methods on a `ZodEffects` which may or may not be there depending on the first type parameter.",,
895218592,453,`.regex()` migration Zod 1 to 3,"Hi @colinhacks 

Congrats for the V3 ðŸŽ‰  ! That new version seems awesome ðŸ‘ðŸ» 

I'm looking to update the zod resolver for react-hook-form and I don't know if it's an issue or not but I can't chain anymore `.regex`

```ts
import { z } from ""zod"";

const password = z
  .string()
  .regex(new RegExp("".*[A-Z].*""), ""One uppercase character"")
  .regex(new RegExp("".*[a-z].*""), ""One lowercase character"")
  .regex(new RegExp("".*\\d.*""), ""One number"")
  .regex(
    new RegExp("".*[`~<>?,./!@#$%^&*()\\-_+=\""'|{}\\[\\];:\\\\].*""),
    ""One special character""
  )
  .min(8, ""Must be at least 8 characters in length"");
```

ðŸ‘‰ðŸ»  https://codesandbox.io/s/angry-proskuriakova-5rqvw

Should I use the `.and` method ?
Thanks!",,
894187563,452,Missing index signature when using passthrough() and infer(),"Iâ€™ve tried to update my projects from using zod v1 to zod v3. Unfortunately it seems like `passthrough()` doesâ€™t work in the same way as `nonstrict()` did before.

Example:

```ts
const foo = z.object({ foo: z.string() }).passthrough();
type Foo = z.infer<typeof foo>;
```

The inferred type `Foo` is now `{ foo: string; }`, but since I want to allow unrecognized keys I would expect something like `{ foo: string; [key: string]: unknown; }`.

Example with zod v1:

```
const foo = z.object({ foo: z.string() }).nonstrict();
type Foo = z.infer<typeof foo>;
```

The inferred type `Foo` is here `{ [x: string]: any, foo: string }`. ",,
892776955,446,3.0.0-beta.4 is marking properties as optional,"```typescript
const authSchema = z.object({
  email: z
    .string()
    .email()
    .transform(z.string(), (x) => x.trim().toLowerCase()),
  password: z.string().min(8),
});
```

Calling `authSchema.safeParseAsync()` returns data as optional.

```typescript
const result: {
    success: false;
    error: ZodError;
} | {
    success: true;
    data: {
        email?: string;
        password?: string;
    };
}
```

Also, safeParse is not working correctly. `if (result.success)` is not given me the data property, if it is negated the error property doesn't come up either. `if (result.success === true)` is working however.

I'm using version `2.0.0-beta.30`",,
892703629,443,"[WIP] `Excessive stack depth comparing types 'ZodIntersection<?, U>' and 'ZodIntersection<?, U>'.`","This is a WIP issue. I believe Zod (beta 4) is causing huge performances problem in my project. 

Ressource: https://github.com/microsoft/TypeScript/issues/43249

The performance problem happened after updating VSCode, so that might be the reason why it's happening.

I'll keep this issue updated

EDIT: this took a few hours of my life, solved by editing my workspace's settings.json following https://github.com/microsoft/TypeScript/issues/43249 proposed resolution

```json
{
  ""typescript.tsdk"": ""../../node_modules/typescript/lib""
}
```",,
892632577,442,Error message order is incorrect,"Hi,

I notice that the error message ordering seems off. It always reports the `email` error first instead of `nonempty`.

```
const schema = z.object({
  email: z
    .string()
    .nonempty({ message: ""Email is required"" })
    .email({ message: ""Email is invalid"" })
});
console.log(schema.safeParse({ email: """" }));
```

I believe this is a regression as its works find in the last 2.** beta version.
https://codesandbox.io/s/ecstatic-sun-b1vk2?file=/src/index.ts",,
892443895,439,Deprecate string.nonempty?,"It can be confusing using it with `.min` when they can both serve the same purpose. For example, it's impossible to know what happens if I do the following without consulting the source code:
```ts
z.string().min(2).nonempty();
```

Does that remove my minimum length of 2 on `.min`? The answer is yes, but it's unclear. I think it would be better to make users just use `.min(1)` as that is far easier to read and look at.",,
890607382,433,`parse` mutates object and adds a `times` property to it,"Hey there! I think I've got an edge case on using a combination of Zod's parse with recursive schema definition.

Basically, I have a schema that uses itself recursively in order to match against a JSON object. It parses correctly, however, I noticed that after parsing, it mutates the original object, adding a property `times` with the value as `NaN`.

Here's the example:

```ts
import assert from ""assert"";
import * as z from ""zod"";

export type None = undefined | null;
export namespace None {
  export const schema: z.ZodSchema<None> = z.union([z.undefined(), z.null()]);
}

export type Some = string | number | boolean;
export namespace Some {
  export const schema: z.ZodSchema<Some> = z.union([z.string(), z.number(), z.boolean()]);
}

export type Value = Some | Data | None;
export namespace Value {
  export const schema: z.ZodSchema<Value> = z.lazy(() => z.union([Some.schema, Data.schema, None.schema]));
}

export type Data = Record<string, unknown>;
export namespace Data {
  export const schema: z.ZodSchema<Data> = z.record(Value.schema);
}

const clone = (data: Object) => JSON.parse(JSON.stringify(data));

const data = {
  payload: {
    data: {},
  },
};

const original = clone(Object.freeze(data));

const result = Data.schema.parse(data);

assert.deepStrictEqual(original, result);
```

In this case the assertion fails due to `parse` have mutated this object, adding `times` to it:

```
  {
    properties: {
      data: {},
-     times: NaN
    }
  }
```

I took a look to try to understand why and it seems the culprit (or at least it's one step into fully understanding why) is this little part here:

https://github.com/colinhacks/zod/blob/1c51624d32756804a0b02a2e18eab31f9234ec1f/src/parser.ts#L133-L152

Basically, as my property is also named `data`, I think we must have some namespaces/variables conflict. When I test with changing `data` to `myData`, it works just fine.",,
883804637,430,Could Zod provide type guards for narrowing union types?,"I am using v3 branch and would like to ask if it is possible for Zod to provide type guards? This will be handy when dealing with union types:

```
const ASchema = z.object({a: z.string()});
type A = z.infer<typeof ASchema>;

const BSchema = z.object({b: z.string()});
type B = z.infer<typeof BSchema>;

const ABSchema = z.union([ASchema, BSchema])
const AB = z.infer<typeof ABSchema>;  // { a: string } | { b: string}


function f(x: AB) {
   if (ASchema.guard(x)) {
       x.a   // x is A
   } else {
       x.b 
   }
}
```
",,
881022247,429,Use existing interfaces and types to type check response from promise,"I understand the examples given for primitive types. But I quite dont understand a few things when I have to put all of them together.

If I have interfaces already do I have to use zodSchema to redeclare them? If yes, then this library would not be useful for existing big projects? Since everything have to be redeclared.

I'll give one example

```

interface Vehicle {
  name: string;
  model?: string;
  year: number;
}

interface Meta {
  id: string;
  url: string;
  description: string;
  meta: Meta;
}

interface Car extends Vehicle {
  supercar?: boolean;
  meta: Meta;
}

axios.get('....').then({data} => {
   // Validate that data is of type Car
})
```

So is validating the response from axios possible without declaring all the interfaces using zod types? Sorry if it seems like a newb question.",,
876312143,425,.nullable and .default,"EDIT: I see in https://github.com/colinhacks/zod/pull/421#issuecomment-830912340 it's not actually supposed to work this way... In which case I request that a ""default() for nulls"" or ""default() handles nulls"" be added, since I cannot figure out a way to do this without removing the null before passing to zod.

(Using 3.0.0-beta.1)

I expect `.nullable().default(...)` to not have `xxx | null` in the output type, in the same way that (redundancy aside) `.optional().default(...)` does not have `xxx | undefined`, but I'm not 100% sure my reasoning is correct.

Should `.default()` replace `null` values, so that `number().nullable().default(1) => number` or `number | null`?
Or does `.default()` only operate on `undefined`s?

Should the chaining order matter so that `number().nullable().default(1) => number` and `number().default(1).nullable() => number | null`?

Example:

```ts
// Given
export const PaginationInputSpec = z
  .object({
    page: z.number().default(1),
    perPage: z.number().default(100)
  })
  .nullable()
  .default({});

// I expect:
PaginationInputSpec.parse(undefined) => { page: number, perPage: number }
// AND
PaginationInputSpec.parse(null) => { page: number, perPage: number }

// but I get 
PaginationInputSpec.parse(...) => { page: number, perPage: number } | null
```

Is this a bug?

I can try to work around it with:
```ts
...
  .nullable()
  .transform((i) => i ?? undefined)
  .default({});
```
which removes the `| null` from the output type, but it DOESN'T ACTUALLY WORK AT RUNTIME, making the whole thing `undefined`.  I expected the ""inner"" defaults to then take effect, but they don't.

Using in a GraphQL API where input optionals can be entirely missing (`undefined`) or explicitly `null`.",,
876151183,424,[Question] How would you clamp values?,"I'm working on a pagination input parameter and I'm using the following, which should be easy to follow:

```ts
const PaginationInputSpec = z.object({
  page: z.number().min(1).default(1),
  perPage: z.number().min(1).max(1000).default(100)
}).optional()
```

However, if the input values are out of range for the `page` and `perPage`, I want to clamp them, not throw an error.  How would I do that?

Without zod I'd do it like this:
```ts
export function clampValues(pagination: PaginationParam | undefined): Required<PaginationParam> {
  const { page = 1, perPage = 100 } = pagination || {};

  return { page: Math.max(1, page), perPage: Math.min(1000, perPage) };
}
```

Should I rather not use zod for this?",,
875451578,423,Add docstrings to inferred type,"Given some code like:

```
import { z } from ""zod"";

const UserSchema = z.object({
  /**
   * The ""ame"" of the ""usern"" _not_ the ""name"" of the ""user""!
   **/
  username: z.string(),
});

interface UserInterface {
  /**
   * The ""ame"" of the ""usern"" _not_ the ""name"" of the ""user""!
   **/
  username: string;
}

type User = z.infer<typeof UserSchema>;

const foo: User = {
  username: """",
};

const bar: UserInterface = {
  username: """",
};
```

if I hover over `username: """"` of foo I don't see the docstring like I would when hovering over the username of bar

This is due to the fact that some of the mapped types are not quite homomorphic types (especially around addquestionmark) so typescript doesn't copy the metadata along to the new type. I think I might be able to change them into homomorphic types by using typescript 4.1's `[key in keyof T as ...]` syntax. 

Would you consider such a PR for merging? Are there any gotcha's that I should be aware of?",,
872685151,419,[V3] Support template literals,"Hello :wave: 

I recently encountered a case, where my schema returned a string, but a function accept only a TS template string

Here is an example showing the issue: https://codesandbox.io/s/snowy-river-n2ih2?file=/src/index.ts

![image](https://user-images.githubusercontent.com/3089715/116715026-9ef6c500-a9d6-11eb-87d2-04fe3a10fdc7.png)

Is there a way, currently or in the future, to be able to do this:

```ts
const str = z.template(`${z.number()}.${z.number()}.${z.number()}`)
type Str = z.infer<typeof str>
// => Str: `${number}.${number}.${number}`
```",,
871292384,418,Unknown keys are incorrectly permitted in Union types.,"(v3) This is similar to the issue in #311, but I'd like some input since Zod does not throw an error in my case at all.

Zod doesn't allow unknown keys in Object schemas. Is it possible to be strict on typing for Object Unions, to be consistent with Typescript?

```
const A = z.object({
          a: z.number()
});

const B = z.object({
          a: z.number(),
          b: z.string()
});
const AB = z.union([A, B]);
        const c = {
          a: 1,
          b: 2,
        };

AB.parse(c); // => returns { a: 1 } but should throw an error.
```

```
interface A {
  a: number;
}
interface B {
  a: number;
  b: string;
}

const b: A | B = {a: 1, b: 2} // Type 'number' is not assignable to type 'string'.
```",,
870036109,417,Using `default()` inside `lazy()` forces type to be optional,"This seems like a bug to me, but if I'm doing something wrong I'd be glad to know what the proper way is to handle this case.  If I do: 

```
const aSchema = z.object({
  name: z.string().nullable().default(null)
})

type A = z.infer<typeof aSchema>

// and typescript says:
type A = {
    name: string | null;
}
```

That type looks right to me.  But if I need a recursive type and I do:

```
type B = {
  name: string | null
, child: B | null
}

const bSchema: z.ZodSchema<B> = z.lazy(() =>
  z.object({
    name: z.string().nullable().default(null)
  , child: bSchema.nullable()
  })
)
```

Then I get a type inference error on `bSchema`:

```
Type 'ZodLazy<ZodObject<{ name: ZodOptional<ZodNullable<ZodString>, true>; child: ZodNullable<ZodType<B, ZodTypeDef, B>>; }, ""strip"", ZodTypeAny, { ...; }, { ...; }>>' is not assignable to type 'ZodType<B, ZodTypeDef, B>'.
  The types of '_input.name' are incompatible between these types.
    Type 'string | null | undefined' is not assignable to type 'string | null'.
      Type 'undefined' is not assignable to type 'string | null'.ts(2322)
```

I would expect to be able to still use `default()` with a non-optional field in this way.  It appears that `name` gets the `ZodOptional` with that `true` second type parameter is getting set with `default()`, and it's cleared out when using `z.infer<>` in the first case but not with the explicit type cast.

Zod version: 3.0.0-alpha.39
TypeScript version: 4.2.3",,
869687987,415,Add support for UUID v5,"It seems UUID v5 is not supported. Here's a simple test case:
```typescript
import * as z from 'zod'

const testUUID = 'b79cb3ba-745e-5d9a-8903-4a02327a7e09';
const schema = z.string().uuid()
schema.parse(testUUID)
```

Error output:
```json
ZodError: [
  {
    ""validation"": ""uuid"",
    ""code"": ""invalid_string"",
    ""message"": ""Invalid uuid"",
    ""path"": []
  }
]
```

Any chance to add support for this?",,
867249038,414,(v3) Refinements don't respect custom error map,"See codesandbox with example: https://codesandbox.io/s/silly-dirac-1q3j0?file=/src/index.ts

Instead, you must always use the refine function's second parameter, which is weird, inconsistent and doesn't seem intentional?

Thanks! The library is great.",,
866925946,411,Generate union from options array,"Hello. ðŸ˜€

How do I validate a Union with a large quantity?

```ts
const fruitsMap = [
  { uid: 1, name: ""banana"" },
  { uid: 2, name: ""apple"" },
  // ... many many many
] as const;

const arrowUIds = fruitsMap.map((v) => v.uid);
type FruitsUidUnions = typeof arrowUIds[number];

type Entity = {
  uid: FruitsUidUnions;

  // ... many many many
  foo: string;
  bar: string;
};

const schema: z.ZodSchema<Entity> = z.object({
  // It's a lot of work.
  uid: z.union([z.literal(1), z.literal(2)]),
});

const schema2: z.ZodSchema<Entity> = z.object({
  // Type Error
  uid: z.union(arrowUIds),
  foo: z.string(),
  bar: z.string()
});

const schema3: z.ZodSchema<Entity> = z.object({
  // Type Error
  uid: z.union(arrowUIds as [z.ZodAny, z.ZodAny, ...z.ZodAny[]]),
  foo: z.string(),
  bar: z.string()
});

const isValidUid = (p: unknown): p is FruitsUidUnions =>
  arrowUIds.some((v) => p === v);
const schema4: z.ZodSchema<Entity> = z.object({
  // How about something like this?
  uid: z.validate().refine(isValidUid),
  foo: z.string(),
  bar: z.string()
});
```",,
864743905,408,Type coming through as optional when using z.infer<>,"The types are coming through as optional when z.infered
<img width=""261"" alt=""Screen Shot 2021-04-22 at 9 32 15 PM"" src=""https://user-images.githubusercontent.com/1079931/115691494-385c2080-a3b2-11eb-8134-9a08ce4f8458.png"">
<img width=""222"" alt=""Screen Shot 2021-04-22 at 9 32 28 PM"" src=""https://user-images.githubusercontent.com/1079931/115691515-3e520180-a3b2-11eb-8795-1bf4d3870f62.png"">
",,
863210798,407,Update comparison with Runtypes,"Hi, I'm a collaborator of https://github.com/pelotom/runtypes. Some descriptions about Runtypes in README.md have become wrong now ðŸ˜‰ 

- Missing object methods: (~~pick~~, ~~omit~~, ~~partial~~, deepPartial, merge, ~~extend~~)
- Missing nonempty arrays with proper typing (`[T, ...T[]]`)
- ~~Missing lazy/recursive types~~
- Missing promise schemas
- ~~Missing union & intersection schemas~~
- Missing error customization
- ~~Missing record schemas~~ (their ""record"" is equivalent to Zod ""object"")


",,
860612246,405,How to know whether a field in zod schema is optional or not?,"Can I get information about the field in zod schema, I want to know if the field is required or not

```ts
export const phoneSchema = object({
  phone: string().refine(
    (phone) => isMobilePhone(phone, ""vi-VN""),
    ""Sá»‘ Ä‘iá»‡n thoáº¡i nÃ y khÃ´ng há»£p lá»‡""
  ),
});
```",,
859740017,403,Feature idea: `.maybe()` === `.optional().nullable()`,Would be nice to have a `.maybe()` that's the same as `.optional().nullable()`. In GraphQL this is used a lot,,
859621671,402,Existing object as omit function argument leads to schema being an empty object,"Hi there, 

I want to use `.omit` with the same argument on multiple schema declarations. To do this, I specify the fields to be omitted in an object and use that object for multiple `.omit` calls instead of writing the same `.omit` argument multiple times. However, when I do this, zod removes all properties from the object instead of only the ones I specified.

Here is an example:

```
import * as z from ""zod"";

// MyType1 has prop2 after omit as expected

const MyType1 = z
  .object({
    prop1: z.string(),
    prop2: z.number()
  })
  .omit({ prop1: true });

type MyType1 = z.infer<typeof MyType1>;

// MyType2 is empty!?!

const omitProps: { [prop: string]: true } = { prop1: true };

const MyType2 = z
  .object({
    prop1: z.string(),
    prop2: z.number()
  })
  .omit(omitProps);

type MyType2 = z.infer<typeof MyType2>;
```

What I expected to get is this
```
type MyType1 = {
    prop2: number;
}

type MyType2 = {
    prop2: number;
}
```

What I get instead is this
```
type MyType1 = {
    prop2: number;
}

type MyType2 = {}
```

I created a codesandbox of this example [here](https://codesandbox.io/s/zod-omit-problem-glfc9?file=/src/index.ts).",,
858160261,397,`.transform()` returning output types unioned with input types,"Hi there,

I've been excitedly looking to into using Zod as it provides great type-safety compared to yup, but also doesn't require a programming style shift like io-ts, which isn't so palatable for my team.

I have unfortunately hit a bit of snag with type inference of `transform()` which is currently limiting our ability to adopt this, though I do wonder if if I am misunderstanding the intent of this function.

I am trying to create a reusable Schema for for the `Decimal` class from `decimal.js`, which is pretty pervasive throughout our code-base.

I'd like it to accept `number`, `string` and `Decimal` instances as input but ultimately transform them into `Decimals`

Here is my attempt:

```typescript
import * as z from ""zod"";
import { Decimal } from ""decimal.js"";

// const decimal = (): z.Schema<Decimal> =>
const decimal = (): z.Schema<Decimal | string | number> =>
  z
    .instanceof(Decimal)
    .or(z.string())
    .or(z.number())
    .refine((value) => {
      try {
        return new Decimal(value);
      } catch (error) {
        return false;
      }
    })
    .transform((value) => new Decimal(value));
```
My expectation here would be that `refine` would trigger an error during parsing if input could not be converted to a Decimal and `transform` would ensure that the output is a `Decimal`.

However if I make the return type of this function with `z.Schema<Decimal>` I get a type error because the inferred type is actually `z.Schema<Decimal | string | number>`.

Am I misunderstanding what `transform` is supposed to be doing here?

Further, it's a little sad that I have to try and construct the `Decimal` instance to validate the input and then have to do it again in the `transform` call. I do understand that `refine` does not actually change the type of the input so this makes sense. Something I'd like to see is something like the following where where `refine` (or some new function?) accepts a type guard that informs the output type. (I have no idea if this is possible though):

```typescript
// const decimalIdeal = (): z.Schema<Decimal> =>
const decimalIdeal = (): z.Schema<Decimal | string | number | undefined> =>
  z
    .instanceof(Decimal)
    .or(z.string())
    .or(z.number())
    .transform((value) => {
      try {undefined
        return new Decimal(value);
      } catch (error) {
        return undefined;
      }
    })
    .refine((value): value is Decimal => value instanceof Decimal);
```
Note that the return type also includes `undefined` in order to type check now. It was this that lead me to believe that `transform` is returning the output type union-ed with the input type.

Many thanks for this library and any help you may be able to provide!

EDIT:

For what it's worth, the inferred type when using `TypeOf` is actually correct, so I've been able to test that the result of the Schema does type check with the following code:

```typescript
const _typeCheckDecimal: z.TypeOf<ReturnType<typeof decimal>> = {} as Decimal;
const _typeCheckDecimalReverse: Decimal = {} as z.TypeOf<ReturnType<typeof decimal>>;
```
But this will need to be done for any object schemas that use the `decimal` type above. It would be nice if the type could be ""correct"" at the declaration site too, if possible. 

",,
858048010,396,How to specify discriminant for union?,"I'm using zod for form input, and there is a single dropdown field that should determine the ""level"" of validation. Essentially, most fields can be empty until you mark the form as ""Published"", at which point, all the fields because required.

I had originally built out two schemas: the non-published schema, and the published schema, that extend from the optional schema and made the rest of the fields required. I then used `z.union([nonPublishedSchema, publishedSchema])` to represent the whole form schema.

Simplified Example: 
```typescript
const nonPublishedBookSchema = z.object({
  title: z.string().optional(),
  availability: z.enum([""Draft"", ""Review""]);
})

const publishedBookSchema = nonPublishedBookSchema.extend({
  title: z.string(),
  availability: z.enum([""Published""]);
})

export const schema = z.union([nonPublishedBookSchema, publishedBookSchema]);
```

However, the errors that come out of zod when flipping the dropdown to ""Published"" make it hard to determine what is truly incorrect about the form. If I have a field empty, the first part of the union error (for non-published) will tell me that the availability enum value is incorrect, and the second part of the union error (for published) will tell me that the field is required.

I'd like to be able to specify the availability field as a sort of switch between different schemas. Basically, i would associate a full schema with a value or a series of values, and the errors I'd like to get out of zod should be specific only to that schema. Is there some way to do this? I thought about doing a refinement at the root of the schema, but I wasn't sure.",,
857000191,395,[Question] how do you sujeest to validate table?,"I have a table which use an array of object for validation.
The problem is that when I validate the array it affects all rows.

``` js
export const PersonSchema = z.object({
  email: z.string().email(),
  givenName,
  familyName,,
}).array();
```

For example if I have a column of email, and it is valid on one row but invalid on the other both cell would show the error because the field name is 'email' on both.",,
856782544,394,`min` and `max` methods for `ZodSet`,[Deleted for privacy reasons],,
856747612,393,Can we store extra data on a chema?,"Can we store some data on a schema like defaultValue for a schema, description of it, so that we can create a value with defaultValue with a method like
```javascript
z.object({
  id: z.string(),
  status: z.enum(['on', 'off']).default('on'),
}).create()
// and then get an object : {id: '', status: 'on'}
```
for form initialization.

or we can have a method like 
``` javascript
z.number().exra({
  title:  'GitHub Stars',
  defaultValue: 0,
})
```


",,
856344910,392,Type of a Schema ?,"Hi,
i would like to write a function that would accept a schema as a parameter.
```ts
const func = (schema:z.Schema<string>)=>{
   const result = schema.safeParse(""foo"");
}
```
However, the compiler says that `schema` has type   `ZodSchema<string, zod.ZodTypeDef, string> | ((_: unknown) => boolean)`
What is the correct type to use for the function ? ",,
855738293,391,"Feature request: "".maybe()"" type","Hi there, thanks for the excellent library, I'm using it on a variety of projects now! A problem I have come across recently is that while building schema for third-party REST APIs (ie. APIs which I have no control/influence over) I have to type non-mandatory properties like this:

```ts
/*
 * Generated from:
 * https://developer.zendesk.com/rest_api/docs/support/attachments#json-format
 */
export const attachmentResourceSchema = zod.object({
  // The content type of the image. Example value: ""image/png""
  content_type: zod.string().nullable().optional(),

  // A full URL where the attachment image file can be downloaded
  content_url: zod.string().nullable().optional(),

  // If true, the attachment has been deleted
  deleted: zod.boolean().nullable().optional(),

  // The name of the image file
  file_name: zod.string().nullable().optional(),

  // Automatically assigned when created
  id: zod.number().nullable().optional(),

  // If true, the attachment is excluded from the attachment list and the attachment's URL can be referenced within the comment of a ticket. Default is false
  inline: zod.boolean().nullable().optional(),

  // The URL the attachment image file has been mapped to
  mapped_content_url: zod.string().nullable().optional(),

  // The size of the image file in bytes
  size: zod.number().nullable().optional(),

  // An array of attachment objects. Note that photo thumbnails do not have thumbnails
  thumbnails: zod.array(zod.unknown()).nullable().optional(),

  // A URL to access the attachment details
  url: zod.string().nullable().optional(),
})
```

The use of both `.nullable()` _and `.optional()` is apparently necessary (I've cross-checked against many payloads). Sometimes the payload contains those nullified properties, and other times it omits them entirely (ie. they are undefined). Could there be a `.maybe()` method which consolidates these two validations? I would be open to alternative naming.

Thanks!",,
855356653,390,`.strict()` and `.and()` combined is not working,"### Bug description

The method `.strict()` and `.and()` combined results in an unexpected parsing error.

### Zod version

`3.0.0-alpha.33`

### Playground

```ts
const a = z.object({ a: z.string() }).strict();
const b = z.object({ b: z.string() }).strict();
const c = a.and(b);

c.parse({ a: ""a"", b: ""b"" });
```

### Output

```sh
error: ZodError: [
    {
      ""code"": ""unrecognized_keys"",
      ""keys"": [
        ""b""
      ],
      ""path"": [],
      ""message"": ""Unrecognized key(s) in object: 'b'""
    },
    {
      ""code"": ""unrecognized_keys"",
      ""keys"": [
        ""a""
      ],
      ""path"": [],
      ""message"": ""Unrecognized key(s) in object: 'a'""
    }
  ]
  ```",,
855346412,389,z.string().uuid() is unreliable,"```js
import * as z from 'zod';

const definitelyNotUUID = '4bf1b128-936b-4cc2-8ec9-0d69e5a97b48blablablawhatever';
const schema = z.string().uuid();
schema.parse(definitelyNotUUID) // no error at all
```

Intrestingly, with `definitelyNotUUID = 'test'` it works as expected.
Tested with zod v.1.11.13",,
855219835,388,TypeError: Cannot read property '_parseWithInvalidFallback' of undefined,"Zod v3.0.0-alpha.29
Typescript v4.2.4

Short repro:

```ts
import * as z from 'zod';

const geojsonPolygonSchema = z.object({
    type: z.literal('Polygon'),
    coordinates: z.array(z.array(z.tuple([z.number(), z.number()]))),
});

const geojsonMultiPolygonSchema = z.object({
    type: z.literal('MultiPolygon'),
});

const geojsonShapeSchema = z.union([geojsonPolygonSchema, geojsonMultiPolygonSchema]);

const value = {
    ""type"" : ""MultiPolygon"",
    ""coordinates"" : [[[
        [0, 1], [2, 3], [4, 5]
    ]]]
}
console.log(geojsonShapeSchema.safeParse(value));
```

Output:

```
TypeError: Cannot read property '_parseWithInvalidFallback' of undefined
  at Object.function (node_modules/zod/lib/types.js:1340:35)
  at _loop_1 (node_modules/zod/lib/PseudoPromise.js:143:44)
  at PseudoPromise.getValueSync (node_modules/zod/lib/PseudoPromise.js:161:17)
  at node_modules/zod/lib/PseudoPromise.js:102:62
  at Array.map (<anonymous>)
  at Object.function (node_modules/zod/lib/PseudoPromise.js:102:32)
  at _loop_1 (node_modules/zod/lib/PseudoPromise.js:143:44)
  at PseudoPromise.getValueSync (node_modules/zod/lib/PseudoPromise.js:161:17)
  at ZodTuple.ZodType._parseInternal (node_modules/zod/lib/types.js:285:33)
  at ZodTuple.ZodType._parseWithInvalidFallback (node_modules/zod/lib/types.js:154:32)
```
",,
852777556,387,Validating file input,"Coming from Yup. I'm trying to validate a required file input with no success:

```javascript
file: z.any().refine(val => val.length > 0, ""File is required"")
```

Any tips?",,
852012955,386,[Question] Custom error message for invalid type,"Suppose this code:

`export const userSchema = z.object({
  id: z.string().nonempty(""Missing Parameter""),
  password: z.string().nonempty(""Missing Parameter"")
});`

If I want to have a custom invalid type error message, such as ""Field id does not have the correct type"", what can be done?
Neither the string or number functions have overloads for messages, meaning they don't accept a custom error message. Is there anything I can do to add this invalid type error message?

i.e.
`
z.string(""Invalid type for id"").nonempty(""Missing Parameter"")
`",,
851803326,385,Firebase integrations,"I'm using zod with applications build on firebase.

firebase database(ex. firestore) can define custom rules like this.

```rule
rules_version = ""2"";
service cloud.firestore {
  match /databases/{database}/documents {
    function isAuthenticated() {
      return request.auth.uid != null;
    }

    function isMe(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }

    match /users/{uid} {
      function validateUserData(data) {
        return 'name' in data && data.name is string
          && 'age' in data && data.age is number;
      }
      allow get: if isMe(uid);
      allow create: if isAuthenticated() && validateUserData(request.resource.data);
      allow update: if isMe(uid) && validateUserData(request.resource.data);
      allow delete: if isMe(uid);
    }
}
```

And in web application, 

```typescript
// schema defs
import * as z from 'zod'

export const UserSchema = z.object({
  name: z.string(),
  age: z.number(),
})
export type UserModal = z.infer<typeof UserSchema>

// user create form

// If you use react-hook-form, it looks like this
export const UserCreateForm = () => {
  const {} = useForm<UserModal>(
    resolver: zodResolver(UserSchema)
  )
  // ....
}
```

And my question is, what might be a hint for me to create a CLI that automatically creates firebase rules based on schema definitions in zod.
Here's a rough image of what it looks like.

```json
// config file
{
  ""inputPath"": ""./src/firestore-rule.ts"",
  ""outputPath"": ""./firestore.rules""
}
```

```typescript
// ./src/firestore-rule.ts
import { Model, funcDef, op } from 'firebase-zod' // This is the library I plan to implement in the future
import { UserSchema } from './schema'

const isAuthenticated = funcDef(({ request }) => op.notNull(request.auth.uid))

const isMe = funcDef(({ request, arg}) => {
  const uid = arg.create('uid')
  return op.and(isAuthenticated(), op.equals(request.auth.uid, uid))
})

export class UserModel extends Model {
  schema = UserSchema
  paths = ['users']
  
  get() {
    return isMe(this.ids[0])
  }
  create({ request }) {
    return op.and(isAuthenticated(), this.validate(request.resource.data))
  }
  update({ request }) {
    return op.and(isMe(this.ids[0]), this.validate(request.resource.data))
  }
  delete() {
    return isMe(this.ids[0])
  }
}
```

Then, I would like to convert this code into a firestore rule by hitting some commands.

Once this is done, we can synchronize the validation in firebase with the validation in zod. Also, firebase rules cannot be split into separate files, which makes the files larger and more obfuscated, but if we can manage them on typescript, we will be able to split the code.

I think I need to know more about zod to make this possible, but I'm not familiar with zod yet. So I'd be very happy if you could give me some hints on how to make this work.",,
851773878,384,How to use `instanceof` to class with private constructor,"first, I want to use zod with `firebase/firestore`. And there is [`FieldValue`](https://firebase.google.com/docs/reference/js/firebase.firestore.FieldValue) class use for `createdAt` or `updatedAt`.

So, I think like this to use zod with firebase
```typescript
import * as z from 'zod'
import firebase from 'firebase/app'

const ServerTimestampSchema = z.instanceof(firebase.firestore.FieldValue)

const UserSchema = z.object({
  name: z.string(),
  // ...
  createdAt: ServerTimestampSchema,
  updatedAt: ServerTimestampSchema
})
```

maybe, this works at run time, but typescript compiler throw this message.

```typescript
// ...
const ServerTimestampSchema = z.instanceof(firebase.firestore.FieldValue)
// Argument of type 'typeof FieldValue' is not assignable to parameter of type 'new (...args: any[]) => any'.
//  Cannot assign a 'private' constructor type to a 'public' constructor type.ts(2345)

// ...
```

If someone has any solutions, please tell me!!",,
849920228,379,Non-latin email addresses arenâ€™t supported,"Inspired by [this article](https://www.netmeister.org/blog/email.html), I decided to check whether any of the following email addresses work with zod@nextâ€™s email string validator. Unfortunately, none of the addresses below are marked as valid, even though Gmail already supports non-latin addresses like:

```
""josÃ©.arraÃ±oÃ§a""@domain
""ÑÐ°Ð¹Ñ‚""@domain
""ðŸ’©""@domain
""ðŸºðŸ•ºðŸŽ‰""@domain
poop@ðŸ’©.la
""ðŸŒ®""@iâ¤ï¸tacos.ws
jschauma@Ø´Ø¨ÙƒØ©Ù…Ø§ÙŠØ³ØªØ±..Ø´Ø¨ÙƒØ©
```",,
849914721,378,Email validation extremely slow for a given string,"First of all, thank you for maintaining this library! It helps a lot with deploying uniform validation logic on both the server and the client.

Using zod v3, I decided to try some of the email addresses mentioned [in this article](https://www.netmeister.org/blog/email.html) and found out that the following string takes around **7 seconds to validate on a MacBook Pro from 2019.** The following string, even though not meant to be used as-is, caused the issue:

```
""put a literal escaped newline here\ <--""@domain
```

I noticed that the issue only happens when `@domain` is used at the end without a TLD (e.g. `.com`). Also, I noticed thereâ€™s a substantial loss of performance when specifying >20 chars before `\ `, as seen below in a minimalistic reproduction case:

```ts
import { z } from ""zod""; // @3.0.0-alpha.33

const Email = z.string().email();
const prevTime = performance.now();
try {
  Email.parse('""xxxxxxxxxxxxxxxxxxxxxxxxxxx\\ "".x');
} catch {}
console.log(`${performance.now() - prevTime}ms`);
```

A live demo of the issue is [available on CodeSandbox](https://codesandbox.io/s/brave-shockley-ny1q0?file=/src/index.ts).",,
847895733,376,[Feature Suggestion] String CSS selector,"Just a suggestion as it came up as a use-case for me today -

Currently, Zod string has secondary validators such as:

```typescript
z.string().url()
```

Would there be any interest in adding a validator for CSS selectors?

```typescript
z.string().selector()
// or
z.string().css()
```

I ended up using this package temporarily for reference: https://github.com/mdevils/css-selector-parse


## Psuedo example

I'm not super great with regex so this is only a start, but if it's something of interest I think it must be possible to write a matcher...  ðŸ¤”

```typescript
// Basic start to regex pattern...
const cssRegex: RegExp = /(div|span|section|h1|h2|h3|h4|h5|h6|header|footer|nav){0,1}[#.]{1}[a-zA-Z][a-zA-Z0-9\-_]+/i
  
// Rule definition...
if (this._def.isCss && !cssRegex.test(ctx.data)) {
  ctx.addIssue({
    validation: ""css"",
    code: ZodIssueCode.invalid_string,
    message: this._def.isCss.message
  })
}

```
",,
847347595,374,Why ignore undeclared object properties in v3?,"I just read that in version 3, object schemas are no longer ""strict"" by default. Does this mean I have to add `.strict()` to all several hundred of my schemas to migrate to version 3? And I have to remember to add `.strict()` every time I write `.object()`? It would be nice if there were a way of opting into the old behavior without having to change hundreds of lines of code.

Honestly, I think from philosophical standpoint, a validation library should always be strict by default. But maybe I'm a purest.

Regardless, thanks for the great library.",,
845002183,372,Typecheck schemas against existing types,"### TL;DR
I would love to have a way to ensure that a Zod schema matches an existing type definition using the normal Typescript type checker. Below is an example of the desired functionality using one possible implementation stolen from [this comment](https://github.com/colinhacks/zod/issues/53#issuecomment-655879215).

```typescript
type Dog = {
  name: string
  neutered: boolean
}

//Passing ""Dog"" as a generic type parameter tells Typescript what the schema should look like
const dogSchema = z.object<Dog>({
  name: z.string().min(3),
  neutered: z.string(), //Error: string can't be assigned to boolean
});
```

### Introduction

I originally raised this suggestion in #53, but decided it probably needs its own issue. See my original comments [here](https://github.com/colinhacks/zod/issues/53#issuecomment-737550649) and [here](https://github.com/colinhacks/zod/issues/53#issuecomment-738110750). Based on the reactions to these comments, there are at least a few other people thinking along the same lines as I am. I will restate my thoughts below.

I want to start by saying that Zod is a really, really cool project. It is the best runtime validation system for typescript by far. I hope the following critiques are constructive. 

### My runtime validation requirements

I started implementing Zod in my project, and I went into this implementation assuming that Zod would meet the following two requirements:

1.  Zod schemas would provide run time checks of my data types. **[true]**
2.  Zod schemas would conform to my existing types, so that it is impossible to change the type without also changing the associated schema (and vice versa) . **[only sort of true]**

In order to get the effect of my second requirement, I discovered that I need to replace my existing code, eg...

```typescript
export interface A {
   readonly ID: number;
   delayEnd: number;
   userID: number;
   reason: string;
   taskID: number;
   initiationDate: number;
   days?: number;
   userName?: string;
}
```

...with something like this...

```typescript
export const aSchema = z.object({
   ID: z.number(), //Note that I've lost the functionality of `readonly` in this conversion
   delayEnd: z.number(),
   userID: z.number(),
   reason: z.string(),
   taskID: z.number(),
   initiationDate: z.number(),
   days: z.number().optional(),
   userName: z.string().optional()
});

//""A"" is generated from the schema
export type A = z.infer<typeof aSchema>;
```

This makes it so that if I change `aSchema`, `A` will automatically update to match, which gives me most of what I was looking for. But there are some serious problems with this solution.

### The Problems

The most obvious problem with the above code example is that it removes some really valuable typescript features: As just one example, the functionality of `readonly` has been lost in the conversion to `aSchema`. Perhaps it is possible to reintroduce that functionality with some fancy Typescript manipulation, but even if that is the case it is still not ideal.

Perhaps a more central problem, though, is that I need to strip out pretty much all of my current type definitions and replace them with Zod schemas. There are some tools out there that will do this work for you (issue #53 was originally and ultimately about building these sorts of tools), but the real issue for me isn't the work of refactoring: The real problem is that such a refactor puts Zod in charge of my type system, which is very undesirable. In my opinion, Typescript should be the master of typing, and Zod should be the master of validation. In the current system, Typescript is subordinated to Zod rather than the other way around.

To make sure my intent is clear, here are a few re-statements of this idea:
- I want to keep all my types as they are and create schemas that conform to them.
- I do not want to replace my existing type definitions with schemas; instead I want to create schemas that match my existing types. 
- I want to keep my type system in typescript and only use Zod to validate that objects fit my existing types. 

To put it a different way, Zod is advertised as ""Typescript first"", but right now it feels more like ""Zod first with Typescript as a close second"". I say that because, currently, if I want to maintain type consistency I have to write the Zod schemas first, then use them to generate types. To be truly ""Typescript first"", the schemas should conform to the types instead of the types being generated from the schemas.

### The `tozod` solution

A great idea that addresses these issues was introduced in [this comment](https://github.com/colinhacks/zod/issues/53#issuecomment-655879215), discussed in [this comment](https://github.com/colinhacks/zod/issues/53#issuecomment-655937376), then partially implemented in the  `tozod` library (see [this comment](https://github.com/colinhacks/zod/issues/53#issuecomment-664193624); the library can be found [here](https://www.npmjs.com/package/tozod)). The `tozod` utility allows me to write the following in place of the above code example:

```typescript
//My interface does not change
export interface A {
   readonly ID: number;
   delayEnd: number;
   userID: number;
   reason: string;
   taskID: number;
   initiationDate: number;
   days?: number;
   userName?: string;
}

//The use of toZod ensures that the schema matches the interface
export const aSchema: toZod<A> = z.object({
   ID: z.number(),
   delayEnd: z.number(),
   userID: z.number(),
   reason: z.string(),
   taskID: z.number(),
   initiationDate: z.number(),
   days: z.number().optional(),
   userName: z.string().optional()
});
```

This meets my requirements perfectly. It preserves my original types and has a schema that conforms to those types. It gives me the same strong typing as using `z.infer` would have, but it leaves Typescript in charge of defining my type system and still gives me all the benefits of runtime validation. It also preserves certain Typescript functionality that can't be modeled in Zod, like the `readonly` in `A`. I think this scenario gives the best of all worlds and is truly ""Typescript-first"". I realize that it is slightly more verbose than just having a schema, but I think the benefits are well worth it. It fits much better into the established Typescript paradigm. I could go on and on about why this is a better solution.

### The problem with `tozod`

There is just one problem with the `tozod` utility. I quickly discovered, and the author of `tozod` admits, that it is ""pretty fragile"" and can only handle the most basic types (see [this comment](https://github.com/colinhacks/zod/issues/53#issuecomment-664753908)). Even a simple union type will cause it to break. The `tozod` library was a great step in the right direction, but in its current state it is virtually unusable in real application environments.

### My suggestion

My suggestion is that we need something like `tozod`, preferably built into `Zod`, that allows schemas to be type checked against existing types in a real application environment. I don't know if this is feasible -- I'm not a Typescript expert, so it might not even be possible; but if it is possible, I think this change would be extremely beneficial.
",,
844618372,371,[Question] How can I get field type from Zod object (reflection like)?,"Assuming I'm having the following:

`
export const PersonSchema = z.object({
  email: z.string().email(),
  givenName: z.string(),
  birthday: z.date().optional(),
});
`

Can I check what's the type of specific field (reflection like)?
I'm passing it to a component via property  

`
{ schema: SchemaObjectDef<ZodRawShape> }
`
.i.e.
`
      <Formation
        schema={PersonSchema}
      />
`

Inside the component (Formation) I like to iterate on the schema definitions and get insight on each field.
For example to check whether it email, string, number, etc.

I'm doing kind of pattern matching and creating a dynamic subcomponent within the Formation control.
",,
842801513,370,URL validator should be a regex,"Ok so, just noticed when i added a url validator that the following passes

```
https://anything
```

this is hardly a URL and `new URL()` is validating too early. 

I think a more refined regex is better than using `new URL()`. I know you had a regex before and you changed just because of a single use case that failed however thats hardly an encouragement to change the way a url is validated. ",,
841942656,368,Mocking,"Hi,

I have started working on a `zod-generators` companion library with aim of generate random values, both valid or invalid, given a zod field of any type.

As a middle ground between functional and unit testing, I often write fixtures for my models, specifically for messages (HTTP request bodies, queue messages). Since the model is shared between producer & consumer, I can write contractual tests as the generated fixtures are shared. I then test that my producer spits out a valid value, and then I check that the consumer is able to process my generated fixtures.

The idea here is to generate fixtures and more importantly random fixtures easier to generate. For example, if my model defines a string and a number, then I would have a function to generate permutations of what can be valid and what can't be valid.

I think the only issues we would see here is with refines (I think we can just apply transforms to the valid generated values) as they are business logic that we can't dynamically inspect.

I have a PoC with very basic support for `zod.boolean`, `zod.number` and `zod.string` here:
https://github.com/dipasqualew/zod-generators

I was just curious of your thoughts before I put more effort into this ðŸ™‚ 

Cheers ",,
841458308,364,Circular dependency when running tsc,"Just ran `tsc` on latest `@next` and received:

```shell
node_modules/zod/lib/types.d.ts:314:14 - error TS2456: Type alias 'deoptional' circularly references itself.

314 declare type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U, any> ? deoptional<U> : T;
                 ~~~~~~~~~~

node_modules/zod/lib/types.d.ts:314:87 - error TS2315: Type 'deoptional' is not generic.

314 declare type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U, any> ? deoptional<U> : T;
                                                                                          ~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:339:49 - error TS2315: Type 'deoptional' is not generic.

339     required: () => ZodObject<{ [k in keyof T]: deoptional<T[k]>; }, UnknownKeys, Catchall, objectOutputType<{ [k in keyof T]: deoptional<T[k]>; }, Catchall>, objectInputType<{ [k in keyof T]: deoptional<T[k]>; }, Catchall>>;
                                                    ~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:339:128 - error TS2315: Type 'deoptional' is not generic.

339     required: () => ZodObject<{ [k in keyof T]: deoptional<T[k]>; }, UnknownKeys, Catchall, objectOutputType<{ [k in keyof T]: deoptional<T[k]>; }, Catchall>, objectInputType<{ [k in keyof T]: deoptional<T[k]>; }, Catchall>>;
                                                                                                                                   ~~~~~~~~~~~~~~~~

node_modules/zod/lib/types.d.ts:339:194 - error TS2315: Type 'deoptional' is not generic.

339     required: () => ZodObject<{ [k in keyof T]: deoptional<T[k]>; }, UnknownKeys, Catchall, objectOutputType<{ [k in keyof T]: deoptional<T[k]>; }, Catchall>, objectInputType<{ [k in keyof T]: deoptional<T[k]>; }, Catchall>>;
```",,
841125852,362,"[V3] after z.setErrorMap, default error message lost, it always return ""Invalid value""","```ts

const errorMap: z.ZodErrorMap = (error, ctx) => {
  if (error.message) return { message: error.message };
  switch (error.code) {
    case z.ZodIssueCode.invalid_type:
      if (error.received === 'null') {
        return { message: `Required` };
      }
      break;
  }

  return { message: ctx.defaultError };
};

z.setErrorMap(errorMap);

const a = z.string().email().min(20).safeParse(null);
if (!a.success) console.log(a.error.formErrors);

// output, this is expected, since I override inside error map
{
    ""formErrors"": [
        ""Required""
    ],
    ""fieldErrors"": {}
}



const a2 = z.string().email().safeParse('test');
if (!a2.success) console.log(a2.error.formErrors);
// output, this is not expected, I want this be the default message `""Invalid email""`

{
    ""formErrors"": [
        ""Invalid value""
    ],
    ""fieldErrors"": {}
}
```

",,
840962809,361,Error when transforming wrapped parser,"A picture is worth a thousand words:

<img width=""1239"" alt=""Screen Shot 2021-03-25 at 9 58 05 AM"" src=""https://user-images.githubusercontent.com/10621548/112484990-d37cbe80-8d50-11eb-939e-7be1b18db867.png"">

Context: I want to take some `ZodType<T>` (which I have aliased as `Parser<T>`) and wrap it inside a `{ data: T }` parser, which I then want to destructure using `transform` to extract the actual data of type `T`.

I don't really know what I'm doing wrong, but it seems like in the simple case (line 5 in the screenshot) it just works. 

What am I doing wrong here?

Version: 3.0.0-alpha.32
TypeScript Version: 4.2.2",,
840953395,360,Property with default() is mandatory in union,"Example:
Typescript version: 4.2.3
Zod version: 3.0.0-alpha.5
Current result: attrOne is mandatory for creating new object with type MyType
Expected result: attrOne is optional, doesnt have to fill to new object
```
export const schema = z
  .object({
    someAttribute: z.union([
      z.object({ type: z.enum(['One']), attrOne: z.string().default('aaa').optional() }),
      z.object({ type: z.enum(['Two']) })
    ])
  })
  .strict()

export type MyType = z.infer<typeof schema>

const myType: MyType = {
  someAttribute: {
    type: 'One'
  }
}
```
Current example works with Zod version 3.0.0-alpha.4
![image](https://user-images.githubusercontent.com/1267665/112483789-a55fa480-8d79-11eb-8bb7-89c49a0e35f5.png)
",,
840572250,359,"When properties have .default, zod infers properties as not optional even if I set .partial ","## Example
![Screen Shot 2021-03-25 at 11 13 59](https://user-images.githubusercontent.com/26219456/112423576-42b8d980-8d76-11eb-98e7-a8fe6d8209d9.png)
![Screen Shot 2021-03-25 at 11 14 05](https://user-images.githubusercontent.com/26219456/112423580-44829d00-8d76-11eb-8b0e-c0619adeb3a3.png)

## Expected behavior
```typescript
export const Foo = z.object({
  bar: z.string().default(''),
})

const FooPartial = Foo.partial()

type InferredFooPartial = z.infer<typeof FooPartial> //  { bar?: string | undefined }
```",,
840119184,358,Clearer way to have optional objects that use their key's defaults,"Take, for example, the following TypeScript interface, which describes what the parsed and validated version of a config schema should look like:

```ts
interface ParsedConfig {
    foo: {
        one: string;
        two: string;
    };
    bar: {
        three: string;
        four: string;
    };
}
```

Take, also, the following type, which describes what the user could provide to customize the configuration of a program:

```ts
type UserConfig = undefined | {
    foo?: {
        one?: string;
        two?: string;
    };
    bar?: {
        three?: string;
        four?: string;
    };
}
```

To accomplish this with Zod, the schema must look like:

```ts
const schema = z.object({
    foo: z.object({
        one: z.string().default('1'),
        two: z.string().default('2'),
    }).default({}),
    bar: z.object({
        three: z.string().default('3'),
        four: z.string().default('4'),
    }).default({}),
}).default({});
```

Note the use of `.default({})` throughout, which forces Zod into using the default values of the keys within the objects. Without `.default({})`, Zod would throw an error indicating that the objects were required if one of the objects was missing entirely. If you try to use `.optional()` instead, then you could end up with an object that won't fit the `ParsedConfig`, like:

```ts
{
    foo: undefined,
    bar: undefined,
}
```

As a new user, this took quite a bit of trial-and-error to discover this. To help make it more clear as to how to accomplish this, along with making it more obvious what's going on whenever someone reads this code in the future, it may be useful to add a built-in function that accomplishes what `.default({})` accomplishes.",,
839719190,357,Adding a `.required` helper on object (v3),"Hello,

Since we have an amazing `z.object().partial()` helper (https://github.com/colinhacks/zod/tree/v3#partial) to mimic the typescript `Partial<>` util, this could be nice have the symetrical `Required<>` util.

Ideally, I would like something like this:
### `.required`

Inspired by the built-in TypeScript utility type [Required](https://www.typescriptlang.org/docs/handbook/utility-types.html#requiredtype), the `.required` method makes all properties required.

Starting from this object:

```ts
const user = z.object({
  username: z.string().optional(),
});
// { username?: string | undefined }
```

We can create a required version:

```ts
const requiredUser = user.required();
// { username: string }
```",,
839053050,356,Wrong default error message for uuid validation,"I'm getting the following default error message for UUID errors using 3.0.0-alpha.30

`[ { ""validation"": ""email"", ""code"": ""invalid_string"", ""message"": ""Invalid email"", ""path"": [ ""id"" ] } ]`

looks like the validation is incorrectly set when adding an issue for UUID validation errors.

```js
if (this._def.isUUID && !uuidRegex.test(ctx.data)) {
  ctx.addIssue({
    validation: ""email"",
    code: ZodIssueCode.invalid_string,
    message: this._def.isUUID.message,
  });
}
```",,
838750898,355,Types not correctly inferred when using transformers (v3),"I'm trying to achieve one thing, basically, coalescing all `null` values into `undefined` when receiving data from an external provider. Since it's really annoying to write all the code necessary in `zod` to understand that again and again:

```ts
const myString = z.string().optional().nullable().transform((v) => v ?? undefined)
```

I was trying to write a wapper to do that automatically. It looks like the following:

```ts
function _optional<T>(zod: z.ZodType<T>): z.ZodTransformer<z.ZodNullable<z.ZodOptional<z.ZodType<T>>>, T | undefined> {
  return zod.optional().nullable().transform((v) => v ?? undefined);
}
```

However, this works well for simple types (for example, the one above):

```ts
const myString = _optional(ts.string());

// this gets correctly inferred as `string | undefined` instead of `string | null | undefined`
type t = z.infer<typeof myString>;
```

But it doesn't work for complex types like objects:

```ts
const UserSchema = _optional(z.object({
  email: _optional(z.string()),
  name: _optional(z.string()),
}));

type User = z.infer<typeof UserSchema>;
```

In the example above, the type `User` gets incorrectly inferred as: 

```ts
// notice the extra null typings
type User  = {
  email: string | null | undefined;
  name: string | null | undefined;
} | undefined
```

instead of 

```ts
type User  = {
  email: string | undefined;
  name: string | undefined;
} | undefined
```

like in the simple example at the beginning.


### Solutions

I could see two solutions, first one, see why this errors is happening (I don't know enough about zod internals as to answer this question myself just yet) or the second one, try to provide a simpler/nicer API for when you need some sort of default. For example:

```ts
const myString = z.string('default value');

const UserSchema = z.object({
  email: z.string(),
  name: z.string(),
}, { email: 'default email', name: 'default email' });
```

Basically meaning that every `zod` validator would accept an extra parameter that would be the default value in case the validated value is `null` or `undefined` (using `??`) and if that parameter is present, mark the validator automatically as `.optional().nullable()`",,
837207817,354,"typescript vs ""plain javascript"" in README","Zod looks great. I tried to use it, but it appears it's not distributed as JavaScript, so it didn't work in my project. 

The ReadMe says `Plain JavaScript: works in browsers and Node.js` and also that it has [typescript requirement](https://github.com/colinhacks/zod#typescript-requirements), which seems at odds with the first statement.

Would you consider creating a JavaScript build that could be imported, so it works directly in JavaScript projects too please?",,
837180579,353,[Feature Request] Built-in string transformers with defaults ðŸ¤–,"> Edit: Just saw this main thread lol: https://github.com/colinhacks/zod/issues/264#issue-760041790 Sorry! ðŸ™

Not a bug, and definitely not urgent as there is already a workaround, but I thought this might be a useful addition one day.... 
I use Zod to parse all my `.env` vars which are always typed as strings, however naturally I want to convert them to various other types like booleans and numbers, while also providing a default value in the expected format.

Currently, I have just made a set of transformers that I export as `t` (similar to the `z` format) but it's kind of hacky compared to the way Zod natively works (in the sense that the PoC code below ""must"" have a default provided, not to mention a second import being required vs if it were available within `z`)...

### ðŸ¤– Transformers

```typescript
// Zod Transformers

import { string } from ""zod""

import { ZodTransformerLoader, ZodTransformers } from ""../types""

/**
 * Transform strings to numbers with a default.
 * @type {ZodTransformer}
 */
export const numberString = (): ZodTransformerLoader<number> => {
  return {
    default: (def: number) =>
      string()
        .default(`${def}`)
        .transform((value: string): number => parseInt(value))
  }
}

/**
 * Transform booleans to numbers with a default.
 * @type {ZodTransformer}
 */
export const booleanString = (): ZodTransformerLoader<boolean> => {
  return {
    default: (def: boolean) =>
      string()
        .default(`${def}`)
        .transform((value: string): boolean => value === ""true"")
  }
}

/**
 * Export a transformer API similar to the z object in Zod.
 * @type {ZodTransformers}
 */
export const t: ZodTransformers = {
  numberString,
  booleanString
}

```


### ðŸŒ³ Environment Schema

```typescript
// Env schema

import { dotenv, EnvSchema, t } from ""../support/dotenv""
import { QueueEnvSchema } from ""./queue""
import { z } from ""zod""

/**
 * Defines the shape of the server env file.
 * @type {z.ZodObject}
 */
export const ServerEnvSchema = EnvSchema.extend({
  SERVER_PORT: t.numberString().default(8080),
  SERVER_HOST: z.string().default(""foo.bar.io"")
})
  .merge(QueueEnvSchema)
  .passthrough()

/**
 * Parses the env file.
 * @type {z.ZodObject}
 */
export const env: z.infer<typeof ServerEnvSchema> = ServerEnvSchema.parse(
  dotenv()
)
```",,
836989808,352,"[Feature Request] ""fallback()"" variation of default() that activates when invalid data is supplied? ðŸ”„","Was wondering if there is a way to achieve a scenario whereby defaults become fallback values if validation fails on that line?

For instance: 

```typescript
describe(""weekday schema"", () => {
  let day: string | undefined
  let schema: ZodEnum<any>

  before(() => {
    schema = z.enum([""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday""])
  })

  beforeEach(() => {
    day = undefined
  })

  it(""tests default when set to invalid day"", () => {
    const defaultSchema = schema.default(""Monday"")
    try {
      day = defaultSchema.parse(""Sunday"")
    } catch (err) {
      day = undefined
    }
    // Would expect to fail...
    expect(day).to.equal(""Monday"")
  })

  it(""tests hypothetical fallback when set to invalid day"", () => {
    const fallbackSchema = schema.fallback(""Monday"")
    try {
      day = fallbackSchema.parse(""Sunday"")
    } catch (err) {
      day = undefined
    }
    // Would expect to pass...
    expect(day).to.equal(""Monday"")
  })
})
```",,
836781583,351,Changed behaviour of refine and merge (Failing to compile),"Hi, first thank you for this library! there is a changed behaviour in v3 for merging a schema with refinement and it feels like a bug (but perhaps I have to use it in a different way^^)

So my questions are: If merging/extending a schema with refinements is not allowed, is there any other way to get this done? Or is there anything wrong with my validation? what is working is, first merging everything and than adding the refinement, but this makes it much more complex.

```
// example 1
const t0 = z.object({ temp: z.string() });
const myString = z.string().refine(val => val.length <= 255, { message: 'message' });

const t1 = z.object({ temp2: myString });
const t4 = t0.merge(t1);
const t3 = t0.extend(t1);

// example 2
const s0 = z.object({ temp1: z.string() });
const s1 = z.object({ temp2: z.string() });
const s3 = s0.refine(obj => obj.temp1.length <= 255, { message: 'message' });
const s4 = s0.merge(s3);
const s5 = s0.extend(s3);
```

v3 (latest alpha):
working:
* t0.merge(t1);

not working (not compiling):
* t0.extend(t1);
* s0.merge(s3);
* s0.extend(s3);

v1 (latest released version) + v2 (latest beta):
working:
* t0.merge(t1);
* s0.merge(s3);

not working:
* t0.extend(t1);
* s0.extend(s3);

",,
836326760,347,SyntaxError: Cannot use import statement outside a module,"When importing zod as an esm module, a syntax error is thrown:

```
import z from 'zod'
^^^^^^

SyntaxError: Cannot use import statement outside a module
```

# Reproduction steps

```sh
mkdir test
cd test
echo '{""type"":""module""}' > package.json
yarn add zod@3.0.0-alpha.9
echo ""import z from 'zod'"" > index.js
node index.js
```

```sh
$ node --version
v15.11.0
$ yarn --version
1.22.10
```

OS: Pop!_OS 20.10 x86_64 (basically Ubuntu 20.10)

# Possible fixes

I haven't pulled anything down to fix it just yet, but the thing it's complaining about is that in order for native esm modules to import other modules, you need to have `""type"": ""module""` in your package.json. I don't know off the top of my head what that will do to commonjs. When I tried just editing it directly in node_modules, the next issue that came up is that the imports inside of `lib/esm/` didn't have extentions, i.e. `import * as z from ""./external""` instead of `import * as z from ""./external.js""`.

I'll try pulling it down and document what I've tried here.",,
835619320,341,v3 function schemas don't show error for missing fields on returns,"Given code:
![image](https://user-images.githubusercontent.com/3749095/111741109-26331380-8843-11eb-9755-d90589af7063.png)


The function returns additional fields that are not on the returns schema. The expected behavior is that TS would throw an error due to `key2` being an additional field on the type. Adding `strict()` does not fix this either",,
835386291,340,Deep Partial registering as full original Schema when type is inferred (post -alpha.7),"Post `-alpha7` release my Deep Partials are registering as the full type:

`TS2739: Type '{}' is missing the following properties from type '{ maxConnections: number; auth: ""none"" | ""iponly"" | ""nbname"" | ""strong""; logFormat: string; }': maxConnections, auth, logFormat, platform`


### Reproduction

```typescript
import { z } from ""zod""

export const TemplateOptionsSchema = z.object({
  maxConnections: z
    .number()
    .min(1)
    .max(65535)
    .default(env.PROXY_MAX_CONNECTIONS),
  auth: ProxyAuthSchema.default(env.PROXY_AUTH),
  logFormat: z.string().default(env.PROXY_LOG_FORMAT)
})

export const PartialTemplateOptionsSchema = TemplateOptionsSchema.deepPartial().passthrough()

export type PartialTemplateOptions = z.infer<typeof PartialTemplateOptionsSchema>

const  options: PartialTemplateOptions = {} // TS2739 error noted above...

```

### Issue

Was previously inferring the correct Deep Partial type when registering:

```typescript
export type PartialTemplateOptions = z.infer<typeof PartialTemplateOptionsSchema>
```


### Short Term Fix

Currently wrapping the type in `Partial<>`, but this seems counter to what would be expected:

```typescript
  options: PartialTemplateOptions = {} // Fail
  options: Partial<PartialTemplateOptions> = {} // Success
```

Just checking to see if this was intentional or unexpected behaviour?",,
835383137,339,Optional with Default failing type check (post -alpha.7),"Not sure if I'm just ""doing it wrong"" but this was working prior to the latest alpha7 release:

#### Fails type check
![image](https://user-images.githubusercontent.com/65471523/111712665-35957980-88a2-11eb-86d7-30aa396316b8.png)

#### Upstream `env` schema:
![image](https://user-images.githubusercontent.com/65471523/111712698-45ad5900-88a2-11eb-8ccc-7462abe12e87.png)

### Possible cause:

The issue appears to be because ` z.string().optional()` is now typing as `() => string | undefined` whereas it was previously typing as `string | undefined`.

`Type 'undefined' is not assignable to type '() => string | undefined'.`

```typescript
// Cause
const env = z.object({
  TOKEN: z.string().optional()
})
// Type Error
const problem = z.object({
  token: z.string().optional().default(env.TOKEN)
})

```

Ultimately just want to make sure this is intentional before I refactor to solve it.",,
835081381,338,v3 string only allowed for enums,"See:
![image](https://user-images.githubusercontent.com/3749095/111670268-df0e3980-87d4-11eb-87ce-456d3cb72de2.png)

Should be allowed to do numbers for enums",,
835065872,337,guidance following removal of intersection,"Hi, with the removal of `intersection`, I'm wondering what the best way to represent base shapes with conditional extensions? From looking at the diff, I suppose the recommendation is to use `merge` or `extend`, but that isn't very ergonomic with union types...

For example, I have a schema that validates oidc-provider client configurations that looks like this:

```ts
const clients = array(
  intersection(
    object({
      client_id: string(),
      grant_types: array(string()),
      redirect_uris: array(string()),
      tos_uri: string().url(),
      policy_uri: string().url(),
    }),
    union([
      object({
        application_type: literal(""native""),
        token_endpoint_auth_method: literal(""none""),
      }),
      object({
        token_endpoint_auth_method: z
          .enum([""client_secret_basic"", ""client_secret_post""])
          .optional(),
        client_secret: string(),
      }),
      object({
        token_endpoint_auth_method: z.enum([""private_key_jwt""]),
        jwks: object({
          keys: array(
            object({
              kty: string(),
              kid: string(),
              n: string(),
              e: string(),
            })
          ),
        }),
      }),
    ])
  )
)
```

It's a little busy, but you can see that there's a base schema that intersects with a union type for all of the conditional variants.

Without `intersect`, it seems like every type in the union has to be explicitly extended:

```ts
const clientBase = {
  client_id: string(),
  grant_types: array(string()),
  redirect_uris: array(string()),
  tos_uri: string().url(),
  policy_uri: string().url(),
};
const clients = array(
  union([
    object({
      application_type: literal(""native""),
      token_endpoint_auth_method: literal(""none""),
    }).extend(clientBase),
    object({
      token_endpoint_auth_method: z
        .enum([""client_secret_basic"", ""client_secret_post""])
        .optional(),
      client_secret: string(),
    }).extend(clientBase),
    object({
      token_endpoint_auth_method: z.enum([""private_key_jwt""]),
      jwks: object({
        keys: array(
          object({
            kty: string(),
            kid: string(),
            n: string(),
            e: string(),
          })
        ),
      }),
    }).extend(clientBase),
  ])
);
```

We can't use `[].map()` over the union argument because `map` doesn't preserve the input length in the output type.

Is there another way of continuing to express this, or is the expectation that every entry in a union has to be manually extended?",,
834736444,335,Documentation for ZodCodeGenerator,"I recently discovered the ZodCodeGenerator while browsing the source, and after discovering how to use it with some trial and error am keen to make use of it for some code generation within a project I'm on. However, I noticed there was no documentation for it and don't wish to rely on a feature which may not be considered part of the libraries stable API.

Is the lack of documentation intentional or accidental?",,
833728876,333,How to achive yup's when() utility? ,"Hi, in [yup](https://github.com/jquense/yup#mixedwhenkeys-string--arraystring-builder-object--value-schema-schema-schema) there is a `when()` utility which allows users to ""adjust the schema based on a sibling or sibling children fields."" Is there a way to contruct such conditionals in `zod` schemas? I could not find such utility in the documentation. If it's by design, please let me know! I'd love to define a schema similar to the one below (`adminSecret` is conditionally optional):

```
import * as z from ""zod"";

interface User {
  id: string;
  isAdmin: boolean;
  adminSecret?: string;
}

const userSchema: z.ZodSchema<User> = z.object({
  id: z.string(),
  isAdmin: z.boolean(),
  adminSecret: z.string().when(""isAdmin"", (isAdmin, schema) => {
    return isAdmin ? schema : schema.optional();
  }),
});

const blob = {
  id: ""20ec0677-68d8-45b5-a522-16cff767ac6f"",
  isAdmin: true,
};

// should throw an error because
// the blob has no adminSecret !
const user = userSchema.parse(blob);
```",,
830135376,332,"A combination of union, transformer and default infers the wrong type","Hi,
I'm using v3.0.0-alpha.4 and encountered a case where adding a default causes the inferred type to be wrong.

Example:

```typescript
const schema = z.array(
  z.union([
    z.string().transform(name => ({ name })),
    z.object({ name: z.string() })
  ])
);

const schemaWithDefault = schema.default([]);

type Schema = z.infer<typeof schema>;
/* 
infers the correct type:
({
    name: string;
} | {
    name: string;
})[]
*/

type SchemaWithDefault = z.infer<typeof schemaWithDefault>;
/* 
infers the wrong type:
(string | {
    name: string;
})[]
*/
```

Any idea what's going on here?
Thanks!",,
827836627,331,Generate a JSON schema from a `zod.object`,"Love `zod`, so thanks for creating the library!

While working on an application, I want to share models and validators across repositories and components, the most common scenario being the backend application and the web frontend view. `zod` is great on this.

However, it would also be great to be able to generate a JSON Schema (https://json-schema.org) via the model definition (i.e. `zod.object`). These JSON objects can then be used to document API OPTIONS.

I believe that each of the zod field and option can be mapped to a JSON schema entity.

Few notes:

1. If there's no interest in implementing this feature, I am happy to jump on it with a fork & PR
2. If you believe that the feature would be out of scope of `zod` I am also happy to create a complementary package, i.e. `zod-json-schema` that exposes the utility function to convert the a `zod` object into a JSON Schema field.

Thanks again for the great library!",,
824636716,328,Parsing a numeric string,"I think that something like this would be awesome

```ts
const numeric = '123'; // typeof string;
const number = zod.string().numeric().int().parse(numeric); // typeof number;
```

numeric() would convert it to a ZodNumber if it was actually a numeric value.

Or maybe, to preserve original string type:
```ts

const numeric = '123'; // typeof string;

const numericString = zod.string().numeric().int().parse(numeric); // typeof string;
const number = zod.number().stringified().int().parse(numeric); // typeof number;
```


What do you think?",,
823797036,327,Feature request: .exact type to prevent excess properties,"Iâ€™m migrating from io-ts to zod since Iâ€™d like a smaller package size, but one of the features I need is the `.exact` method. Itâ€™s a way to prevent an object from having more properties than the schema defines (or as Typescript calls it, â€œexcess propertiesâ€).

~If this is a feature that youâ€™d be interested in, I can submit a PR for it [just like I enhanced tsoa by adding an excess properties check into that library.](https://github.com/lukeautry/tsoa/issues/336) Or if zod already has something like this, I canâ€™t add a PR enhance the docs. Or if zod already defaults to no excess properties, I can add to the readme for that.~

Update: I read the full readme and saw that zod does support this but doesnâ€™t use the term exact or excess. Iâ€™ll submit a PR that adds those words to aid others in searching for these terms. Btw, bravo on taking this approach as the default! :)",,
817746744,326,self reference types,"Self-reference types are not rare and in each project, it is possible to have a bunch of them.
```typescript

interface Label {
  name: string,
  value: string,
}

interface Button {
  name: string,
  value: string,
}

type View = Container | Button | Label;

interface Container{
  name: string,
  children: View
}

```

I couldn't find a solution to implement this using `zod`.

```typescript
const labelSchema = z.object({
  name: z.string(),
  value: z.string(),
});

const buttonSchema = z.object({
  name: z.string(),
  value: z.string(),
});

const containerShcema = z.object({
  name: z.string(),
  children: z.union([labelSchema, buttonSchema, containerShcema]).array(),
});

```

This will cause compiler error for `containerSchema` inside union array:
**`Block-scoped variable 'containerShcema' used before its declaration.`**",,
815881460,325,Get valid data after safeParse failure,"I frequently find myself wanting to get data that passed validation after a `safeParse` failure.

To provide a bit of context, I am using zod ( v3 ) with NextJS to validate the `context.query` object, and I want to reload the page with only the valid query params if validation fails. It's pretty simple to strip fields based on the `error.path` looping through the returned errors, but there are still some cases like unknown fields presence that are not so easy to handle.

Any chance this is already possible / planned for development? I'd also be willing to work on it myself if it sounds like a valid feature.",,
814315537,321,Question: How to make optional field to become required again?,"some shema are shared. to make it weakner, some fields are optional. but in some cases such as fucntion args, I hope some fields to be set as required again. I didn't find a method to achieve this.",,
814255653,320,Question: How to support time alias?,"For example, I have a type `ID`

```
type ID = string;
```

I would like to create a schema `IDSchema` for it, but currently I have to 

```
const IDSchema = z.string();
```

which represents a string, not an ID.",,
813009465,319,Possibility to export a single bundled z object?,"This is obviously a quite low priority item as it's not a functional issue, but it would be great to allow importing a single `z` object with destructuring syntax.

For example: 

```typescript
import { z } from ""zod""
```

Alternatively, if that ends up bloating the regular `import * as z from ""zod""` default export, creating a secondary export location such as this would be equally as good:

```typescript
import { z } from ""zod/z""
```

### Example export

```typescript
// ./src/z.ts

import * as z from ""./index""

export { z }

```

Happy to do a PR if you are open to it, but thought I'd check first?
",,
812705041,318,z.ObjectID() ?,"I am trying to integrate zod with Mongoose but I have an issue.

One of the fields is ObjectID... how should I define this in the schema? I tried z.string() but I does not work (even if I add the ObjectID as a string on my object before saving it, I guess Mongoose internally converts it back to ObjectID before calling the pre-validate hook so in the end I am getting an ObjectID again).

Any workaround? Maybe something like https://github.com/jquense/yup/issues/467",,
809413996,316,feature request: zod.fallback() and zod.catch(),"zod is awesome!

Maybe this is already possible, but often I need more granular control of `safeParse`-like behavior... Something like:

```
const color = string().fallback('#000000');
const person = object({ name: string(), age: number() }).fallback({});
```

Or, maybe with more granular control (e.g. have the fallback be based on a `ZodError`):

```
const person = object( {name: string(), age: number() }.catch(err =>  { console.error(err.message); return {} );
```

(so `.fallback(foo)` is just `.catch(() => foo)`).

Thanks for listening/considering!

ps: some of this might be doable with `any().transform(val => xxx).string()` but seems super hacky and non zod-like since
you basically have to use JS/TS to coerce the value...",,
808413234,315,Avoid upper level index import to avoid require cycle,"Hello, thanks for the amazing library.
I'm currently using the latest version of zod (3.0.0.-alpha-4) with react-native and I noticed a weird require cycle through my whole application:



> WARN     Require cycle: index.js -> src/Root.tsx -> src/routes/Router.tsx -> src/routes/stacks/Authentication.tsx -> src/screens/Authentication/index.ts -> src/screens/Authentication/SignInMail.tsx -> src/screens/Authentication/components/SignInForm.tsx -> node_modules/zod/lib/cjs/index.js -> node_modules/zod/lib/cjs/types/object.js -> node_modules/zod/lib/cjs/helpers/objectUtil.js -> index.js

I did some digging and I found this kind of import:

https://github.com/colinhacks/zod/blob/bb93ec5448d4b06ef3a458160e697babb2059980/src/helpers/objectUtil.ts#L3

I think it is somehow miss referencing this to my app package.json main script.
I tried renaming my entry point to something else but it still gave the warning.

thanks for your attention",,
806056422,314,Comparison request with 'decoders',"If you have time it would be nice to see a comparison with the [decoders](https://github.com/nvie/decoders) library, too.

Thank you!",,
802302644,313,Allow `z.function([z.string()])` rather than needing to use `z.tuple(...)` every time,"Minor convenience request:

I'd like to use zod as a very lightweight way of basically making typescript assertions ""real"". So my hope is that using `z.function(...)` is almost as little overhead as defining a vanilla typescript function. Situation now:

```ts
import * as z from 'zod'

export const myFunction = z.function(z.tuple([z.string()])).implement(str => console.log(str))
```

It'd be great if `z.function` auto-tuplified the inputs so we didn't have to use `z.tuple`:

```ts
import * as z from 'zod'

export const myFunction = z.function([z.string()]).implement(str => console.log(str))
```

I'd be happy to open a PR if you're open to the idea?",,
802238469,312,Update v2/beta instructions in readme,"Hi, love the library!

In the readme found at https://github.com/colinhacks/zod and https://npmjs.com/package/zod (places I'd usually expect to find ""blessed""/up-to-date docs), it says ""Zod 2 is recommended for all new projects"". On clicking through to the v2 branch, this seems to be very much not the case. The write up of why is very helpful, but it might be a good idea to update the v1 readme saying _v3_ is recommended for all new projects (with a brief explainer and/or link to issue on why v1 -> v3).

Or, if v1 is still the recommendation until v3 comes out of alpha/typescript 4.1 is more widely adopted, remove the message entirely?",,
801396240,311,Incorrect error for unions with literals,"**Description**
I use `zod@2.0.0-beta.30`
I want to use zod to parse structures like
```typescript
type T = { val: 'a', a?: string } | { val: 'b', b?: number }
```
but I get incorrect error when I tries to parse structure with incorrect field's type

**Demo**
```typescript
import * as z from 'zod'

const Schema = z.union([
  z.object({
    val: z.literal('a'),
    a: z.ostring()
  }),
  z.object({
    val: z.literal('b'),
    b: z.onumber()
  })
])

console.log(Schema.parse({
  val: 'a',
  a: 123         
}))
```

**Expected error**
```
Error: [
  {
    ""code"": ""invalid_type"",
    ""expected"": ""string"",
    ""received"": ""number"",
    ""path"": [
      ""a""
    ],
    ""message"": ""Expected string, received number""
  }
]
```

**Actual error**
```
Error: [
  {
    ""code"": ""invalid_literal_value"",
    ""expected"": ""b"",
    ""path"": [
      ""val""
    ],
    ""message"": ""Input must be \""b\""""
  }
]
```",,
801187754,310,Validating optional text inputs,"Considering an optional email text input: from user perspective I think the appropriate validation for this would be `z.string().email().optional()` which allows either `undefined` or a valid email.

In [`React`](https://reactjs.org/docs/forms.html#controlled-components), these types of inputs are almost never undefined. In fact, optional fields are considered empty strings.

What is the common way to achieve validating these type of fields correctly with zod? I have tried things like `z.union([z.string().email, z.literal('')])` or `refine`, which felt a little unintuitive for a simple, yet very common optional field value.

I was hoping for either a configurable `optional` type that could allow empty strings as well or a dedicated empty type for a string.

Anyway, thank you for this great validation library, happy to help in any way!",,
800902507,309,error when using zod with skypack,"![image](https://user-images.githubusercontent.com/15090582/106842184-7feddd00-66de-11eb-887d-78338c7be7bd.png)
same error if runs in browser
```html
<!DOCTYPE html>
<html lang=""en"">
  <body>
    <script type=""module"">
      import z from 'https://cdn.skypack.dev/zod';
      z.string().parse('fish')
    </script>
    <script type=""module"">
      import * as z from 'https://cdn.skypack.dev/zod';
      z.string().parse('fish')
    </script>
  </body>
</html>
```",,
798592563,308,Received error type for string array is different than expected,"I'm using version **3.0.0-alpha.4** and defining my schema as:
```
const postSchema = z.object({
    message: z.string().min(10),
    tags: z.string().array().max(3),
});
```

The type suggested by VSCode for `errors.tags` is `(FieldError | undefined)[] | undefined`, however, if zod gives me `FieldError | undefined`.",,
797262116,307,Open Zod to externally-defined combinators,"To define a `ZodTypeDef` instance, one must pick a member of the enum `ZodTypes`. This is a problem for users wishing to define their own instances of `ZodType`, which requires a `ZodTypeDef` instance.

The solution is to factor the centralized aspects of Zod such that every combinator owns its error reporting, parsing logic, etc.",,
797253107,306,Staged computation,Zod parsing currently is performed by a massive function `ZodParser` dispatching on the type of the current node to decide what operation to perform. This dispatch operation likely interferes with the JIT optimizer. Instead we could front-load it at schema creation time; each schema object would carry with it its own `parse` closure built compositionally.,,
795269455,302,`nonstrict` broken in zod 2 and 3?,"The `nonstrict` example in README does not seem to be working as expected with zod 2 or 3. TS 4.1
Specifically no index signature is added to the inferred type to allow arbitrary keys",,
794765540,301,Check if schema has a key,"**(zod v3)**

Could we add a way to check if a Zod object has a key (based on a string) at runtime?
e.g.:

```typescript
const Location = z.object({
  latitude: z.number(),
  longitude: z.number(),
});

Location.hasKey('foobar'); // false
Location.hasKey('latitude'); // true
```

... which would essentially just be:
```typescript
public hasKey(key: string): boolean {
  return this.shape[key] !== undefined
}
```

I'm not sure if something like this already exists, I've just been checking the shape.

---

To extend the question, is it possible to also do this with a `Schema`? (I'm aware `shape` doesn't exist on `Schema`, so this example doesn't work)
e.g.:

```typescript
import * as z from 'zod'

export const personSchema = z.object({
  firstName: z.string(),
  lastName: z.string(),
  email: z.string(),
  phoneNumber: z.string()
});

function hasKey(key: string, schema: z.Schema<any>): boolean {
  return schema.shape[key] !== undefined
}

console.log(hasKey('firstName', personSchema));
```

I have a use case where this would be very helpful; I'm hoping this is already possible, and I've just missed it in the documentation.

I've tried solving it by passing a Zod object into my use case via generics, but `ZodObject<T>` complains. I'm probably supposed to be using some other type?",,
794615670,300,Show received value in ZodError for .nativeEnum,"I received a malformed payload today. `ZodError.message` looked as follows: ""Input must be one of these values: A3, A7, ..., XB"". Unfortunately I can't figure out what the offending value was, which would help me begin my investigation.

If someone modified the error formatting for `.nativeEnum` to include the value, would you accept that PR? Any doubts or caveats you'd like to see addressed?",,
793784301,299,Feedback wanted: integration with the property-based testing library fast-check,"Hello Colin et al.

First of all, thanks for your work on Zod. It has proved tremendously useful since I discovered it.

Over the past couple of weekends, I developed a little library to integrate Zod with the property-based testing library [fast-check](https://github.com/dubzzz/fast-check). It uses the schema information to automatically generate valid test data. It would be absolutely great to get some feedback before I finalize and release it. Would you consider using it? Do the docs make sense? etc.

https://github.com/DavidTimms/zod-fast-check

It's currently implemented against the Zod V2 beta branch, so I need to update it to work with V3 before it is ready to be released.

Thanks",,
791300595,296,problem with z.nativeEnum with optional(),"Hi, pls help me with validation of optional field of nativeEnum

https://codesandbox.io/s/react-hook-form-nestedvalue-forked-6gh4n?file=/src/App.tsx

related issue https://github.com/react-hook-form/react-hook-form/issues/3985",,
791074196,295,safeParse method can return an ZodError object instead of success property,"Is it possible to return an ZodError object? like this:

```
const maybeData = stringSchema.safeParse(""billie"")

if (maybeData instanceof ZodError) {
  // handle error then return
}

// underneath the if statement, TypeScript knows
// that validation passed
console.log(maybeData)
```",,
787368422,294,produce module build for bundling and tree shaking support,"It would be nice if you could also produce and publish an ES module build of zod for bundler consumption. I can probably send a PR when I get the chance to.

[here is an article](https://rollupjs.org/guide/en/#what-is-tree-shaking) if you're not familiar with bundling and tree shaking. [Another article](https://rollupjs.org/guide/en/#publishing-es-modules) on how to point bundlers at the module build

Thanks for considering! (ps i dont use rollup lol)",,
787105479,293,Removing the type guards?,"Saw the note about removing `check`, but if it is simply `safeParse().success`, why can we not implement it that way in the base type? I assume this has already been tried, but if there is a problem with that, it would be helpful to know what the problem is so that I don't accidentally reproduce the issue in my own usage.",,
786012549,291,[Feature Request] Using Typescript Decorators for Object Schemas,"Right now, we declare object schemas like this:
```js
const dogSchema = z.object({
  name: z.string(),
  neutered: z.boolean(),
});
```
What if instead, we declared schemas with [decorators](https://www.typescriptlang.org/docs/handbook/decorators.html#property-decorators) so we didn't have to retype the associated class?
```js
class Dog {
    @zodProperty
    public name: string;
    @zodProperty
    public neutered: boolean;
    @zodProperty({ email: true })
    public email: string;
}


const myObj = { name: ""blabla"" } // Example request body
try {
    const myDog: Dog = getSchema(Dog.name).parse(myObj); // no need to rewrite schema, can use class multiple times
}
catch (err) {
}
```",,
786006683,290,v2: Using .default() with z.enum() disables .options,"Hi, thanks for this awesome library!

Stubled over this:

```typescript
    const myEnum = z.enum(['foo', 'bar', 'baz'])
    console.log(myEnum.options) // [ 'foo', 'bar', 'baz' ]
    const myEnumWithDefault = myEnum.default('bar')
    console.log(myEnumWithDefault.options)
```

The last line triggers:

```plain
error TS2339: Property 'options' does not exist on type 'ZodTransformer<ZodOptional<ZodEnum<[""foo"", ""bar"", ""baz""]>>, ZodEnum<[""foo"", ""bar"", ""baz""]>>'.

32     console.log(myEnumWithDefault.options)
                                     ~~~~~~~
```

I suppose that's a bug. Is there any other way to retrieve the list of possible options and using a default at the same time?

Thanks!",,
784211437,289,All properties is z.object are optional by default,"The docs state the following:

> // all properties are required by default

However, in the newest version you can do the following (same as the dog example):

```
const dogSchema = z.object({
  name: z.string(),
  neutered: z.boolean(),
});

type Dog = z.infer<typeof dogSchema>;
/* 
erroneously equivalent to:
type Dog = { 
  name?: string; 
  neutered?: boolean;
}
*/

const fido: Dog = {
  name: 'Fido',
}; // This does not give any error
```

This seems to have broken in 1.2.4.

But even in version 1.2.3, you are able to do this:

```

const fido: Dog = {
  name: undefined,
  neutered: true,
}; // This does not give any error
```

Which shouldn't be possible, as the type is `string`.",,
783644121,288,"Object.defineProperty(exports, ""__esModule"", { value: true });","A confusing title?
I must admit I do not understand it.
I love zod, I kneel before zod!
THANK YOU for zod!!!

When I updated my packages from
`    ""zod"": ""2.0.0-beta.29""`
to
`    ""zod"": ""2.0.0-beta.30""`

My app started to fail, with the following in the web console.
```
exports.ZodCodeGenerator = ZodCodeGenerator;

});

Object.defineProperty(exports, ""__esModule"", { value: true });

var ZodDef = /*#__PURE__*/Object.freeze({
    __proto__: null
});
```

Reverting to `""zod"": ""2.0.0-beta.29""` made the problem go away.
",,
780673127,286,.keyof,"I have an enum mapping an external status string to an internal status string:

```typescript
enum STATUS_MAP {
  pending = internal.Pending,
  engaged = internal.Pending,
  pickup_confirmed = internal.Pending,
  canceled = internal.Cancelled,
  on_route = internal.Pending,
  on_delivery = internal.Shipped,
  delivered_recipients_here = internal.Delivered,
  delivered_recipients_not_here = internal.Delivered,
}
```

If I understand correctly there is no combinator out of the box that takes this enum and returns a schema for the keys (`pending`, `engaged`, etc.) Am I correct?

If so, I'll try to implement such a combinator and submit it as a PR this week-end.",,
780622758,285,[Feature Request] Add ZodObject support to .pick & .omit,"As I understand it, `.pick` & `.omit` currently accept `Record<string, true | undefined>`. I think it would be useful if it accepted a zod value as well.

For example, if we start with 

```javascript
const A = z.object({ a: z.number(), b: z.string() });
const B = z.object({ c: z.string(), d: z.string() });
const AB = A.merge(B);
```

and wanted to get the `A` schema back from `AB` we need to do

```javascript
const A2 = AB.pick({ a: true, b: true });
```

 or something like this if we wanted to ensure we always got all properties from `A`
```javascript
const aKeys = Object.keys(A.shape).reduce((acc, key) => {
  acc[key] = true;
  return acc;
}, {} as Record<string, true>);
const A3 = AB.pick(aKeys);
```

Is there a reason the values must be `true`? Is ""truthy"" enough? That would allow `AB.pick(A.shape)`

I think `string[]` array is closest to TS `Pick`,
```typescript
type A = Pick<A, 'a' | 'b'>
const A = AB.pick(Object.keys(A.shape));
```

but that would be a breaking change. Is there an issue or any other docs/background about using object vs array as the second arg?

I only found `zod` yesterday and spent a little time reading docs and trying some examples, so I could be missing/misunderstanding something. I just wondered if we needed this new interface or if we could use an existing one.

Cheers on the great library.",,
776747646,281,Feature Request: Custom error message for primitive type errors,"Yup allows for defining an error message for failed type checks via a `typeError(message: string)` operator. Doesn't seem like there's anything like this in Zod. I'd rather have custom humanized error messages than an unchangeable: `Expected number, received nan`.",,
776063038,279,JSDoc for Zod methods,"Visual Studio Code uses JSDoc to populate pop-ups. It would be nice to view the docs within the editor.

@colinhacks if contributors write some docs are you interested in merging them?",,
776013856,278,[zodv2] How do I get data of the model in refinement error message?,"Hi! I'm using zod v2 and stuck on one thing.
Let's say I have a schema like this:
```
const schema = z.object({
  start: z.number(),
  end: z.number(),
}).refine(
  ({ start, end }) => start <= end,
  { path: ['end'], message: `End must be greater than ${start}` }, // It won't work :(
);
```
So, I want the error message to point to the `end` field and it must contain the value of the `start` field.
It seems, there is no way to do that in zod2?
Am I missing anything?",,
775903670,277,How to properly configure TypeScript?,"Hey! Cheers for making zod. It's great! ðŸŒŸ 

**Question**

How do I properly configure TypeScript to get strict type checking?

My `tsconfig.json` has `""strict"": true` using TypeScript `4.1.3`.

<details><summary>tsconfig.json</summary>

```js
{
  // see https://www.typescriptlang.org/tsconfig to better understand tsconfigs
  ""include"": [""src"", ""types""],
  ""compilerOptions"": {
    ""module"": ""esnext"",
    ""lib"": [""dom"", ""esnext""],
    ""target"": ""ESNext"",
    ""importHelpers"": true,
    // output .d.ts declaration files for consumers
    ""declaration"": true,
    // output .js.map sourcemap files for consumers
    ""sourceMap"": true,
    // match output dir to input dir. e.g. dist/index instead of dist/src/index
    ""rootDir"": ""./src"",
    // stricter type-checking for stronger correctness. Recommended by TS
    ""strict"": true,
    // linter checks for common issues
    ""noImplicitReturns"": true,
    ""noFallthroughCasesInSwitch"": true,
    // noUnused* overlap with @typescript-eslint/no-unused-vars, can disable if duplicative
    ""noUnusedLocals"": true,
    ""noUnusedParameters"": true,
    // use Node's module resolution algorithm, instead of the legacy TS one
    ""moduleResolution"": ""node"",
    // transpile JSX to React.createElement
    ""jsx"": ""react"",
    // interop between ESM and CJS modules. Recommended by TS
    ""esModuleInterop"": true,
    // significant perf increase by skipping checking .d.ts files, particularly those in node_modules. Recommended by TS
    ""skipLibCheck"": true,
    // error out if import and file system have a casing mismatch. Recommended by TS
    ""forceConsistentCasingInFileNames"": true,
    // `tsdx build` ignores this option, but it is commonly used when type-checking separately with `tsc`
    ""noEmit"": true
  }
}

```

</details>


However, I get non-strict results. Below screenshot should infer `str: string` without the `?`. ðŸ‘‡ 


<img width=""415"" alt=""Screenshot 2020-12-29 at 14 48 20"" src=""https://user-images.githubusercontent.com/459267/103288534-58bc3580-49e5-11eb-99a5-bc11800cbff3.png"">


If you can't answer on the top of your head & need a reproduction example I can of course provide that!",,
774897986,276,object is marking all properties as optional,"I have this simple schema:

```typescript
let schema = z.object({
  email: z.string().email(),
  password: z.string()
})
```

When calling `safeParseAsync` on that schema, all keys in the `data` property are optional.

![Screen Shot 2020-12-26 at 13 12 29](https://user-images.githubusercontent.com/42145089/103155204-19d77700-477c-11eb-9467-024e1ef76a24.png)

I've tested this using both `latest` and `beta` version
",,
773730271,275,How to cast string to number?,"I have something like this:

```typescript
const params = z.object({
  id: z.number()
})
```

This fails immediately since id is a query string param and so is a string.
Then I tried:

```typescript
const params = z.object({
  id: z.transformer(z.string(), z.number(), x => Number(x))
})
```

But the compiler yells:

```
Type 'ZodObject<{ id: ZodTransformer<ZodString, ZodNumber>; }, ""passthrough"", ZodTypeAny, { id: number; }, { id: string; }>' is not assignable to type 'ZodType<{ id: number; }, ZodTypeDef, { id: number; }>'.
  The types of '_input.id' are incompatible between these types.
    Type 'string' is not assignable to type 'number'
```

What am I doing wrong?",,
772923691,274,Performance and benchmarks with others,"Hi

I saw this test results and it actually came after I had already looked into a issue with slow code where I discovered that zod was taking up 600 ms to parse 1000 json elements.

https://github.com/moltar/typescript-runtime-type-benchmarks

Zod is one of the slowest in the overview.

Normally speed is not a problem since I use zod on user input, but if you run a busy api endpoint this could be something important.

Did something experience something like it?",,
770921344,273,[Feature Request]: Meta data/labels,"I saw this being mentioned before in another issue, but I'd like to make the request again with a slightly different user story.

My team is looking at replacing Joi with ZodV2 in its Hapi microservice.  We really like that we can create an input validation for a handler, and have it tightly coupled to the handler's input's type definition.  So there is no more worrying about, ""Oh, is the validation wrong, or is the input's typing wrong"".  Its the same.

The only loose thread is documentation.  We want to create something that parses our Hapi route objects, sees the Zod object we have passed to the validator, and generates a  documentation page for that route.

Simply parsing the ZodObject isn't quite cutting it.  It ends up lacking information and context that we'd like, between refinements, transformations, and things that we just want to have more explanation on.  If individual Zod elements could have a `.label` or a `.meta` property, it'd give us a bit more flexibility in creating documentation that is tightly coupled with our zod schema.

",,
768401574,272,Please export ZodNonEmptyArray,"The `nonempty` method of `ZodArray` returns `ZodNonEmptyArray`, but it isn't exported. Can it be exported in `src/index.ts`, so we can write `ZodNonEmptyArray<Schema>` instead of `ReturnType<zod.ZodArray<Schema>['nonempty']>` when declaring a function returning the result of `nonempty` method?",,
766482049,270,Implementing a 'deep equality' schema,"This is my first time developing an app with Zod. Sorry if I've missed something obvious!

Is it possible to create a Zod schema which checks, for an input, whether that input is an object which equals deeply to another, given object?
I've tried implementing that using literals, transformers, refinements and a combination of the three, but did not manage to find a good solution.

For exmaple, if I have `const obj = { x: 3, y: ""y"" }`, the schema would check for a given input `a`, if `a` is an object, which has two keys - `x` and `y`, whose values are `3` and `""y""` respectively.

Thanks!
P.S. I have a true appreciation for this library and for the solution it provides.
",,
763280589,267,"RFC: parse->parseSync, parseAsync->parse","I think the Yup-style method naming makes more sense, where the plain `.parse` method returns a promise and `.parseSync` returns synchronously (skipping over any async refinements). Transformers complicate things; I you have an async transformer somewhere in your schema, I think `.parseSync` will just have to throw.

A sub-proposal is to rename the `safeParse` methods to simply `parse` and `parse` methods to `unsafeParse`. When I use Zod in a project, the method I end up using most commonly is `.safeParseAsync` which is pretty verbose. I strongly prefer the ""safe"" version of the methods, since it makes it's cleaner than a try/catch block and gives you back a statically typed `ZodError` on failure. I also use a lot of async refinements so I'm in the habit of calling the async method. Depending on how others use Zod, it may be worthwhile to switch these naming conventions. Or at least find a better name than `.safeParseAsync`.

Clearly this is a breaking change, I'm curious if others think it's worth it. ",,
760541131,265,deepPartial does not work as expected with unions,"Consider the following: 

```typescript
const A = z.object({p1: z.string()});
const B = z.object({a: z.union([A, z.null()])});
const PB = B.deepPartial();
PB.parse({a: {}});
```

Running this yields the following error:
```
Error: [
  {
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""string"",
            ""received"": ""undefined"",
            ""path"": [
              ""a"",
              ""p1""
            ],
            ""message"": ""Required""
          }
        ]
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""null"",
            ""received"": ""object"",
            ""path"": [
              ""a""
            ],
            ""message"": ""Expected null, received object""
          }
        ]
      }
    ],
    ""path"": [
      ""a""
    ],
    ""message"": ""Invalid input""
  }
]
    at new ZodError (/Users/kagrama/dev/cisco/dna/team-center/cli/node_modules/zod/src/ZodError.ts:134:5)
    at ZodObject.parse (/Users/kagrama/dev/cisco/dna/team-center/cli/node_modules/zod/src/parser.ts:171:17)
```

Ideally `deepPartial` would recurse through unions, taking the `deepPartial` of the union's members, where applicable.  I know that I can change `B`'s definition to:

```typescript
const B = z.object({a: z.union([A.deepPartial(), z.null()])});
```

...but this would seem to defeat the purpose of `deepPartial`.  I've got schemas nested to various levels of depth, and it seems that with `deepPartial`'s current behavior, I would have to duplicate schema definitions to achieve what I want...",,
760041790,264,RFC: Refactoring transformers and Zod 3,"## TLDR 

Transformers are poorly designed. I want to reimplement them but there will be breaking changes. Under this proposal, Zod 2 will never come out of beta and we'll jump straight to Zod 3 with a better implementation of transformers. Skip to ""New Implementation"" for details.

The reason Zod 2 has been in beta for so long (well, one of the reasons anyway!) is that Iâ€™ve been increasingly unsatisfied with Zodâ€™s implementation of transformers. Multiple issues have cropped up that have led me to re-evaluate the current approach. At best, transformers are a huge footgun and at worst theyâ€™re fundamentally flawed.

## Context

Previously (in v1) the ZodType base class tracked the inferred type in a generic parameter called `Type`. But transformers accept an Input of one type and return an Output of a different type. To account for this, `Type` was renamed to `Output` and a third generic property was added (`Input`). For non-transformers, `Input` and `Output` are the same. For transformers only, these types are different.

![Screen Shot 2020-12-08 at 5 09 36 PM](https://user-images.githubusercontent.com/3084745/101593584-03bc6f00-39a5-11eb-8a66-5e7e84103290.png)


Let's look at  `stringToNumber` as an example:

```ts
const stringToNumber = z.transformer(z.string(), z.number(), val => parseFloat(val));
```

For `stringToNumber`, Input is `string` and Output is `number`. Makes sense.

What happens when you pass a value into `stringToNumber.parse`?

1. The user passes a value into `stringToNumber.parse` 
2. The transformer passes this value through the `parse` function of its _input schema_ (z.string()). If there are parsing errors, it throws a ZodError
3. The transformer takes the output from that and passes it into the transformation function (`val => parseFloat(val)`)
4. The transformer takes the output of the transformation and validates it against the output schema (z.number())
5. The result of that call is returned

Here's the takeaway: for a generic transformer `z.transformer(A, B, func)`, where A and B are Zod schemas, the argument of `func` should be the `Output` type of A and the return type is the `Input` type of B. This lets you do things like this:

```ts
const stringToNumber = z.transformer(z.string(), z.number(), val => parseFloat(val));
const numberToBoolean = z.transformer(z.number(), z.boolean(), val => val > 25);
const stringToNumberToBoolean = z.transformer(stringToNumber, numberToBoolean, val => 5 * val);
```

## The problems with transformers

After implementing transformers, I realized transformers could be used to implement another much-requested feature: default values. Consider this:

```ts
const stringWithDefault = z.transformer(z.string().optional(), z.string(), val => val || ""trout"");
stringWithDefault.parse(""marlin"") // => ""marlin""
stringWithDefault.parse(undefined) // => ""trout""
```
Voila, a schema that accepts `string | undefined` and returns `string`, substituting the default ""trout"" if the input is ever undefined.

So I implemented the `.default(val:T)` method in the ZodType base class as below (partially simplified)

```ts
default(def: Input) {
  return ZodTransformer.create(this.optional(), this, (x: any) => {
    return x === undefined ? def : x;
  });
}
```

Do you see the problem with that? I didnâ€™t. Neither did anyone who read through the [Transformers RFC](https://github.com/colinhacks/zod/issues/100) which I left open for comment for a couple months before starting on implementation.

Basically this implementation doesnâ€™t work at all when you use it on transformers. 

> Side note: should the `.default` method for `stringToNumber` accept a number or a string? As implemented above it should accept a string (the `Input`). But already this is unintuitive to many people.

```ts
stringToNumber.default(""3.14"")

// EQUIVALENT TO
const defaultedStringToNumber = z.transformer(
  stringToNumber.optional(),
  stringToNumber,
  val => val !== undefined ? val : ""3.14""
)

defaultedStringToNumber.parse(""5"")
/* { ZodError: [
  {
    ""code"": ""invalid_type"",
    ""expected"": ""string"",
    ""received"": ""number"",
    ""path"": [],
    ""message"": ""Expected string, received number""
  }
] */
```

Letâ€™s walk through why this fails. The input (""5"") is first passed into the transformer input (`stringToNumber.optional()`). This converts the string `""5""` to the number `5`. This is then passed into the transformation function. But wait: `val` is now `number | undefined`, but the transformer function needs to return a `string`. Otherwise, if we pass `5` into `stringToNumber.parse` itâ€™ll throw. So we need to convert `5` back to `""5""`. That may seem easy in this toy example but itâ€™s not possible in the general case. Zod canâ€™t know how to magically undo  the transformation function. 

In practice, the current definition of `default` in ZodType shouldnâ€™t have even been possible. The only reason the type checker didnâ€™t catch this bug is because there are a regrettable number of `any`s floating around in Zod. Itâ€™s not a simple matter to switch them all to `unknown`s either; Iâ€™ve had to use `any` in several instance to get type inference and certain generic methods to work properly. Iâ€™ve tried multiple times to reduce the number of `any`s but Iâ€™ve never managed to crack it.

Itâ€™s possible this is a one-off issue. I could find some other way to implement `.default()` that doesnâ€™t involve transformers. Unfortunately this isnâ€™t even the only problem in Zodâ€™s implementation.

## The `.transform` method

Initially the only way to define transformers was with `z.transformer(A, B, func)`. Eventually I implemented a utility function you can use like this:

```ts
z.string().transform(z.number(), val=>parseFloat(val));

 // equivalent to 
z.transformer(z.string(), z.number(), val=>parseFloat(val));
```

Some users were executing multiple transforms in sequence without changing the actual data type:

```ts
z.string()
  .transform(z.string(), (val) => val.toLowerCase())
  .transform(z.string(), (val) => val.trim())
  .transform(z.string(), (val) => val.replace("" "", ""_""));
```

To reduce the boilerplate here, it was recommended that I overload the method definition to support this syntax:

```ts
z.string()
  .transform((val) => val.toLowerCase())
  .transform((val) => val.trim())
  .transform((val) => val.replace("" "", ""_""));
```

If the first argument is a function instead of a Zod schema, Zod should assume that the transformation doesnâ€™t transform the type. In other words, `z.string().transform((val) => val.trim())` should be equivalent to `z.string().transform(z.string(), (val) => val.trim())`. Makes sense. 

Consider using this method on a transformer:

```ts
stringToNumber.transform(/* transformation_func */);
```

What type signature do you expect for `transformation_func`? 

Most would probably expect `(arg: number)=>number`. Some would expect `(arg: string)=>string`. Neither of those are right; itâ€™s `(arg: number)=>string`. The transformation function expects an input of `number` (the Output of `stringToNumber`) and a return type of `number` (the Input of `stringToNumber`). This type signature is a natural consequence of a series of logical design decisions, but the end result is dumb. Intuitively, you should be able to append `.transform(val => val)` to any schema. Unfortunately due to how transformers are implemented, that's not always possible.

## More complicated examples

The fact that I incorrectly implemented both `.transform` and `.default` isn't even the problem. The problem is that transformers make it difficult to write any generic functions on top of Zod (of which `.transform` and `.default` are two examples). Others have encountered similar issues. #199 and #213. are more complicated examples of how the current design of transformers makes it difficult to write any generic functions on top of Zod. Nested transformers in particular are a minefield.  

## A path forward

When I set out to implement transformers I felt strongly that each transformer should have a strongly defined input and output transformer. This led to me implementing transformers as a separate subclass of ZodType (ZodTransformer) in an attempt to make transformers compose nicely with other schemas. This is the root of the issues Iâ€™ve laid out above. 

Instead I think Zod should adopt a new approach. For the sake of differentiation Iâ€™ll use a new term ""mods"" instead of ""transformations"". Each Zod schema has a list of post-parse modification functions (analogous to Yupâ€™s transform chain). When a value is passed into `.parse`, Zod will type check the value, then pass it through the mod chain. 

```ts
const schema = z.string()
  .mod(val => val.length)
  .mod(val => val > 100);

type In = z.input<typeof schema> // string
type Out = z.input<typeof schema> // boolean
```

Unlike before, Zod doesnâ€™t validate the data type between each modification. Weâ€™re relying on the TypeScript engine to infer the correct type based on the function definitions. In this sense, Zod is behaving just like I intended; itâ€™s acting as a reliable source of type safety that lets you confidently implement the rest of your application logic â€” including mods. Re-validating the type between each modification is overkill; TypeScriptâ€™s type checker already does that.

Each schema will still have an Input (the inferred type of the schema) and an Output (the output type of the last mod in the mod chain). But because weâ€™re avoiding the weird hierarchy of ZodTransformers everything behaves in a much more intuitive way.

One interesting ramification is that you could interleave mods and refinements. Zod could keep track of the order each mod/refinement was added and execute them all in sequence:

```ts
const schema = z.string()
  .mod(val => parseFloat(val))
  .refine(val => val > 25, { message: ""Too short"" })
  .mod(val => `${val}`)
  .refine(val => /^\d+$/.test(val), { message: ""No floats allowed"" });
```

## Compatibility

I was using the ""mod"" terminology above to avoid confusion with the earlier discussion. In reality I would implement the ""mod chain"" concept using the existing syntax/methods: `.default`, `.transform`, etc. In fact I think I could switch over to the ""mod"" approach without any major API changes.

- `A.transform(func)`: instead of returning a ZodTransformer, this method would simply append `func` to the ""mod chain""
- `A.transform(B, func)`: this would return `A.transform(func).refine(val => B.safeParse(val).success)`
- `z.transformer(A, B, func)`: this could just return `A.transform(func).refine(val => B.safeParse(val).success)`
- `A.default(defaultValue)`: this is trickier but still possible. This function would instantiate `A.optional().mod(val => typeof val !== ""undefined"" ? val : defaultValue)`. Then all the mods of A would be transferred over to the newly created schema

Under the hood things would be working very differently but most projects could upgrade painlessly unless they explicitly use the ZodTransformer class in some way (which isnâ€™t common).

I would still consider this to be a breaking change of course. If/when I make these changes, I plan to publish them as Zod v3. In this scenario Zod 2 would never leave beta, weâ€™d jump straight to v3. 

This transformers issue has caused me a lot of grief and headaches but Iâ€™m confident in the new direction; in fact I already have most of it working. I want to put this out for feedback from the community. The issues Iâ€™m describing are pretty subtle and not many people have run into them, but I believe the current implementation is currently untenable.
",,
759050078,259,Custom validations not running if default types fail.,"May be a copy of https://github.com/colinhacks/zod/issues/68 but I'm still seeing this issue. Using version: 2.0.0-beta.26

```
const someSchema = z
  .object({
    name: z.string().nonempty(""name required.""),
    lower_bound: z.number(),
    upper_bound: z.number(),
  })
  .refine((val) => val.lower_bound < val.upper_bound, {
    message: ""Upper bound must be greater than lower bound."",
    path: [""lower_bound"", ""upper_bound""],
  });

  console.log(
    someSchema
    .safeParse({name: """", lower_bound: 100, upper_bound: 0})
    .error
    .issues
  );

  // OUTPUT:
  // [
  //   {
  //     ""code"": ""too_small"",
  //     ""minimum"": 1,
  //     ""type"": ""string"",
  //     ""inclusive"": true,
  //     ""message"": ""name required."",
  //     ""path"": [
  //       ""name""
  //     ]
  //   }
  // ]
```",,
758356364,258,v2.0.0-beta.23: Non-enumerable properties are considered undefined,"I use Zod to check the type of the error produced by [body-parser](https://github.com/expressjs/body-parser), but it fails since commit 0f47d2f13d08c9e8c04f64a86e078cd18f40652e because non-enumerable properties are ignored. Is it an intentional change, or it is considered a bug?

Zod works fine for enumerable properties.
```
> const zod = require('zod')
> let a = { message: 'x' };
> zod.object({ message: zod.string() }).parse(a)
{ message: 'x' }
```

But it fails for an Error object because `message` is non-enumerable by default.
```
> let e = new Error('x')
> zod.object({ message: zod.string() }).parse(e)
Uncaught ZodError: [
  {
    ""code"": ""invalid_type"",
    ""expected"": ""string"",
    ""received"": ""undefined"",
    ""path"": [
      ""message""
    ],
    ""message"": ""Required""
  }
]
```

If I manually set it to enumerable, it can be successfully validated.
```
> Object.defineProperty(e, 'message', { enumerable: true })
> zod.object({ message: zod.string() }).parse(e)
{ message: 'x' }
```",,
758165868,257,`play` script fails to run,"As mentioned [here](https://github.com/colinhacks/zod/issues/225#issuecomment-739452319), the `play` script is currently not functional in the `v2` branch. The error below occurs.

```
$ yarn play
yarn run v1.22.5
$ nodemon -e ts -w . -x ts-node src/playground.ts --project tsconfig.json
[nodemon] 2.0.2
[nodemon] to restart at any time, enter `rs`
[nodemon] watching dir(s): *.*
[nodemon] watching extensions: ts
[nodemon] starting `ts-node src/playground.ts --project tsconfig.json`
sh: ts-node: command not found
[nodemon] failed to start process, ""ts-node"" exec not found
[nodemon] Error
    at Bus.<anonymous> (./zod/node_modules/nodemon/lib/nodemon.js:156:25)
    at Bus.emit (events.js:327:22)
    at ChildProcess.<anonymous> (./zod/node_modules/nodemon/lib/monitor/run.js:167:11)
    at ChildProcess.emit (events.js:315:20)
    at Process.ChildProcess._handle.onexit (internal/child_process.js:275:12)
âœ¨  Done in 0.32s.
```

To resolve this, simply adding `ts-node` to the dev dependencies should be enough. Though, `playground.ts` also appears to not be in a stable state either. The error below occurs.

```
Error: You can't call .parse on a schema containing async transformations.
```

Perhaps also putting playground in a stable state as well may be good for new developers coming in and being able to test out the library right away. A decision here should probably be made on whether this ticket should encompass both issues before a PR is sent in, though ðŸ™‚ ",,
758154999,256,TS Jest unsupported version warnings when running tests,"When running tests in the v2 branch the output below is noticed.

```
ts-jest[versions] (WARN) Version 4.0.5 of typescript installed has not been tested with ts-jest. If you're experiencing issues, consider using a supported version (>=2.7.0 <4.0.0). Please do not report issues in ts-jest if you are using unsupported versions.
```

This is due to a recent upgrade of the Typescript version without bumping the version for TS Jest. The following changes are recommended:

* Bump `ts-jest` from `25.2.1` to `26.4.4`
* Bump `jest` from `25.1.0` to `26.6.3`
* Bump `@types/jest` from `25.1.4` to `26.0.16`
* Change `tsConfig` key in `jest.config.json` to `tsconfig` (former is now deprecated)",,
758150443,255,`badge` script fails to run after tests,"When running tests in the `v2` branch the output below is noticed.

```
$ make-coverage-badge --output-path ./coverage.svg
./zod/node_modules/make-coverage-badge/cli.js:64
  if (err) throw err
           ^

[Error: ENOENT: no such file or directory, open './coverage/coverage-summary.json'] {
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: './coverage/coverage-summary.json'
}
error Command failed with exit code 1.
```

This is due to the `rootDir` key in `jest.config.json` pointing to `src`, which then generates `coverage/` under said directory. Two solutions are noted below, along with a recommendation.

1. Change `badge` script to `make-coverage-badge --report-path ./src/coverage/coverage-summary.json --output-path ./coverage.svg` in `package.json`
2. (**recommended**) Change `rootDir` to `.` in `jest.config.json`",,
756564980,248,Sending validator as first-class-function verifies badly,"See this code:

```typescript
import * as z from ""zod"";

const callback = (predicate: (val: string) => boolean) => {
  return predicate(""hello"");
};

console.log(callback(z.string().is)); // false!?
console.log(callback((value) => z.string().is(value))); // true
```
https://codesandbox.io/s/priceless-shadow-diu6n?file=/src/index.ts

Passing the `is` function seems to return a bad value, however, creating a callback (example 2) and using the `string.is` function within it works.

This seems wrong, and I don't even know how I could create this bug?

Btw, it doesn't matter what kind of schema I create, I just used string as an example. Any `is` function seems affected.

What's weird to me: passing `z.string().is` returns false, while passing `(value) => z.string().is(value)` returns true. They should be the same thing?

I used `    ""zod"": ""^2.0.0-beta.25""`",,
755634808,245,Question: How to validate a set of properties as required?,"Firstly, thanks for zod. I found some of the other tools in your comparison, but zod is the one that really seems to fit for my use case. Plus, I'm deeply impressed by the 3 letter name which was unused in npm and elsewhere! :-)

I have 3 properties, `foo`, `bar` and `baz`. If `bar` is present, then so must be `baz`. In other words, `bar` and `baz` must always be present or absent together. I couldn't figure out how to achieve this result in TypeScript, maybe I need union interfaces, I'm not sure. Is there a way to do it in zod?

I created a duplicate type that requires both `bar` and `baz` and I use that inside `.refine()` with a `.check()`, but I wonder if there's a clearer way to express what I'm trying to do?",,
755622818,244,Representing a function with additional properties,"Is it possible to represent a function that also has additional properties on it?

Thinking specifically of cases like [Storybook stories](https://github.com/storybookjs/storybook/blob/b8aa525731ac2933a2489da51e449f617236e093/lib/addons/src/types.ts#L255-L262):

```ts
// Simplified from the real type
interface Story<Args, StoryFnReturnType> {
  (args: Args): StoryFnReturnType;
  storyName?: string;
}
```

These are functions with some properties added to them. Something like

```js
function SomeFunc() {
  // ...
}

SomeFunc.storyName = ""hello there"";
```

I haven't been able to find any existing issues or documentation around this, but let me know if this has already been brought up. I also understand if this is too challenging or not a priority to implement.

Thanks!",,
755503516,243,Validation order 2.0.0-beta.25,"Hi, 

I've created a sandbox for a situation, when validation rules take strange order. 

Assuming having a schema like this 
`const formValuesSchema = z.object({
  name: z.string(),
  company: z.string(),
  email: z.string().email()
});`

I don't get an Invalid email error when email is filled, until the other fields are filled as well.
It happens on version 2.0.0-beta.25

https://codesandbox.io/s/elegant-drake-4ultm?fontsize=14&hidenavigation=1&theme=dark&file=/src/index.ts:27-137",,
754684077,241,Generic transformers?,"Thanks for a great library! Was doing some exploration for using, and was wondering if there was a way to make a ""generic"" transformer-like thing. I have a generic type called `Serialized` which basically maps a type that contains dates (recursively) to a type that swaps those properties for strings. This type is used for Postgres `to_json` and over-the-wire dates from API to client. It looks like:

```ts
export type Serialized<T> = {
  [P in keyof T]: T[P] extends Date
    ? string
    : T[P] extends Date | null
    ? string | null
    : T[P] extends any[]
    ? Serialized<T[P]>
    : T[P] extends any[] | null
    ? Serialized<T[P]> | null
    : T[P] extends object
    ? Serialized<T[P]>
    : T[P];
};
```

In my code, I'm currently manually creating schemas that `.extend` the base schema and replace the date(|null) properties with string(|null) manually, but I was wondering if there was a way to abstract that out such that I could, in essence, build up the `ZodObject._shape` dynamically?",,
754524835,240,"Skip regex() when optional() and string is empty """"","It makes more sense to only go through regex when the value is not empty for optional(), it removes overhead and it makes things more elegant. Currently to accomplish this requirement we need to allow empty in regex or to remove the empty fields from the formData before passing it to .parse

```
// Middle Name(optional)
const middleName = zod.string().optional().regex(/^[a-zA-Z0-9]+$/, { message: ""Only alphabets and numbers are allowed."" })
middleName.parse("""");  // returns regex error message
```

My current workaround but honestly it really shouldn't go to that step since there's no need for regex to validate an empty string
```
// prepend $| to allow empties
const middleName = zod.string().optional().regex(/^$|[a-zA-Z0-9]+$/, { message: ""Only alphabets and numbers are allowed."" })

```",,
753981473,239,"Refine is taking precedence over optional, nullable, nonempty","I've been using .regex for my validations and recently [saw a tip in the docs](https://github.com/colinhacks/zod#strings) to use validator.js for that so I went ahead and tried it out using refine, now the problem is refine seems to take precedence over optional, nullable, nonempty. 

```
import * as zod from ""zod"";

import isDate from 'validator/es/lib/isDate'
import toDate from 'validator/es/lib/toDate'

let test = zod.string().optional().nullable().refine(isDate, { message : ""Please use the format YYYY-MM-DD(e.g 1986-02-20, 1986/02/20)"" })
console.log(test.safeParse("""")) // error
console.log(test.safeParse(null)) // error
console.log(test.safeParse(undefined)) // error
```",,
752731786,238,Uncaught TypeError: Cannot convert a Symbol value to a number,"The following code sample will throw said error because after the validation failed the `refine` function is still called:

```ts
z.union([z.number(), z.string().transform(z.number(), Number.parseFloat)])
  .refine((v) => v >= 1)
  .parse(""foo"");
```

This is supposed to accept `5` or `""5""` and reject anything that is not parsable into a positive number. 

But the refine will be called even if the union parsing failed and then `v` will be `Symbol(""invalid_data"")`

```
> z.union([z.number(), z.string().transform(z.number(), Number.parseFloat)]).refine((v) => v >= 1).parse(""foo"");
Uncaught TypeError: Cannot convert a Symbol value to a number
    at repl:1:92
    at Object.check (/home/despairblue/git/wunderflats/api/node_modules/zod/lib/cjs/types/base.js:167:34)
    at ZodUnion.parse (/home/despairblue/git/wunderflats/api/node_modules/zod/lib/cjs/parser.js:892:41)
> 
```

Without the refine it works as expected:

```
> z.union([z.number(), z.string().transform(z.number(), Number.parseFloat)]).parse(""foo"");
Uncaught ZodError: [
  {
    ""code"": ""invalid_union"",
    ""unionErrors"": [
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""number"",
            ""received"": ""string"",
            ""path"": [],
            ""message"": ""Expected number, received string""
          }
        ]
      },
      {
        ""issues"": [
          {
            ""code"": ""invalid_type"",
            ""expected"": ""number"",
            ""received"": ""nan"",
            ""path"": [],
            ""message"": ""Expected number, received nan""
          }
        ]
      }
    ],
    ""path"": [],
    ""message"": ""Invalid input""
  }
]
    at new ZodError (/home/despairblue/git/wunderflats/api/node_modules/zod/lib/cjs/ZodError.js:73:28)
    at ZodUnion.parse (/home/despairblue/git/wunderflats/api/node_modules/zod/lib/cjs/parser.js:195:17) {
  issues: [
    {
      code: 'invalid_union',
      unionErrors: [Array],
      path: [],
      message: 'Invalid input'
    }
  ],
  addIssue: [Function],
  addIssues: [Function],
  flatten: [Function]
}
> 
```

Question regarding this. It seem `refine` function are not allowed to throw. ~~Does that mean a `refine` function **must** succeed?~~

Forget the last part as they can return `false` obviously. ",,
752407118,236,"Change `formErrors` to produce normalized, deep object instead of `flatten()`","I use `error.formErrors` in every project, and it's used the default Blitz.js form abstraction for displaying form errors on the client.

**The problem is that this flattens the errors to a single level, loosing critical path information for nested object errors.**

You can see an example here:

```ts
const test = zod
  .object({
    name: zod
      .object({
        firstName: zod.string().nonempty({ message: ""First name can not be empty."" }),
        middleName: zod.string(),
        lastName: zod.string(),
      })
  })
  .safeParse({
    name: {
      firstName: """",
      middleName: ""estrada"",
      lastName: """",
    },a
  }).error.fieldErrors;
```

```
  {
    name: [""First Name can not be empty."", ""Required"", ""Required""]
  }
```

Instead of the above, which is unusable, the result should be:

```
  {
    name: {
      firstName: [""First Name can not be empty.""], 
      middleName: [""Required""],
      lastName: [""Required""]
  }
```

### Workaround for 2 levels 

```ts
  } catch (error) {
    const fieldErrors: any = {}
    for (const issue of error.issues) {
      if (issue.path.length > 0) {
        if (issue.path.length === 1) {
          fieldErrors[issue.path[0]] ??= []
          fieldErrors[issue.path[0]].push(issue.message)
        } else {
          fieldErrors[issue.path[0]] ??= {}
          fieldErrors[issue.path[0]][issue.path[1]] ??= []
          fieldErrors[issue.path[0]][issue.path[1]].push(issue.message)
        }
      } else {
        // form error
      }
    }
    return fieldErrors
  }
```",,
749938557,235,Parsing process.env safety,"_I do not speak English natively nor do I consider myself to have a good level. For this reason, I apologize if I make any mistakes and please keep it in mind when reading and interpreting my messages. I'm doing the best I can. Thanks a lot._

Hello, I want to parse process.env

process.env is a `Zod.record(Zod.string())`

```ts
import * as Zod from 'zod';

enum Environments {
  PRODUCTION = 'production',
  DEVELOPMENT = 'development'
}

const EnvironmentVariables = Zod
  .object(
    {
      NODE_ENV: Zod.enum([Environments.DEVELOPMENT, Environments.PRODUCTION]),
      PG_HOST: Zod.string(),
      PG_PORT: Zod.number().int(),
      PG_DATABASE: Zod.string(),
      PG_USERNAME: Zod.string(),
      PG_PASSWORD: Zod.string(),
      /** Add custom environment variables to parse */
    }
  )
  .nonstrict()
  .parse(
    Object.assign(
      {},
      process.env,
      {
        PG_PORT: Number(process.env.PG_PORT),
      }
    )
  );

export const Environment = Object.assign(
  {},
  EnvironmentVariables,
  {
    IS_DEVELOPMENT: EnvironmentVariables.NODE_ENV === Environments.DEVELOPMENT ? true : false,
    IS_PRODUCTION: EnvironmentVariables.NODE_ENV === Environments.PRODUCTION ? true : false,
  },
);
```

The problem with this, is that `[k: string]: any;` is `any` when I want to let it be `[k: string]: string;`

```ts
const EnvironmentVariables: objectUtil.Flatten<{
    NODE_ENV: Environments;
    PG_HOST: string;
    PG_PORT: number;
    PG_DATABASE: string;
    PG_USERNAME: string;
    PG_PASSWORD: string;
} & {
    [k: string]: any; // I want this to be [k: string]: string;
}>
```

How would you build it? Thanks!",,
748186232,234,Webpack error when building zod,"When building my (typescript) project with webpack (4.41.5) I get:

```
ERROR in ./node_modules/zod/lib/src/index.js
Module not found: Error: Can't resolve './ZodError' in '/my-project/node_modules/zod/lib/src'
 @ ./node_modules/zod/lib/src/index.js 136:9-30
 @ ./src/zod/zod.ts
 @ ./src/zod/index.ts
 @ ./src/index.ts
```
I am using zod 1.11.10.

I have made a repo to reproduce the error: https://github.com/mspoulsen/zod-error

Any ideas? Thanks!
",,
747813875,233,Function infer return type,"Currently, I'm trying a lot of type manipulation on Zod schema.

Just for the example, I have this:
```typescript 
function foo<T extends z.ZodSchema<any>>(bar: z.infer<T>) {
  return {} as z.infer<T>;
}

const schema = z.object({
  foo: z.number()
});

type SchemaType = z.infer<typeof schema>;

const obj: SchemaType = {
  foo: 15
};

const bar = foo(obj); // expected SchemaType, but it's any
```

I don't know if it's a limitation of typescript or zod or just a mistake, and if there is a solution.",,
745554488,230,Zod 2 - parseAsync breaks unions of objects,"```typescript
import * as z from 'zod';

const Schema = z.union([
    z.object({
        ty: z.literal('A'),
    }),
    z.object({
        ty: z.literal('B'),
    }),
]);

(async () => {
  const obj = { ty: 'A' };
  console.log(Schema.parse(obj));  // Works
  console.log(await Schema.parseAsync(obj));  // Works with 1.11.10, breaks with 2.0.0-beta.21
})();
```

With Zod 2.0.0-beta.21, the `parseAsync` call fails with

```json
{
  ""code"": ""invalid_literal_value"",
  ""expected"": ""B"",
  ""path"": [
    ""ty""
  ],
  ""message"": ""Input must be \""B\""""
}
```

The objects wrapping the literals are important. A schema of `z.union([z.literal('A'), z.literal('B')])` worked fine.",,
745247742,229,z.infer to extract schema as a type,"Hi, first of all.. awesome library! Was wondering how you get the schema as a type? In v1 you could do z.infer<...> but infer doesn't seemingly exist in beta, unless I'm missing something? ",,
744527115,228,Any way to access siblings when defining schema?,"I'm trying to replicate `yup.when`, which allows the schema to change based on values present in an object.

For instance, when creating a new audio recording, a type and name is necessary.  When completing the recording, the runtime is necessary too.

In yup one could do that with a `status = 'started' | 'complete'` check, where `complete` would make the `runtime` field required.

(I don't intend to change the schema vastly, but different refinements and optionality would be great.)

I realise I can do this with separate schemas (pick / omit / partial will help), but hoping I don't need to build a layer over Zod to decide which schema to run.",,
744448967,227,Repo restructuring to remove circular dependencies,"### Related issues

- https://github.com/colinhacks/zod/issues/175#issuecomment-724316421
- https://github.com/colinhacks/zod/pull/226

### RFC

- [ ] `base`s shouldn't import other modules
  - for example, `src/types/base.ts` should be reconsidered
- [ ] api reused in other modules should be modularized, for example:
  - `src/parser.ts` should be split into two files
    - `src/parser/index.ts` & `src/parser/types.ts` so the circular dependency between ZodError & parser is removed
      - and a similar approach could be done on other instances of circular dependency",,
744442742,225,Batch repo enhancements,"Let me please propose batch of changes to the DX, so it'd be easier for others to contribute.
Please let me know what you would approve, so I'd know what to help you with :)

### Todo (Not started yet)

- [ ] add [automated releases generation](https://medium.com/p/44c015f38fd6) and make commits messages more strict
  - as a user of this library, it was a bit time consuming to browse commits to realize what changed between `beta` versions

### Completed
- [x] use `typescript-eslint` instead of `tslint`
  - it's been almost 2 years since the standard in TS linting is `ESLint`, [more info](https://eslint.org/blog/2019/01/future-typescript-eslint)
- [x] add `.log` files to `.gitignore`
  - for example, there's already a mistakenly uploaded `yarn-error.log`
- [x] bump prettier & use community defaults
  - let's use the defaults, so it's more likely to please higher % of contributors
- [x] ~~add `.npmignore` to exclude unrelated files from the deployed package~~
  - improve the `files` + `exclude` instead
- [x] remove empty `dependencies` object from package.json
- [x] add `husky` to add `git` hooks
  - it's important to automatically prevent issues like in #218 from happening, when there are bunch of unrelated formatting changes
    - at least automatic code formatting should be in place
- [x] add official funding references of your GitHub sponsors link to the `package.json`
  - I suggest to start with the use described in [this PR from react-virtual](https://github.com/tannerlinsley/react-virtual/pull/78/files)
",,
743244862,224,Zod [V2] - Transforms are not called when using .output,"Hi @colinhacks 

When calling `parse` / `parseAsync` on a schema that uses `.output`, the transform isn't actually run. For example:

```typescript
const name = zod.string().transform(val => val.toUpperCase());
const result = await name.parse('Ross');
```

`result` returns `ROSS` as expected, however

```typescript
const name = zod.string()
                .transform(val => val.toUpperCase())
                .output; // <--- Append .output (then later, if this were an object I can `omit()` etc);

const result = await name.parse('Ross');
```

Appending `.output` and running the above returns `Ross`. The transform isn't called. I'm running `2.0.0-beta.21`",,
743054419,223,Please use paths instead of array indices for nested schema objects,"```
const test = zod
  .object({
    name: zod
      .object({
        firstName: zod.string().nonempty({ message: ""First name can not be empty."" }),
        middleName: zod.string(),
        lastName: zod.string().nonempty(),
      })
      .refine((name) => name.firstName === name.middleName, {
        message: ""First and Middle Name must be the same"", // refinement test.
      }),
  })
  .safeParse({
    name: {
      firstName: """",
      middleName: ""estrada"",
      lastName: """",
    },
  }).error.flatten();
```

console.log:
```
  fieldErrors: {
    name: (3) [""First Name can not be empty."", ""Should be at least 1 characters"", ""First and Middle Name must be the same""]
  }
```

I have a component for each field and the lack of path prevents me from passing the error message to their respective components (ex: <FirstNameInput error={ {error.fieldErrors?.name?} }) />).  We can always use object.keys to achieve the current behavior as well.

Another issue is the error message becomes very unclear since they don't reference any paths in their message (ex: Should be at least 1 characters). The workaround here is to manually type the name inside the custom error message but that just isn't elegant especially if we'll be doing that per field.",,
742632852,222,"Bug: Inconsistent ""Expected never, received array"" in v2","**Environment:**

> Node 12.18.2
> Webpack 4.44.2
> Zod 2.0.0-beta.21


```json
// tsconfig.json
// target: commonjs2
{
  ""compilerOptions"": {
    ""module"": ""commonjs"",
    ""target"": ""es2019"",
    ""lib"": [""es2020""],
    ""strict"": true,
    ""noImplicitAny"": true,
    ""strictNullChecks"": true,
    ""noImplicitThis"": true,
    ""alwaysStrict"": true,
    ""noImplicitReturns"": true,
    ""noFallthroughCasesInSwitch"": false,
    ""inlineSourceMap"": true,
    ""inlineSources"": true,
    ""experimentalDecorators"": true,
    ""emitDecoratorMetadata"": true,
    ""strictPropertyInitialization"": false,
    ""typeRoots"": [""./node_modules/@types"", ""./typings""]
  },
  ""include"": [""src/**/*""],
  ""exclude"": [""node_modules"", ""**/*.test.ts"", ""**/*.it.ts""]
}
```

**Error**

I'm experiencing the following error when the parser encounters an **unknown field**: `Expected never, received array`. 

The weirdest thing is that this does not happen in local development, but it only happens when files are bundle with webpack and production mode.

**Expected result**

According to v2 doc: _By default Zod object schema strip unknown keys from the output._

**Code**

Here's a snippet of code that I have:

```typescript
const atAgencySchema = z
  .object({
    agencyId: z.string(),
    market: z.enum(['X', 'Y', 'Z']),
    name: z.string(),
  })

// ...
const record = { agencyId: 'id', market: 'Y', name: 'yo', skills: ['1'] } 
atAgenciesSchema.parse(record) // throws ""Expected never, received array""
```

**Workaround**

Reverted back to v1, and used `nonstrict()`",,
742444723,221,Feature request: one of fields required,"If I am not mistaken right now you have to use `refine` and write your own logic to support such a feature. Zods goal is a nice developer experience and I think this would a good addition.

```
const schema = z.object({
  name: z.string().nonempty(),
  familyName: z.string().nonempty(),
  email: z.string().email(),
  phone: z.string(),
}).oneOf('email', 'phone')
```

This schema would only require nonempty `email` or `phone`.",,
742419503,220,Feature request: is boolean true?,"Hey, 
First time using Zod. Is there a function like `nonempty()` for booleans? Or do you have to use refine?

`is(true)` or `is(false)`",,
740684239,219,Function Type Error,"@colinhacks Can you take a look at this?

```ts
import * as z from 'zod';

export type Data = boolean | null | number | string | undefined | { [key: string]: Data } | Data[];

export type Input = { [key: string]: z.Schema<Data> };
export type Output = z.Schema<Data | void>;
export type IO<I, O> = { input: I; output: O };

export function fn<I extends Input, O extends Output>(io: IO<I, O>) {
  return z.function(z.tuple([z.object(io.input)]), z.promise(io.output));
}

// ReturnType<typeof fn> doesn't work properly
type Fns = { [key: string]: ReturnType<typeof fn> };

export function createSchema<T extends Fns>(fns: T) {
  return fns;
}

export const UserSchema = createSchema({
  getMessage: fn({ // Type Error
    input: { name: z.string() },
    output: z.string(),
  }),
});
```",,
739390782,217,Can't use omit after calling transform,"Hi,

I've noticed that it's not possible to call `.transform` and then call `.omit`. Is this expected?

In the example below `const user` is invalid beacuse `omit` does not exist.

```typescript
export class Example {
  schema = zod.object({
    id: zod.number(),
    name: zod.string()
  }).transform((data) => data); //<-- just to illustrate the point

  create(name: string): zod.infer<Example['schema']> {
    const user = this.schema.omit({ id: true }).parse({ name });
    return this.db.save(user);
  }
}
```",,
737911987,216,Access to current object when using defaults,"Hi,

I'm trying to set a default value, depending on the value of another property within an object, for example:
- If `dataTypes` contains 'type_one', `responseTypes` should default to 'one'
- If `dataTypes` does not contain 'type_one', `responseTypes` should default to empty

```typescript
const myScheam = zod.object({
  dataTypes: zod.array(zod.enum(['type_one', 'type_two'])).nonempty(),
  responseTypes: zod.array(zod.enum(['one']).optional())
})
```
I can't see any way to do this using defaults / a transformer as I don't have access to the current object being parsed.

Is this currently not possible? (Using Zod 2.0.0-beta.20)

Thanks!",,
737757024,215,ESM module in Zod 2 beta causing runtime error,"With Zod 2.0.0-beta.20:

![Screenshot](https://i.imgur.com/0kYAYgU.png)

With Zod 1.11, no error.

Only seems to happen when using the object type
```ts
// no crash
z.string();
z.date();
// crashes
z.object({});
z.object({
  id: z.string(),
});
```
",,
736268013,214,"Feature request: Add ""Did you mean X?""","When misspelling a property in an object type, I get such an error right now:
```
Error: 1 validation issue(s)

  Issue #0: unrecognized_keys at 
  Unrecognized key(s) in object: 'errorrFormat'

    at new ZodError (/root/code/runtime-validation/node_modules/zod/src/ZodError.ts:124:5)
```
It would be great, if a ""Did you mean `errorFormat`?"" could be shown.

[In Prisma Client, we're using `js-levenshtein` for that purpose](https://github.com/prisma/prisma/blob/32b25e4ca23d068e123548454b0461ea60cb4999/src/packages/client/src/runtime/utils/common.ts#L190) (after comparing all the 500 levenshtein implementations on NPM ðŸ˜„  )

",,
736079426,213,Feature Request: Allow generating an object with a full set of defaults that may not validate,"I am looking to use zod as a way to validate user configuration files for a command line utility.  It looks like a great fit compared to what we are doing now, but I am having trouble with one aspect.

The workflow we use is:

- Allocate an initial set of defaults in a nested object  (note: this isn't fully filled in so won't validate the schema)
- Pass to a user provided configuration function (ex. app.config.js) that extends the configuration
- Fill in final settings based upon combination of user and defaults
- Validate final config with schema.  (looking for extra properties, validation checks, etc)

My problem is that in this model I don't see a way to use zod to create the initial defaults object.  I know I could create it as a plain old javascript object separate from the schema, but I was hoping to take advantage of the .default() methods within the schema to have the schema be self describing without having a separate large defaults object.

So my hope was to make something like this work:

```javascript
const ConfigSchema = z.object({
   /** The name to use. */
   name: z.string().default('blah'),

   /** Another nested part. */
   nested: z
      .object({
         value: z.number(),
         val2: z
            .string()
            .nullable()
            .refine((v) => v && v.length === 5, 'Must be length 5.'),
      })
      .default({
         value: 20,
         val2: null,
      }),
});

type ConfigType = z.infer<typeof ConfigSchema>;

describe('zod', () => {
   it('validates a good value', () => {});

   it('can provide defaults to override', () => {
      // We can build a set of default values that don't validate yet
      const default_results = ConfigSchema.safeParse({});  // <--- Need something here to just get defaults
      const cfg = default_results.data;

      expect(cfg.nested.val2).toEqual(null);

      // then: user modifies it with config overrides
      cfg.nested.val2 = '12345';

      // and: now it can validate
      const results = ConfigSchema.safeParse(cfg);
   });
});
```

Is anything like this possible or practical as a feature in zod?  I think it is effectively a SafeParse that doesn't do any checks, but instead just sets the default values on the object passed in.",,
736036467,212,How to define two objects that depends on each other (circular references)?,"In typescript youre able to create two types that depends in each other, ex:

```ts
type ObjectA = {
  b: ObjectB;
};

type ObjectB = {
  a: ObjectA;
};
```
But a similar pattern doesn't work with zod
```ts
const zObjectA = z.object({
  b: zObjectB,
});

const zObjectB = z.object({
  a: zObjectA,
});
```
`- error TS7022: 'zObjectA' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.`
",,
735418268,211,Request for help: typed Zod combinator with dynamic field name,"I apologize, this is almost certainly not the correct place to ask, but I'm not sure where else.

I asked [this question](https://stackoverflow.com/questions/64665779/typed-zod-combinator-with-dynamic-key) on Stack Overflow, reproducing it below.

___

My XML to JSON library emits `{MyKey: T}` for one-element lists, and `{MyKey: T[]}` for multi-element lists. The corresponding TypeScript type is `type XmlJsonArray<T, element extends string> = Record<element, T | T[]>`. I've used the following to implement it as a Zod schema:

```typescript
const XmlJsonArray = <T, element extends string>(element: element, schema: z.Schema<T>) => {
  // TODO what is the idiomatic approach here?
  const outerSchema: Record<element, z.Schema<T | T[]>> = {} as any;
  outerSchema[element] = z.union([schema, z.array(schema)]);
  return z.object(outerSchema);
};
```

Is there a way to do this without using `any`?",,
734578141,210,Lack of flexibility and escape hatches,"I am in the process of turning huge dynamically loaded config (that wasn't validated before and was simply huge `interface`) into a `zod` schema. I am running into some issues related to the fundamental lack of flexibility in zod. It seems like in some scenarios I cannot turn off validation in zod entirely. 

Code like this:
```typescript
interface Worker {
	doWork: (services: Service): Promise<void>;
}
```

`services` here is a complicated object with a variety of dependencies and I simply don't want to validate it in any way. I am fine with assuming that function provided by the user is correct. Also I don't want to suffer a performance impact by using `args` and `returns`. It seems like it's not possible to express this in any way in zod.

1) Using `z.function()` will end up being inffered as `() => unknown`.

```typescript
z.object({doWork: z.function()})
``` 

2) Using `z.any()` ends up being inferred as *optional* property which is not what I wanted ie.

```typescript
z.object({doWork: z.any().refine(v => v instanceof Function)})
```

is:

```
{
	doWork?: any
}
```

It would be cool to have some way to override type inferred by zod to anything else (it would also allow simple implementation for opaque types). For example:

```typescript
z.object({doWork: z.function().cast<((services: Service) => Promise<void>)>()})
```",,
733437377,207,V2 - Readd checks info on schema,"Hello,

I'm implementing a functionality to add **maxLength** attributes in input fields in React, based on the value of max attributes of Zod schema.

Basically, I read every field of schema, and check the **._def.checks** and pick up the **maximum** attribute of **too_big** code.

The **checks** was an array of objects in version 1, with the **code**, **maximum** and another info.

But in version 2 the **checks** array is an array of objects with only a check property with a function.

Would it be possible to add those information again?",,
732541919,205,Slow parsing performance,"I've just started using this library to check that parsed JSON objects conform to the types I define. I'm really enjoying it, but I'm afraid I've hit a performance snag.

Everything works fine with small tests but when I ran it on a slightly bigger input file (~10MB) I noticed that it was really slow.

I've tried the latest version and the beta, and `check` vs `parse`, with similar results. The beta is faster, but I don't see a big difference between `check` and `parse`.

After profiling the `check` version in the beta, I'm seeing calls to `.check` taking in the 500ms-1100ms range per object. 
![image](https://user-images.githubusercontent.com/167588/97613435-fc568d00-1a18-11eb-9d53-89899c718724.png)

Are those numbers typical, or am I doing something wrong with the schema definitions?

My schema definitions look like:
```
const EntryJsonSchema = z.object({
  a: z.string().optional().nullable(),
  b: z.string().optional().nullable(),
  id: z.string().optional().nullable(),
  creation: z.string().optional().nullable(),
  content: ContentJsonSchema.optional().nullable(),
  labels: z.string().array().optional().nullable(),
  answers: AnswerJsonSchema.array().optional().nullable(),
  results: ResultJsonSchema.array()
    .optional()
    .nullable(),
});

const ContentJsonSchema = z.object({
  id: z.string().optional().nullable(),
  title: z.string().optional().nullable(),
  version: z.union([z.number(), z.string()]).optional().nullable(),
});

const AnswerJsonSchema = z.object({
  key: z.string().optional().nullable(),
  value: z.any().optional().nullable(),
});

const ResultJsonSchema = z.object({
  key: z.string().optional().nullable(),
  value: z.any().optional().nullable(),
});
```

I'm really hoping that there is a way to speed it up, as this is too expensive for the use case where I'll have to process files with 100k+ objects.

Thanks!",,
731727963,204,Using refine causes errors to not be removed on blur or change,"I have a group of checkboxes and I want at least one to be checked. My schema is 
```
const schema = z.object({
  flags: z.array(z.boolean()).refine(flags => flags.some(flag => flag)),
  reason: z.string().nonempty()
})
```
When I click submit with none checked an error appears as it should, however when I click a radio button the error is not cleared until I click the submit (all other errors resolve on change)",,
731187174,203,[Feature request] make it possible to access the form data when creating custom error messages,"I believe we have an issue that is similar to !163, but, I'm not sure if our issue can be addressed using the `refinementData`.

Consider having the following schema:
```ts
z.object({
  paymentType: z.object({
    name: z.string(),
    minLimit: z.number(),
    maxLimit: z.number(),
  }),
  amount: z.number()
})
```
So the amount should always stay between minLimit and maxLimit. we can check for this simply by using a `.refine`:
```ts
z.object({...})
  .refine(
    ({ paymentType, amount }) => paymentType <= amount.maxLimit,
    { message: ""Please enter a smaller value"", path: [""amount""] }
  )
  .refine(
    ({ paymentType, amount }) => paymentType >= amount.minLimit,
    { message: ""Please enter a larger value"", path: [""amount""] }
  )
```
This works perfectly fine, but the issue arises when I want to show a more descriptive error message. something like ```The value should be greater than or equal to ${paymentType.min}```.
It's simply not possible to handle this case in the schema itself, and I need to refine the schema afterward in my component when I have the selected values in a state (I'm using `React`).

My proposal is to add support for passing a function as the `refine`s second parameter with the following definition:
```ts
(arg: Type) => Pick<Check<Type>, ""path"" | ""message"" | ""params"">
```
So we can have access to everything we need when we're constructing the error message.

I also thought about changing the refine signature to something like this:
```ts
refine: <Func extends (arg: Type) => any>(check: Func, message?: string | Pick<Check<Type>, ""path"" | ""message"" | ""params"">) => this;
refine: <Func extends (arg: Type) => any>(check: (arg: Type) => { isValid: boolean } & Pick<Check<Type>, ""path"" | ""message"" | ""params"">) => this;
```
It's much simpler, but as we are letting `any` as the return type of the check func right now, this would be a breaking change that we might want to avoid. So I propose accepting a function as the second parameter at least.",,
730432892,202,protected _refinement field in ZodType breaks cross package schema usage,"- package A (has dependency on zod)
```ts
import * as z from 'zod';

export const s = z.object({
    id: z.string(),
});
```
- package B (also has dependency on zod)
```ts
import { s } from 'package A';
import * as z from 'zod';

const makeValidator = <T>(schema: z.ZodType<T>) => {
    return (thing) => schema.safeParse(thing);
};

export const validator = makeValidator(s); // line 26
```
- error on `line 26`:
```
Property '_refinement' is protected but type 'ZodType<Type, Def>' is not a class derived from 'ZodType<Type, Def>'
```

I think this issue is caused by this typescript limitation https://github.com/microsoft/TypeScript/issues/7755

I have found the following workaround to get structural typing to work again
```ts
type SafeParseResult<T> =
    | {
          success: true;
          data: T;
      }
    | {
          success: false;
          error: z.ZodError;
      };

interface ZodParser<T> {
    safeParse(thing: unknown): SafeParseResult<T>;
}

const makeValidator = <T>(schema: ZodParser<T>) => {
    return (thing) => schema.safeParse(thing);
};

export const validator = makeValidator(s); // ok
```

Another workaround is to have package A declare a peerDependency on `zod`, but that's  a pain.

A nice solution would be to export an interface to make working with schemas in a generic fashion easier. I think schemas should all implement a unique interface, similar to ZodType<T> but without the protected/private components.",,
730028697,201,How to get all the defaults from schema?,"Something like


```
const schema = z.object({
  name: z.string().default(""A""),
});


schema.getDefaults()

// returns:
{ name: 'A' }
```",,
729782028,200,JSDoc or similar documentation for inferred types?,Is there a way to provide JSDoc (or some kind of documentation) attached to the inferred types?,,
729571831,199,Zod 2: nested transforms don't work,"I'm trying to use Zod to parse data that has arrays nested in an object like this (don't blame me, from a third party :D):

```ts
const classes = {
  elements: [
    {
      students: {
        elements: [{ id: 1 }, { id: 2 }, { id: 3 }],
      },
    },
    {
      students: {
        elements: [{ id: 4 }, { id: 5 }, { id: 6 }],
      },
    },
  ],
};
```

I can write a parser like this, that works as expected, but there's a lot of boilerplate:

```ts
const studentSchema = z.object({
  id: z.number(),
});

const classesSchema = z.object({
  elements: z.array(
    z.object({
      students: z.object({
        elements: z.array(studentSchema),
      }),
    }),
  ),
});

classesSchema.parse(classes); // works
```

I wrote a helper function, that builds the array schema and uses transforms to remove it from the parsed data:

```ts
export const transformArray = <T extends z.ZodTypeAny>(childSchema: T) => {
  const schema = z.object({
    elements: z.array(childSchema),
  });

  return z.transformer(schema, z.array(childSchema), (val) => val.elements);
};

const classTransformSchema = z.object({
  students: transformArray(studentSchema),
});

classTransformSchema.parse(classes.elements[0]); // works
```


However if I try to use this to parse the whole object, it compiles and has the correct return type, but at runtime throws an error:

```ts
const classesTransformSchema = transformArray(classTransformSchema);

classesTransformSchema.parse(classes); // throws `invalid_type` error
```

* Zod 2.0.0-beta.16
* TypeScript 4.0.3",,
725908059,198,Would you add comparison with $mol_data?,"- [Docs](https://github.com/eigenmethod/mol/tree/master/data)
- [Example](https://www.typescriptlang.org/play?downlevelIteration=true#code/JYWwDg9gTgLgBAbwFBzgEhBANgfQCYCGMBOAzjFMAHYDmcBpcAyhQDQrqa6HE7UwBTGgKj1GASSox2qDNnxESUAQGNoeMXABKqmZ3k8SEMDGAQqBLJoCyBAJ4AjAXrndFOAG4FKBKZoBq3nYuXAq8AiAEwFYMcLbRIQbuYMBgApoACqkCSAC+cABmUBAgcABEoYY4llhlANxISCpYDIzWdgAiROkIcByoalTkUACuKjDQABReWCMCAFxww9Q0AJSIcLn9cHYC3gCEi1QjIE5Q25hSABaHcMenItuEdrf3Z3mNg+RwAKqkIh0ACoAeTgAF5tKpJsgAJAWEDpRYsUTsGEEYRwRa2RwCSZwSTwdaohzAWBXZ6YuBZNJ45FwVhxTrdOBEpAwsBXcyIuCBKB2WkUen4vysmGRaKU+JWdi5VaNAD08rgAFEhiNlHAYFdgIwdfRfv9zl94AArajgg0AkHQtnw7kAcgAUtR7fS2ejuQBmT1umEkskUxb2gCMAE4ABwAFgAtAAGcNxyOu1EcrmUgDsoeDACZPZGAKwANnT4dDsdR4qsQYKEAgAAEBAAPAjgLACAB00BoybycqQis1djSEAKcDNVHBYIhyAHMOUBDw5iwdjuLYWSwoKwas-ni6oy-owgA-EcTmc4AAfOAjKh4AQFagCPDbpVzvZ7g-+rXPLElARSF84DfBclxXVMqAEE8N0oWhLzuM8REA4CPxXStFmWWhAK2fslQAQSwLAIAAdzgUDLSgUgkAKG9xjMCcwBgmAADk1zxEZDUpGAhwEEdyKBYF20CWZ0nWWEvmwDtCJoNjDXbO0WQ+JAGP4FiETxccFJwuAAHVilgk1SHMQpilKQ0PEeY0x0Midp1tNdKSdF1fQ9SlvV9L9yXsBywyjOME1jJNfXA7lMxzPMixLMsKyiKs4HtAAeeVSBUSgTAAPh7fJYl8OwFSVLQb1MBE4BEYooEWABtCoYrKABdOBEuS1KYDSuA9SoCB4AIOB5XbABqOt+vlJTGNU3E+OtKyjPWOUgA)",,
725050016,197,RFC: Mocking,"I'm open to a PR for a `.mock` method that lets you generate mock data for your schemas.

## Proposal 

### New base method: `.mock`
A `.mock` method on the base class. 

```ts
z.string().mock(); // => ""AkvoFxGfoHFhdfKF"" (random string)
z.number().mock(); // => 18916.19016 (random number)
```

### Overrides

This method could accept some parameters that let you overriding the default mocking functions for each data type (e.g. strings, numbers, tuples, etc).

```ts
z.string().mock({
  stringMocker: ()=>['hello', 'goodbye'][Math.round(Math.random())]
});
// => randomly chooses ""hello"" or ""goodbye""
```

### Instance-specific mocking functions

There would also need to be a way to override the mocking function for a particular schema instance (probably a `.mocker()` or `.setMocker()` method on the base class). 

```ts
z.string()
  .refine(val => val === val.toLowerCase())
  .mocker(()=>{
    return randomString().toLowerCase();
  })
  .mock(); // => ""akvofxgfohfhdfkf""
```

### Issues

#### Refinements

Zod has no way of generating a value that satisfies a given refinement. There would also need to be a way to override the mocking function for a particular schema instance (probably a `.mocker()` or `.setMocker()` method on the base class). 

#### Unions

Which union ""option"" should be used to generate the value? Perhaps a randomly chosen one? Should the mocked value for an optional value be `undefined` 50% of the time?


#### Transformers

Should Zod mock a value for the input or the output type? Not a huge issue, this can just be an option/flag in the `.mock` method.",,
724744927,196,Not getting infer in TS types,"![image](https://user-images.githubusercontent.com/19697099/96473797-b26aeb80-124f-11eb-8148-beb229a62018.png)

I am on the beta version of Zod and I'm facing this error from TypeScript.

This is my `tsconfig.json`

```json5
{
  ""compilerOptions"": {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */
    /* Basic Options */
    // ""incremental"": true,                   /* Enable incremental compilation */
    ""target"": ""ES2018"" /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */,
    ""module"": ""commonjs"" /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */,
    ""lib"": [
      ""ESNext""
    ] /* Specify library files to be included in the compilation. */,
    // ""allowJs"": true,                       /* Allow javascript files to be compiled. */
    // ""checkJs"": true,                       /* Report errors in .js files. */
    // ""jsx"": ""preserve"",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */
    // ""declaration"": true,                   /* Generates corresponding '.d.ts' file. */
    // ""declarationMap"": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */
    ""sourceMap"": true /* Generates corresponding '.map' file. */,
    // ""outFile"": ""./"",                       /* Concatenate and emit output to single file. */
    ""outDir"": ""./dist"" /* Redirect output structure to the directory. */,
    // ""rootDir"": ""./src"" /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */,
    // ""composite"": true,                     /* Enable project compilation */
    // ""tsBuildInfoFile"": ""./"",               /* Specify file to store incremental compilation information */
    // ""removeComments"": true,                /* Do not emit comments to output. */
    // ""noEmit"": true,                        /* Do not emit outputs. */
    // ""importHelpers"": true,                 /* Import emit helpers from 'tslib'. */
    // ""downlevelIteration"": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
    ""isolatedModules"": true /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */,
    /* Strict Type-Checking Options */
    ""strict"": true /* Enable all strict type-checking options. */,
    ""noImplicitAny"": true /* Raise error on expressions and declarations with an implied 'any' type. */,
    ""strictNullChecks"": true /* Enable strict null checks. */,
    // ""strictFunctionTypes"": true,           /* Enable strict checking of function types. */
    // ""strictBindCallApply"": true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions. */
    // ""strictPropertyInitialization"": true,  /* Enable strict checking of property initialization in classes. */
    // ""noImplicitThis"": true,                /* Raise error on 'this' expressions with an implied 'any' type. */
    ""alwaysStrict"": true /* Parse in strict mode and emit ""use strict"" for each source file. */,
    /* Additional Checks */
    // ""noUnusedLocals"": true,                /* Report errors on unused locals. */
    // ""noUnusedParameters"": true,            /* Report errors on unused parameters. */
    // ""noImplicitReturns"": true,             /* Report error when not all code paths in function return a value. */
    // ""noFallthroughCasesInSwitch"": true,    /* Report errors for fallthrough cases in switch statement. */
    /* Module Resolution Options */
    // ""moduleResolution"": ""node"",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    // ""baseUrl"": ""./"",                       /* Base directory to resolve non-absolute module names. */
    // ""paths"": {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
    // ""rootDirs"": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */
    // ""typeRoots"": [],                       /* List of folders to include type definitions from. */
    // ""types"": [],                           /* Type declaration files to be included in compilation. */
    // ""allowSyntheticDefaultImports"": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */
    ""esModuleInterop"": true /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */,
    // ""preserveSymlinks"": true,              /* Do not resolve the real path of symlinks. */
    // ""allowUmdGlobalAccess"": true,          /* Allow accessing UMD globals from modules. */
    /* Source Map Options */
    // ""sourceRoot"": """",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    // ""mapRoot"": """",                         /* Specify the location where debugger should locate map files instead of generated locations. */
    // ""inlineSourceMap"": true,               /* Emit a single file with source maps instead of having a separate file. */
    // ""inlineSources"": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */
    /* Experimental Options */
    // ""experimentalDecorators"": true,        /* Enables experimental support for ES7 decorators. */
    // ""emitDecoratorMetadata"": true,         /* Enables experimental support for emitting type metadata for decorators. */
    /* Advanced Options */
    ""skipLibCheck"": true /* Skip type checking of declaration files. */,
    ""forceConsistentCasingInFileNames"": true /* Disallow inconsistently-cased references to the same file. */
  },
  ""include"": [
    ""src/**/*""
  ]
}
```",,
724238296,195,Using .mock() as a .default() only in testing?,"Hey hey,

So we are looking at using a ""zod first approach"" to developing libraries (DDD?).

As such we have just been looking at a way to quickly mock inputs during develop and testing. One idea we had was to use [.default()](https://github.com/vriad/zod/tree/v2#default-values) to produce the test data - but then we realised this didn't make sense as we would then have these defaults in production as well.

It would be great if there were an equivalent `.mock()` that would return a mock value if no other is received and node env == `dev` or `test` (or some other config).

cc @iainkirkpatrick",,
724043335,194,z.infer not required by default?,"![image](https://user-images.githubusercontent.com/4253551/96373779-e20aec80-1198-11eb-87e6-61b065330b77.png)

I'm using Typescript 4.0.3 and zod 1.11.9",,
723091768,192,v2.0.0-beta.12: Cannot find module <...>/node_modules/zod/[]]./lib/src/index.js'.,"After upgrading to `v2.0.0-beta.12` I started getting the following error:

```
Cannot find module <...>/node_modules/zod/[]]./lib/src/index.js'.
```

Caused by this line:
https://github.com/vriad/zod/blob/v2/package.json#L5

It seems that the main field in the package.json file was very recently changed from:

```
""main"": ""./lib/src/index.js"",
```
to

```
""main"": ""[]]./lib/src/index.js"",
```

",,
722834341,191,Missing type for discriminated union result of safeParse,"Maybe I am doing something incorrectly here.

If I have an array of results from `safeParse`, and I want to filter on the successful ones and then use the `data` from each, I need a type to pass to the `Array.filter` function. Zod does not export a type like this, because the appropriate type is only defined inline: 
https://github.com/vriad/zod/blob/d1ae8e3538167a41e13ab6cfc2466ef3ca69e63a/src/types/base.ts#L69

I defined a type that takes the `typeof` of a schema as input, and can then be passed to `.filter` to allow this behavior.

The type is:
```
type ZodSafeParseSuccess<T extends zod.ZodSchema<T['_input']>> = { success: true; data: zod.infer<T> };
```
And assuming `parseResult` is the output of calling `safeParse` on an input (say objects retrieved from a database or sent by a client), here is example usage:
```
  [parseResult]
    .filter(
      (result): result is ZodSafeParseSuccess<typeof someSchema> => result.success === true,
    )
    .map((result) => result.data);
```

Here, in the `.map` tsc will know that `data` exists and infer its type correctly based on the schema. 

An appropriate `ZodSafeParseError` type could easily be derived similarly.

Looking forward to feedback - was there an easier way to do this, or should this be closed as a reference for how to fix, or should I open a PR and add this type definition into Zod?",,
718898883,190,"Ability to require one or another field, or require one field if another is provided","I read through the readme and nothing popped out as supporting this functionality, apologies if I missed something.

The Joi library contains the .with() and .xor() methods which allows you to define whether or not fields are required based on whether or not another field exists. This would be helpful in a case where I want to allow a user to signup with either an `email` or `phoneNumber` field, or a `password` or `googleAuthToken`, or that both `password` and `repeatPassword` exist (and match also?)

You can see how this works in the example in their documention: https://joi.dev/api/?v=17.2.1#example",,
718632595,188,type infer of schema.default() not optional automatically?,"![image](https://user-images.githubusercontent.com/33362998/95657702-80cd8400-0adb-11eb-91fd-cab5a52e4265.png)

> Equivalently you can express this using the built-in .default() method, available on all Zod schemas. The default value will be used if and only if the schema is undefined.

Should schema be optional when default is defined? ",,
716115754,184,catchall doesn't work in 2.0.0-beta.9,"The example for `.catchall` in the readme doesn't return the correct result:

```ts
> z.object({name: z.string()}).catchall(z.number()).parse({name: ""Foo"", validExtraKey: 61})
{ name: 'Foo' }
```

It should have returned:

```ts
{name: 'Foo', validExtraKey: 61}
```",,
714752834,182,z.string() satisfied with empty string in ^2.0.0-beta.9,"^2.0.0-beta.9

Tested with `z.string().parse("""")` as well.

I don't suppose this is the expected behaviour?",,
714600379,181,How to relate two object fields?,"What is the best way to relate two objects fields in a schema?

Ex: 

```ts
enum AnimalType {
  Cow,
  Cat,
}

const cowSchema = z.object({
  moo: z.string(),
});

const catSchema = z.object({
  meow: z.string(),
});

const animalSchema = z.object({
  animalType: z.nativeEnum(AnimalType),
  animalData: z.union([cowSchema, catSchema]),
});
```

I want to parse the object in a way that if the user sets the animalType to Cat, zod will parse animalData using the catSchema. Is it possible to do this without using the refine mehtod?",,
714034849,180,v2 beta: Type 'Shape' does not satisfy the constraint 'ZodRawShape',"When compiling with `zod@2.0.0-beta.9` on TypeScript `4.0.3`, I get this error:

```
node_modules/zod/lib/src/helpers/partialUtil.d.ts(11,39): error TS2344: Type 'Shape' does not satisfy the constraint 'ZodRawShape'.
node_modules/zod/lib/src/helpers/partialUtil.d.ts(11,94): error TS2344: Type '{ [k in keyof Shape]: DeepPartial<Shape[k]>; }' does not satisfy the constraint 'ZodRawShape'.
  Type 'DeepPartial<Shape[k]>' is not assignable to type 'ZodTypeAny'.
    Type '{ object: Shape[k] extends ZodObject<infer Shape, infer Params, ZodTypeAny, { [k in keyof addQuestionMarks<{ [k in keyof infer Shape]: infer Shape[k][""_output""]; }>]: addQuestionMarks<...>[k]; }, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }> ? ZodOptional<...> : never; rest: ReturnType<...>; }[S...' is not assignable to type 'ZodType<any, any, any>'.
      Type '{ object: Shape[k] extends ZodObject<infer Shape, infer Params, ZodTypeAny, { [k in keyof addQuestionMarks<{ [k in keyof infer Shape]: infer Shape[k][""_output""]; }>]: addQuestionMarks<...>[k]; }, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }> ? ZodOptional<...> : never; rest: ReturnType<...>; }[S...' is not assignable to type 'ZodType<any, any, any>'.
        Type '{ object: Shape[k] extends ZodObject<infer Shape, infer Params, ZodTypeAny, { [k in keyof addQuestionMarks<{ [k in keyof infer Shape]: infer Shape[k][""_output""]; }>]: addQuestionMarks<...>[k]; }, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }> ? ZodOptional<...> : never; rest: ReturnType<...>; }[S...' is not assignable to type 'ZodType<any, any, any>'.
          Type '{ object: Shape[k] extends ZodObject<infer Shape, infer Params, ZodTypeAny, { [k in keyof addQuestionMarks<{ [k in keyof infer Shape]: infer Shape[k][""_output""]; }>]: addQuestionMarks<...>[k]; }, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }> ? ZodOptional<...> : never; rest: ReturnType<...>; }[S...' is not assignable to type 'ZodType<any, any, any>'.
            Type '(Shape[k] extends ZodObject<infer Shape, infer Params, ZodTypeAny, { [k in keyof addQuestionMarks<{ [k in keyof infer Shape]: infer Shape[k][""_output""]; }>]: addQuestionMarks<{ [k in keyof infer Shape]: infer Shape[k][""_output""]; }>[k]; }, { [k in keyof addQuestionMarks<...>]: addQuestionMarks<...>[k]; }> ? ZodOptio...' is not assignable to type 'ZodType<any, any, any>'.
              Type 'ReturnType<Shape[k][""optional""]>' is not assignable to type 'ZodType<any, any, any>'.
                Type 'unknown' is not assignable to type 'ZodType<any, any, any>'.
                  Type 'ReturnType<Shape[keyof Shape][""optional""]>' is not assignable to type 'ZodType<any, any, any>'.
                    Type 'unknown' is not assignable to type 'ZodType<any, any, any>'.
                      Type 'ReturnType<Shape[string | number | symbol][""optional""]>' is not assignable to type 'ZodType<any, any, any>'.
                        Type 'unknown' is not assignable to type 'ZodType<any, any, any>'.
                          Type 'ReturnType<Shape[string][""optional""]> | ReturnType<Shape[number][""optional""]> | ReturnType<Shape[symbol][""optional""]>' is not assignable to type 'ZodType<any, any, any>'.
                            Type 'ReturnType<Shape[string][""optional""]>' is not assignable to type 'ZodType<any, any, any>'.
                              Type 'unknown' is not assignable to type 'ZodType<any, any, any>'.
node_modules/zod/lib/src/helpers/partialUtil.d.ts(12,45): error TS2344: Type 'Shape[k]' does not satisfy the constraint 'ZodTypeAny'.
  Type 'Shape[keyof Shape]' is not assignable to type 'ZodType<any, any, any>'.
    Type 'Shape[string] | Shape[number] | Shape[symbol]' is not assignable to type 'ZodType<any, any, any>'.
      Type 'Shape[string]' is not assignable to type 'ZodType<any, any, any>'.
```

- `zod@1.11.9` compiles fine
- When looking at `node_modules/zod/lib/src/helpers/partialUtil.d.ts(11,39)` I see red squiggles in VS Code. I suspect it could be a type error in the library.

My `tsconfig.json`:
```
{
  ""compilerOptions"": {
    ""module"": ""CommonJS"",
    ""target"": ""ES2019"",
    ""strict"": true,
    ""outDir"": ""dist"",
    ""esModuleInterop"": true
  },
  ""include"": [""src""]
}
```
",,
713224877,179,Failed async refinement causes other `issues` to not be returned,"When using the new `safeParseAsync` an async validation failure causes the `issues` array to only contain the async failure, the other errors are not included in the returned value.  Is this expected? The failing test is posted below.
```
import * as z from 'zod'

test('testing zod', () => {
  expect.assertions(2)
  const base = z.object({
    hello: z.string(),
    foo: z.number()
      .refine(async (data) => {
        return false
      }, {message: ""invalid""})
  })
  const result = base.safeParseAsync({hello: 3, foo: 3})

  return result.then(r => {
    expect(r.success).toBe(false)
    if (r.success === false) 
      expect(r.error.issues.length).toBe(2) // <--- `issues` has length of 1 here
  });
});
```",,
713070385,178,[Feature Request]: Ability to provide a message to types,"I am currently using Blitz.js which uses zod for validation on the server and on the client. Everything works perfectly exept one small thing. When I want to customize the error message ""Required"" that is thrown by z.string() or other similar functions, there is not a good way to to it. With min() i can just provide the message as a prop, for z.string() I either have to provide a custom ZodErrorMap or avoid using zod for this. Would it be possible to change the string method to exept a message prop like this?
```typescript
z.string({message: ""Email is a required field.""})
```
or
```typescript
z.string(""Email is a required field."")
```",,
711176436,177,[Request] Generate JSON schema out of a zod object,"@tonyxiao that's exactly what I am looking for because basically:
- all my backend services use `fastify` (rest framework like Express)
- each route has a JSON Validator built-in
- each backend service exposes its OpenAPI Spec thanks to these json schemas

So basically, I am looking at a Zod to JSON Schema helper to avoid having to double specify each type. Let me know if you find anything!

_Originally posted by @lazharichir in https://github.com/vriad/zod/issues/75#issuecomment-694865003_",,
710779966,176,"Type 'ZodTransformer<ZodAny, ZodBoolean>' is not assignable to type 'ZodTypeAny'","Is this error meant to be correct? If so I feel like I just missed something fundamental in how to use transforms.

I am using the transforms I created in [pip-types](https://github.com/bamboocreativenz/pip-types/blob/8918d7721383aaac5a39ea07b88077db244b4bdc/src/boolean.ts#L120), though in the new project I updated zod to `""zod"": ""^2.0.0-beta.9""` and can compile and run the tests.

The code: 

```
export const surveyRecordTransform = z.object({
  name: z.string(),
  archive: zToBoolean,
  ... (100 more such lines)
})
```

I would then use this:

```
const typedSurveyRecord = surveyRecord.parse(data)
```

And i get this error (from VSCode type checking)

```shell
(property) Archive: ZodTransformer<ZodAny, ZodBoolean>
Type 'ZodTransformer<ZodAny, ZodBoolean>' is not assignable to type 'ZodTypeAny'.
```

<details>
<summary>Rest of error :)</summary>

```
  Types of property 'parse' are incompatible.
    Type '(x: unknown, params?: ParseParams) => boolean' is not assignable to type '(x: unknown, params?: ParseParams) => any'.
      Types of parameters 'params' and 'params' are incompatible.
        Type 'import(""...node_modules/zod/lib/src/parser"").ParseParams' is not assignable to type 'import(""...node_modules/zod/lib/src/parser"").ParseParams'.
          Types of property 'seen' are incompatible.
            Type '{ schema: any; objects: { data: any; error?: any; times: number; }[]; }[]' is not assignable to type '{ schema: ZodType<any, ZodTypeDef, any>; objects: { input: any; error?: ZodError; output: any; }[]; }[]'.
              Type '{ schema: any; objects: { data: any; error?: any; times: number; }[]; }' is not assignable to type '{ schema: ZodType<any, ZodTypeDef, any>; objects: { input: any; error?: ZodError; output: any; }[]; }'.
                Types of property 'objects' are incompatible.
                  Type '{ data: any; error?: any; times: number; }[]' is not assignable to type '{ input: any; error?: ZodError; output: any; }[]'.
                    Type '{ data: any; error?: any; times: number; }' is missing the following properties from type '{ input: any; error?: ZodError; output: any; }': input, outputts(2322)
base.d.ts(29, 5): The expected type comes from this index signature.
```

</details>


I do realise that I am trying to compose my transform within another Zod object and thinking about this now I realise this may not have been how I am meant to use it.

ie make a bunch of coercion transforms and then use these in Zod Objects to then use on incoming Api data to both map and coerce the types and provide static typing for development... AND very LOUD errors should the coercion fail. #my-little-dream

",,
710608434,175,Generate an ESM bundle,"Hello! Would you be open to a pull request adding an ESM bundle? This would require roughly two changes:

1) add a build script `build:esm`, building the project using a slightly modified `tsconfig.json` and outputting to `dist/esm` (or similar).
2) add a `module` field to `package.json` pointing to `dist/esm/index.js`.

If you are keen I am happy to PR :)

Thanks for the library!",,
710435023,174,In V2 how to get `parseAsync` to collect errors for all fields?,"Firstly, thanks for this great lib! I'm wondering how to collect errors for all fields in the new `parseAsync` method?  It seems to stop collecting after the first error.
```
import * as z from 'zod'

const schema = z.object({
  username: z.string().nonempty(),
  password: z.string().nonempty(),
});

schema.parseAsync({username: '', password: ''})
  .then(() => {})
  .catch(e => {
    if (e.errors.length !== 2) {
      throw 'Expected two errors'
    }
  })
```",,
709969880,172,Support for Map and Set,"Currently it is not possible to validate data structures that use `Map`, `WeakMap`, `Set` or `WeakSet`. Is there any chance to support those types, similar to how `z.record` or `z.array` works.

For example:

```js
const myMapSchema = z.map(z.string(), z.number());
const mySetSchema = z.set(z.string());
```",,
709693710,170,"How to check if an object ""isZodSchema""?","Hey!

I am updating one package of mine, and it would always accept an object containing zod shapes, like

```ts
const zodShape = {
  value: zod.number()
}
function f<Z extends ZodRawShape>(zodShape: Z) {
  const schema = zod.object(zodShape)
}

```

I was doing it to prevent having to always write zod.object({...}), as I was using always objects.

However, now I want it to also accept stuff like a zod.number() without a wrapping object, but still being able to pass an object without the wrapping zod.object() (will be applied automatically by the function).

So, I need to check if the object is already a zod schema so I don't run z.object() on a it again.

Is there some kind of isZodSchema function?",,
709683215,169,[Discussion] Parsing input that's a superset of the schema type,"Given a zod schema like
```
const ZRecord = z.object({
    id: z.number(),
    name: z.string()
});
```
how can I use `ZRecord` to extract the schema from a conforming object that has additional fields? E.g.
```
const result = ZRecord.safeParse({ id: 123, name: ""Joe"", notes:""enjoys hiking"" });
```

Is there any option that I can pass to the parse methods (e.g. `ZRecord.safeParse`) that will ignore additional keys, but also mention them in the `result.error.errors` list? I was hoping that even when `result.success` was `false`, `result.data` would still have the parsed hierarchy. I don't see a way to do this other than iterating through the `ZAddEntryParams.shape` hierarchy and pulling the relevant attributes from the input into a new ""clipped"" object before parsing.

It would be valuable to extract the schema from a larger object for something like a web request, to give the API caller a message that they had extra keys in their request.",,
709295377,168,Usage in JavaScript,"Hi,

Can this library be used with pure JavaScript (no TypeScript)?

I read the documentation and despite the **strictNullChecks** requirement and types, it doesn't says can't be used with JavaScript.

I made a test here in a mixed JavaScript/TypeScript project without **strictNullChecks** and it worked.

I was thinking about using the library in a pure JavaScript project, so I would like to see your opinion and recommendations on the matter, possibly mentioning in the docs.

Thanks.",,
707778778,166,Zod 2 beta 5: applying transform() to arrays ,"Hi,

I'm trying to use `.transform()` on a string array to remove possible duplicates.
This is my schema:
```ts
DummyInput = z.object({
  pokemonTypes:
    z.array(string())
    .nonempty()
    .transform(cleanDuplicateStringsFromArray)
})
```
The function signature is `(array: string[]) => string[]`. Seems right - take an array of strings and transform it to itself.. although I get an error: 
```
TS2345: Argument of type '(array: string[]) => string[]' is not assignable to parameter of type '(arg: [string, ...string[]]) => string | Promise<string>'. Â Â Type 'string[]' is not assignable to type 'string | Promise<string>'. Â Â Â Â Type 'string[]' is not assignable to type 'string'.
```

Am I missing something here?",,
706227292,163,[Feature Request]: zod2 access to refinementData,"in zod2 there's no way anymore to access the refinementData.  

This can be very convenient when we want to reuse the info to display hints in the GUI (e.g. _The password must have between 5 and 10 characters_, ..)

We could simply add the refinement data as a property to the check function: e.g. in `base.ts`: 

```ts
refinement = (
    check: (arg: Output) => any,
    refinementData: MakeErrorData | ((arg: Output) => MakeErrorData),
  ) => {
    const augmentedCheck = (val, ctx) => {
      if (!check(val)) {
        ctx.addError(
          typeof refinementData === 'function'
            ? refinementData(val)
            : refinementData,
        );
      }
    };
    augmentedCheck.refinementData = refinementData;
    return this._refinement(augmentedCheck);
  };
```

Then we can simply loop over all `ZodTypeDef.checks` and check the `refinementData` property is set",,
706174705,162,[Discussion] zod2 - default() condition,"The current implementation replaces all falsy values to the default.   
I was surprised by this. I expected that only `undefined` is checked - but maye I'm just biased because I am used to Joi: [Joi.default()](https://joi.dev/api/?v=17.2.1#anydefaultvalue)

There are also cases where we don't want this.  
* a number may have a default of `5`, but `0` could also be a valid value
* and also `null` can sometimes be a valid value (different from the default)

The options that we have:  
1. `default()` could have a parameter to decide which to use
1. we could have 3 different functions: `defaultIfFalsy()`, `defaultIfUndefined()`, `defaultIfUndefinedOrNull()`
1. or just document in detail how `default()` function works and force the users of the lib to create custom transformers for the other cases
",,
706032122,161,Zod 2 beta 5: parse() adds optional fields with 'undefined' as a value,"Hi @vriad,

I've upgraded to Zod 2 beta and it works cool.

The first bug I've met now, is that if you send an object without certain optional fields, `.parse()` adds them with undefined value.

For instance, my schema looks like that (simplified):
```ts
export const SNamedEntity = z.object({
  _id: string().refine(validateUUID),
  name: z.string().max(100),
  createdAt: string().refine(validateDateString).optional(),
  updatedAt: string().refine(validateDateString).optional(),
  isActive: boolean().optional(),
});
```
And the object I send to it has only `_id` and `name`. However, when I set a breakpoint after I `.parse()` this object with the with the above schema, I see that all of the optional fields are present there now: 

```js
{ 
  _id: '5f6418f13b179e3da326a1aa',
  name: ""John Doe"",
  createdAt: undefined,
  updatedAt: undefined,
  isActive: undefined,
}
```

It freaks out Mongo, it thinks that I'm trying to overwrite its internal createdAt field with undefined and throws me an error.

Interestingly, if I send a valid date in createdAt field, mongo is totally allright with that (it ignores it as it should). Only `undefined` trips it :)
",,
705889473,160,[Question] How do I validate fields after calling .transform?,"Hi!
First of all, thanks for creating this great library. 
I'm giving `zod@beta` a try (more precisely, `v2.0.0-beta.5`), as I'm especially interested in the `transform` feature.

Now to the question. Let's assume I have the following object:

```ts
const query = {
  // note that the values below are strings, not numbers
  size: '10',
  offset: '20'
};
```

**What I want to do:**
 - convert the strings above to numbers
 - validate that these numbers are greater than 1

Is there a way of achieving this using a single schema and a combination`.min(1) and .transform()?`

Let's assume that the query object is constructed from an external source and I cannot change the values of the fields size or offset to be numbers.

 Unfortunately the code below won't work, as `.transform` returns a `ZodTransformer`
 which has no method called .min().

### Attempt 1 (does not work)

```ts
const schema = z.object({
  size: z.string()
    .transform(z.number(), Number)
    // unfortunately this won't work - as ZodTransformer does not have a method called .min()
    .min(1)
})
```

### Approach 2 (works with some downsides)

```ts
const schema = z.object({
  size: z.string()
    .refine(val => Number(val) > 0)
    .transform(z.number(), Number),
  offset: z.string()
    .refine(val => Number(val) > 0)
    .transform(z.number(), Number),
})
```

The approach above works, but there are a couple downsides:
  - I'm transforming a string to a number twice (one time inside `.refine` and one time inside `.transform`)
  - I can't leverage of the API returned by `z.number()` which is more elegant than refine and also returns more specific error codes.

This can probably also be solved by using two different schemas, but that would introduce a bit of duplication which I would like to avoid.

Is there a way of achieving what I want to do while using a syntax more similar to the first approach? 

Thanks in advance - happy to give more details if needed.",,
705215298,159,.safeParse() and generics,"Hi,

I have a quick question.

I want to wrap `safeParse()` into a utility method, that gets an `unknown` object, `ZodObject` and returns the parsed data if succeeded, like this:

```
export const shapeObject = (object: unknown, zodObject: AnyZodObject) => {
  const validationResult = zodObject.safeParse(object);
  if (validationResult.success) {
    return validationResult.data;
  } 
  
  return null;
}
```

The question is, what is the correct way to type such a method? Can I somehow use generics to know what will it return?

Thanks,",,
704910090,158,[Proposal] Attaching metadata to schema,"I am proposing to add `.meta()` method that allows attaching metadata to schema

## Proposed way it would work
Basic usage:
```ts
const schema = z.string().meta({ some: ""data"" })

schema.meta // => { some: ""data"" }
```
Multiple `.meta` calls would merge (shallowly) with previous metadata and overwrite repeated fields:
```ts
const schema = z.string()
  .meta({ foo: 1, bar: 2, nested: { prop: ""data"" }})
  .meta({ baz: 3, nested: { otherProp: ""data"" }})
  .meta({ foo: 4 })

schema.meta // => { foo: 4, bar: 2, baz: 3, nested: { otherProp: ""data"" }}
````
`.meta` would have following signature:
```ts
meta(metadata: Record<string, any>): this
```
## Use cases:
One of the uses cases i can think of is generating forms from schema. Imagine library that does that, more or less in following way:
```jsx
// from this schema
const schema = z.object({
  username: z.string(),
  age: z.number().min(18),  
})
// this is generated form:
<form>
  <input type=""text"" name=""username"" />
  <input type=""number"" name=""age"" />
</form>
```
Now, let's say we want to use certain component (assuming React here) for certain field. For example we want to use `FancyPhoneNumberField` component for `phone` field:
```jsx
// from this schema
const schema = z.object({
  username: z.string(),
  age: z.number().min(18),
  phone: z.string().meta({ formgenComponent: FancyPhoneNumberField })
})
// this is generated form:
<form>
  <input type=""text"" name=""username"" />
  <input type=""number"" name=""age"" />
  <FancyPhoneNumberField name=""phone"" />
</form>
```
_Of course library like this would probably add much more props but this is minimal version to understand use case_

There are probably many other cases where attaching metadata would be useful.

 I am willing to implement and document this if gets accepted
",,
703575635,157,default() function missing?,"The [docs](https://github.com/vriad/zod#default-values) mention that we can use `default()`:

> Equivalently you can express this using the built-in .default() method, available on all Zod schemas.
> 
> z.string().default('default value');

but that seems not to exist.  
e.g. `z.string().default('abc')` does not compile

My zod version `1.11.8`

Is it a bug or am I missing something?",,
701882808,153,Support parametrisable schemas,"It would be cool to be able to do something like this:

```ts
export type Foo<T> = {
  name: string
  value: T
}

const fooSchema = <T>(valueSchema: z.ZodSchema<T>): z.ZodSchema<Foo<T>> => z.object({
  name: z.string(),
  value: valueSchema
})
```

(In fact it would be even cooler to be able to use `z.infer` on the `ReturnType<typeof fooSchema>`, but TypeScript is not yet capable of this -- see https://github.com/microsoft/TypeScript/issues/40542)

The above code produces the following compile error, which I have to be honest, is beyond my understanding:
```
error TS2322: Type 'ZodObject<{ name: ZodString; value: ZodType<T, ZodTypeDef>; }, { strict: true; }, { [k in keyof ({ [k in undefined extends T ? ""value"" : never]?: { name: string; value: T; }[k] | undefined; } & { [k in Exclude<...> | Exclude<...>]: { ...; }[k]; })]: ({ [k in undefined extends T ? ""value"" : never]?: { ...; }[k] | und...' is not assignable to type 'ZodType<Foo<T>, ZodTypeDef>'.
  Types of property '_type' are incompatible.
    Type '{ [k in keyof ({ [k in undefined extends T ? ""value"" : never]?: { name: string; value: T; }[k] | undefined; } & { [k in Exclude<""name"", undefined extends T ? ""value"" : never> | Exclude<...>]: { ...; }[k]; })]: ({ [k in undefined extends T ? ""value"" : never]?: { ...; }[k] | undefined; } & { [k in Exclude<...> | Exclu...' is missing the following properties from type 'Foo<T>': name, value

45 const fooSchema = <T>(valueSchema: z.ZodSchema<T>): z.ZodSchema<Foo<T>> => z.object({
                                                                              ~~~~~~~~~~
46   name: z.string(),
   ~~~~~~~~~~~~~~~~~~~
47   value: valueSchema
   ~~~~~~~~~~~~~~~~~~~~
48 })
   ~~
```",,
701880273,152,Specific Optional Type,"I was just playing around with various things, and I noticed optional-ness is reapplied to things depending on how you write it, for example if I write it this way (see below), `message` is ""double optional"" since that is what the code says it is. But double optional doesn't have any meaning - so it can be flattened.

so i have this union which makes sense given the code below

`    message: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodUndefined]>, z.ZodUndefined]>;`

can it become:  `    message: z.ZodUnion<[z.ZodString, z.ZodUndefined]>;`

Optional is not just a union with undefined though, it also includes ""missing"" / ""not there at all"". So there seems to be something that is not being captured currently.

Unions also seem to be a weak point in the error messaging which is otherwise top notch. Having a specific optional - lets you give the error message for the optional type instead of the union which i think is a pretty big deal.

Right now all unions (so all optionals) give the same error:

```
[Error: 1 validation issue(s)

     Issue #0: invalid_union at message
     Invalid input
   ]
```
vs a non-optional of the same

```
[Error: 1 validation issue(s)

     Issue #0: invalid_type at message
     Expected string, received number
   ]
```

This difference only make sense if you know that optional was being represented by a union with undefined in which we no longer know which option in the union is our type.

Code i was experimenting with is below for reference

```ts
const ErrorBase = z
    .object({
        message: z.string(),
        stack: z.string(),
    })
    .partial();

export const ErrorType = ErrorBase.extend({
    name: z.string(),
    code: z.number(),
    context: z.record(z.any()),
    cause: ErrorBase,
}).partial();
```

",,
701055192,151,Combine min() and optional(),"It would be helpful if you could combine min() and optional().

Let's say you have a password field that can either be filled out with at least 6 characters or not at all.

The straightforward solution doesn't work unfortunately since I also get an error when the field is not filled out.
```js
const userUpdateSchema = z.object({
  password: z.string().min(6).optional(),
});
```

Can this be implemented?

",,
700825040,150,Error message formatting,"Currently, the error message is generated with `./index` as a separator when joining the path segments of an error, making the message quite difficult to read (especially when you have many path segments).

`[0, 'status']` gives: `Issue #1: invalid_enum_value at 0./indexstatus`

I feel this should either be `/` or `, `, or is there a specific reason for this? It looks like part of an import path, so maybe some editor shenanigans?",,
700711451,149,Optional support for tuples,"I have tried everything I can think of - however something is preventing me from writing a function type for variable number of parameters.

I can very easily write a tuple in typescript that support a variable number of elements

```ts
    type OneOrTwo = readonly [number, Record<string, string>?] 

    const one: OneOrTwo = [1] as const;
    const likeOne: OneOrTwo = [1, undefined] as const
    const two: OneOrTwo = [1, {}] as const;
```

However I cannot figure out how to do the same with zod.

```ts
const contract = {
    parms1: z.tuple([z.number()]),
    parms2: z.tuple([z.number(), z.record(z.any()).optional()]),
    ret: z.string(),
};

const p2 = z.tuple([z.number(), z.record(z.any()).optional()]) 
const u = z.union(contract.parms1, contract.parms2); // type error

p2.parse([1] as const) // too_small
u.parse([1] as const) //  invalid_union
```

It appears that it is not supported - what is involved in supporting it?

Note that since my use case is function schemas - i need to support:

```
[1]
[1, {}]
[1, undefined]
```",,
699504391,148,"Pass context to parse methods, to use it in refinements","Hello,

I'm using Zod in the backend, and GraphQL.

I have the following code:

```typescript
// zod schema
const CREATE_SCHEMA = z.object({
  cliente: z.number()
  // other properties...
});

// GraphQL resolver
const resolver: Resolvers = {
  Mutation: {
    createChequeDevolvido: (parent, { input }, context) => {
      CREATE_SCHEMA.safeParse(input);
      // persist validated input in database...
    }
  }
};
```

The `cliente` property is an id to the table `cliente`, and I want to validate if it exists.

So it would look like this (using Objection.js):

```typescript
// zod schema
const CREATE_SCHEMA = z.object({
  cliente: z.number().refine(async arg => Cliente.query().where(""id"", arg).first(), {
    message: ""Cliente nÃ£o existe no banco de dados.""
  });
  // other properties...
});
```

But I need to add the `tenant` key to that query, but the `tenant` key is only avaliable in the `context` argument within the GraphQL resolver.

In Joi, you can pass a `context` property in the `validate` methods. This `context`is a bag of values to be used in the validation schemas.

By having something like that in Zod, we pass a `context` option in the `parse` methods, and this `context`is avaliable as a parameter in the `refine`method, and other places if necessary.

I think that would solve my problem. Something like this:

```typescript
// zod schema
const CREATE_SCHEMA = z.object({
  cliente: z.number().refine(async (arg, context) => Cliente.query()
      .where(""id"", arg)
      .where(""tenant"", context.tenant)
      .first(), {
    message: ""Cliente nÃ£o existe no banco de dados.""
  });
  // other properties...
});

// GraphQL resolver
const resolver: Resolvers = {
  Mutation: {
    createChequeDevolvido: (parent, { input }, context) => {
      CREATE_SCHEMA.safeParse(input, {
        context: {
          tenant: context.tenant // the context here is the GraphQL context
        }
      });
      // persist validated input in database...
    }
  }
};
```

In short, this would add the possibility of using external, runtime values in validations.

What do you think?

Sorry if this was in docs or in another issue, but I couldn't find it.

Thanks.

",,
699445231,147,Merge not supported by union types,"I saw that `z.intersection` is being deprecated in favor of `merge`, but the later does not yet support `union` types.

```ts
const Type1Sub1 = z.object({
    foo: z.string()
});

const Type1Sub2 = z.object({
    baz: z.string()
});

const Type1 = z.union([ Type1Sub1, Type1Sub2 ]);

const Type2 = z.object({
    foo: z.number(),
    baz: z.number()
});

const MergeType1 = Type1.merge(Type2); // does not work
const MergeType2 = Type2.merge(Type1); // does not work

const IntersectionType1 = z.intersection(Type1, Type2); // works: (Type1Sub1 & Type2) | (Type1Sub2 & Type2)
const IntersectionType2 = z.intersection(Type2, Type1); // works: (Type2 & Type1Sub1) | (Type2 & Type1Sub2)

```


edit: updated with objects, primitives don't make much sense here",,
697273255,146,bi-directional virtuals population issue,"Hi,

Thanks for your work - Typegoose makes life with Mongo and Typescript a breeze :)

I have a strange issue (probably, because I'm trying to do a strange thing).
In my use case, Users can follow each other, and these relations contain additional properties - so I moved them to the separate model Followship. 

Followship has `followerId` and `followeeId` (both IDs of Users) to define the relation. What I want is an ability to pull the Followships separately and populate Users in them, and also an ability to pull Users with their Followships populated.

So here is how my models look:

User:
```typescript
@modelOptions({
  schemaOptions: {
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
  }
})
export class User {

  @prop({ required: true })
  public name!: string;

  @prop({unique: true})
  public email!: string;

  @prop()
  public password!: string;

  // 
  @prop({
    ref: Followship,
    type: Followship,
    localField: '_id',
    foreignField: 'followeeId',
    justOne: false
  })
  public followers?: Ref<Followship>[];

  @prop({
    ref: Followship,
    type: Followship,
    localField: '_id',
    foreignField: 'followerId',
    justOne: false
  })
  public followees?: Ref<Followship>[];

  public static getById(this: ReturnModelType<typeof User>,
                        id: string
  ): Promise<DocumentType<User> | null> {
    return this.findById(id)
      .select('name email address')
      .populate('followees')
      .populate('followers')
      .exec();
  }
}
```

Followship:
```typescript
@modelOptions({
  schemaOptions: {
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
  }
})
export class Followship {
  @prop({ required: true })
  followerId!: ObjectID;

  @prop({ required: true })
  followeeId!: ObjectID;

  @prop({
    ref: User,
    localField: ""followerId"",
    foreignField: ""_id"",
    justOne: true
  })
  public follower?: Ref<User>;

  @prop({
    ref: User,
    localField: ""followeeId"",
    foreignField: ""_id"",
    justOne: true
  })
  public followee?: Ref<User>;

  @prop()
  seeFirst!: boolean;

  public static getFollowersOfUser(this: ReturnModelType<typeof Followship>,
                                   userId: string
  ): Promise<DocumentType<Followship>[]> {
    return this.find({ followeeId: userId })
      .populate({ path: ""follower"" })
      .exec();
  }
}
```

The issue is the following:
When I call `User.getById()`, I get the User object correctly populated with followers and followees (is there a better term for it in English btw?). But when I call `Followship.getFollowersOfUser()`, I get the array of Followships - with `follower: null`.
Debug mode shows, that `Followship.getFollowersOfUser()` tries to find the User ids in the Followship collection, and obviously fails:
```
Mongoose: followships.find({ followeeId: ObjectId(""5f5836e2de810118a26bddba"") }, { projection: {} })
Mongoose: followships.find({ _id: { '$in': [ ObjectId(""5f56808196a0b238cf32fcff"") ] } }, { skip: undefined, limit: undefined, perDocumentLimit: undefined, projection: {} })
```

The thing is, that if I remove the virtual fields from User model, `Followship.getFollowersOfUser()` returns just fine:
```
Mongoose: followships.find({ followeeId: ObjectId(""5f5836e2de810118a26bddba"") }, { projection: {} })
Mongoose: users.find({ _id: { '$in': [ ObjectId(""5f56808196a0b238cf32fcff"") ] } }, { skip: undefined, limit: undefined, perDocumentLimit: undefined, projection: {} })
```

Am I doing something wrong, or is there a workaround for this? Except using only the User's virtuals",,
696814704,145,valid object fails to be parsed when using z.intersection,"I tried following the intersection example in your README:

```typescript
const HasId = z.object({
    id: z.string(),
});
  
const BaseTeacher = z.object({
    name: z.string(),
});
  
const Teacher = z.intersection(BaseTeacher, HasId);

type Teacher = z.infer<typeof Teacher>;

const t: Teacher = { // compiles ok
    id: '123',
    name: 'hello'
};

Teacher.parse(t); // => throws
console.log('ok');
```
prints the following:
```
2 validation issue(s)

  Issue #0: unrecognized_keys at
  Unrecognized key(s) in object: 'id'

  Issue #1: unrecognized_keys at
  Unrecognized key(s) in object: 'name'
```

if I replace the `Teacher` zod definition with:
```typescript
const Teacher = z.object({
    id: z.string(),
    name: z.string()
});
```
then the object is validated ok.

Am I doing something wrong ? I'm using the latest 1.11.5 version on TS 4.0.2",,
692428224,142,Some questions,"Hello,

I'm giving a try of your lib in my project, and it looks quite nice.

I have some questions, sorry if this is not the best place to do it, but I didn't find a tag in stackoverflow...

1 - Can I use this lib in the backend and frontend, or just in one of two?

2 - I'm trying to do the following rule:
The **bank** property (an object) of an object (a React form) is required.
But I don't care about **bank** properties, just if it is informed (not undefined) or not, because it comes from an autocomplete component.

I'm doing like this:

```typescript
z.object({
  bank: z
    .object({
      id: z.union([z.number(), z.string()])
    })
.nonstrict(),
```

Is this the best way?

3 - How to extend this lib with custom methods?
For example, a string validation method to validate CPF (a SSN like number in my country).
I did a refine and it worked well, but I'm thinking about extending the schema, like this:

```typescript
z.string().cpf()
```

Can I just reexport zod with my custom methods like this:

```typescript
const CustomZod = {
  string: () =>
    z.string().refine(
      arg => validateCPF(arg),
      { message: ""CPF invÃ¡lido"" }
    )
};
```

Is this the best way?

4 - I'm using Formik, and in Formik the validation function receives an object of values and must return an object with the error messages, one message for each key. I'm doing like this:

```typescript
const validateZod = (values: unknown): object => {
    const parsingResult = props.validationSchema.safeParse(values);

    if (parsingResult.success) {
      return {};
    }

    const flattenedErrors = parsingResult.error.flatten();

    const errors = {};

    for (const [key, value] of Object.entries(flattenedErrors.fieldErrors)) {
      errors[key] = value[0];
    }

    return errors;
  };
```

Is this the best way?

5 - I want to add a functionality to add asterisks to required fields in Formik.
So basically I would need to read the Zod schema passed to form, and check what fields of schema are required to put the asterisk.
Basically a reverse engineering of sorts.
How can I do that with Zod?

Thanks a lot.",,
691829186,140,[Request] Support for nested pick masks,"First of all, thank you @vriad for your passion for addressing code/API quality problems.

Speaking of subject, let's say we have complex nested schema. For particular function we want to select the only fields we care about:

```typescript
const LocalPizzaClient = User.pick({
  firstName: true,
  contactInfo: {
    phoneNumber: true,
  },
  address: {
    street: true,
    building: true,
  }
});
```

Would it possible be to extend `.pick(...)` function to support nested masks? As an option, the extended mask notation also may not care of whether the nested field is object or array of objects.",,
690117515,138,[Question] What is the recommended approach to attach metadata?,"Note: this is related to #76 which was closed.

So basically we need to attach some arbitrary metadata. The zod definitions and the meta-data should then be used to create an [Open API specification](https://swagger.io/docs/specification/about/).

I do **not** want to support a second tree of objects just for some metadata (note, that the data can be deeply nested) - as explained by @ivan-kleshnin [here](https://github.com/vriad/zod/issues/76#issuecomment-667862512)

The nasty workaround that I use now is to add a dummy refinement (the check-function always returns `true`) that stores our custom meta-info in the `params`.

",,
690082890,135,use default name for jest config,"**Current behavior**
When we clone the repo and start the jest tests in an IDE (e.g. IntelliJ) the test runner fails, because it cannot find the jest-config file.
![2020-09-01_13h45_42](https://user-images.githubusercontent.com/20422904/91848882-70fc8d80-ec5b-11ea-880d-580c0bf43983.png)

**Expected behavior**
Starting the jest test directly from the IDE (IntelliJ) should work without further config.

**What is the motivation / use case for changing the behavior?**
It took me quite long to find out why this does not work.

As a workaround we would need to edit all run-configs and add an explicit `--config` parameter which is tedious.

I suggest, to rename the current `jestconfig.json` config file to the default config file name `jest.config.js` (see [jest-docs](https://jestjs.io/docs/en/configuration)), then this is much easier to use.",,
690078215,134,array.nonempty().max() does not work,"
```ts
const nonEmptyMax = z
  .string()
  .array()
  .nonempty()
  .max(2);

nonEmptyMax.parse(['a']);
```
fails with:
```
Issue #0: too_big at 
  Should have at most 2 items
```

the check function of `ZodNonEmptyArray.max()` is wrong
```ts
check: data => data.length >= maxLength,
```
should be `<=`:
```ts
check: data => data.length <= maxLength,
```
",,
689780447,133,Use nonstrict with unknown instead of any,"Currently when `.nonstrict()` is used, `[k: string]: any` appears on the inferred type. Is it possible to use `[k: string]: unknown` instead? The problem of using `any` is that TypeScript allows you to do anything on any property. If you have a typo on the property name, an unexpected `undefined` will appear at runtime. If `unknown` is used, at least TypeScript can report an error when you try to use it or assign it to a different variable.

This feature request is similar to https://github.com/vriad/zod/issues/104. I am not sure if this issue will be considered a duplicate of it, but I think `.nonstrict()` will be much safer to use if it uses `unknown` instead of `any` by default.",,
689503574,131,z.number not working properly when used with z.record,"I basically have a data structure called rawNcdcConfig which is a record made up of rawServices. Within a rawService, I want a required number field called port.

Example:

```typescript
const rawServiceSchema = z.object({
  configPath: z.string(),
  port: z.number().positive(),
  realApi: z.string().url(),
  rateLimit: z.number().positive().optional(),
})
const rawNcdcConfigSchema = z.record(rawServiceSchema)

const rawDataToParse = {
  Config1: {
    configPath: './my-file.yml',
    port: 5001,
    realApi: 'http://example.com',
  },
  Config2: {
    configPath: './my-file.yml',
    port: 5002,
    realApi: 'http://example.com',
  },
  // this one is missing a port so I expect a validation error to be thrown
  'Another Config': {
    configPath: './my-file.yml',
    realApi: 'http://example.com',
  },
}

const parsedData = rawNcdcConfigSchema.parse(rawDataToParse)
console.dir(parsedData)
```

Output:
![image](https://user-images.githubusercontent.com/20561445/91768039-f12be000-ebd4-11ea-85b6-a9195b43cd2a.png)

If I parse the ""Another Config"" object directly using the `rawServiceSchema`, it throws as expected:

```typescript
const parsedData = rawServiceSchema.parse(rawDataToParse['Another Config'])
console.dir(parsedData)
```

Output: 
![image](https://user-images.githubusercontent.com/20561445/91768331-5a135800-ebd5-11ea-8179-c61ec60ea0e7.png)

Is this a bug or am I doing something wrong?",,
689094538,130,IE11 support,"Hi!

Which browsers are officially supported by zod? 
Is it possible to add ie11 support? now zod breaks because it needs `Array.prototype.find`
https://github.com/vriad/zod/blob/d1ae8e3538167a41e13ab6cfc2466ef3ca69e63a/src/parser.ts#L92",,
688617855,129,Path is not being appended from `.refine` to custom `errorMap`,"Hello

It looks like there is a problem with custom validation with `refine` method when the provided `path` elements are not being appended to the resulting path within a custom error map function.

I figured that it would be easier to demonstrate the issue with a screenshot and a [live demo](https://codesandbox.io/s/zod-path-error-map-demo-wpiob).

So on line `6` we have a custom validation that specifies additional path elements on validation failure.
On line `16` we print the passed `path` value to the console which is expected to be `[""items"", ""items-too-few""]` but we get `[""items""]`
In addition on line `37` we display the `ZodError` errors array which has the correct (expected) path elements.

![image](https://user-images.githubusercontent.com/85254/91647289-d84eed80-ea61-11ea-9183-ae611881ec53.png)

Also, it looks like the error map function is not being called at all if the `refine` params object specifies `message` property, but that is a separate issue, let me know if I should open another one.

Thank you for the great library


",,
686234257,128,parse() not picking up repetitions of the same error in an Array type,"Hey there,

Big fan of this library's simplicity and flexibility. One thing I have noted however, is that `parse()` under-reports errors in an array, for items with the same key. Given the following code:

```
  const Shape = array(
    object({
      name: string().nonempty(),
      value: string().nonempty(),
    })
  );

  const data = [
    {
      name: ""Name 1"",
      value: ""Value"",
    },
    {
      name: """",
      value: ""Value"",
    },
    {
      name: """",
      value: """",
    },
  ];

  try {
    Shape.parse(data);
  } catch (e) {
    if (e instanceof ZodError) {
      console.log(e.errors);
    }
  }
```

I would expect three `too_small` errors to occur - on `data[1].name`, `data[2].name` and `data[2].value`. However, only two errors are reported:

```
[
  {
    ""code"": ""too_small"",
    ""minimum"": 1,
    ""type"": ""string"",
    ""inclusive"": true,
    ""path"": [
      1,
      ""name""
    ],
    ""message"": ""Should be at least 1 characters""
  },
  {
    ""code"": ""too_small"",
    ""minimum"": 1,
    ""type"": ""string"",
    ""inclusive"": true,
    ""path"": [
      2,
      ""value""
    ],
    ""message"": ""Should be at least 1 characters""
  }
]
```

Using Zod v 1.10.3.

I am not sure if this is a bug, or a feature - if it's the latter it isn't documented anywhere. It's clear from the above that `data[2]` is getting validated as `value` is being reported, but something is swallowing the error for its `name`.

My use-case btw is validating form data, and I have repeated rows of the same object shape, so having the error highlighted on every instance is the desired outcome.

If there is either a fix, or a workaround for this, that'd be very much appreciated. Thanks.",,
685354845,127,Failed to validate union objects,"First of all: thanks for great contribution to this package, it's really awesome.

However, I ran into an issue when I try to validate a union of objects, which simply looks like this:

```js
const extensions = z.object({
  name: z.string(),
})

const dog = z.object({
  extensions
});

const cat = z.object({
  extensions
});

const animal = z.union([dog, cat]);

// it should output type error because name is ought to be type of string
const validateResult = animal.parse({ extensions: { name: 123 } });  
```
**And I expected the `validateResult` to contain errors but instead it didn't.**

And when I changed the code to:

```diff
- const extensions = z.object({
-   name: z.string(),
- })

const dog = z.object(
-  extensions
+  extensions: z.object({
+    name: z.string(),
+  })
});

const cat = z.object({
-  extensions
+  extensions: z.object({
+    name: z.string(),
+  })
});

const animal = z.union([dog, cat]);

// it should output type error because name is ought to be type of string
const validateResult = animal.parse({ extensions: { name: 123 } });  
```
**It surprisingly worked!!**

Really need your help. Appreciate it!",,
685184782,126,"Support for date, time and date-time format strings","Currently, Zod is lacking support for validating date, time and date-time stamps. As a result, users may need to implement custom validation via [`.refine`](https://github.com/vriad/zod#custom-validation). But the use case for date/time/date-time is very common, so if Zod ships it out-of-the-box like it does for `uuid`, `email`, etc, it would be helpful.

- Stemmed from https://github.com/vriad/zod/issues/30#issuecomment-679383286
- AJV's in-built regexes are [here](https://github.com/ajv-validator/ajv/blob/master/lib/compile/formats.js#L37) for reference.",,
682619019,125,ZodUnion didn't import when using babel-jest,"I get an error when accessing nullable method when using babel-jest. I've discovered that the error is due to the ZodUnion file not being imported correctly.

TypeError: Cannot read property 'create' of undefined at ZodNumber.ZodType.nullable (node_modules/zod/src/types/base.ts:114:62)

if i use explicit imports, imports will work fine.

I created PR: https://github.com/vriad/zod/pull/124",,
682227695,123,Strip unknown keys from object schemas by default,"Hi!

First of all, looks like a great job you did with this library. Looks very clean and developer friendly, and has some features I'm missing from io-ts.
Actually, I extended io-ts with some of them your library offers out of the box, but before I would jumping into and trying whether your library would work in my project, I'd like to ask something in advance to see if I could achieve it with it:
**Is there a way to 'export' a structure (object) that way Zod would delete the keys that are masked out (with `omit`)?**

The use case: I'd like to use Zod to serialize ('export') and unserialize (parse) custom structures (actually React component states, but could happen for multiple other use cases). But sometimes, there are data in the component state which is needed for runtime, but not needed (and I don't want) to serialize/unserialize.

At unserialization, masking is OK, it will ignore the not needed ones if I create a new 'masked' type.
But at serialization... I have the full data structure, and if I serialize it, it would contain all, even masked data as well. That's what I don't want.

An example based on a doc example:

```
const Recipe = z.object({
  id: z.string(),
  name: z.string(),
  ingredients: z.array(z.string()),
});

const NoIDRecipe = Recipe.omit({ id: true });
type NoIDRecipe = z.infer<typeof NoIDRecipe>;

const data: Recipe = { id: 1, name: 'test', ingredients: ['x', 'y', 'z'] };

const serializable = NoIDRecipe.<serialize/export/clean?>(data);
```

Here, I'd like to make a copy of the 'data' variable, but with the NoIDRecipe schema, and in the copy (serializable) structure I want the 'id' keys to be removed, based on the schema (as NoIDRecipe doesn't contain it).
Is it possible somehow?

",,
681256176,121,Inferring all object properties as optional,"I have this problem recently, I have this schema
`const ArticleData = z.object({
  title: z.string(),
  date: z.string(),
  tags: z.array(z.string())
});`
But if I check what's the type of it is inferred, I get something like this.
![image](https://user-images.githubusercontent.com/47081011/90552849-bcab3380-e193-11ea-89ee-552bd1e9f953.png)
So in the end parse method gives me this thing:
![image](https://user-images.githubusercontent.com/47081011/90552900-d2205d80-e193-11ea-9691-3f1d86f56791.png)
My version of zod is ""^1.10.3"".

",,
680656579,120,Too strict url check,"The following URL fails the validation:

```
http://nautil.us/issue/88/love--sex/the-hard-problem-of-breakfast
```

However, the same URL is accepted without any issue by the URL class:

```js
> new URL('http://nautil.us//issue/88/love--sex/the-hard-problem-of-breakfast').toString()
'http://nautil.us//issue/88/love--sex/the-hard-problem-of-breakfast'
```

I'm not familiar with the intricacies of validating URLs, so this might be a non-issue. But I thought about reporting it since I can use the URL just fine.

Using zod 1.10.1",,
680569819,119,ZodErrorCode not importing correctly,"I get an error when accessing string methods when using React Native with Expo. I've discovered that the error is due to the ZodError file not being imported correctly.

`TypeError: undefined is not an object (evaluating '__1.ZodErrorCode.invalid_string')`

The import is currently `import { ZodErrorCode } from '..'` at zod/src/types/string.ts.

Changing it to `import { ZodErrorCode } from '../ZodError'` fixes the issue.

This works fine in other environments, maybe the babel config that Expo uses is messing things up.",,
679745918,118,Export InvalidUnionError type,"I am currently making a utility function for a use case to specially handle union errors. The error object is a bit nested in my situation so feeling the need for that. **Can `InvalidUnionError` be exported as a type from the library?** Otherwise finding it a bit difficult to deal with it in TS.

For instance, I have:

```ts
function findUnionError(zodError: zod.ZodError): ZodSuberror | undefined {
  return zodError.errors.find(err => {
    return err.code === zod.ZodErrorCode.invalid_union;
  })
}
```

It will be great if I can do:

```ts
function findUnionError(zodError: zod.ZodError): InvalidUnionError | undefined {
  return zodError.errors.find((err) => {
    return err.code === zod.ZodErrorCode.invalid_union;
  }) as InvalidUnionError | undefined;
}
```

Because later I need to access the `.unionErrors` property and can't do it:

![image](https://user-images.githubusercontent.com/25290212/90334191-8467f180-dfe9-11ea-8757-703c98dbfb83.png)

I am again needing to do:

```ts
function something(err: zod.ZodError): void {
  const errorItem = findUnionError(err);
  if (errorItem !== undefined && errorItem.code === zod.ZodErrorCode.invalid_union) {
    // do something with errorItem.unionErrors
    errorItem.unionErrors
  }
}
```

which feels like a little extra steps.",,
679555973,117,Detailed errors for union schema,"I'd like to have more information or even TS-like details for union errors (Add a flag to parse?):

My types:
```
export const T = z.union([
  A, B, C
])
```
So what I currently get from this is:
```
     Error: 1 validation issue(s)

  Issue #0: invalid_union at 
  Invalid input
```
What I'd like to get is something more similar to this:

```
'{ t: 1 }' is not assignable to parameter of type '{ a: number } | { b: number }'
```

Is this sensible|doable|easy|hard?",,
676335106,116,type with fixed values,"is there a way to convert a typescript type with fixed values to a zod schema? 

some components from external libraries contain props with  types like below:
```js
type AcceptedValues = 1|2|3|4|5|6|7|8|9|10|11|12;
```

I would like to validate data so I can pass it to the component.
Here is what I tried:
```js 
type AcceptedValues = 1|2|3|4|5|6|7|8|9|10|11|12;
const mynumber = zodNumber().positive().min(1).max(12);

export const validateNumber = (data: unknown): AcceptedValues => { 
	try {
		return mynumber.parse(data);
	} catch (error) {
		if (error instanceof ZodError) {
			console.log(error.errors);
		}
	}
	return 12;
};
```
The error of the first return in validateNumber: `Type 'number' is not assignable to type 'AcceptedValues'.`


",,
676109790,115,"Custom refine path should override, not extend","In the absence of proper async validation my current approach can be described as such.

1) I'm adding new fields in the form (one per async action)
2) I'm filling those fields asynchronously on change and on submit
3) I'm validating the form synchronously after 2)

```js
import * as Z from ""zod""

let schema = Z.object({
  fromAccount: Z.object().nonstrict(), // dynamically loading select field
  toAccount: Z.object().nonstrict(), // dynamically loading select field
  relationsAreUnique: Z.boolean().refine(Boolean, {
    message: ""Testimonial was already given"",
    path: [""toAccount""],
  })
})

...
schema.parse({
  fromAccount: {id: ""1""},
  toAccount: {id: ""2""},
  relationsAreUnique: await isAccountAccountPairUnique({fromAccount: ""1"", toAccount: ""2""})
})
```

It kinda works. The problem is that `path` option for `relationsAreUnique` does not produce `[""toAccount""]`  path.
It actually produces `[""relationsAreUnique"", ""toAccount""]`. So I can't straightforwardly use it in the form rendering layer.

Maybe such hacks will disappear in newer Zod. But we aren't there yet. 
Intuitively, I expected `path` to be a full path (since it's an array).",,
676101548,114,Custom messages for type validations,"I want to translate form messages. 

```
...
  toAccount: Z.object({message: ""Gimme object!""}),
```

^ `message` is unused and the result (for e.g. `null`) is default:

```
Expected object, received null
```

In [the sources](https://github.com/vriad/zod/blob/master/src/types/boolean.ts) I see that custom messages are not supported for basic type parsing/validation like `boolean`, etc. 
But they should be (for I18n at the very least).",,
674198996,112,Validation of unions containing merged objects failing,"First of all: i really like this package (especially because of the typescript type integration)

However, I ran into an issue where i was validating a union of objects, which were based on the same `base` object. This object had some properties defined and the validation of those properties doesn't work correctly.

Given the following code:
``` ts
const base = z.object({
  id: z.string(),
});

const type1 = base.merge(
  z.object({
    type: z.literal(""type1""),
  })
);
const type2 = base.merge(
  z.object({
    type: z.literal(""type2""),
  })
);

const union1 = z.union([type1, type2]);
const union2 = z.union([type2, type1]);

const value1 = {
  type: ""type1"",
};

const value2 = {
  type: ""type2"",
};

console.log(""value1"", value1);
console.table([
  [""type1 directly"", type1.check(value1)],
  [""z.union([type1, type2])"", union1.check(value1)],
  [""z.union([type2, type1])"", union2.check(value1)],
]);

console.log(""value2"", value2);
console.table([
  [""type2 directly"", type2.check(value2)],
  [""z.union([type1, type2])"", union1.check(value2)],
  [""z.union([type2, type1])"", union2.check(value2)],
]);
```
In the example objects above, the `id` props is left out completely

You get the following output:
``` sh
  console.log
    value1 { type: 'type1' }

  console.log
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ (index) â”‚             0             â”‚   1   â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚    0    â”‚     'type1 directly'      â”‚ false â”‚
    â”‚    1    â”‚ 'z.union([type1, type2])' â”‚ false â”‚
    â”‚    2    â”‚ 'z.union([type2, type1])' â”‚ true  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜

  console.log
    value2 { type: 'type2' }

  console.log
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ (index) â”‚             0             â”‚   1   â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚    0    â”‚     'type2 directly'      â”‚ false â”‚
    â”‚    1    â”‚ 'z.union([type1, type2])' â”‚ true  â”‚
    â”‚    2    â”‚ 'z.union([type2, type1])' â”‚ false â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
```

The first line in the table shows the expected result (false) but as you can see the unions aren't consistent in their result.

If i pass in an object where type is set to something that doesn't match any of the allowed values then validation works correctly. This means that check will return `false` no matter which order the `z.objects` are passed to `z.union`",,
672727863,110,Typings not compatible with TS 3.8,"When using zod, typescript check will throw an error:

```
/node_modules/zod/lib/src/index.d.ts(42,418): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/index.d.ts(42,1044): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/index.d.ts(42,1590): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/index.d.ts(42,2216): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/index.d.ts(64,422): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/index.d.ts(64,1048): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/index.d.ts(64,1594): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/index.d.ts(64,2220): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T>]: NoNever<T>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(49,312): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(49,776): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(49,1154): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(49,1618): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(52,312): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(52,776): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(52,1154): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
/node_modules/zod/lib/src/types/object.d.ts(52,1618): error TS2536: Type 'k' cannot be used to index type '{ [k in keyof NoNever<T_1>]: NoNever<T_1>[k][""_type""]; }'.
```

- Typescript: `3.8.3`
- Zod: `1.10.1`",,
671951533,109,Yup's validateAt method analogy?,"Is there an analogy or an alternative to `validateAt` method of Yup: https://github.com/jquense/yup#mixedvalidateatpath-string-value-any-options-object-promiseany-validationerror

It's useful to skip unnecessary validations when someone's validate at `onChange` events.
You want to validate only a SINGLE field, not an entire form/scheme. 

Another related method is `reach`: https://github.com/jquense/yup#yupreachschema-schema-path-string-value-object-context-object-schema  I use it to extract meta-data from the scheme (see https://github.com/vriad/zod/issues/76)",,
670440394,106,RFC: Make object schemas nonstrict by default,"Zod's policy of disallowing any unknown keys by default is confusing and probably not worth it. It also makes the inferred types incorrect:

```ts
const A = z.object({
  a: z.string(),
});

const B = z.object({
  b: z.string(),
});

const AB = z.intersection(A, B);


type AB = z.infer<typeof Teacher>;
// { a: string; b: string };
```
The actual inferred type here should be never because no data will properly pass validation.

If anyone has a reason why object schemas **should** be strict by default, speak now!
",,
669636020,105,Generic for parsing objects,"Really enjoy the library! Thank you for the work!

To easier debug when a parse fails, I made a small wrapper like this:
```
function parse(parser, obj) {
  try {
    return parser.parse(obj);
  } catch (e) {
    console.log(obj);
    throw e;
  }
}
```

The problem is that typescript can not infer this function.

I tried multiple combinations but can not seem to get it right.

I looked through issues already mentioning generic and did fine one small example: https://github.com/vriad/zod/issues/93 but it did not help fully.

```
function parse<K, T extends z.ZodType<K, any>>(parser: T, obj): K {
  try {
    return parser.parse(obj);
  } catch (e) {
    console.log(obj);
    throw e;
  }
}
```
```
function parse<T extends z.ZodType<any, any>, K typeof T>(parser: T, obj): K {
  try {
    return parser.parse(obj);
  } catch (e) {
    console.log(obj);
    throw e;
  }
}
```
```
interface Schema<T> {
  parse: (data:unknown): T;
  check: (data:unknown): data is T;
}
function parse<T extends Schema<K>>(parser: T, obj) {
  try {
    return parser.parse(obj);
  } catch (e) {
    console.log(obj);
    throw e;
  }
}
```

```
interface SchemaVal {
  parse<K>(data: unknown): K;
}

function parse<T extends SchemaVal>(parser: T, obj): K {
  try {
    return parser.parse(obj);
  } catch (e) {
    console.log(obj);
    throw e;
  }
}
```


",,
669525260,104,Typed key signature for object schemas,"In TypeScript, one can do this
```ts
type MyType = {
  requiredKey1: string;
  requiredKey2: number;
  [extraKeys: string]: string;
};
```
such that `requiredKey1` and `requiredKey2` are required and additional keys with `string` values can also be added.

Is there a way to achieve this with Zod?

It seems that `.nonstrict()` only supports the values being `any`, as shown in the doc:
```ts
const dogSchemaNonstrict = dogSchema.nonstrict();

type NonstrictDog = z.infer<typeof dogSchemaNonstrict>;
/*
{
  name: string; 
  neutered: boolean;
  [k:string]: any;
} 
*/
```

Is it possible to support requiring specific type for nonstrict object? Maybe add an optional parameter to `.nonstrict()`? Something like this:

```ts
const dogSchemaNonstrict = dogSchema.nonstrict(z.number());

type NonstrictDog = z.infer<typeof dogSchemaNonstrict>;
/*
{
  name: string; 
  neutered: boolean;
  [k:string]: number;
} 
*/
```

---

(While `Record` with `.refine` can certainly achieve the functionality, inferring its TypeScript type will lose the information of the required fields (and their values' types).)",,
667493741,103,Create a zod type from a TS enum,"Right now if you want to create a type from a TS enum, you have do something like the following:

```ts
enum PlantLifecycle {
  Evergreen = 'EVERGREEN',
  Deciduous = 'DECIDUOUS',
  SemiDeciduous = 'SEMI_DECIDUOUS'
};

const lifecycle = z.union([
  z.literal(PlantLifecycle.Deciduous),
  z.literal(PlantLifecycle.Evergreen),
  z.literal(PlantLifecycle.SemiDeciduous),
]);
```

There should be an easier way of doing this, like:
```ts
enum PlantLifecycle {
  Evergreen = 'EVERGREEN',
  Deciduous = 'DECIDUOUS',
  SemiDeciduous = 'SEMI_DECIDUOUS'
};

z.enum(PlantLifecycle);
```",,
666369865,102,Why the necessity of strictNullChecks?,"Hey great lib, but I cannot use it. 
Currently our project does not have `strictNullCheck` enabled.
Adding validation is a first step in increasing type safety to eventually have `strictNullChecks` 

I understand

```ts
type Dog = {
  name:string | undefiend;
  neutered: boolean  | undefiend;
}
```
means nothing without strictNullChecks, However

```ts
type Dog = {
  name?: string;
  neutered?: boolean;
}
```

Does. 

Is it a technical limitation to treat these two cases the same way?
",,
665986408,101,Error stack trace should not include Zod internals,"Currently the stack trace includes Zod internals like this:

```diff
ZodError: event.data.new.title: Invalid input: expected string, received undefined
-    at new ZodError (/Users/b/c/infra/node_modules/zod/lib/src/ZodError.js:36:28)
-    at ZodObject.parse (/Users/b/c/infra/node_modules/zod/lib/src/parser.js:142:17)
    at exports.handler (webpack-internal:///./functions/hasura/eventCreated.ts:41:39)
    at InProcessRunner.run (/Users/b/c/infra/node_modules/serverless-offline/dist/lambda/handler-runner/in-process-runner/InProcessRunner.js:100:16)
    at processTicksAndRejections (internal/process/task_queues.js:97:5)
    at async process.<anonymous> (/Users/b/c/infra/node_modules/serverless-offline/dist/lambda/handler-runner/child-process-runner/childProcessHelper.js:39:14)
}
```

But what I want is this:
```
ZodError: event.data.new.title: Invalid input: expected string, received undefined
    at exports.handler (webpack-internal:///./functions/hasura/eventCreated.ts:41:39)
    at InProcessRunner.run (/Users/b/c/infra/node_modules/serverless-offline/dist/lambda/handler-runner/in-process-runner/InProcessRunner.js:100:16)
    at processTicksAndRejections (internal/process/task_queues.js:97:5)
    at async process.<anonymous> (/Users/b/c/infra/node_modules/serverless-offline/dist/lambda/handler-runner/child-process-runner/childProcessHelper.js:39:14) 
}
```

#### Version

```
zod: 1.9.0
```
",,
665705565,100,RFC: Transformations (e.g. casting/coercion),"âš ï¸ Update: this approach has been abandoned in Zod 3 for a more Yup-like ""transform chain"" approach.

This is the proposed API for implementing data transformation functionality in Zod.

## Proposed approach

No need to over complicate things. The problem to solve is how Zod should handle/support transformations from type A to type B. So I propose the creation of a new class `ZodTransformer`. This class is a subtype of `ZodType` (so you can use it like any other schema â€”Â `.refine`, `.parse`, etc).

Internally, instances of this class will have these properties
- `input: ZodType`: an input schema
- `output: ZodType`: an output schema
- `transformer: (arg: T['_type']) => U['_type']`: a transformer function

There is only one transformer function, not a ""transform chain"" like in Yup (ðŸ‘‹ @jquense). This makes it easier for Zod to statically type the function. Any sort of functional composition/piping can be done using libraries external to Zod.

You would create an instance using the `ZodTransformer.create` static factory method (aliased to `z.transformer`):

## Usage

Coercing a string into a number.

```ts
const stringToNumber = z.transform(z.string(), z.number(), (data)=>parseFloat(data));
type stringToNumber = z.infer<typeof stringToNumber>; // number

stringToNumber.parse(""12"") // => 12 (number)
```

## `.input/.output`

```ts
stringToNumber.input; // ZodString
stringToNumber.output; // ZodNumber
```

## `.transform` method

~~Every ZodTransform instance will have a `.transform` method. This method lets you easily chain transforms, instead of requiring many nested calls to `z.transform()`.~~

Every _ZodType_ instance (the base class for all Zod schemas) will have a `.transform` method. This method lets you easily create a ZodTransform, using your current schema as the input:

```ts
const trimAndMultiply = z.string()
  .transform(z.string(), x =>x.trim())
  .transform(z.number(), x => parseFloat(x))
  .transform(z.number(), num => num * 5);

console.log(trimAndMultiply.parse(' 5 ')); // => 25
```
## ~~`.toTransformer` function~~

âš ï¸ Edit: This section is no longer relevant since the `.transform` method has been moved to the base ZodType class instead of only existing on ZodTransform.

As you can see above, the first method call is `.transformer` (which is a factory function that returns a ZodTransform). All subsequent calls are to `.transform()` (a chainable method on the ZodTransformer class).

To make the syntax for defining chains of transforms more consistent, I propose a `toTransformer` function:

```ts
const stringTransformer = z.transformerFromSchema(z.string());

// equivalent to
const stringTransformer = z.transformer(z.string(), z.string(), x => x);
```

With this you could rewrite `trimAndMultiply` like so:

```ts
const trimAndMultiply = z.toTransformer(z.string())
  .transform(z.string(), z.string(), x =>x.trim())
  .transform(z.number(), x => parseFloat(x))
  .transform(z.number(), num => num * 5)
  .refine(x => x > 20, 'Number is too small');
```

~~## `.clean`~~
This section is now irrelevant and will now be implemented by overloading `.transform()`

âš ï¸ I really don't like the name ""clean"" for this; if you have any better ideas please make suggestions.

There will be redundancy if you are chaining together transforms that don't cast/coerce the type. For instance:

```ts
z.toTransformer(z.string())
  .transform(z.string(), val => val.trim())
  .transform(z.string(), val => val.toLowerCase())
  .transform(z.string(), val => val.slice(0,5))
```

I propose a `.clean` method that obviates the need for the redundant `z.string()` calls. Instead it uses `this.output` as both the input and output schema of the returned ZodTransform.

```ts
z.toTransformer(z.string())
  .clean(val => val.trim())
  .clean(val => val.toLowerCase())
  .clean(val => val.slice(0,5))
```
## .default

Transformations make the setting of default values possible for the first time.

```ts
z.string().default('default_value');

// equivalent to
z.transformer(z.string().optional(), z.string(), x => x || ""default_value"");
```

## Complications

### Separate input and output types
There are some tricky bits here. Before now, there was no concept of ""input types"" and ""output types"" for a Zod schema. Every schema was only associated with one type. 

Now, ZodTransformers have different types for their inputs and outputs. There are issues with this. Consider a simple function schema:

```ts
const myFunc = z.function()
  .args(z.number())
  .returns(z.boolean())
  .implement(num => num > 5);

myFunc(8);
```

This returns a simple function that checks if the input is more than 5. As you can see the call to `.implement` automatically infers/enforces the argument and return types (there's no need for a type signature on `num`).

Now what if we switch out the input (`z.number()`) with `stringToNumber` from above?

```ts
const myFunc = z
  .function()
  .args(stringToNumber)
  .returns(z.boolean())
  .implement(num => num > 5);

myFunc(8); // works
myFunc(""8""); // throws
```

It's not really clear what should happen here. The function expects the input to be a number, but the transformer expects a string. Should myFunc(""8"") work? 

### Type guards

1. I hadn't really considered how this will impact type guards. Like I mentioned under ""Complications"" in the original RFC, each schema is now associated with both an input and output type. For schemas that aren't ZodTransformers, these are the same. Type guards can _only_  be used to verify the input type:

```ts
const stringToNumber = z.transformation(z.string(), z.number(), parseFloat);
const data = ""12"";

if(stringToNumber.check(data)){
  data; // still a string
}
```

I think perhaps typeguards aren't really compatible with any sort of coercion/transformation and it might be better just to get rid of them. @kasperpeulen

### Unions

Not sure how I didn't see this issue before.

Consider a union of ZodTransformers:

```ts
const transformerUnion = z.union([
  z.transformer(z.string(), z.number(), x => parseFloat(x)),
  z.transformer(z.string(), z.number().int(), x => parseInt(x)),
])
```

What should happen when you do `transformerUnion.parse('12.5')`? Zod would need to choose which of the transformed values to return. 

One solution is to have union unions return the value from the first of its child schemas that passes transformation/validation, in the order they were passed into `z.union([arg1,arg2,etc])`. In the example above it would return the float, and never even execute `parseInt`.

Another solution is just to disallow passing transformers in unions (and any other types that would cause problems) ðŸ¤·â€â™‚ï¸


## Design consideration

One of my design considerations was trying to keep all data mutation/transformation fully contained within ZodTransformers. This leads to a level of verbosity that may be jarring. Instead of adding a `.default()` method to every Zod schema, you have to ""convert"" your schema into a ZodTransformer first, then you can use its `.default` method yourself.

## Try it

Most of this has already been implemented in the alpha branch, so you can play around with it. Open to any questions or concerns with this proposal.  ðŸ¤™ 

`yarn add zod@alpha`

Tagging for relevance: @krzkaczor @ivosabev @jquense @chrbala @jakeginnivan @cybervaldez @tuchk4 @escobar5 

",,
665692124,99,Inferred recursive types without casting,"Interesting in more information on what is holding back nested types from being simpler?  I can't seem to think of what it could be as I can model and infer things on a pretty insanely sophisticated level -- but I am sure I am just not understanding a piece of the chain here.  
",,
665609731,98,Is there a way to set nonstrict as a default?,I'm writing types for JSON responses we get from external APIs. I don't particularly want to start throwing errors if they ever add additional fields to their responses. Is there a way for me to get non-strict functionality as a default without adding it to all of my types?,,
665559290,97,Allow Custom Errors on any value?,"Any reason not to allow defining the last argument for any value as an error message to allow overriding the error message for that property easily?  The current method is not really ideal, especially when you have many string props but need different errors.

A couple nice ways to handle it:

### Allow Last Param to be Error Message

> Would also accept a custom error that it would throw instead of ZodError (similar to Joi)

```typescript
const TestSchema = z.object({
	three: z.literal('hi').optional(),
	one: z.number(),
	two: z.literal(3, 'that isnt 3 dummy'),
	four: z.string('string not whatever you gave!'),
	five: z.date()
})
```

### Add a `.error()` option like Joi

```typescript
const TestSchema = z.object({
	three: z.literal('hi').optional(),
	one: z.number(),
	two: z.literal(3).error(new Error('that isnt 3 dummy')),
	four: z.string().optional().error(new Error('string not whatever you gave!')),
	five: z.date()
})
```

---

For the VSCode extension I am working on, these styles add the benefit that jsdoc can be used to transfer over error messaging easily:

![](https://media2.giphy.com/media/kHIevgJMwj1pGRCxEl/giphy.gif)
",,
665537870,96,Demand for VSCode Extension?,"Was playing around with VSCode and Zod based on #53 -- seeing if there is enough demand for this to put time into the concept.  It is slow in the preview as I built that out in about 1 hour, but seems it could be nice - and make it easier to use Zod since you wouldn't really need to even learn all the specifics - you could just create your TypeScript Type then translate it.

It utilizes the TypeScript Compiler API to read the AST and infer from there.

> Since this is just using the TypeScript compiler API - this could pretty easily become a browser tool as well which you could just paste in your type and get a valid zod schema out from it.

> On that note, this is more of a Typescript Plugin than a VSCode Extension - since the vscode part of it is just providing the menu option to run the TS Compiler and it uses the TS Compiler to build Typescript Code. 

```typescript
export const generatePrimitive = ({ kind, name, props, zodImportValue }: {
  kind: ts.SyntaxKind;
  name: string;
  zodImportValue: string;
  props: { isOptional: boolean; errorMessage: undefined | string; isNullable?: boolean }
}) => {
  let flags = '';

  if (props.isOptional) {
    flags += '.optional()';
  }
  if (props.isNullable) {
    flags += '.nullable()';
  }

  let errorMessage = props.errorMessage ? wrapQuotes(props.errorMessage) : '';

  switch (kind) {
    case ts.SyntaxKind.NumericLiteral:
      return `${zodImportValue}.literal(${name})${flags}`;
    case ts.SyntaxKind.StringLiteral:
      return `${zodImportValue}.literal(${wrapQuotes(name)})${flags}`;
    case ts.SyntaxKind.StringKeyword:
      return `${zodImportValue}.string()${flags}`;
    case ts.SyntaxKind.BooleanKeyword:
      return `${zodImportValue}.boolean()${flags}`;
    case ts.SyntaxKind.NullKeyword:
      return `${zodImportValue}.null()${flags}`;
    case ts.SyntaxKind.UndefinedKeyword:
      return `${zodImportValue}.undefined()${flags}`;
    case ts.SyntaxKind.NumberKeyword:
      return `${zodImportValue}.number()${flags}`;
    case ts.SyntaxKind.AnyKeyword: 
      return `${zodImportValue}.any()${flags}`;
    case ts.SyntaxKind.BigIntKeyword:
      return `${zodImportValue}.bigint()${flags}`;
    case ts.SyntaxKind.VoidKeyword:
      return `${zodImportValue}.void()${flags}`;
    case ts.SyntaxKind.ClassKeyword: {
      if (name === 'Date') {
        return `${zodImportValue}.date()${flags}`;
      }
      // TODO : Handle Class & InstanceOf based on symbol & import detection context
    }
    default:
     return `${zodImportValue}.any(${errorMessage})`;
  }
};
```

![](https://media2.giphy.com/media/QakVCETUNihvcuMv73/giphy.gif)

---

The code above just uses strings to build it which was easier in this case.  For those potentially interested, to move to using the TypeScript Compiler / AST to build it all, the generated type in the gif would be something like:

```typescript
[
  ts.createVariableStatement(
    undefined,
    ts.createVariableDeclarationList(
      [ts.createVariableDeclaration(
        ts.createIdentifier(""TestSchema""),
        undefined,
        ts.createCall(
          ts.createPropertyAccess(
            ts.createIdentifier(""z""),
            ts.createIdentifier(""object"")
          ),
          undefined,
          [ts.createObjectLiteral(
            [
              ts.createPropertyAssignment(
                ts.createIdentifier(""three""),
                ts.createCall(
                  ts.createPropertyAccess(
                    ts.createCall(
                      ts.createPropertyAccess(
                        ts.createIdentifier(""z""),
                        ts.createIdentifier(""literal"")
                      ),
                      undefined,
                      [ts.createStringLiteral(""hi"")]
                    ),
                    ts.createIdentifier(""optional"")
                  ),
                  undefined,
                  []
                )
              ),
              ts.createPropertyAssignment(
                ts.createIdentifier(""one""),
                ts.createCall(
                  ts.createPropertyAccess(
                    ts.createIdentifier(""z""),
                    ts.createIdentifier(""number"")
                  ),
                  undefined,
                  []
                )
              ),
              ts.createPropertyAssignment(
                ts.createIdentifier(""two""),
                ts.createCall(
                  ts.createPropertyAccess(
                    ts.createIdentifier(""z""),
                    ts.createIdentifier(""literal"")
                  ),
                  undefined,
                  [ts.createNumericLiteral(""3"")]
                )
              ),
              ts.createPropertyAssignment(
                ts.createIdentifier(""four""),
                ts.createCall(
                  ts.createPropertyAccess(
                    ts.createIdentifier(""z""),
                    ts.createIdentifier(""string"")
                  ),
                  undefined,
                  []
                )
              ),
              ts.createPropertyAssignment(
                ts.createIdentifier(""five""),
                ts.createCall(
                  ts.createPropertyAccess(
                    ts.createIdentifier(""z""),
                    ts.createIdentifier(""date"")
                  ),
                  undefined,
                  []
                )
              )
            ],
            true
          )]
        )
      )],
      ts.NodeFlags.Const
    )
  ),
  ts.createTypeAliasDeclaration(
    undefined,
    undefined,
    ts.createIdentifier(""Test""),
    undefined,
    ts.createTypeReferenceNode(
      ts.createQualifiedName(
        ts.createIdentifier(""z""),
        ts.createIdentifier(""infer"")
      ),
      [ts.createTypeQueryNode(ts.createIdentifier(""TestSchema""))]
    )
  )
];
```

-->

```typescript
const TestSchema = z.object({
	three: z.literal('hi').optional(),
	one: z.number(),
	two: z.literal(3),
	four: z.string(),
	five: z.date()
})

type Test = z.infer<typeof TestSchema>;
```",,
660451580,94,Is Typescript 3.4+ not supported?,"Can not pass the unit tests with typescript 3.7

Is it planned to support only 3.9+ again ((now in beta)), but not previous versions? ",,
659945053,93,Field errors helper method,"The `error.formErrors.fieldErrors` feature is super helpful!

Here's my current usage with react-final-form.

```tsx
<Form
   validate={(values) => {
      try {
        SignupInput.parse(values)
      } catch (error) {
        return error.formErrors.fieldErrors
      }
   }}
```

But it would be super awesome if instead the zod object had a function that did the above for me. Something like this:

```tsx
<Form 
   validate={SignupInput.validate} 
```",,
659940694,92,Improve default error for required field,"Currently passing `undefined` to a field defined as `z.string()` results in the following error message:

```
Invalid input: expected string, received undefined
```

What I want is this:

```
Required
```

Other error messages are nice by default, like ""Invalid Email"" and ""Should be at least 10 characters"".",,
659232818,91,Potential bug with z.string().uuid(),"I came across this while using zod in an express.js environment. Every other request was failing the uuid validation (`Invalid uuid`). I hacked together a minimal zod-only test-case and found out that this happens without express as well.

The second time `parse()` is called when validating a schema which uses `uuid()` it throws a `ZodError: uuid: Invalid uuid`. Interestingly, this does not happen when using `z.string().email()` which internally AFAICT does the same thing, only with a different regex.

```js 
const z = require('zod');

const schema = z.object({ uuid: z.string().email() });
try {
  schema.parse({ uuid: 'foo@example.com' });
  schema.parse({ uuid: 'foo@example.com' });
} catch(err) {
  console.log('[EMAIL] This should not happen', err);
}

const schemaUUID = z.object({ uuid: z.string().uuid() });
try {
  schemaUUID.parse({ uuid: '1a657d0c-b676-4bbf-9d18-d9ecb8547d8d' });
  schemaUUID.parse({ uuid: '1a657d0c-b676-4bbf-9d18-d9ecb8547d8d' });
} catch(err) {
  console.log('[UUID] This should not happen', err);
}
```
",,
658740939,90,Optional string problem (?),"Hello! Congratulations and thanks for this lib.

I don't know if this is an error, as I just started using it, but seems strange.

This doesn't raises errors
```
const createStoreSchema = zod.object({
  name: zod.string().max(20).optional()
}).optional();
```
But this one does

```
const createStoreSchema = zod.object({
  name: zod.string().optional().max(20)
}).optional();
```

`Property 'max' does not exist on type 'ZodUnion<[ZodString, ZodUndefined]>`",,
657329117,89,Comparison with https://github.com/ianstormtaylor/superstruct,"I would like to know how this library compares to https://github.com/ianstormtaylor/superstruct.

Thanks!",,
655811145,88,Option to create params from input in custom validation,"zod [custom validation](https://github.com/vriad/zod#custom-validation) allows params to be passed in to the error object. It would be nice if these could be created based on the initial data.

That is, instead of this type signature:
``.refine(validator: (data:T)=>any, params?: RefineParams)``

zod could use:
``.refine(validator: (data:T)=>any, params?: RefineParams | (data: T) => RefineParams``",,
655811097,87,Asynchronous validations,"There's support for validating [promise types](https://github.com/vriad/zod#promises), but I don't see a way to create async validators.

What I'm thinking of is something like this:

```js
const foreignKey = z.string().refine(idExistsAsync, {
  message: ""ID not found"",
});
foreignKey.parseAsync(""1234"")
```

Where ``idExistsAsync`` is some function that asynchronously checks some backend to make sure that the value is valid. It returns a promise. Of course this would mean that the entire schema becomes async, so there are some other concerns here when async values are used as fields on objects.",,
655811018,86,Docs on integrating with other OSS,"It would be nice to have docs on how to integrate zod with other OSS. This would help people:
* identify whether zod will work well with their tech stack
* figure out how to use zod with their tech stack
* help zod validate its feature set. If the docs are hard to write, zod is probably missing something.

#### GraphQL
It seems like zod could be well suited for GraphQL validations. It would be handy to have a reference for the parallels of GraphQL types and their corresponding zod types, as well as any other suggestions for integrating zod into the GraphQL environment.

As a single small example:

```graphql
union Fish = Salmon | Tuna | Trout
type Catch {
  fish: Fish!
}
```

```js
const FishEnum = z.union([z.literal('Salmon'), z.literal('Tuna'), z.literal('Trout')]);
const Catch = z.object({
  fish: FishEnum,
});
```

Of course it's a bit less obvious when it comes to nullable types because GraphQL is nullable by default, and zod is required by default. 

#### React PropTypes
Seems like an integration that would make sense for libraries. Similar docs like those for GraphQL could make sense.

#### formik
Formik has [native support](https://formik.org/docs/guides/validation) for Yup schemas. Docs on integrating zod with formik would be nice!",,
655810913,85,Guidance on creating slight schema variants for varied contexts,"I am interested in using zod for frontend, API, and backend validation. 

For example, a browser might validate user inputs live as they are changed on the page. The user hits ""submit"" which sends the data to the API. The API runs its own validations on this data that may be somewhat different. The API changes the data slightly to conform with the backend needs. The backend has a similar schema, but there are some small differences.

Differences might be things like:
* Adding a field deep in the schema
* Swapping a foreign key ID for an object pulled from some other location
* API allows partial inputs for updates, but the backend sometimes requires complete inputs. For example, take a blog post draft that can be missing a title field, but the backend requires a title to be persisted before publishing.

I'm not necessarily looking for changes to the library, but rather recommended patterns through documentation, blog posts, etc. I see that zod supports merging, masking, and extending, but am looking for higher level guidance on patterns for this type of use case. I can see schema sharing as something that could potentially make a codebase much more complex without due care. The guidance here might be to create separate schemas because the costs of coupling schemas across contexts is too high!

There may also be features that could be added to zod that make this use case easier.",,
655810843,84,Contextual validations,"I'm looking for a way to validate in different ways in different contexts. For example, take a complex object on the client (browser) with foreign-key fields (IDs) that map to other objects on the backend. The client has a mechanism for retrieving these IDs and naturally trusts them. The client also may not have a reasonable mechanism for validating them. On the server, we don't trust these to be valid IDs by default. We need to ensure that they map to real objects.

How would we share most of the schema, but have slightly differing validations in different contexts?

From a high level, I'm thinking of a context object that can be passed down and used in the validators similar to how a lot of GraphQL server implementations work.",,
654622971,82,[bug] Cannot parse objects intersection,"# Description

I have following description for `ShapeEntity`
```typescript
import * as z from ""zod"";

const SquareData = z.object({
  type: z.literal(""square""),
  data: z.object({
    width: z.number(),
    height: z.number(),
  }),
});
const CircleData = z.object({
  type: z.literal(""circle""),
  data: z.object({
    radius: z.number(),
  }),
});

const ShapeData = z.union([SquareData, CircleData]);
const ShapeEntity = z.intersection(z.object({ id: z.string() }), ShapeData);
type ShapeEntity = z.infer<typeof ShapeEntity>;
```

When I try to parse valid circle, zod fails
```typescript
try {
  let circle = {
    id: ""id"",
    type: ""circle"",
    data: { radius: 123 },
  };
  ShapeEntity.parse(circle);
  console.log(""circle success"");
} catch (error) {
  console.log(error.message);
  // Left side of intersection: Unexpected key(s) in object: 'type', 'data'
  // Right side of intersection: 
  //     union option #0: Unexpected key(s) in object: 'id'
  //     union option #1: Unexpected key(s) in object: 'id'
}
```

# Workaround
It can work if I redefine type as union of merged parts
```typescript
const ShapeEntityBase = z.object({ id: z.string() });
const ShapeEntity = z.union([
  ShapeEntityBase.merge(SquareData),
  ShapeEntityBase.merge(CircleData),
]);
```
But it does not feel native, because in typescript I define type as `Base & (Opt1 | Opt2)`, not as `(Base & Opt1) | (Base & Opt2)`
",,
650904806,78,Zod V2,"Hi @vriad 

I've been looking for a solid JavaScript schema validation lib for awhile now and after trying out many, Iâ€™ve just found Zod! It looks great, thanks for creating it. I see that you've started work on a V2 and wanted to ask if there was a timeline for this? I'm just starting on a new project and would like to know if it's worth waiting.

Thanks,
Ross",,
650649819,77,Is there a way to define a schema for a function that returns void?,"First of all, zod is awesome.  I would recommend adding it to the awesome-typescript list(s) as an alternative to io-ts.

I'm trying to define a schema for a function that does not return a value.  Example:

```typescript
function foo(): void {}
```

Currently I am using `z.unknown` for `returnType`:

```typescript
const FooSchema = z.function(z.tuple([]), z.unknown())
```

This works, but is it the correct way to do it?  Should there be a void type for function schemas?

",,
645077901,76,Similar to Yupâ€™s meta properties?,"This is an extremely useful feature yup had that is keeping me from transitioning to zod, basically each schema object have additional properties that can be used for validation and other use case.",,
645077174,75,[Request] Create schema from JSON,Iâ€™ve been using YUP which canâ€™t do that and recently saw zod. Just wondering if this is on the table? A use case is a dynamically made schema by my users. Something like zod.importJSON(jsonOBJ),,
642830423,74,Error reporting is useless when using z.function().implement(),"I have multiple functions written with `z.function().implement()` that call each other and one of them was returning `undefined` instead of the an object fitting its return type. It took me about an hour to find the exact function that was throwing due to error messages like these that do not tell you anything about which object schema or function is throwing:

```
TypeError: Cannot convert undefined or null to object at Function.keys (<anonymous>)

      at ZodObject.parse (node_modules/zod/src/parser.ts:90:32)
      at Object.<anonymous> (node_modules/zod/src/parser.ts:268:35)
      at step (node_modules/zod/lib/src/parser.js:32:23)
      at Object.next (node_modules/zod/lib/src/parser.js:13:53)
      at fulfilled (node_modules/zod/lib/src/parser.js:4:58)
```

```
Non-object type: undefined

      at new ZodError (node_modules/zod/src/ZodError.ts:10:5)
      at Function.ZodError.create (node_modules/zod/src/ZodError.ts:17:19)
      at Function.ZodError.fromString (node_modules/zod/src/ZodError.ts:35:21)
      at ZodObject.parse (node_modules/zod/src/parser.ts:84:51)
      at Object.<anonymous> (node_modules/zod/src/parser.ts:268:35)
      at step (node_modules/zod/lib/src/parser.js:32:23)
      at Object.next (node_modules/zod/lib/src/parser.js:13:53)
      at fulfilled (node_modules/zod/lib/src/parser.js:4:58)
```

I am writing in TS, so this might be related to the TS compiler, but the errors are still useless if they don't tell you which schema or function is throwing.",,
642345725,73,Unions and enums from an array,"I might be missing something, but it seems this is currently not possible, but would be a great time/code saver:

```typescript
const STATUSES = ['Assigned', 'In Progress', 'On Location', 'Succeeded', 'Failed'];
const StatusSchema = z.union(STATUSES.map(z.literal));
const StatusSchema2 = z.enum(STATUSES);
```
",,
642138017,72,"All object properties are optional, but object cannot be empty","I could not figure out how to write a rule that covers this scenario:

The object has `foo` and `bar` properties, that are optional
```
const Input = z.object({
  foo: z.number(),
  bar: z.string(),
}).partial();
```

You can pass `{foo: 1}`, `{bar: 'a'}` or `{foo: 1, bar: 'a'}, but `{}` should fail.

I guess I can do this with, `z.union`, but that seems like an overkill, especially if there are more than 2 object properties.

Seems to me that there should be a method that validates if an object is `{}`
",,
641252782,71,Correct way to use a third party Class/type in a Zod schema object?,"I'm trying to do this, but TypeScript complains:

```js
  z.object({
    slug: z.string().min(1).max(255),
    title: z.string().max(255),
    timeStart: Timestamp,
  })
```

Error:
```
Type 'typeof Timestamp' is missing the following properties from type 'ZodType<any, ZodTypeDef>': _type, _def, parse, is, and 5 more.
```

I basically want to make a schema that asserts that `timeStart` is an instance of the class `Timestamp` (which itself is a class I imported from a third party library).

How can I do this? Sorry if it's obvious.

Thank you for writing this library by the way, it's by far the best solution for TypeScript runtime checking I've found (and I've tried many).",,
641227086,70,Support anyCase()/ignoreCase() for literals,"It would be great to have support for anyCase/ignoreCase for literals/enums. 
Example use case would be an API that accepts String enum and doesn't care about case.",,
638449958,69,Specify path for object refinement,"refine is the recommended way for validating related properties on an object
https://github.com/vriad/zod/issues/61
Consider this schema

```
const validationSchema = z
  .object({
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    email: z.string().email(),
    password: z.string(),
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, 'Both password and confirmation must match')

```
with this input data 

```
{
  firstName: 'zod',
  lastName: '',
  email: 'theba@zod.c',
  password: 'thetetathea',
  confirmPassword: 'thethtbet',
}
```

we get this error

```
[
  {
    message: 'Both password and confirmation must match',
    path: [],
  },
]
```

The path is empty. Ideally, the path should contain ""confirmPassword"" so that the error can be easily displayed on the UI",,
638413980,68,Return all schema errors,How do I get Zod to return all the errors. Currently schema.parse throws on the first error. Something like yup's `{abortEarly: false}` would be nice,,
637697341,67,Union errors path,"I was wondering why errors path is inlined within the message when using union types:
```typescript
try {
    const parser = z.array(
      z.union([
        z.object({ messages: z.array(z.string().nonempty()) }),
        z.string(),
      ]),
    );

    parser.parse([{ messages: [''] }]);
  } catch (e) {
    // eslint-disable-next-line no-console
    console.log('errors: ', JSON.stringify(e.errors));
  }
```
gives:
```
[{""path"":[0],""message"":""\n\tunion option #0: messages.0: Value cannot be empty string\n\tunion option #1: Non-string type: object""}]
```

But why not (?)
```
[{""path"":[0, ""messages"", 0],""message"":""Value cannot be empty string""}]
```",,
635428335,66,Readonly fields,Typescript allows to declare fields as readonly. Is there any workaround to add readonly property to interface infer-ed from zod schema?,,
635208420,65,How to best mix required and optional properties?,"I expected this to work:

```ts
const AnObjSchema = z.object({
  file: z.string(),
  author: z.string().optional(),
  tags: z.array(z.string()).optional(),
});

type AnObj = z.infer<typeof AnObjSchema>;
// type AnObj = {
//   file?: string; // should not be optional
//   author?: string;
//   tags?: string[];
// }
```

Alas, property `.file` is not required in the inferred type. Do I have to do an intersection type of two object types?",,
633805536,64,Releases and tags on GitHub,"Hi :)

I see there is new releases of zod, but the tags does not appear on the GitHub repo. I see the latest i 1.7 but the latest here on GitHub is 1.2?
",,
631750874,63,Request: nonempty for string,"I'm using MUI for my forms and it requires my default input values to be an empty string. Of course that means an empty input will pass Zod validation because it is indeed a string and does exist.

Currently im using `refine` and checking the length is greater than 0. It works fine.

But a nice and simple solution would be a `nonempty` method that rejects empty strings.",,
631253659,62,Generating an object from schema,"This may not be a feature that makes sense to build, but it would be incredibly useful.

A normal workflow is to create a schema for your form state, generate a type, and then write the same object over again to use as the initial form state:

```
const formSchema = z.object({
  name: z.string(),
  email: z.string(),
});

type FormState= z.infer<typeof formSchema>

const initialFormState: FormState = {
  name: '',
  email: '',
 };

const [formState, setFormState] = useState<FormState>()
```

And now as your form grows so do these 2 objects.

I would love to be able to do something like this:
```
const formSchema = z.object({
  name: z.string().default(''),
  email: z.string().default(''),
});

type FormState= z.infer<typeof formSchema>

const initialForm = z.generate(formSchema);

const [formState, setFormState] = useState<FormState>(initialForm)
```

Currently I have a utility function I wrote that does this, it's not recursive and not very robust, but it does what I need and as a result my code is much cleaner. Everything can be updated simply by changing the Zod schema. Any thoughts on a feature like this?
",,
631249161,61,Require one of two fields,"Similar to this Yup issue: https://github.com/jquense/yup/issues/176

I'd like to conditionally validate at least one of n values are set. Yup and Joi solve this problem with a `.when` method.

Does Zod currently have a solution to this problem?",,
631061792,60,Custom validation error?,"```ts
const stringSchema = z.string();
stringSchema.parse(12); // throws Error('Non-string type: number');
```

Instead throw either:
* `ValidationError('Non-string type: number')`
* `ZodError('Non-string type: number')`

Benefit: You can filter for Zod-specific errors when catching.",,
628087199,59,Unexpected missing key errors with intersections/unions that conflict with inferred type,"I'm getting `.parse` errors that seem incorrect with a schema similar to this one:

```typescript
z.intersection(
    z.object({
      user: z.object({
        email: z.string(),
        firstName: z.string(),
        lastName: z.string()
      }),
      org: z.object({ name: z.string()})
    }),
    z.union([
      z.object({
        provider: z.literal(""email""),
        emailVerificationToken: z.string(),
      }),
      z.object({
        provider: z.enum([""github"", ""gitlab""]),
        externalAuthSessionId: z.string(),
      }),
    ])
 )
```

But when using `.parse` or `.check` on an object that matches the inferred type, I get missing key errors.

So with a seemingly valid object like this one (that type checks fine with the inferred type):

```typescript
{
  user: { email: ""example@email.com"", firstName: ""Test"", lastName: ""User""},
  org: { name: ""Test Org"" },
  provider: ""email"",
  emailVerificationToken: ""token""  
}
```

I get the error:
```
Left side of intersection: Unexpected key(s) in object: 'provider', 'emailVerificationToken'\nRight side of intersection: \n\tunion option #0: Unexpected key(s) in object: 'org', 'user'\n\tunion option #1: Unexpected key(s) in object: 'org', 'user', 'emailVerificationToken'
```

Is this a bug or am I misunderstanding something about how intersections and unions work in zod?
",,
627538921,57,Using getters for some functionality?,"```ts
// Before: `.number()`, `.optional()` etc. as methods
const union = z.union([z.number(), z.boolean()]);
const optionalString = z.string().optional();

// After: `.number()`, `.optional()` etc. as getters
const union = z.union([z.number, z.boolean]);
const optionalString = z.string.optional;
```
",,
627513907,56,"ZodObject methods (pick, omit, partial, etc.) for intersections and unions of objects","I've been converting lots of TS types to zod. It's going pretty smoothly. Again, thanks for the _excellent_ work on this lib! But some of the types are fairly complex with nested intersections and unions of object types, and I find myself really wishing I could use the ZodObject methods on these types, especially `pick`, `omit`, and `partial`.

So for a zod definition like this:

```typescript
const schema = z.intersection(
  z.object({key1: z.string()}), 
  z.union([
    z.object({key2: z.string()}),
    z.object({key3: z.string()}),
  ])
);
```

I'd love to be able to do:

```typescript
schema.pick({key1: true, key3: true});
schema.omit({key2: true});
schema.partial();
```

And same for other structures: unions of objects, unions of intersections, etc.

It seems like it could be doable to call them recursively through all levels of nesting with the appropriate subset of keys as long as every intersection/union resolves to an object? Maybe type inference is an issue?

I'm getting around this by breaking up complex types into many constituent ZodObject schemas, and then re-composing them using the object methods as needed, but it would be a lot easier to just call the methods directly on the full schema.",,
626672121,55,Specify valid keys in Record,"In TS, I can define an object like so:

`type Flags = Record<""flag1""|""flag2"", boolean>` 

or:

`type Flags = {[k in ""flag1""|""flag2""]: boolean}`

It doesn't seem there's any way to accomplish this now in zod? I have lots of TS types using this pattern with large unions that I *really* don't want to duplicate everywhere as `z.object` keys, so this would be handy to get full parity with TS.",,
626067233,53,Generating Zod schema from TS type definitions,"Love this library! I'm just beginning to convert a large TS project with many types, and I'm wondering how feasible it would be to automatically run through a file and convert any TS types to a zod schema and the accompanying inferred type. Or perhaps using the language server somehow would be easier? Either way, it would remove a ton of tedium from adopting zod for an existing project.
 
I guess I'll just barrel through and convert them one by one, which will probably take me a few hours at least, but figured I'd suggest this for those who might end up in a similar spot.",,
619589352,52,proper mechanism to integrate with 3rd party types,"# problem

```ts
import { Bananas } from '@fruit/banana'
import * as z from 'zod'
const schema = z.object({
  apple: z.string(),
  banana: z.doSomethingWith3pType() // z.object({}) ??
})
const myType = z.infer<typeof schema> // { apple: string, banana: ???? }
```

what the best way to get my 3p schema in? assuming because types have been compiled away, getting my 3p schema may not be possible, _but_, is there a mechanism to put my type into the schema, and get it reflected back out?",,
618285729,51,Middle Ground between strict and unstrict,"Often when calling an HTTP endpoint, we're only interested in small bits of the data, but not the whole response. I, therefore, tried to model a ""zod"" (don't know what you call it :) ) based on that shape. Of course, I got an error because of unexpected types. The docs pointed me to ""nonstrict"" mode, which works great. I have a guarantee that the properties I need are there. The only issue is that it's not typesafe...the ""nonstrict"" mode carries over to the other end, and I can ask for any property I want, even if it doesn't exist.

Is there a hybrid mode? Or perhaps a setting in parse that doesn't error when coming across unexpected properties.",,
617058502,50,Union errors don't point to actual problem,"When trying to parse a union type you get a very generic error that doesn't tell you what actually went wrong.

```ts
import * as z from 'zod';

enum ContactType {
    Address = 'ADDRESS',
    Phone = 'PHONE',
}

const addressSchema = z.object({
    kind: z.literal(ContactType.Address),
    address: z.object({
        streetAddress: z.string(),
        city: z.string(),
        stateOrProvince: z.string(),
        zipCode: z.string(),
    }),
});

const phoneSchema = z.object({
    kind: z.literal(ContactType.Phone),
    phone: z.string(),
});

const contactSchema = z.union([ addressSchema, phoneSchema ]);

const data = {
    kind: ContactType.Address,
    address: {
        streetAddress: '123 Fake Street',
        city: 'Springfield',
        stateOrProvince: 'OH',
        // Missing zipCode
    },
};

contactSchema.parse(data);
```

This will give you:
```
Error parsing union.
Received: {
  ""kind"": ""ADDRESS"",
  ""address"": {
    ""streetAddress"": ""123 Fake Street"",
    ""city"": ""Springfield"",
    ""stateOrProvince"": ""OH""
  }
}
Expected: object OR object
```

If you change the last line to `addressSchema.parse(data);` you get something useful:
```
`address.zipCode`: Non-string type: undefined
```

It would be nice if this worked more like TypeScript itself does when type checking unions and told you why each possible type in the union failed to work. Perhaps something like:
```
object: Unexpected key(s) in object: 'address'
object: `address.zipCode`: Non-string type: undefined
```

Even better would be if it could give something more useful than `object` for the names of these but I'm not sure how you'd accomplish that without adding some means of providing metadata for types.",,
614958816,49,z.function can not be used with z.object,"version: 1.0.9 | 1.2.5 | 1.5.0

When using z.function with z.object like this:
```
const MouseEvents = z.object({
    onClick: z.function(z.tuple([z.number()]), z.undefined())
})
```
Type error throws:
![image](https://user-images.githubusercontent.com/3960056/81444778-4cf7d680-91aa-11ea-9f2e-396a0427e5c1.png)
",,
613768937,47,Can you provide an example of how to do { stripUnknown: true }?,"I'm wondering how to do this option from yum:

`stripUnknown`:remove unspecified keys from objects.

I can pluck or omit, but what if I only want to pick the properties on the ZodObject?

For example:

```
const Animal = z.object({
 name: z.string(),
}),
export type Animal = z.infer<
  typeof Animal
>;
```

But, it so happens that an object such as `{ name: 'tommy', kind: 'cat' }` comes along.  How do I only validate the properties on Animal and drop others like `kind`? 

Since I am returned the same object and .nonstrict allows me to still verify the keys I care about, I would like to be able to drop the unknown keys that are on the object.  

The zod object Animal has a .toJSON which return the shape and I can get keys this way:

`Animal.toJSON().shape['0']`

",,
612111430,46,How to parse Dates in Api with zod,"Hi, Great wrok with zod. maybe i'm using it wrong but how would i parse a date in Api params i would get a string of Date and Zod expects a Date object. Should i  use the zod.string() and parse the date in the backend?",,
612075808,45,Type inference issue for Object schemas,"First, Thank you very much for your awesome work ðŸ‘ 

I figured out when I'm using `z.infer` on an object schema, the inferred type has all the object's attributes optional. According to the doc, all the attributes should be required.

Example from the doc:
```typescript
const dogSchema = z.object({
  name: z.string(),
  neutered: z.boolean(),
});

type Dog = z.infer<typeof dogSchema>;

/* 
equivalent to:
type Dog = { 
  name:string; 
  neutered: boolean;
}
*/
```

But this is what I get:
```
type Dog = {
    name?: string;
    neutered?: boolean;
}
```

I'm using zod `1.5.0` and I've also tried with `1.3.0` but keep getting the Dog type with optional attributes.

Thanks for your help!",,
611377888,43,Type inference incorrectly sets all fields as optional by default,"Zod version: 1.5.0
TS version: 3.8.3

The type inference does not seem to be working properly, making all values of objects to be optional by default.

Let me take this code derived from the readme:

```ts
import * as z from ""zod"";

const dogSchema = z.object({
  name: z.string(),
  neutered: z.boolean(),
});

type T = z.TypeOf<typeof dogSchema>;  // -> { name?: string, neutered?: boolean }

const dog: T = {};  // -> Compiles without error
```

The expected behavior would be a compilation error deriving from `name` and `neutered` to be required.",,
611172281,42,Value transformation / object mapping,"Hey! I just tried `zod` and I quite enjoy it so far, great job! I have a feature request/discussion. 

Problem: I would like my schema to not only validate data but transform it as well. A particular use case is that I would like to specify a mapping in my object schema. 

One could imagine a type `z.stringAsNumber()` which would parse strings like `""123""` to a number `123`. Something like this is totally possible with `io-ts`.

Or even more powerful case. Where object validation could remap keys:

```typescript
const envSchema = z.object({
  SERVER_HOST: z.string(),
  PUBLIC_S3_URL: z.string(),
  PRIVATE_BACKEND_URL: z.string(),
})
```

This schema is used to validate environment variables. It would be cool if I could specify a key mapping to end up with renamed keys in a parsed object for example (example API)

```typescript
const envSchema = z.object({
  serverHost: { value: z.string(), key: 'SERVER_HOST' },
  publicS3: { value: z.string(), key: 'PUBLIC_S3_URL' }
  privateBackendURL: { z.string(), key: 'PRIVATE_BACKEND_URL' }
})
```

I feel like this is a very common situation. Of course, it can be done manually after schema validation but I believe that it would be cool to support this one way or another. WDYT @vriad? Is this something that you want to support eventually?",,
610953283,41,JSON utility type,"I just found myself needing a generic type for any valid JSON and put this together:

```ts
type Literal = boolean | null | number | string;
type Json = Literal | { [key: string]: Json } | Json[];

const Literal = Zod.union([Zod.boolean(), Zod.null(), Zod.number(), Zod.string()]);
const Json: Zod.ZodType<Json> = Zod.lazy(() =>
  Zod.union([Literal, Zod.array(Json), Zod.record(Json)])
);
```

Putting this in an issue for anyone who might be on the lookout or if the library might want to integrate a higher-level utility constructs like this.",,
610952663,40,Requesting any and / or unknown types,Coming from `io-ts` there were useful `t.any()` or `t.unknown()` types for accepting anything but not making many assertions about what values contained. Is that something that fits into the Zod vision?,,
606630379,39,discriminated union regression between 1.0.9 and 1.3.0,"The following schema

```typescript
export const CellResultsAPIValidator = z.union([
  z.object({
    kind: z.literal(""error""),
    error: z.object({
      message: z.string(),
      type: z.string(),
    }),
  }),
  z.object({
    kind: z.literal(""results""),
    results: z
      .array(
        z.union([
          z.object({
            kind: z.literal(""data""),
            data: z.tuple([z.string(), z.string(), z.string()]),
          }),
          z.object({
            kind: z.literal(""error""),
            error: z.tuple([z.string(), z.string(), z.object({})]),
          }),
          z.object({
            kind: z.literal(""skipped""),
          }),
        ])
      )
      .nonempty(),
  }),
]);
```

no longer validates the following

```
{ Error: Type mismatch in union.
Received: {
  ""kind"": ""results"",
  ""results"": [
    {
      ""kind"": ""error"",
      ""error"": [
        ""InvalidReferenceError"",
        ""object type or alias 'User' does not exist"",
        {
          ""65521"": ""7"",
          ""65522"": ""11"",
          ""65523"": ""1"",
          ""65524"": ""8""
        }
      ]
    }
  ]
}

Expected: object OR object
    at new ZodError (/Users/yury/dev/edge/tutorial/node_modules/zod/lib/src/ZodError.js:20:28)
    at Function.ZodError.create (/Users/yury/dev/edge/tutorial/node_modules/zod/lib/src/ZodError.js:66:21)
    at Function.ZodError.fromString (/Users/yury/dev/edge/tutorial/node_modules/zod/lib/src/ZodError.js:71:25)
    at ZodUnion.parse (/Users/yury/dev/edge/tutorial/node_modules/zod/lib/src/parser.js:159:39)
```

after upgrading from 1.0.9 to 1.3.0",,
605504853,38,Generate class from object schema,"Just like function implementation, it would be interesting to create an object `implement(readonly: bool)` method, that would create an anonymous class having the following functionality:

- Has a `constructor(t?: Type)` that validates the object
- Defines getters and setters (if not readonly)
- May offer `assign(other: Partial<Type>)` or `with(other: Partial<Type>)`, that respectively assign or copies the object and assign values, then runs validation

This would help creating ES6 classes inheriting from this base class, with validation built-in:

```ts
class MyUser extends userSchema.implement() {
    set password(pw: string) {
        this.passwordDigest = hash(pw);
    }
}
```

There are a few unknowns for this: specifically, in case of nested objects that have an implementation, it would be great to return an instance of that implementation rather than a bare object. Some mapping between `ZodType` and implementation could theoretically be passed to Implement.",,
604797750,37,Support for custom validation,"Is there any plan to support custom validation?
It could be of the form: `z.string().validate(someValidationFunction)`.

That would be a great help to build advanced schemas.

This could also take the form of custom types, but for now, `z.ZodType` / `z.ZodTypeDef` not being exposed as part of the API make it a hack IMO.",,
602910174,36,Type-checking methods do not accept `unknown`,"As of version `1.2.5`, the `parse`, `is` and `check` methods on `ZodType` expect to receive an argument which is _already_ of the schema's type. This is surprising to me; at version `1.0.15` I was passing `unknown` values to these functions, since the input is of unknown type (typically from IO) and the functions are being called explicity to _discover_ whether the value matches the type.

Since I don't want to incorrectly-type the values before they are checked, it seems the only option here is to use `any`, which from my point of view is strictly worse than `unknown`.

Is there a downside I'm not seeing to permitting `unknown` as input to these functions?",,
602868429,35,Support for other primitives,Are there plans to support other primitives such as Promise and BigInt?,,
601664736,34,Optional Properties was broken,"It was worked  in 1.0.9 , but broken in 1.2.3 .

```js
export const stackProps = z
    .object({
        direction: Direction.optional(),
        horizontalAlign: Alignment.optional(),
        verticalAlign: Alignment.optional(),
        wrap: z.boolean().optional(),
        grow: z.boolean().optional(),
        shrink: z.boolean().optional(),
    })

type PropType = z.TypeOf<typeof stackProps>
```
![image](https://user-images.githubusercontent.com/3960056/79527081-4f7a7b00-8099-11ea-86a1-1bd318708d01.png)
![image](https://user-images.githubusercontent.com/3960056/79527175-818bdd00-8099-11ea-9ab1-8059f9a6b830.png)
",,
600802418,33,Custom error messages,"Is there a way to hook into the validation error messages to provide custom ones?

This would be useful for client-side validation when the errors are user-facing and might need to be translated.",,
596814490,32,Partial Schema Validation,"Hey man!  Great job with the library!  Coming from io-ts I really like how similar the syntax is.   I'm looking for a feature that I have yet to find in any schema validation libraries.  The ability to validate both complete and partial input against a single defined schema.

The use case is this.  I have an API that allows creation and update of a resource.  Both operations need to validate the input.  In the creation case, the input needs to strictly adhere to the schema.  In the update case, any partial input that matches a subset of the schema should be accepted.

I can accomplish this with any schema validation library by creating 2 schemas but my schemas are quite large and this would be painful.  It would be great to be able to either:
- Clone a schema as a ""deep partial"" in which every nested prop is converted to partial.
- Parse/decode input using a ""asPartial"" option that allows some (or all) properties to be missing.

Thanks for contributing this library to the community!",,
595510568,31,Parser logs to the console,"When using the library to parse values, I'm seeing a lot of logs to the console of this form:

    seen string before: undefined

They seem to be coming from this line in `parser.ts`: https://github.com/vriad/zod/blob/f154275fafd1cd105dcfe4bc63f37313057b3171/src/parser.ts#L24

Is this intended behaviour, or was this shipped by mistake?",,
595264507,30,Date type handling?,"This lib looks like a really nice approach. I don't see support for `Date` types, though. Do you have a plan to support them?",,
594090550,29,Schema masking,"Spun off from #16.

See the discussion there about masking.",,
593904289,28,Dictionary type: unknown keys but known values,"I've looked through the docs, but I'm unclear on how to achieve a dictionary type that has unknown string keys, but known values, basically the type of `Record<string, KnownType | undefined>`. The `nostrict()` modifier is _close_, but I don't see how to specify the value type when using that",,
592462618,27,Cannot find module 'zod'.,"My tests seem to be failing after the upgrade. Any ideas?

https://github.com/moltar/typescript-runtime-type-benchmarks/pull/155

https://github.com/moltar/typescript-runtime-type-benchmarks/pull/155/checks?check_run_id=553968076
",,
589651001,25,Basic Zod Example does not compile,"I tried to use Zod and cannot get even the most basic example from the documentation to compile.

Here is the code:

```
import zod from 'zod';
zod.object({
  name: zod.string(),
  neutered: zod.boolean(),
});
```

Using typescript 3.8.3 with tsConfig:

```
{
  ""compilerOptions"": {},
  ""include"": [""src/**/*""]
}
```

Finally the message typescript provides:

```
node_modules/zod/lib/types/object.d.ts:46:43 - error TS2344: Type '{ [k in Exclude<keyof Params, ""strict"">]: Params[k]; } & { strict: false; }' does not satisfy the constraint 'ZodRawShape'.
  Property 'strict' is incompatible with index signature.
    Type 'false' is not assignable to type 'ZodAny'.

46     nonstrict: () => ZodObject<T, Flatten<{ [k in Exclude<keyof Params, ""strict"">]: Params[k]; } & {
                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
47         strict: false;
   ~~~~~~~~~~~~~~~~~~~~~~
48     }>>;
   ~~~~~

```
",,
588210456,24,Cannot find module './ZodError',That file doesn't exist.  Did you forget to include it?,,
586563979,23,Type guards vs Zod,"Hi!

I am wondering what are the differences between Zod and typescript type guards. What are the pros/cons/limits/purposes for each.",,
585428823,21,Is it possible to generate schema from ts annotation using babel plugin?,Just like how https://github.com/gcanti/babel-plugin-tcomb works.,,
584620584,20,Include src in compiled package,"My webpack throwing a lot of warnings about sourcemaps.
```
WARNING in ./node_modules/zod/lib/types/string.js
Module Warning (from ./node_modules/source-map-loader/index.js):
(Emitted value instead of an instance of Error) Cannot find source file '../../src/types/string.ts': Error: Can't resolve '../../src/types/string.ts' in '/Users/okhomenko/brightback/brightback-server/src/main/webpack/node_modules/zod/lib/types'

WARNING in ./node_modules/zod/lib/types/object.js
Module Warning (from ./node_modules/source-map-loader/index.js):
(Emitted value instead of an instance of Error) Cannot find source file '../../src/types/object.ts': Error: Can't resolve '../../src/types/object.ts' in '/Users/okhomenko/brightback/brightback-server/src/main/webpack/node_modules/zod/lib/types'
```

It's trying to merge sourcemaps from zod and can't find source typescript files.
@vriad Could you please include src as part of the published package? 
",,
583571151,19,vs Yup,"Hi,

I have read your article and reasoning for creating this lib. And I first, ye cool correct types, I will use it.
But then I see that
1. Is a fraction of yup features
2. json-schema could be converted to yup
3. With yup I can insert custom messages
4. I can do required('this is required')

My question, where do you use it, so you can live without the above features?",,
583277284,18,Is it possible to add default values? ,"Hi, I love this library, it's perfect for the project I'm currently working on. I come from **Joi**, and it has a `.default('value')` for specifying a default value if not set. Does this library have something similar? is that a possibility?

Thanks",,
582018476,17,ValidationError.path,"When Zod throws a validation error, specify where in the schema that error occurred. Can be very helpful for large schemas.

Split off from #14.",,
582018105,16,No unknown keys,"This feature causes yup to throw an error on validation if there's a property on the object that doesn't match the schema. Similar to `yup.object().noUnknown()` 

Split off from #14.",,
581675324,14,A couple of yup features that would be nice to have,"I'm really impressed with this project and its ease of use.  There are a couple of features from yup that would be really useful.

#1. yup.object().noUnknown() - This feature causes yup to throw an error on validation if there's a property on the object that doesn't match the schema
#2. ValidationError.path - When yup throws a validation error, it specifies where in the schema that error occurred which can be very helpful for large schemas",,
581268772,13,TypeScript has a capital S,"Typescript â†’ TypeScript

Sorry, pet peeve of mine. Cool library! :)",,
581059556,11,Added to typescript-runtime-type-benchmarks,"Hey @vriad, the package looks great.

I added it to the benchmark repo.

https://github.com/moltar/typescript-runtime-type-benchmarks",,
581008086,10,Site documentation fix,"On https://vriad.com/blog/zod/ under ""Custom Union Types,"" F.parse(null) should return ""null"" and not ""42."" It's correct on the Github README, just not on the site.",,
580799542,9,Is published package not transpiled?,"I'm developing a aws lambda based application, that means I cannot direcly use typescript code when deploying, when I tried to deploy a lambda using zod, my webpack process failed with the following error:

```
Error: TypeScript emitted no output for /Users/osp/dev/strestsaas/server/node_modules/zod/index.ts. By default, ts-loader will not compile .ts files in node_modules.
You should not need to recompile .ts files there, but if you really want to, use the allowTsInNodeModules option.
```

I think the published version of the package should not directly link to .ts files in order for transpiled projects to work, right?",,
580797395,8,Enum validation support?,"Is it possible right now? related to #3 

example:

```typescript
enum Foo {
  BAR = 'BAR',
  BAZ = 'BAZ'
}
let e = z.enum(Foo);

e.parse(""LOL""); // throws
```",,
580603096,7,Can't build in my project with strictPropertyInitialization: true,"Because zod isn't compiled when it's distributed in npm, my TS compiler tries to compile it. However, my project has `strict: true` in its config options, with no strict flags turned off, and so it ends up failing to build because zod has `strictPropertyInitialization` set to false. I get a handful of errors like `Property 'schema' has no initializer and is not definitely assigned in the constructor`

I currently can only use this library in my app if my strict compile options are set to what zod has, which is definitely not preferable. (And that's a shame because I _really_ like the idea of this and I too was _this_ close to trying to write my own library after being unhappy with the status quo.)

I think it would help a lot if the project was actually pre-compiled, and the JS + .d.ts files were distributed in npm, instead of the raw TS files.

(Also, side note that is kind of related to my above suggestion: I run our app using ts-node, and I get `Cannot use import statement outside a module` when ts-node tries to import zod. I'm pretty sure that this would also be fixed by releasing the compiled code instead of the raw TS.)",,
580396482,5,Is it possible to add support for literal types and discriminated unions?,"It would be cool if the variation of the below code is allowed:

```typescript
const CellText = z.object({
  kind: ""text"",
  body: z.string(),
});

const CellCode = z.object({
  kind: ""code"",
  code: z.string(),
});

const Schema = z.array(
  z.object({
    category: z.string(),
    cells: z.array(z.union([CellText, CellCode])).nonempty(),
  })
);
```",,
580336480,4,Add comparison to runtypes,"Hey @vriad, this package looks awesome. I am wondering (and I am sure other's who are reading the README) what the difference is between this package and [runtypes](https://github.com/pelotom/runtypes).

Would be great to add this info to the README as well! ",,
580296739,3,Branded types,"Feature request: branded types 
This issue can be the primary discussion ground for implemented branded types.

**Option 1:** 
Replicating io-ts's symbol trickery to create types like NonZeroNumber or Email (it might be difficult to do that one while remaining ergonomic)

I don't love all the boilerplate associated with `io-ts` branded types (i.e. `interface PositiveBrand { readonly Positive: unique symbol }`).

**Option 2** 

It may be able to include string/number validators as a literal generic argument of the ZodString/ZodNumber classes, like so:

```
const num: z.number({ max: 5 }) // => z.ZodString
const max5: z.number({ max: 5 }) // => z.ZodString<{ max: 5 }>
```

That way the validations being enforced are easy to see with a glance at the type definition. This would only work for built-in validators I believe (?). This is also different, in that validations are registered at the instance level instead of the class level. ",,
580274793,2,Type assertions,"I've been thinking a lot about validation libaries and I share your frustration with Yup. Yup does not get everything right. I'm scared about to introducing io-ts is it has a high a cognitive overhead, but I really love what io-ts does.

I think I'll experiment with this libarary a bit, but in terms of io-ts features do you think zod could be improve with these features?

* built in type guards - i.e.  io-ts's `is()` method on codecs.
* built in type assertions - (maybe call it `assert()`) using the new assertion function types in typescript 3.7 (io-ts doesn't actually have this probably because it wants us to use `Either` instead of exceptions)
* branded types - doing io-ts's symbol trickery to create types like `NonZeroNumber` or `Email` 
  * it might be difficult to do that one while remaining ergonomic",,
580272041,1,Typo in the doc?,"Hi!

Awesome work on this lib, I was waiting for years for someone to tackle this problem ;)

```js
const dogsList = z.array(dogSchema);

dogsList.parse([
  { name: ""Cujo"", neutered: null },
  { name: ""Fido"", age: 4, neutered: true },
]) // passes

dogsList.parse([]) // passes
```
I believe this shouldn't pass because of the lack of `age` in the first item right?",,
